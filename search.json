[{"title":"利用AutoSSH建立SSH隧道，实现内网穿透","url":"/2020/010618877.html","content":"\n​\t\t当我们使用公司或家中电脑搭建了Web服务时，一般不能直接从外网访问，为了实现从外网直接访问到内网的服务，一般会需要用到 **内网穿透** 技术。常用的内网穿透工具有NAT转发、DMZ主机、AutoSSH、ngrok、frp、花生壳等。下面将会介绍如何通过SSH端口转发，使内网主机A的服务转发至公网主机B上。\n\n### 需要条件：\n​\t\t一台内网主机A，一台Linux公网主机B。下文以CentOS7系统为例。\n\n### 第一步：公网服务器配置\n\n​\t\t修改公网主机B的SSH配置文件`/etc/ssh/sshd_config`\n\n```\nGatewayPorts yes\n```\n\n​\t\t这样可以把监听的端口绑定到任意IP 0.0.0.0上，否则只有本机127.0.0.1可以访问。\n\n​\t\t重启sshd服务\n\n```bash\nsudo service sshd restart\n```\n### 第二步：安装AutoSSH服务\n\n  在内网主机A上，执行以下命令安装AutoSSH\n```bash\nyum install autossh\n```\n### 第三步：断线免密登录自动重连\n​\t\tssh反向链接会因为超时而关闭，如果关闭了那从外网连通内网的通道就无法维持，为此我们需要结合免密码登录及AutoSSH来提供稳定的ssh反向代理隧道。\n\n​\t\t1、在内网主机A上产生公钥和私钥\n\n```bash\nssh-keygen \n```\n  然后按三次回车执行默认选项生成公钥和私钥。会生成密钥文件和私钥文件 id_rsa,id_rsa.pub或id_dsa,id_dsa.pub\n\n​\t\t2、拷贝秘钥\n  在内网主机A上继续执行如下命令，将内网主机A上的秘钥文件copy到公网主机B中。\n\n```bash\nssh-copy-id  username@ip\n```\n  其中“username”是公网主机B的用户名，ip为公网主机B的ip，然后按照提示输入公网主机B的密码就完成了。\n\n### 第四步：利用AutoSSH实现端口转发\n  在内网主机A上，利用AutoSSH建立一条SSH隧道\n```bash\n autossh -M 4010 -NR 80:localhost:4000 username@xxx.xxx.xxx.xxx (-p xxxx)\n```\n​\t**参数解释：**\n - “-M 4010”意思是使用内网主机A的4010 端口监视SSH连接状态，连接出问题了会自动重连\n - “ -N”意思是不执行远程命令\n - “-R”意思是将远程主机（公网主机B）的某个端口转发到本地指定机器的指定端口\n\n​\t**代码解释：**\n - “80:localhost:4000”意思是将内网主机A的 4000 号端口转发至公网主机B的 80 号端口上\n\n - “username@xxx.xxx.xxx.xxx”意思是公网主机B的用户名和IP\n\n - “-p xxxx”意思是公网主机B的SSH端口，如果是默认的22号端口，则可以不输入.\n\n   \n\n### 第五步：监听端口检查\n\n​\t\t分别检查本地主机A及公网主机B的端口监听情况，出现如下进程则为正常。\n\n​\t\t本地主机A：\n```bash\n[root@localhost ~]# lsof -i:4010\nCOMMAND   PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME\nssh      6710 lixl    5u  IPv6 0x15699cecfe8a4995      0t0  TCP localhost:altserviceboot (LISTEN)\nautossh 46984 lixl    3u  IPv4 0x15699cece41d5e95      0t0  TCP localhost:altserviceboot (LISTEN)\n```\n\n​\t\t远程主机B：\n```bash\n[root@localhost ~]# lsof -i:8080\nCOMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nsshd    9762 root   10u  IPv4 473994      0t0  TCP *:webcache (LISTEN)\nsshd    9762 root   11u  IPv6 473995      0t0  TCP *:webcache (LISTEN)\n```\n\n### 第六步：开启自启动\n\n​\t\t配置AutoSSH开机自启动，输入：\n```bash\nvi /etc/rc.d/rc.local\n```\n​\t\t添加内容:\n```bash\nautossh -M 4010 -fCNR 80:localhost:4000 username@xxx.xxx.xxx.xxx (-p xxxx)\nchmod +x /etc/rc.d/rc.local\n```\n​\t\tcentos7之后，修改/etc/rc.d/rc.local启动脚本需要重新赋予可执行权限。\n\n​\t\t至此完成了端口转发，在相应的应用（如浏览器）中输入公网服务器B的IP+端口即相当于直接访问内网主机A的相应服务，大功告成！\n\n### 常见问题\n\n  - 配置完通过外网IP加端口无法访问： 请检查公网服务器防火墙是否开放响应端口。\n  - 本地服务重启后，通过外部端口无法访问：这种情况是由于没有检测到通道之前已经断开，AutoSSH应该有类似的机制，还没有仔细研究。\n\n### 参考文章\n  - https://www.jianshu.com/p/7accc1e485d3\n  - https://blog.csdn.net/weixin_36394852/article/details/72725505\n  - https://blog.csdn.net/zll_0405/article/details/81208606","tags":["内网穿透"],"categories":["网络"]},{"title":"DDD领域驱动设计","url":"/2019/122036340.html","content":"\n[DDD ](https://s.geekbang.org/search/c=2/k=DDD/t=)和 DSL、DCI 的关系是什么？开发团队为何需要 DDD？它与微服务与中台又有着怎样的联系？目前业界实践 DDD 最大的问题是什么？11 月 30 日，在由 ThoughtWorks 举办的领域驱动设计峰会 [DDD-China 2019 ](http://www.ddd-china.com/speaker-info.html)上，InfoQ 记者带着这些问题对中兴通讯资深软件架构师张晓龙进行了采访。\n\n## DDD、DSL 和 DCI\n\nDDD 概念最早提出于 2004 年，作为一种软件开发的指导思想，DDD 对软件开发带来了诸多可能与方向，张晓龙认为 DDD 为软件开发带来的好处主要有以下几点：\n\n- 首先，最大好处就是所有参与者围绕一个统一一致的领域模型工作，传统的分析模型和设计模型不再割裂，不管是做设计、做分析还是写代码、写文档，脑海中所构建的画面都是一致的。\n- 第二，DDD 是一个软件开发过程，它显式地把领域和设计放到了软件开发的核心，软件人员和业务人员被受到同样的重视，他们合作来构建领域模型，使得软件的交付质量更高且维护成本更低；\n- 第三，DDD 提出的分层架构，有效分离了业务复杂度和技术复杂度，凸显了领域模型，使得领域层的代码和领域模型保持高度一致；\n- 第四，统一语言非常重要，每个概念在各自的上下文中是清晰的无歧义的，同时要控制领域模型的复杂度，于是 DDD 在战略上提出了分离子域（问题域空间）和拆分 BC（解决方案空间）的模式，BC 间通过 Context Mapping 来集成；\n- 第五，DDD 在战术层面提出了很多模式（聚合，实体，值对象，服务，工厂，仓储），对领域模型中的元素进行了分类，并给出了每类元素在领域模型中的职责和特征，降低了领域模型的构建成本。\n\n张晓龙此前曾在 DDD-China 峰会和[ ArchSummit 全球架构师峰会](https://archsummit.infoq.cn/2019/beijing/)上分别做过《当 DDD 遇上 DSL（Domain-Specific Language）》、《当 DDD 遇上 DCI（Data，Context， Interactive）》的演讲，在他看来，DDD 和 DSL、DCI 之间存在极强的关联性。\n\nDDD 和 DSL 的融合有三点：\n\n1. 面向领域；\n2. 模型的组装方式；\n3. 分层架构演进。\n\nDSL 可以看作是在领域模型之上的一层外壳，可以显著增强领域模型的能力。它的价值主要有两个，一是提升了开发人员的生产力，二是增进了开发人员与领域专家的沟通。举个例子：想让 BA 负责流程契约的设计，该流程契约是一个活文档，可以跑测试，而 BA 不熟悉宿主语言。于是，我们设计了一种外部 DSL 来专门描述流程契约，对 BA 非常友好，学习成本也很低（不超过 5 分钟就可以学会），最后发现 BA 很快就广泛使用了起来。外部 DSL 并不一定要定义新文法，我们直接复用了 plantUML 文法，安装该插件可以自动生成序列图，非常棒！对于外部 DSL，需要自己实现一个解析器将 DSL 文法解析成语法树，再根据语法树生成语义模型。语义模型可以看作领域模型（严格的讲语义模型是领域模型的子集），外部 DSL 就是对领域模型的一种组装方式。\n\nDCI 的作用主要体现在两方面：\n\n首先，DCI 助力 DDD 战术设计：\n\n1. 显式地对 ROLE 建模，解决了贫血模型与充血模型之争；\n2. 一个聚合可以支持哪些 ROLE，一个 ROLE 可以由哪些聚合扮演，一个场景下哪些聚合要扮演哪些角色；\n3. 当 Aggregate 内部实体行为比较多时可以嵌套使用 DCI 来拆分和组合；\n\n其次，DCI 助力 DDD 代码落地：\n\n1. 对象就是 Data，Client 为 Context，对象在 Client 中的行为就是 ROLE。\n2. 根据正交设计原则得到小类（素材库），根据多重继承（only C++）或依赖注入来组合素材，不管是行为类还是数据类，都按 Role 的方式来组合，对像仅仅组合 Role 并注入依赖；\n3. 小类大对象：类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域；领域对象需要真正意义上的生命周期管理。\n\n张晓龙认为，DCI 对一些开发人员的影响可能比 DDD 和 DSL 还大，因为开发人员每天都在不断倒腾代码，想让代码的组合性更强，以便快速应对需求的变化。\n\n## 开发团队真的需要 DDD\n\nDDD 思想贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，和最终的代码实现，甚至对代码的测试与重构。代码是业务的核心资产，不管是否特性团队，开发团队肯定是代码的编写者和守护者。\n\n对于开发团队而言，需要关注以下几点：\n\n- 首先是统一语言，让团队成员可以做到无障碍的沟通，不管是什么角色都能基于同样的画面进行讨论；\n- 其次是团队中各个角色都围绕领域模型开展工作；\n- 第三是代码物理设计容易标准化，比如说在分层设计时，基础设施层怎么设计，应用层怎么设计，DTO 应该放在哪儿，领域层中各个建模元素如何组织？\n\n更进一步，在分层架构里，应用层更加关注横切面的东西，比如说要上报一个告警，要给用户发送一个 Email，这些最好都集中放到应用层里面。但触发是在领域层发生的，应用层怎么知道？通过领域事件来实现依赖反转，即应用层订阅领域事件，领域层发布领域事件。\n\n在中兴通讯，核心业务属于通信行业，DDD 的应用场景跟互联网企业有着很大差别：\n\n1. 嵌入式软件；\n2. 兼业务复杂性和技术复杂性；\n3. 软件规模大，功能复杂，特性交叉；\n4. 高质量，高性能，高可靠等要求。\n\n张晓龙举例提到，中兴通讯在开发团队中实践 DDD 的经验具体而言有以下几点：\n\n1. 领域专家下团队，和团队一起交流和协作；\n2. 教练指导，开展战训营，定期 review；\n3. 架构、设计、编码和工程实践：（1）DCI，DSL，正交设计，组合式设计；（2）编码规范和纪律；（3）嵌入式 C/C++ 最佳实践；（4）软件工程能力：开发者测试，小步安全流畅的重构，持续交付流水线，每日 Code Review。\n\n## DDD 与微服务\n\nDDD 概念提出距今已经有 15 年的历史，前十年时间都一直处于不温不火的状态，而在最近几年才开始大行其道。张晓龙表示，中兴通讯在 2012-2015 年期间也有过一些成功的案例，但对于整个业界来说了解的人并不多。他拿 DDD-China 峰会举例解释：这次峰会的参会者有 500 人的规模，而我们假设峰会在 2015 年之前举办的话，估计参会者不会超过 100 人。因此，我们可以断定是[微服务](https://s.geekbang.org/search/c=2/k=微服务/t=)的热风让人们重新发现了领域驱动设计的价值。\n\n微服务架构从提出以来一直没有很好的理论支撑如何合理地划分服务边界，人们常常为服务要划分多大而争吵不休。而 DDD 被发现恰好可以弥补微服务的营养不良：（1）服务最大不要大过一个 BC，否则服务内可能会存在有歧义的领域概念；（2）服务最小不要小过一个聚合，否则会引入分布式事务的复杂度；（3）服务间最好通过 Domain Event 来进行交互，这样可以让服务保持松耦合。微服务和 DDD 的结合，让微服务架构看起来似乎更加稳健了。\n\n“微服务就像是 DDD 的心上人，使得 DDD 真正焕发起了青春。”张晓龙这样解释。\n\n对于业界目前流行的[中台](https://s.geekbang.org/search/c=2/k=中台/t=)概念，张晓龙同样也有自己的看法：\n\n中台和 DDD 不是同一个层面的东西，不能为了把它们联系在一起，而强行找相似点。中台实际上就是多条业务线的共同需求，比如对于滴滴公司来说，快车、专车和出租车等业务都是微服务架构，这些业务的很多服务是相似的，考虑将这些服务从各个前台下沉到统一的平台，这个平台就是中台。中台要考虑各个前台的需求，所以复杂性变高了。\n\n中台是一种企业级的架构模式，从企业全局整体视角来看架构全貌，而 DDD 是一种主流的软件开发方法，用来应对软件的核心复杂性。中台架构可以看作是微服务架构的延伸和发展，服务复杂性很高，所以更需要用 DDD 的方式去设计和建模，但二者之间并不是相同层面的概念。\n\n## DDD 的困局\n\n最近几年 DDD 的火爆也给业界开发团队带来了一些迷思，为什么我的 DDD 推行不下去？为什么我的 DDD 做起来总是跟敏捷一样，最后都变了味？\n\n张晓龙总结了 DDD 目前面临的几大困局：\n\n- 首先是领域案例面比较窄。目前业界的 DDD 实践案例并不多，而且很多案例是偏向互联网领域的，对于工业领域、嵌入式领域和操作系统领域基本没有涉及；\n- 第二，DDD 书籍非常少，而且大多数书籍是以 Java 或 C#写的。如果开发团队用的是 C、C++、Python 或 Go 语言，基本没有可参考的书籍，难度也就更大一些（尤其是 C 和 C++）；\n- 第三，各个巨头公司，比如 Google，微软，BAT 等，很少组织、参与或赞助 DDD 峰会，没有形成引导作用，业界自然也就少有跟随效应；\n- 第四，开发团队要么找不到领域专家，要么领域专家无法与开发团队长时间保持沟通，导致实践中出现偏差；\n- 第五，DDD 落地有一定的门槛，对开发者的技能和素质都有较高的要求。\n\n针对以上几大困局，张晓龙也给出了自己的解决方案：\n\n1. 培训 OOA、OOD 和 OOP 的基本知识，并实战演练，不断弥补与高手的 gap ；\n2. 领域专家和团队一起工作，确保大家头脑中的画面是一致的；\n3. DDD 建模要有文档交付物，并和代码同步演进，以便对代码不熟悉的人员也能看到并理解领域驱动设计成果的全貌。\n\n软件开发没有银弹，DDD 也不是万能的。如果开发团队真的决定用 DDD 的思想指导软件开发，就一定要跟随时代的脚步，吃透 DDD 这个旧瓶里装的新酒。","tags":["软件设计方法论","领域驱动"],"categories":["软件设计"]},{"title":"物流、商流、资金流、信息流之间的关系","url":"/2019/121252656.html","content":"\n物流、商流、资金流和信息流是流通过程的四大组成部分，这四者构成了一个流通过程。几者的关系“互为存在、相互作用、密不可分”，既相互独立，又是一个综合体。将物流、商流、资金流和信息流有机结合起来，会产生更大的能量，创造更大的经济效益。\n\n所谓商流，就是一种买卖或者说是一种交易活动过程，通过商流活动发生商品所有权的转移。\n\n商流是物流、资金流和信息流的起点，也可以说是后\"三流\"的前提，没有商流一般不可能发生物流、资金流和信息流。反过来，没有物流、资金流和信息流的匹配和支撑，商流也不可能达到目的。\"四流\"之间有时是互为因果关系。\n\n比如，A企业与B企业经过商谈，达成了一笔供货协议，确定了商品价格、品种、数量、供货时间、交货地点、运输方式等，并签订了合同，也可以说商流活动开始了。要认真履行这份合同，自然要进入物流过程，将货物进行包装、装卸、保管和运输。同时伴随着信息传递活动。如果商流和物流都顺利进行了，接下来是付款和结算，即进入资金流的过程。无论是买卖交易，还是物流和资金流，这三大过程中都离不开信息的传递和交换，没有及时的信息流，就没有顺畅的商流、物流和资金流。没有资金支付，商流不会成立，物流也不会发生。\n\n可以讲。商流是动机和目的，资金流是条件，信息流是手段，物流是终结和归缩。\n\n就是说由于需要或产生购买欲望，才决定购买，购买的原因和理由就是商流的动机和目的；因为想购买或决定购买某种商品，才考虑购买资金的来源或筹措资金问题。不付款商品的所有权就不归你，这就是条件；又因为决定购买，也有了资金，然后才付之行动，这就是买主要向卖主传递一个信息，或去商店向售货员传递购买信息，或电话购物、网上购物，这些都是信息传递的过程，但这种过程只是一种手段；然而，商流、资金流和信息流产生后，必须有一个物流的过程，否则商流、资金流和信息流都没有意义。\n\n举个例子，一个单位搬进新办公地点后要购买几台空调，这个单位可能直接去商店选购，也可能打电话或网上采购，就产生了商流活动。由此也伴生出资金流(如现金支付，支票付款或银行走账)和信息流。可是只完成这\"三流\"，并不是事物的完结，还必须将空调送至买主，最终还是少不了运输、装卸等物流过程。\n\n那么。怎样才能保证将卖出去的空调按买主要求的时间、地点和数量，准确、完全地送货上门呢？\n\n首先，出售空调的商店里有库存，或者商店给厂家打电话，让厂家从仓库取货。无论从商店取货，还是从仓库取货，都需要有车将空调送过去，如果销售量过于集中，车子跑不过来，或者司机调整不过来怎么办？如果仓库里缺这种型号的空调又怎么办？看来，这都属于物流的问题。\n\n再往复杂一些说，假如空调厂家对空调的销售量预测的不准确，预测的销售大干实际需要，就产生库存积压，浪费仓库保管费，多占压生产资金。假如预测的销售量小于实际需要，则不仅少赚利润，失去市场，而且还可能影响企业声望。怎样才能既不浪费保管费和占压资金，又能保证供货呢？除了准确的市场需求预测，及时掌握各种信息外，还要构筑一个先进、合理的物流系统。首先要进行商品的需求、购买力、市场容量、销售时点、销售数量等基础性调查研究。然后，再制定一个与商流相配套的物流规划。根据市场情况，决定建几个配适中心，建多大规模，如何构筑配送网络等等。\n\n因为物流是受商流制约，随商流变化而变化，往往为了占领市场、扩大销售而牺牲物流利益的，所以，在竞争激烈的商品经济社会要加强对物流问题的研究，加强对信息技术等现代科学手段的充分利用。\n\n商流和资金流是传统性的经济活动，规则性强，已经比较成熟和定型，进一步的科学化管理受时代和经济发展水平限制。信息流主要依赖互联网，由计算机支持，是电子化传输和软件开发问题。这方面的竞争会不断加剧和复杂化，各企业的技术水平将来也会彼此接近。\n\n前几年兴起的电子商务热，之所以急剧降温，是因 \"物流瓶颈\"造成的，而不是信息技术自身的问题。而且，商流、资金流和信息流将来都可能由计算机和网络通信部分替代，只有物流难以做到这一点。而旦物流又最落后，物流发展的空间比商流、资金流和信息流要大，合理化、科学化管理的余地要大，节约费用的潜力要大。这是因为：\n\n- 第一，物流是一门新兴科学，很多人对物流基本知识、物流理论、物流的重要作用、重视物流的必要性和必然性还了解不多，还需要一个认识过程。物流与商流、资金流以及信息流相比，发展滞后。进度缓慢，如不及时超上，要拖其他\"三流\"的后腿。同时也说明，物流的发展因过去是一流空白，是\"黑暗的大陆\"。因此它的发展空间也就更大。\n\n- 第二，物流在商品总成本中的费用比例大，过去不受重视，这块庞大的成本，只要我们稍加努力，就会有利可图。这块\"第三利润源泉\"，是新经济时代最有前景的领域，是节约费用最大的空间。\n\n- 第三，物流发展时间尚短，成熟程度差，物流管理科学化较低。只要我们认识到这一点，认真对待，大力加强对物流的管理，就能大大提高物流生产效率，大幅度增加经济效益。\n\n- 第四，过去还很少有人将物流与商流、资金流、信息流联系起来考虑。也没有将\"四流\"做为一个大系统对待。今后如果真正把\"四流\"统一起来、协调起来，那将产生不可估量的效益。目前的主要矛盾表现在物流和信息流两个方面。\n\n在此我们有必要强调，商流、物流、资金演、信息流，虽然各有独立存在的意义，并各有自身的运行规律，但是，\"四流\"是一个相互联系、互为伴随、共同支撑流通活动的整体。在认识和研究流通经济，或者在进行物流管理过程中一定要把握这一点，以使我们认识问题全面化、科学化，把物流工作做得更有成效。","tags":["四流合一"],"categories":["供应链"]},{"title":"Typora如何方便的使用图床","url":"/2019/120114500.html","content":"\n本文提到两种插件组合方式，iPic及PicGo，支持主流图床。\n\n对于Typora + iPic方式，是Typora默认支持的。但iPic免费版会将图片匿名上传到公共网络服务器，一旦上传到服务器上，将无法删除图片文件。 \n\nPicGo是一款开源的图床软件，该软件与iPic的不分伯仲，文档支持中文，支持插件开发。\n\n> 使用GitHub仓库创建图床，存在的问题是国内访问github的速度很慢，可以利用 [jsDelivr CDN](https://www.jsdelivr.com/) 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案）国内该平台是首个「打通中国大陆与海外的免费CDN服务」，网页开发者无须担心中国防火墙问题而影响使用。\n\n## iPic方式\n\n\n如果你同时运营好几个内容平台的文字工作，主力用 Markdown 写作，在 Markdown 中插图片相信多少有些让人头疼：\n\n- 一些平台的图片外链不允许抓取\n- 用图床工具处理又要每张图片手动操作\n- ......\n\n操作次数一多，难免会降低我们的效率。\n\n少数派在曾介绍过一款方便的图床工具 [iPic](https://sspai.com/tag/iPic)，之后开发者开放了 iPic 的图片上传接口服务 [iPicUploader](https://github.com/toolinbox/iPicUploader)，其它 App 能够很方便地调用 iPicUploader 接口上传图片至图床。目前，Markdown 编辑器 [Typora](https://sspai.com/tag/Typora) 已经接入 iPicUploader，通过两款工具的搭配，我们能轻松地完成在 Markdown 中插图的工作。\n\n### 自动上传图片至图床\n\n打开 Typora 中的「Edit - Image Tools - Upload Local Images via iPic」选项，在 Typora 中插入本地图片时，iPic 会自动将图片上传图床并使用 Markdown 语法替换文内地址。\n\n<img src=\"https://tva1.sinaimg.cn/large/006tNbRwly1g9h1cwvrjrg30hm0bsgze.gif\" alt=\"img\" style=\"zoom:50%;\" />\n\n如果你已经在 Typora 中插入好本地图片，按照上述步骤打开使用 iPic 传图的选项，Typora 会自动将所有本地图片上传图床并以 Markdown 语法替换。\n\n<img src=\"https://tva1.sinaimg.cn/large/006tNbRwly1g9h1d0yw9qg30ha0c0na3.gif\" alt=\"img\" style=\"zoom:50%;\" />\n\n### 不容忽视的快捷键\n\n当然，你的主力 Markdown 工具可能并不是 Typora，通过在选中图片之后使用 ⌘ + U 快捷键上传也是一个不错的选择。\n\n<img src=\"https://tva1.sinaimg.cn/large/006tNbRwly1g9h1d1fw4rg30j60asqmc.gif\" alt=\"img\" style=\"zoom:50%;\" />\n\n### 关于 iPicUploader\n\niPicUploader 是 iPic 图床工具开放的上传服务，目前已经由开发者[在 GitHub 开源](https://github.com/toolinbox/iPicUploader)。\n\n<img src=\"https://tva1.sinaimg.cn/large/006tNbRwly1g9h1d1xfstg30j60asqn0.gif\" alt=\"img\" style=\"zoom:50%;\" />\n\n<img src=\"https://tva1.sinaimg.cn/large/006tNbRwly1g9h1d2fdxig30j60as1kx.gif\" alt=\"img\" style=\"zoom:50%;\" />\n\n<img src=\"https://tva1.sinaimg.cn/large/006tNbRwly1g9h1d32idjg30j60asx4d.gif\" alt=\"img\" style=\"zoom:50%;\" />           \n\n虽然使用上不如 iPic 的操作来得简单方便，开发者的初衷也是为了其它开发者能够更方便地在应用中接入 iPicUploader 完成上传图片至图床的功能。对于普通用户来说，这里还是建议使用 [iPic](https://itunes.apple.com/cn/app/ipic-easily-upload-images/id1101244278?l=en&mt=12) 的图床功能即可。\n\n## PicGo方式\n\n### 1. 下载运行PicGo\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20191201133609.png/w1280\" style=\"zoom: 50%;\" />\n\n下载zip包后，解压，运行可执行文件*\n\n### 2. 配置图床\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20191201133631.png/w1280\" style=\"zoom: 50%;\" />\n\n*如图配置*\n\n> - 设定仓库名的时候，是按照“账户名/仓库名的格式填写”\n> - 分支名统一填写“master”\n> - 将之前的Token黏贴在这里\n> - 存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹\n> - 自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上。如果使用jsDelivr加速访问，需要将自定义域名设置为【[https://cdn.jsdelivr.net/gh/](https://link.zhihu.com/?target=https%3A//cdn.jsdelivr.net/gh/)用户名/图床仓库名 】。\n\n### 3.快捷键及相关配置\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20191201133736.png/w1280\" style=\"zoom: 50%;\" />\n\n## 参考文章\n\n- [iPic + Typora，方便快捷地在 Markdown 中插图](https://sspai.com/post/36275)\n- [Molunerfinn/PicGo](https://github.com/Molunerfinn/PicGo)\n- [Typora与PicGo的使用笔记]([https://bugwz.com/2019/09/22/typora-picgo/#%E4%B8%80-typora](https://bugwz.com/2019/09/22/typora-picgo/#一-typora))\n- [PicGo+GitHub图床，让Markdown飞](https://juejin.im/entry/5c4ec5aaf265da614420689f)\n- [Github+jsDelivr+PicGo 打造稳定快速、高效免费图床](https://www.jianshu.com/p/a36e9c64361d)\n\n","tags":["Typora","iPic","PicGo"],"categories":["软件工具"]},{"title":"吴恩达神经网络与深度学习笔记","url":"/2019/10029178.html","content":"\n​\t\t吴恩达是人工智能领域的大牛，著作颇丰，其推出的机器学习课程在学生之中反响强烈，深受中国学生的推崇。**Deep Learning Specialization**对卷积神经网络 (**CNN**)、递归神经网络 (**RNN**)、长短期记忆 (**LSTM**) 等深度学习常用的网络结构、工具和知识都有涉及。\n\n## 概论\n\n### 模型适用性\n\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/33a613e0dc2642d87288b66c026e97538052f630daa29a48faa4acb539b00f6ef521c398a55f1495ff85d58bd5844ea8?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20191002-211009%402x.png&amp;size=750\" alt=\"神经网络示意图\" style=\"zoom:70%;\" />\n\n​\t\t标准神经网络   ——>  房产价格预测及在线广告点击预测\t\n​\t\t卷积神经网络\tCNN\t——>\t图像领域\n​\t\t循环神经网络\tRNNs\t——>\t序列数据，语言处理\n​\t\t混合神经网络\t\t——>\t无人驾驶\n\n数据积累 + 计算能力提升 + 算法改进  使得深度学习能够发挥作用，受欢迎。\n\n \n\n## 物体监测\n\n​\t目标是输出bx，by，bh，bw及1～4个分类标签，目标标签定义如下：\n\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/4aeca6af50f7cfd6bf9d879a56905ea45e1ad517e10c2d2bd2ee71d42d4b68bcaefc2e8c5ed421a8cff54c1e558c46f3?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20191003-130947%402x.png&amp;size=750\" alt=\"定义目标标签\" style=\"zoom:40%;\" />\n\n- 基于滑动窗口的目标监测算法：可以监测到图片中是否有目标（如汽车），缺点是计算成本高。如果加大滑动窗口的步长可能会影响性能。\n- YOLO对象监测算法：如把图片划分成3x3个区域，通过增加N个anchor box，分别监测9个区域，得到 3x3x2x8 个Y值。过滤掉无效数据（Pc=0），得到N个预测的边界框。针对每个anchor运行非最大值抑制。获得交并比最大边框，如图：\n    <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/d3ae98cff57c4d885146e216e71400758f45676f632931f0c277ee33973fec27245bc43db38f8f31f85f5c1a93e66125?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20191004-092921%402x.png&amp;size=750\" alt=\"YOLO对象监测算法\" style=\"zoom:40%;\" />\n- R-CNN：运行图像分割算法，只在候选框（识别到汽车）运行卷积网络分类器。 缺点还是太慢了。\n- Fast R-CNN：用滑动窗口的一个卷积实现。问题是得到**候选区域**的聚类步骤仍然很慢。 \n- Faster R-CNN：使用卷积神经网络（而且传统分割算法）来获取候选色块，速度比R-CNN快，但事实比YOLO慢很多。\n","tags":["吴恩达","神经网络"],"categories":["深度学习"]},{"title":"对象检测算法之YOLO-V3","url":"/2019/10029099.html","content":"\n## 概述：\n\n​\t\tYolo是一种使用卷积神经网络进行目标检测的算法。目标检测是指计算机和软件系统对图像或场景中的目标进行定位和识别的任务。与识别算法相比，检测算法不仅可以预测类别标签，还可以检测对象的位置。目标检测已广泛应用于人脸检测、车辆检测、人流量统计、网络图像、安防系统和无人驾驶等多个领域。\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20200106230653.png/w1280\" style=\"zoom:50%;\" />\n\n​\t\t2012年深度学习的突破性进展和迅速普及，使得R-CNN、Fast-RCNN、Faster-RCNN、RetinaNet以及快速、高度准确的SSD、YOLO等目标检测算法应运而生。YOLO v3非常快速和准确。在mAP值为0.5 IOU时，YOLO v3与Focal Loss相当，但速度约快4倍。此外，只需更改模型的大小即可轻松在速度和精度之间进行权衡，无需重新训练！\n\n​\t\t2012年深度学习的突破性进展和迅速普及，使得 R-CNN、Fast-RCNN、Faster-RCNN、RetinaNet以及快速、高度准确的 SSD、YOLO 等目标检测算法应运而生。YOLO v3非常快速和准确。在 mAP 值为 0.5IOU 时，YOLO v3 与 Focal Loss 相当，但速度约快 4 倍。此外，只需更改模型的大小即可轻松在速度和精度之间进行权衡，无需重新训练！\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20200106230722.png/w1280\" style=\"zoom:50%;\" />\n\n### Yolo-V3架构\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20200106230801.png/w1280\" style=\"zoom:50%;\" />\n\n## 参考文章\n  - [目标检测第5步-keras版YOLOv3训练](https://cloud.tencent.com/developer/article/1418308)\n  - [YOLO: Real-Time Object Detection](https://pjreddie.com/darknet/yolo/)\n  - [ 支持在自己的数据集上进行训练的YOLO v3 TensorFlow 实现](https://github.com/wizyoung/YOLOv3_TensorFlow)\n  - [YunYang1994/tensorflow-yolov3 含自主训练](https://github.com/YunYang1994/tensorflow-yolov3)\n  - [Keras/Tensorflow+python+yolo3训练自己的数据集](https://blog.csdn.net/Patrick_Lxc/article/details/80615433)\n  - [目标检测第6步-keras版RetinaNet训练](https://cloud.tencent.com/developer/article/1418306)\n  - [](https://github.com/OlafenwaMoses/ImageAI/blob/master/imageai/Detection/README.md)","tags":["对象监测","YOLO"],"categories":["深度学习"]},{"title":"基于Hexo的hexo-theme-matery主题搭建个人博客","url":"/2019/092856736.html","content":"\n对于有一定技术背景的同学，自己动手搭建博客网站是一个很不错的选择。选择喜欢的主题，按需进行个性化配置，随时在本地用自己喜欢的工具写文章，一键发布到多个博客托管平台，使用自己喜欢的图床/CDN来加速...\n\n> 本站基于Hexo的hexo-theme-matery主题构建，同时托管在Github和Gitee的Pages服务中，通过 PicGo + 阿里云OSS 作为图床进行静态资源加速。如果不喜欢付费图床，也可以采用 Github+jsDelivr。\n\n## 特性\n\n- 简单漂亮，文章内容美观易读\n- [Material Design](https://material.io/) 设计\n- 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现\n- 首页轮播文章及每天动态切换 `Banner` 图片\n- 瀑布流式的博客文章列表（文章无特色图片时会有 `24` 张漂亮的图片代替）\n- 时间轴式的归档页\n- **词云**的标签页和**雷达图**的分类页\n- 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）\n- 可自定义的数据的友情链接页面\n- 支持文章置顶和文章打赏\n- 支持 `MathJax`\n- `TOC` 目录\n- 可设置复制文章内容时追加版权信息\n- 可设置阅读文章时做密码验证\n- [Gitalk](https://gitalk.github.io/)、[Gitment](https://imsun.github.io/gitment/)、[Valine](https://valine.js.org/) 和 [Disqus](https://disqus.com/) 评论模块（推荐使用 `Gitalk`）\n- 集成了[不蒜子统计](http://busuanzi.ibruce.info/)、谷歌分析（`Google Analytics`）和文章字数统计等功能\n- 支持在首页的音乐播放和视频播放功能\n\n## 下载\n\n当你看到这里的时候，应该已经有一个自己的 [Hexo](https://hexo.io/zh-cn/) 博客了。如果还没有的话，不妨使用 Hexo 和 [Markdown](https://www.appinn.com/markdown/) 来写博客和文章。\n\n点击 [这里](https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master) 下载 `master` 分支的最新稳定版的代码，解压缩后，将 `hexo-theme-matery` 的文件夹复制到你 Hexo 的 `themes` 文件夹中即可。\n\n当然你也可以在你的 `themes` 文件夹下使用 `Git clone` 命令来下载:\n\n```bash\ngit clone https://github.com/blinkfox/hexo-theme-matery.git\n```\n\n## 配置\n\n### 切换主题\n\n修改 Hexo 根目录下的 `_config.yml` 的  `theme` 的值：`theme: hexo-theme-matery`\n\n#### `_config.yml` 文件的其它修改建议:\n\n- 请修改 `_config.yml` 的 `url` 的值为你的网站主 `URL`（如：`http://xxx.github.io`）。\n- 建议修改两个 `per_page` 的分页条数值为 `6` 的倍数，如：`12`、`18` 等，这样文章列表在各个屏幕下都能较好的显示。\n- 如果你是中文用户，则建议修改 `language` 的值为 `zh-CN`。\n\n### 新建分类 categories 页\n\n`categories` 页是用来展示所有分类的页面，如果在你的博客 `source` 目录下还没有 `categories/index.md` 文件，那么你就需要新建一个，命令如下：\n\n```bash\nhexo new page \"categories\"\n```\n\n编辑你刚刚新建的页面文件 `/source/categories/index.md`，至少需要以下内容：\n\n```yaml\n---\ntitle: categories\ndate: 2018-09-30 17:25:30\ntype: \"categories\"\nlayout: \"categories\"\n---\n```\n\n### 新建标签 tags 页\n\n`tags` 页是用来展示所有标签的页面，如果在你的博客 `source` 目录下还没有 `tags/index.md` 文件，那么你就需要新建一个，命令如下：\n\n```bash\nhexo new page \"tags\"\n```\n\n编辑你刚刚新建的页面文件 `/source/tags/index.md`，至少需要以下内容：\n\n```yaml\n---\ntitle: tags\ndate: 2018-09-30 18:23:38\ntype: \"tags\"\nlayout: \"tags\"\n---\n```\n\n### 新建关于我 about 页\n\n`about` 页是用来展示**关于我和我的博客**信息的页面，如果在你的博客 `source` 目录下还没有 `about/index.md` 文件，那么你就需要新建一个，命令如下：\n\n```bash\nhexo new page \"about\"\n```\n\n编辑你刚刚新建的页面文件 `/source/about/index.md`，至少需要以下内容：\n\n```yaml\n---\ntitle: about\ndate: 2018-09-30 17:25:30\ntype: \"about\"\nlayout: \"about\"\n---\n```\n\n### 新建友情连接 friends 页（可选的）\n\n`friends` 页是用来展示**友情连接**信息的页面，如果在你的博客 `source` 目录下还没有 `friends/index.md` 文件，那么你就需要新建一个，命令如下：\n\n```bash\nhexo new page \"friends\"\n```\n\n编辑你刚刚新建的页面文件 `/source/friends/index.md`，至少需要以下内容：\n\n```yaml\n---\ntitle: friends\ndate: 2018-12-12 21:25:30\ntype: \"friends\"\nlayout: \"friends\"\n---\n```\n\n同时，在你的博客 `source` 目录下新建 `_data` 目录，在 `_data` 目录中新建 `friends.json` 文件，文件内容如下所示：\n\n```json\n[{\n    \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\",\n    \"name\": \"码酱\",\n    \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\",\n    \"url\": \"http://luokangyuan.com/\",\n    \"title\": \"前去学习\"\n}, {\n    \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\",\n    \"name\": \"闪烁之狐\",\n    \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\",\n    \"url\": \"https://blinkfox.github.io/\",\n    \"title\": \"前去学习\"\n}, {\n    \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\",\n    \"name\": \"ja_rome\",\n    \"introduction\": \"平凡的脚步也可以走出伟大的行程\",\n    \"url\": \"ttps://me.csdn.net/jlh912008548\",\n    \"title\": \"前去学习\"\n}]\n```\n\n### 代码高亮\n\n由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 [hexo-prism-plugin](https://github.com/ele828/hexo-prism-plugin) 的 Hexo 插件来做代码高亮，安装命令如下：\n\n```bash\nnpm i -S hexo-prism-plugin\n```\n\n然后，修改 Hexo 根目录下 `_config.yml` 文件中 `highlight.enable` 的值为 `false`，并新增 `prism` 插件相关的配置，主要配置如下：\n\n```yaml\nhighlight:\n  enable: false\n\nprism_plugin:\n  mode: 'preprocess'    # realtime/preprocess\n  theme: 'tomorrow'\n  line_number: false    # default false\n  custom_css:\n```\n\n### 搜索\n\n本主题中还使用到了 [hexo-generator-search](https://github.com/wzpan/hexo-generator-search) 的 Hexo 插件来做内容搜索，安装命令如下：\n\n```bash\nnpm install hexo-generator-search --save\n```\n\n在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项：\n\n```yaml\nsearch:\n  path: search.xml\n  field: post\n```\n\n### 修改页脚\n\n页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 `/layout/_partial/footer.ejs` 文件中，包括站点、使用的主题、访问量等。\n\n### 修改社交链接\n\n在主题的 `_config.yml` 文件中，默认支持 `QQ`、`GitHub` 和邮箱的配置，你可以在主题文件的 `/layout/_partial/social-link.ejs` 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：\n\n```html\n<a href=\"https://github.com/blinkfox\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\">\n    <i class=\"fa fa-github\"></i>\n</a>\n```\n\n其中，社交图标（如：`fa-github`）你可以在 [Font Awesome](https://fontawesome.com/icons) 中搜索找到。以下是常用社交图标的标识，供你参考：\n\n- Facebook: `fa-facebook`\n- Twitter: `fa-twitter`\n- Google-plus: `fa-google-plus`\n- Linkedin: `fa-linkedin`\n- Tumblr: `fa-tumblr`\n- Medium: `fa-medium`\n- Slack: `fa-slack`\n- 新浪微博: `fa-weibo`\n- 微信: `fa-wechat`\n- QQ: `fa-qq`\n\n> **注意**: 本主题中使用的 `Font Awesome` 版本为 `4.7.0`。\n\n### 修改打赏的二维码图片\n\n在主题文件的 `source/medias/reward` 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。\n\n### 一键部署\n\n通过 [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git) 插件可以实现一键将博客同时部署到多个git仓库中。如同时发布到github及gitee提供的pages服务。安装：\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n修改 Hexo 根目录下的 `_config.yml` 文件中的如下内容。\n\n```yaml\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  - type: git\n    repo: https://github.com/lxl80/blog.git\n    branch: gh-pages\n    ignore_hidden: false\n  - type: git\n    repo: https://gitee.com/lxl80/lxl80.git\n    branch: master\n    ignore_hidden: false\n```\n\n然后通过 `hexo g -d` 即可实现一键发布。\n\n### 文章链接转静态短地址（建议安装）\n\n如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 `SEO`，且 `gitment` 评论对中文链接也不支持。我们可以用 [hexo-permalink-pinyin](https://github.com/viko16/hexo-permalink-pinyin) Hexo 插件生成文章时生成中文拼音的永久链接，或者用[hexo-abbrlink](https://github.com/rozbo/hexo-abbrlink) 生成静态文章链接。以下结合hexo-abbrlink生成类似 `/yyyy/mmdd+随机数.html` 的文章链接地址。\n\n安装命令如下：\n\n```bash\nnpm install hexo-abbrlink --save\n```\n\n在 Hexo 根目录下的 `_config.yml` 文件中，修改 `permalink:` ，并在文件末尾新增 `abbrlink: `配置项：\n```yaml\npermalink: :year/:month:day:abbrlink.html\n\nabbrlink: \n  alg: crc16 #算法选项：默认为crc16丨crc32比crc16复杂一点，长一点 \n  rep: dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制\n```\n\n### CND全站加速（建议启用）\n\n放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，[jsDelivr](https://www.jsdelivr.com/) + Github便是免费且好用的CDN，非常适合博客网站使用。\n\n**用法：**\n\n```http\nhttps://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径\n```\n\n**例如：**\n\n```http\nhttps://cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg\n```\n\n注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源\n\n> 还可以配合 [PicGo](https://github.com/Molunerfinn/PicGo)图床上传工具的**自定义域名前缀**来上传图片，使用极其方便。具体使用方法可参见我的另一篇文章:  [Typora如何方便的使用图床](/2019/120114500.html)\n\n### 文章字数统计插件（可选的）\n\n如果你想要在文章中显示文章字数、阅读时长信息，可以安装 [hexo-wordcount](https://github.com/willin/hexo-wordcount)插件。\n\n安装命令如下：\n\n```bash\nnpm i --save hexo-wordcount\n```\n\n然后只需在本主题下的 `_config.yml` 文件中，激活以下配置项即可：\n\n```yaml\nwordCount:\n  enable: false # 将这个值设置为 true 即可.\n  postWordCount: true\n  min2read: true\n  totalCount: true\n```\n\n### 添加 RSS 订阅支持（可选的）\n\n本主题中还使用到了 [hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed) 的 Hexo 插件来做 `RSS`，安装命令如下：\n\n```bash\nnpm install hexo-generator-feed --save\n```\n\n在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项：\n\n```yaml\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n  content:\n  content_limit: 140\n  content_limit_delim: ' '\n  order_by: -date\n```\n\n执行 `hexo clean && hexo g` 重新生成博客文件，然后在 `public` 文件夹中即可看到 `atom.xml` 文件，说明你已经安装成功了。\n\n## 常用命令\n\n### 指令说明\n`hexo server` #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。\n\n`hexo server -s` #以静态模式启动\n\n`hexo server -p 5000` #更改访问端口   (默认端口为4000，'ctrl + c'关闭server)\n\n`hexo server -i IP地址` #自定义 IP\n\n`hexo clean` #清除缓存  ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹\n\n`hexo g` #生成静态网页  (执行 $ `hexo g`后会在站点根目录下生成public文件夹, hexo会将\"/blog/source/\"   下面的.md后缀的文件编译为.html后缀的文件,存放在\"/blog/public/ \"   路径下)\n\n`hexo d` #自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)\n\n`hexo init` 文件夹名称 #初始化XX文件夹名称\n\n`npm update hexo -g`#升级\n\n`npm install hexo -g` #安装\n\n`node-v`          #查看node.js版本号\n\n`npm -v`        #查看npm版本号\n\n`git --version`  #查看git版本号\n\n`hexo -v`      #查看hexo版本号\n\n### 简写指令\n`hexo n \"我的第一篇文章\"`       等价于        `hexo new \"我的第一篇文章\"`  还等价于       `hexo new post \"我的第一篇文章\" `   \n\n`hexo p` 等价于 `hexo publish`\n\n`hexo g` 等价于 `hexo generate` \n\n`hexo s`等价于 `hexo server`    \n\n`hexo d` 等价于 `hexo deploy`\n\n`hexo g -d`等价于`hexo generate --deploy`\n\n注: `hexo  clean` 没有 简写,  `git --version` 没有简写\n\n## 文章 Front-matter 介绍\n\n### Front-matter 选项详解\n\n`Front-matter` 选项中的所有内容均为**非必填**的。但我仍然建议至少填写 `title` 和 `date` 的值。\n\n| 配置选项   | 默认值                      | 描述                                                         |\n| ---------- | --------------------------- | ------------------------------------------------------------ |\n| title      | `Markdown` 的文件标题        | 文章标题，强烈建议填写此选项                                 |\n| date       | 文件创建时的日期时间          | 发布时间，强烈建议填写此选项，且最好保证全局唯一             |\n| author     | 根 `_config.yml` 中的 `author` | 文章作者                                                     |\n| img        | `featureImages` 中的某个值   | 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: `http://xxx.com/xxx.jpg` |\n| top        | `true`                      | 推荐文章（文章是否置顶），如果 `top` 值为 `true`，则会作为首页推荐文章 |\n| cover      | `false`                     | `v1.0.2`版本新增，表示该文章是否需要加入到首页轮播封面中 |\n| coverImg   | 无                          | `v1.0.2`版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 |\n| password   | 无                          | 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 `password` 的值，该值必须是用 `SHA256` 加密后的密码，防止被他人识破。前提是在主题的 `config.yml` 中激活了 `verifyPassword` 选项 |\n| toc        | `true`                      | 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 `config.yml` 中激活了 `toc` 选项 |\n| mathjax    | `false`                     | 是否开启数学公式支持 ，本文章是否开启 `mathjax`，且需要在主题的 `_config.yml` 文件中也需要开启才行 |\n| summary    | 无                          | 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 |\n| categories | 无                          | 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 |\n| tags       | 无                          | 文章标签，一篇文章可以多个标签                              |\n\n> **注意**:\n> 1. 如果 `img` 属性不填写的话，文章特色图会根据文章标题的 `hashcode` 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图**各有特色**。\n> 2. `date` 的值尽量保证每篇文章是唯一的，因为本主题中 `Gitalk` 和 `Gitment` 识别 `id` 是通过 `date` 的值来作为唯一标识的。\n> 3. 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 `_config.yml` 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：[开源中国在线工具](http://tool.oschina.net/encrypt?type=2)、[chahuo](http://encode.chahuo.com/)、[站长工具](http://tool.chinaz.com/tools/hash.aspx)。\n\n以下为文章的 `Front-matter` 示例。\n\n### 最简示例\n\n```yaml\n---\ntitle: typora-vue-theme主题介绍\ndate: 2018-09-07 09:25:00\n---\n```\n\n### 最全示例\n\n```yaml\n---\ntitle: typora-vue-theme主题介绍\ndate: 2018-09-07 09:25:00\nauthor: 赵奇\nimg: /source/images/xxx.jpg\ntop: true\ncover: true\ncoverImg: /images/1.jpg\npassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92\ntoc: false\nmathjax: false\nsummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\ncategories: Markdown\ntags:\n  - Typora\n  - Markdown\n---\n```\n\n## 效果截图\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20191201160205.png/w1280\" alt=\"首页\" style=\"zoom: 50%;\" />\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20191201160256.png/w1280\" alt=\"标签页\" style=\"zoom:50%;\" />\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20191201160325.png/w1280\" alt=\"归档页\" style=\"zoom:50%;\" />\n\n<img src=\"https://lxl823.oss-cn-beijing.aliyuncs.com/2019/20191201160350.png/w1280\" alt=\"文章详情页\" style=\"zoom:50%;\" />\n\n## 自定制修改\n\n在本主题的 `_config.yml` 中可以修改部分自定义信息，有以下几个部分：\n\n- 菜单\n- 我的梦想\n- 首页的音乐播放器和视频播放器配置\n- 是否显示推荐文章名称和按钮配置\n- `favicon` 和 `Logo`\n- 个人信息\n- TOC 目录\n- 文章打赏信息\n- 复制文章内容时追加版权信息\n- MathJax\n- 文章字数统计、阅读时长\n- 点击页面的'爱心'效果\n- 我的项目\n- 我的技能\n- 我的相册\n- `Gitalk`、`Gitment`、`Valine` 和 `disqus` 评论配置\n- [不蒜子统计](http://busuanzi.ibruce.info/)和谷歌分析（`Google Analytics`）\n- 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 `hashcode` 值取余，来选择展示对应的特色图\n\n**我认为个人博客应该都有自己的风格和特色**。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 `_config.yml` 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：\n\n### 修改主题颜色\n\n在主题文件的 `/source/css/matery.css` 文件中，搜索 `.bg-color` 来修改背景颜色：\n\n```css\n/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */\n.bg-color {\n    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);\n}\n\n@-webkit-keyframes rainbow {\n   /* 动态切换背景颜色. */\n}\n\n@keyframes rainbow {\n    /* 动态切换背景颜色. */\n}\n```\n\n### 修改 banner 图和文章特色图\n\n你可以直接在 `/source/medias/banner` 文件夹中更换你喜欢的 `banner` 图片，主题代码中是每天动态切换一张，只需 `7` 张即可。如果你会 `JavaScript` 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，`banner` 切换的代码位置在 `/layout/_partial/bg-cover-content.ejs` 文件的 `<script></script>` 代码中：\n\n```javascript\n$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');\n```\n\n在 `/source/medias/featureimages` 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 `_config.yml` 做同步修改。\n\n## 参照网站\n- [闪烁之狐](https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/)\n- [hexo-theme-matery](https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md)\n- [Hexo进阶之各种优化](https://blog.sky03.cn/posts/42790.html#toc-heading-1)\n\n  ","tags":["Hexo"],"categories":["工具"]},{"title":"Tensorflow2.0入门实战","url":"/2019/090963177.html","content":"​\t\tTensorFlow是2015年年底开源的一套深度学习框架，是目前最活跃的深度学习框架。本文基于2.0版本，首先介绍它的安装和基本用法，然后讨论了深度学习的基本概念，包括神经网络前向计算、损失函数、反向传播计算和优化函数等，接着介绍了卷积神经网络和循环神经网络，最后介绍了在大规模应用的场景下，如何实现分布式的深度学习训练。\n\n### 安装Tensorflow环境：\n```bash\n# 安装python3,pip \nsudo yum -y install epel-release\nsudo yum -y install gcc gcc-c++ python3-pip python-devel atlas atlas-devel gcc-gfortran openssl-devel libffi-devel\n\n#更新python国内源\n\tmkdir ~/.pip\n\tvim ~/.pip/pip.conf\n\t\t[global]\n\t\tindex-url = https://pypi.mirrors.ustc.edu.cn/simple/\n\t\t[install]\n\t\ttrusted-host = mirrors.ustc.edu.cn\n# 安装virtualenv\npip3 install --upgrade virtualenv\nvirtualenv --system-site-packages ~/venvs/tensorflow\n\ncurl \nsudo python get-pip.py\npip --version\n\nsudo pip install virtualenv\nvirtualevn --version\n\n# 创建python虚拟环境\nvirtualenv --system-site-packages -p python2.7 ./venv\n# 激活虚拟环境\nsource venv/bin/activate\n\n# 安装Tensorflow\npip install  -i http://mirrors.aliyun.com/pypi/simple/ tensorflow\n# 查看安装的软件\npip list installed\n\n#通过python交互式环境验证安装是否成功\npython\nimport tensorflow as tf\nexit()  //退出python交互环境\ndeactivate  //退出python虚拟环境\n```\n\n### Helloworld示例验证\n```bash\nsource venv/bin/activate\npython //进入python交互式环境\nimport tensorflow as tf\nhello = tf.constant(\"hello tensorflow.)\nsess = tf.Session()\nsess.run(hello)\n```\n\n### 在Jupyter交互式环境中使用Tensorflow\n```bash\npip install jupyter\npython -m ipykernel install --user --name=venv\njupyter kernelspec list\njupyter notebook //自动打开浏览器\n```\n\n### 在Docker中使用Tensorflow\n```bash\ndocker pull tensorflow/tensorflow:nightly-jupyter\nvim docker-compose.yml #制作配置文件\ndocker-compose up -d #初次启动，以后用start/stop\ndocker exec -it xxxx bash #进入docker,然后执行如下命令升级安装Python3\n\tapt-get update\n\tapt-get install python-software-properties\n\tapt-get install python3.6\n\tapt install python3-pip\n\t#更新python国内源\n\tmkdir ~/.pip\n\tvim ~/.pip/pip.conf\n\t\t[global]\n\t\tindex-url = https://pypi.mirrors.ustc.edu.cn/simple/\n\t\t[install]\n\t\ttrusted-host = mirrors.ustc.edu.cn\n\t\t\n\t#在jupyter中启用python3\n\tjupyter kernelspec list # 查看激活的kernel\n\tpython3 -m pip install ipykernel  \n\tpython3 -m ipykernel install --user\n\n\trm /usr/local/bin/python\n\tln -s /usr/bin/python3.6 /usr/local/bin/python\n\tpython --version  #显示Python 3.6.x，则安装成功\n\n\tpip install --upgrade tensorflow jupyter matplotlib pandas seaborn numpy tensorflow-hub tensorflow-datasets pillow\n\tpip list installed\n```\n- 使用docker-compose管理容器\n```ymal\nversion:  '3'\nservices:\n  tensorflow-jupyter:\n    image: tensorflow/tensorflow:nightly-jupyter\n    ports:\n      - \"8888:8888\"\n      - \"6006:6006\"\n    volumes:\n      - .:/tf/notebooks\n```\n启动： docker-compose up\n\n### Tensorflow架构介绍\n\n<img src=\"https://pic4.zhimg.com/80/v2-14f1196030f7bd2db1ceff96bc9b0ddb_hd.jpg\" alt=\"Tensorflow架构图一\" style=\"zoom:50%;\" />\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/3b16e5b406f603289fdeb140ee76e14190f57f14a72d49c11aea6fbd116b59234c971528be44e40cf6d42d638a2c3b14?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;size=750=\" alt=\"Tensorflow架构图二\" style=\"zoom: 50%;\" />\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/4250deb81e391cffa189c9d95f4a4e1c74c1fbb43c6a60b0ddd5efea4acd47ba090e0f3c42b5146ddfe7d7edf6bc8686?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;size=750=\" style=\"zoom:50%;\" />\n\n### 实战：使用CNN识别彩色尺寸各异的猫狗图片\n​\t参考 [Colab](https://colab.research.google.com/drive/1WerlZnNfh7N4RqO26gbctQ6NINkMxPkO)\n  #### 扁平化处理\n \t调整尺寸为一致的150 * 150，以便可以生成相同大小的一位数组\n  #### 彩色图像处理\n \t使用三维数组建模，增加RGB作为3维数组的深度值，如图：\n    <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0479c21b4302a6c26eb97984094a43864ca895cb1e33bb3f41de3f5a7d408d9d7a723f11ff403adc1ea9749c252ae77e?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;size=750=\" style=\"zoom:50%;\" />\n\n  #### 对彩色图像执行卷积运算：\n- 将彩色图像分解为3维数组\n  <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c50a4ac38c7ce1aba88acd8610c03e76ca95fe46cdd25a11313bf9f5626602d00af10dc4b8cbab30601f6c19eb1a30ae?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=111.png&amp;size=750\" style=\"zoom:50%;\" />\n- 利用三个过滤核进行卷积运算示例\n    <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/d5867af3457e0692e7d8e33c54aa169ac453c7e75c4a9a9e634b195027b320c708e3aa95b9f8c2c048096570fffb3f4e?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=112.png&amp;size=450\" style=\"zoom:50%;\" />\n- 示例中使用三个三维过滤器进行卷积运算\n    <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c059b5c447235ce967e6a6624cc566aa1905b7e2ab7754c0c23b38b32dd9059dc59fc3c7eae44bdb951220dcbbc79e53?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-163837%402x.png&amp;size=750 =\" alt=\"使用三个过滤核进行卷积运算获得的三维结果\" style=\"zoom: 50%;\" />\n- 代码说明\n```\n  tf.keras.layers.Conv2D(filters, kernel_size, ...)  #  参数：过滤器数量, 卷积核形状, ...\n  #本例中使用：\n  tf.keras.layers.Conv2D(3, (3,3), ...)\n```\n​\t在训练CNN时，将通过损失函数更新三维核中的值，从而最小化损失。\n\n  #### 执行最大池化运算\n      <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/9f7687a18e5b38514ae2a90d6fc13fdbeec4ce39957fb08f465afbf43f16b912d982cdb72fb9f3d24e7cd455d1ffec8f?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-175829%402x.png&amp;size=750=\" style=\"zoom:40%;\" />\n\n   最大池化处理后，获得的三维数组宽度和高度减半，但深度不变。\n\n  #### 使用验证集解决过拟合问题（早停法）\n\n​    通常在完成训练后，在测试集上进行验证才能发现过拟合问题。可以通过增加验证集，在每轮训练过程中基于验证集检查效果，分析训练损失和验证损失与周期的函数图，可判断出模型泛化效果。\n\n   <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/e8f7b98ddbbc9f117c5d1bf110d76ef3b414866b0b6e3539338b3216fe451f8aa59c6ffa5601e4c59d970ba8ecffb2db?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-201908%402x.png&amp;size=750\" style=\"zoom:40%;\" />\n\n   \t可以看出，验证集有助于我们判断CNN应该训练多少个周期，即可以达到较好的训练效果又不会出现过拟合，提前结束训练一遍获取最优模型。对于有多个潜在模型可选择时（如为模型选择合适的参数/结构），也可以用这种方法对比选择最优模型。\n\n> 如果训练集足够广泛（如各种各样可能的图片都有，如大小，位置，猫狗完整性等），将有助于训练出泛化能力强的模型。\n\n  #### 使用图像增加技术避免过拟合\n\n​    通过应用各种图片变换，可以增加样本数量，提高泛化能力避免过拟合的效果。\n\n   <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0d8bfb44efdffc9b668a4823a975c2cf71f25fa4d821352a1d1ca753744267a8df99e53f85482386e6a262712cfef8dc?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-204934%402x.png&amp;size=750\" style=\"zoom:40%;\" />\n\n  ### 使用随机丢弃避免过拟合（仅限深度神经网络）\n\n​     丢弃是指在训练过程中，随机关闭网络中的某些神经元。可以强制其它神经元产生更大的影响，在训练中扮演积极角色，如图：\n\n   <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/2c5a2132d7102530a3931a7105d7a8072be268a23bce15834b5e7535b6980e861cd49cbe5491ab8a854259885654f033?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-211219%402x.png&amp;size=750\" style=\"zoom:40%;\" />\n\n   在实践中，会指定每个训练周期每个神经元被丢弃的概率。\n\n### 实战： 图片增强的狗与猫图片分类\n\n参考[Colab](https://colab.research.google.com/drive/1d3BmTUhMi4zFL9p4PMrKObJvfwj1zvFL#scrollTo=LZPYT-EmVrWo)，我们将遵循一般的机器学习流程:\n- Examine and understand data 检查和理解数据\n- Build an input pipeline 构建输入管道\n- Build our model 建立我们的模型\n- Train our model 训练我们的模型\n- Test our model 测试我们的模型\n- Improve our model/Repeat the process 改进我们的模型 / 重复这个过程\n\n### 其它避免过拟合的技巧\n\n- 收集更多数据及添加噪音：这和数据增强的目的是一样的，但是也会使模型对于自然界中可能遇到的干扰更加稳定。\n\n- 简化模型：通过逐步降低模型的复杂性ーー随机森林中估计值的数目、神经网络中参数的数目等ーー你可以使模型足够简单，不会过度拟合，但也足够复杂，可以从你的数据中学习。 要做到这一点，根据模型的复杂性来查看两个数据集上的错误是很方便的。\n\n- 改变训练方式：包括改变损失函数，或者模型在训练期间的工作方式。\n\n- 正则化：正则化是一个约束模型学习以减少过拟合的过程。 其中一个最强大的和众所周知的技术正则化是增加一个惩罚的损失函数。 最常见的是 L1和 L2。L1惩罚的目的是最小化权重的绝对值，这有助于识别数据集中最相关的特性。L2惩罚的目的是使权重的平方最小化，效率高于L1。通过惩罚，该模型被迫在权重上做出妥协，因为它不能再将权重任意增加。 这使得模型更加通用，有助于防止过拟合。\n\n  参考文章： [6 tricks to prevent overfitting in machine learning.](https://hackernoon.com/memorizing-is-not-learning-6-tricks-to-prevent-overfitting-in-machine-learning-820b091dc42)\n\n### 练习：增加版花朵图像分类\n\n​\t参考：[自行练习版Colab](https://colab.research.google.com/drive/1uURGgGNTeeyJ4Zfeoz81ggmUARxuNhfK#scrollTo=tk5NT1PW3j_P)，[官方版Colab]()\n\n### 迁移学习\n\n#### \t基础知识\n\n迁移学习的原理是通过使用由机器学习专家创建的经过大型数据训练过的模型，将模型已经学习到的知识迁移到新的数据集上，可以显著提高预测准确率。如上面猫狗识别的实战可以将准确率从80%提高到95%\n\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/8ec95bbbf4a17ab91b71cffaca9dca22f2f4020cd3b621c387f2972b0678f4ae35aec76d835f9c464c5a5f9edfed187b?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-130000%402x.png&amp;size=750=\" style=\"zoom:40%;\" />\n\n​\t\t在迁移学习中，预训练的模型中的参数将被冻结（避免随机初始化权重），只训练最后分类层级的变量，可以显著提高训练速度。\n\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/695902034ea19e36c9a7169926b7872bebc6f2c9f4aa53fa4aa88cc556012da1cb029e18d4688174459ef489ca77d718?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-130849%402x.png&amp;size=750\" style=\"zoom:35%;\" />\n\n​\t示例代码：\n\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/58b0e59034ade88fb41c26a1c7c918efc3eccfae6995ec8fb908883b250ea2273c2653bb2cfc96dbe6a6cb144570c40d?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-132906%402x.png&amp;size=750\" style=\"zoom:40%;\" />\n\n​\t参考Colab：[对猫狗数据集应用迁移学习](https://colab.research.google.com/drive/1aGtbtCl2wSrcIMk9aadlJz2LtCHZ601R#scrollTo=3n0Wb9ylKd8R) , [通过迁移学习分类花朵图像](https://colab.research.google.com/drive/177BHQe1KCLdzMvMW7TvSRfblPsG30fJV#scrollTo=oXiJjX0jfx1o)\n\n### 实战：房价预测（线性回归）\n\n#### \t基础知识\n\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/9a5c4539cd94381da65ed1936112134e2b4a12ee162954ca027e4b288fe87ba83dcf95a32a54eaa18a52be096bb2d439?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-151749%402x.png&amp;size=750\" style=\"zoom:40%;\" />\n\n<img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/08aa206814b71996987241fb6f0cfaad6b870417d5ab71ee80d9795d49a33764f92bf4e4aacf94824ecb83a82f88ed63?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-153950%402x.png&amp;size=750\" style=\"zoom:40%;\" />\n\n- matplotlib 是一个 Python 2D 绘图库，可以生成出版物质量级别的图像和各种硬拷贝格式，并广泛支持多种平台，如:Python 脚本，Python，IPython Shell 和 Jupyter Notebook。\n\n- seaborn 是一个基于 matplotlib的 Python 数据可视化库。它提供了更易用的高级接口，用于绘制精美且信息丰富的统计图形。\n\n- mpl_toolkits.mplot3d 是一个基础 3D绘图(散点图、平面图、折线图等)工具集，也是matplotlib 库的一部分。同时，它也支持轻量级的独立安装模式。\n\n- NumPy 是一个 BSD 开源协议许可的，面向 Python 用户的基础科学计算库，在多 维数组上实现了线性代数、傅立叶变换和其他丰富的函数运算。\n\n  <img src=\"https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/f602ee77363996f0a1d8eae20742ca797fbdf93f868417b1733f05ed5dae75508b1bc5c10925984456133eb0f56014b9?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-171026%402x.png&amp;size=750\" style=\"zoom:40%;\" />\n\n\n\n### 参考文章\n\n- [Tensorflow free course](https://classroom.udacity.com/courses/ud187)\n- [Introducing TensorFlow Hub: A Library for Reusable Machine Learning Modules in TensorFlow](https://medium.com/tensorflow/introducing-tensorflow-hub-a-library-for-reusable-machine-learning-modules-in-tensorflow-cdee41fa18f9)\n- [Understanding your Convolution network with Visualizations](https://towardsdatascience.com/understanding-your-convolution-network-with-visualizations-a4883441533b)\n- [TensorFlow快速入门与实战](https://time.geekbang.org/course/detail/153-78981)\n- [Win10安装Tensorflow](https://www.cnblogs.com/guoyaohua/p/9265268.html)\n- [超详细：win10安装tensorflow-gpu1.8.0完整步骤](https://blog.csdn.net/xiaohuihui1994/article/details/83589701)","tags":["Tensorflow"],"categories":["人工智能"]},{"title":"机器学习常用术语","url":"/2019/090864521.html","content":"\n​\t\t机器学习领域有着许多非常基本的术语，这些术语听来可能相当高深莫测、它们事实上也可能拥有非常复杂的数学背景，本文会对这些常用的基本术语进行说明与解释。\n\n- 人工智能：一种计算机科学分支，旨在让计算机达到人类的智慧。实现这一目标有很多方式，包括机器学习和深度学习。\n- 机器学习：一系列相关技术，用于训练计算机执行特定的任务。\n- 神经网络：一种机器学习结构，灵感来自人类大脑的神经元网络。神经网络是深度学习的基本概念。\n- 深度学习：机器学习的一个分支，利用多层神经网络实现目标。通常“机器学习”和“深度学习”可以相互指代。\n- 监督式学习：\n- 非监督式学习：\n- 训练流程：是指将网络的内部变量调整为最佳可能值，使它们能够将输入映射到输出。为了实现这个目标，我们将采用梯度下降法这一优化流程，它会使用数值分析找到模- 型内部变量的最佳可能值。\n- 梯度下降法：梯度下降法会以迭代方式调整参数，每次朝着正确的方向小幅更改参数，直到达到最佳值。“最佳值”是指再调整的话，会降低模型的效果。在每次迭代过程中- 衡量模型好坏的函数称为“损失函数”，每次调整的目标是“最小化损失函数”。\n- 特征：模型的输入\n- 样本：用于训练流程的输入/输出对\n- 标签：模型的输出\n- 层级：神经网络中相互连接的节点集合。\n- 模型：神经网络的表示法\n- 密集全连接层 (FC)：一个层级中的每个节点都与上个层级中的每个节点相连。\n- 权重和偏差：模型的内部变量\n- 损失：期望输出和真实输出之间的差值\n- MSE：均方误差，一种损失函数，它会将一小部分很大的差值视作比大量很小的差值更糟糕。\n- 梯度下降法：每次小幅调整内部变量，从而逐渐降低损失函数的算法。\n- 优化器：梯度下降法的一种具体实现方法。（有很多算法。在这门课程中，我们将仅使用“Adam”优化器，它是 - ADAptive with Momentum 的简称，并且被视为最佳优化器。）\n- 学习速率：梯度下降过程中的损失改进“步长”。\n- 批次：在训练神经网络的过程中使用的一组样本。\n- 周期：完全经过整个训练数据集一轮\n- 前向传播：根据输入计算输出值\n- 反向传播：根据优化器算法计算内部变量的调整幅度，从输出层级开始，并往回计算每个层级，直到抵达输入层。\n- 扁平化：将二维图像转换为一维向量的过程\n- ReLU：一种激活函数，使模型能够解决非线性问题。如果它接收到任何负输入，则该函数返回0，但对于任何正值x，它返回该值。参考：[深度学习中的 ReLU](https://www.kaggle.com/dansbecker/rectified-linear-units-relu-in-deep-learning)\n- Softmax：一种函数，能够为每个潜在输出类别生成概率\n- 分类：一种机器学习模型，用于区分两个或多个输出类别\n- 训练集：用于训练神经网络的数据。\n- 测试集：用于测试神经网络最终效果的数据。\n- 验证集：训练完毕时，使用验证集衡量模型的最终准确率。\n- 递归：输出一个值的模型。例如，估算房屋价值。\n- 分类：一种模型，能够输出多个类别的概率分布。\n- CNN：卷积神经网络。即至少有一个卷积层的网络。典型的 CNN 还包括其他类型的层级，例如池化层和密集层。\n- 卷积：向图像应用核（滤波器）的过程\n- 核/滤波器：小于输入的矩阵，用于将输入变成多个小区域\n- 填充：在输入图像周围添加像素，像素值通常为 0\n- 池化：通过下采样降低图像大小的过程。池化层有多种类型。例如，平均池化通过求平均值将多个值变成一个值。但是最大池化是最常见- 的池化类型。\n- 最大池化：一种池化过程，通过获取多个值中的最大值，将多个值变成一个值。\n- 步长：在图像上滑动核（滤波器）的间隔像素数量。\n- 下采样：降低图像大小的操作\n\n## 其它基础知识常用术语：\n- 线性与非线性：\n- 一维向量：\n- 方差：是指一组数据中的各个数减这组数据的平均数的平方和的平均数，如（1，2，3,4,5）这组数据的方差，就先求出这组数据的平均数（1+2+3+4+5）÷5＝3，然后再求各个数与平均数的差的平方和，用（1-3）²+（2-3）²+（3-3）²+（4-3）²+（5-3）²＝10，再求平均数10÷5＝2，即这组数据的方差为2. 意义：当数据分布比较分散（即数据在平均数附近波动较大）时，各个数据与平均数的差的平方和较大，方差就较大；当数据分布比较集中时，各个数据与平均数的差的平方和较小。因此方差越大，数据的波动越大；方差越小，数据的波动就越小。方差不仅仅表达了样本偏离均值的程度，更是揭示了样本内部彼此波动的程度，也可以理解为方差代表了样本彼此波动的期望。\n\n\n\n## 常用算法模型\n\n- OpenPose：OpenPose人体姿态识别项目是美国卡耐基梅隆大学（CMU）基于卷积神经网络和监督学习并以caffe为框架开发的开源库。可以实现人体动作、面部表情、手指运动等姿态估计。适用于单人和多人，具有极好的鲁棒性。是世界上首个基于深度学习的实时多人二维姿态估计应用。其成功的一部分原因是它在 GitHub 上开源了其实现代码（ https://github.com/CMU-Perceptual-Computing-Lab/openpose ），并配有详细的说明文档。\n\n- DeepCut：DeepCut（ https://arxiv.org/abs/1511.06645 ）是一个自底向上的多人人体姿态估计方法。\n\n- RMPE（AlphaPose）：是一个流行的自顶向下姿态估计算法。该论文的作者认为，自顶向下方法的性能通常依赖于人体检测器的精度，毕竟人体姿态估计是在检测器检出的框的区域内进行的。因此，错误的定位和重复的候选框会使姿态检测算法的性能降低。为解决这一问题，作者提出了使用对称空间变换网络（Symmetric Spatial Transformer Network，SSTN）来从不准确的候选框中抽取高质量的单人区域。然后，作者使用了一个单人的姿态估计器（Single Person Pose Estimator，SPPE）来从抽取到的区域中估计此人的姿态骨架。接着，作者用一个空间逆变换网络（Spatial De-Transformer Network，SDTN），将估计出的姿态重新映射到图像坐标系下。最后，用一个参数化的姿态非极大抑制（Non-Maximum Suppression，NMS）方法来处理重复预测的问题。另外，作者还引入了一种姿态候选生成器（Pose Guided Proposals Generator），来增广训练样本，以便更好地训练 SPPE 和 SSTN 网络。RMPE 的显著特征是，该方法可以推广到任意的人体检测算法和 SSPE 的组合。\n\n- Mask RCNN：Mask RCNN（ https://arxiv.org/abs/1703.06870 ）是一个非常流行的语义和实例分割架构。该模型可以同时预测图像中多个物体的候选框位置及分割其语义信息的 mask。该模型的基础架构很容易被扩展到人体姿态估计上来。\n\n- DensePose：这是Mask-RCNN的一种变体，可以以每秒多帧的速度在每个人体区域内密集地回归特定部位的UV坐标。它基于一种能将图像像素通过卷积网络映射到密集网格的系统——DenseReg。模型的目标是决定每个像素在表面的位置以及它所在部分相对应的2D参数。DensePose借用了Mask-RCNN的架构，同时带有Feature Pyramid Network（FPN）的特征，以及ROI-Align池化。除此之外，他们在ROI池化的顶层搭建了一个全卷积网络。想了解DensePose更多的技术细节，请阅读原论文。\n\n- Realtime Multi-Person Pose Estimation： 这一模型和上面的OpenPose高度相关，同时特征模型能与多种框架相关联。论文的作者提供了一种自下而上的方法，对多人的姿态进行实时估计，不需要用任何人物探测器。这种方法运用了一种非参数表示，我们称为Part Affinity Fields（PAFs），用它可以学习将图中人物和其身体部位联系到一起。有关该技术的具体细节和理论，可以阅读原文。另外，这一方法最棒的特征之一就是它可以在多种不同的框架中实现，针对不同框架，已经公开了相关代码和模型。\n\n- AlphaPose：lphaPose是一款精准的多人姿态评估工具，并声称是第一款开源系统。AlphaPose既可以在图片、视频或多图中进行姿态估计，也能在画面中对动作进行追踪。它的输出形式非常广泛，包括PNG、JPG和AVI等具有关键点的图片形式，也有JSON格式的输出，这一特点也使其成为众多应用受欢迎的工具。目前，这一工具支持TensorFlow和PyTorch两种实现。AlphaPose利用一种区域性的多人动作估计框架将不精准的人类边界框该进程精确的动作估计。这里有三种元素：对称空间转换网络（SSTN）、参数化姿态非极大抑制（NMS）以及姿态导向的生成器（PGPG）。\n\n- DeepPose： DeepPose算是比较“古老”的了，论文发布与2014年，提出了一种基于深度神经网络的姿态估计方法，是基于DNN向身体关节回归的问题。它以一种整体的方式估计姿态，并且表述起来非常简洁强大。DeepPose是第一个将深度学习应用到人类姿态估计上的应用，并且取得了当时顶尖的结果，成为了其他方法的baseline。\n\n- MTCNN人脸检测：是2016年的论文提出来的，MTCNN的“MT”是指多任务学习(Multi-Task)，在同一个任务中同时学习”识别人脸“、”边框回归“、”人脸关键点识别“。相比2015年的CVPR(边框调整和识别人脸分开做)的结构，MTCNN是有创新的。\n\n- FaceNet：是 Google 研究人员于 2015 年开发的人脸识别系统，一个通用的系统，可以用于人脸验证（是否是同一人？），识别（这个人是谁？）和聚类（寻找类似的人？）。与其他的深度学习方法在人脸上的应用不同，FaceNet并没有用传统的softmax的方式去进行分类学习，然后抽取其中某一层作为特征，而是直接进行端对端学习一个从图像到欧式空间的编码方法，然后基于这个编码再做人脸识别、人脸验证和人脸聚类等。通过卷积神经网络学习将图像映射到欧几里得空间。空间距离直接和图片相似度相关：同一个人的不同图像在空间距离很小，不同人的图像在空间中有较大的距离。\n\n- CTPN：是在ECCV 2016提出的一种文字检测算法。CTPN结合CNN与LSTM深度网络，能有效的检测出复杂场景的横向分布的文字，是目前比较好的文字检测算法。 https://zhuanlan.zhihu.com/p/34757009\n\n- Faster RCNN：经过R-CNN和Fast RCNN的积淀，Ross B. Girshick在2016年提出了新的Faster RCNN，在结构上，Faster RCNN已经将特征抽取(feature extraction)，proposal提取，bounding box regression(rect refine)，classification都整合在了一个网络中，使得综合性能有较大提高，在检测速度方面尤为明显。\n\n- SLAM： Simultaneous Localization And Mapping的 英文首字母组合，一般翻译为：同时定位与建图、同时定位与地图构建。SLAM是指当某种移动设备（如机器人、无人机、手机等）从一个未知环境里的未知地点出发，在运动过程中通过传感器（如激光雷达、摄像头等）观测定位自身位置、姿态、运动轨迹，再根据自身位置进行增量式的地图构建，从而达到同时定位和地图构建的目的。定位和建图是两个相辅相成的过程，地图可以提供更好的定位，而定位也可以进一步扩建地图。需要说明的是，上述扫地机器人例子中，定位和建图是SLAM的基本要求，而路径规划是在此基础上的高级功能，不属于SLAM的讨论范畴。\n\n- SFM：Structure From Motion，通过相机的移动来确定目标的空间和几何关系，是三维重建的一种常见方法。\n  它与Kinect这种3D摄像头最大的不同在于，它只需要普通的RGB摄像头即可，因此成本更低廉，且受环境约束较小，\n  在室内和室外均能使用。\n  \n- ResNet：ResNet是由微软研究院的Kaiming He等四名华人提出，他们通过自己提出的ResNet Unit成功训练出来152层的神经网络并在ILSVRC2015比赛中斩获冠军。ResNet语义分割领域最受欢迎且最广泛运用的神经网络.ResNet的核心思想就是在网络中引入恒等映射，允许原始输入信息直接传到后面的层中，在学习过程中可以只学习上一个网络输出的残差（F(x)），因此ResNet又叫做残差网络。、\n\n- R-CNN：伯克利大学的Girshick教授等人共同提出了首个在目标检测方向应用的深度学习模型：Region-based Convolutional Neural Network（R-CNN）。该网络模型如下图所示，其主要流程为：先使用selective search算法提取2000个候选框，然后通过卷积网络对候选框进行串行的特征提取，再根据提取的特征使用SVM对候选框进行分类预测，最后使用回归方法对区域框进行修正。\n\n  <img src=\"https://pic2.zhimg.com/80/v2-bd5baff7669ca7ddce811c7149c11799_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n- Fast R-CNN：由于R-CNN的效率太低，2015年由Ross等学者提出了它的改进版本：Fast R-CNN。其网络结构图如下图所示（从提取特征开始，略掉了region的选择）Fast R-CNN在传统的R-CNN模型上有所改进的地方是它是直接使用一个神经网络对整个图像进行特征提取，就省去了串行提取特征的时间；接着使用一个RoI Pooling Layer在全图的特征图上摘取每一个RoI对应的特征，再通过FC进行分类和包围框的修正。\n\n  <img src=\"https://pic2.zhimg.com/80/v2-ae08e5aa35c2e8bfd65491e3c39888cd_hd.jpg\" style=\"zoom:50%;\" />\n\n- Faster R-CNN：2016年提出的Faster R-CNN可以说有了突破性的进展（虽然还是目标检测哈哈哈），因为它改变了它的前辈们最耗时最致命的部位：selective search算法。它将selective search算法替换成为RPN，使用RPN网络进行region的选取，将2s的时间降低到10ms，其网络结构如下图所示：\n\n  <img src=\"https://pic3.zhimg.com/80/v2-d7b27123e9e95200303959aeaf8816e2_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n  ​\tFaster R-CNN优缺点：\n\n  - 使用RPN替换了耗时的selective search算法，对整个网络结构有了突破性的优化；\n  - Faster R-CNN中使用的RPN和selective search比起来虽然速度更快，但是精度和selective search相比稍有不及，如果更注重速度而不是精度的话完全可以只使用RPN；\n\n- Mask R-CNN：Mask R-CNN（终于到分割了！）是何恺明大神团队提出的一个基于Faster R-CNN模型的一种新型的分割模型，此论文斩获ICCV 2017的最佳论文，在Mask R-CNN的工作中，它主要完成了三件事情：目标检测，目标分类，像素级分割。恺明大神是在Faster R-CNN的结构基础上加上了Mask预测分支，并且改良了ROI Pooling，提出了ROI Align。其网络结构真容就如下图所示啦：\n\n  <img src=\"https://pic4.zhimg.com/80/v2-8123af16197c5b6b486808fafe2246d7_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n  ​\tMS R-CNN的优缺点：\n\n  - 优化了Mask R-CNN中的信息传播，提高了生成预测模板的质量；\n  - 未经大批量训练的情况下，就拿下了COCO 2017挑战赛实例分割任务冠军；\n  - 要说缺点的话。。应该就是整个网络有些庞大，一方面需要ResNet当作主干网络，另一方面需要其它各种Head共同承担各种任务。\n\n- SetNet：SegNet是剑桥提出的旨在解决自动驾驶或者智能机器人的图像语义分割深度网络，SegNet基于FCN，与FCN的思路十分相似，只是其编码-解码器和FCN的稍有不同，其解码器中使用去池化对特征图进行上采样，并在分各种保持高频细节的完整性；而编码器不使用全连接层，因此是拥有较少参数的轻量级网络：\n\n  <img src=\"https://pic4.zhimg.com/80/v2-f6a18a6bad1cbfd8c359a45656604fe3_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n  ​\tSetNet的优缺点：\n\n  - 保存了高频部分的完整性；\n  - 网络不笨重，参数少，较为轻便；\n  - 对于分类的边界位置置信度较低；\n  - 对于难以分辨的类别，例如人与自行车，两者如果有相互重叠，不确定性会增加。\n\n- LSTM:长短时记忆（LSTM，Long Short Term Memory）模型在时间信息处理中很受欢迎，关键思想是单元（cell）状态，如图水平线贯穿的顶部。LSTM将信息移除或添加到单元状态（cell state），称为门（gates）：输入门（𝑖𝑡），忘记门（𝑓𝑡）和输出门（𝑜𝑡）可以定义为如下公式：\n\n  <img src=\"https://pic2.zhimg.com/80/v2-3f99658ef0bee863c16c243cf5de9279_hd.jpg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n- GRU：Gated Recurrent Unit ，也来自LSTMs。GRU受欢迎的主要原因是计算成本和模型的简单性，如图所示。在拓扑、计算成本和复杂性方面，GRU是比标准LSTM更轻的RNN版。 该技术将遗忘门（forget gates）和输入门（input gates）组合成单个“更新门（update gate）”，并将单元状态、隐藏状态以及一些其他变化合并。更简单的GRU模型越来越受欢迎。数学上GRU可以用表示如下公式：\n\n  <img src=\"https://pic4.zhimg.com/80/v2-15ac0386cacc6f89cd9b4bbe07806ebf_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n- RNN： 递归神经网络（Recurrent Neural Network，RNN），不同于CNN，是用来处理序列数据的模型。有一点共同的是，RNN在几个时间点也具有共享权重的特点。RNN是唯一的，它允许随时间推移在一系列向量上进行操作。在Elman架构中，使用隐层的输出和隐层的正常输入一起作为输入。 另一方面，Jordan网络中输出单元的输出作为隐藏层的输入。相反地Jordan使用输出单元的输出同时作为自身和隐藏层的输入。RNN方法的主要问题是梯度消失/下降。如图示意所示。\n\n  <img src=\"https://pic4.zhimg.com/80/v2-4359eedb6d8821257dae8988614b7d23_hd.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n- 迁移学习：迁移学习是一种机器学习的方法，指的是一个预训练的模型被重新用在另一个任务中。迁移学习是一种优化，是一种节省时间或者得到更好性能的捷径。\n\n- ArchiGAN: 基于GAN实现公寓户型及家具自动划分，参考地址: https://devblogs.nvidia.com/archigan-generative-stack-apartment-building-design/?linkId=70968833\n\n- SLAM：同时定位与建图（simultaneous localization and mapping，SLAM）是自动驾驶与增强现实领域中常用的技术。主要研究装置通过各种传感器在未知环境中的感知与定位问题。可以描述为: 机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置估计和地图进行自身定位,同时在自身定位的基础上建造增量式地图，实现机器人的自主定位和导航。使用的基于机器人操作系统（ROS）框架工作的SLAM算法。 在ROS中提供的五种基于2D激光的SLAM算法分别是：HectorSLAM，Gmapping，KartoSLAM，CoreSLAM和LagoSLAM。当然最后还有比较经典的google开源的cartographer，虽然不是基于ROS的但是大牛们已经将它修改为基于ＲＯＳ的版本的cartographer_ros\n\n- U-Net：在图像分割任务特别是医学图像分割中，U-Net[1]无疑是最成功的方法之一，该方法在2015年MICCAI会议上提出，目前已达到四千多次引用。其采用的编码器（下采样）-解码器（上采样）结构和跳跃连接是一种非常经典的设计方法。目前已有许多新的卷积神经网络设计方式，但很多仍延续了U-Net的核心思想，加入了新的模块或者融入其他设计理念。\n\n  <img src=\"https://pic3.zhimg.com/v2-63be140aee258bc15cfc1541f0a60d22_1200x500.jpg\" alt=\"图像分割的U-Net系列方法\" style=\"zoom:50%;\" />\n\n- \n\n\n\n参考文章\n\n- [Google机器学习和TensorFlow专用术语表](https://developers.google.com/machine-learning/glossary/)\n- [最全综述 | 图像分割算法](https://zhuanlan.zhihu.com/p/70758906)","tags":["机器学习"],"categories":["人工智能"]},{"title":"JavaScript语言发展史","url":"/2019/081712933.html","content":"\n## 诞生\nJavaScript 因为互联网而生，紧跟着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。\n\n1990年底，欧洲核能研究组织（CERN）科学家 Tim Berners-Lee，在全世界最大的电脑网络——互联网的基础上，发明了万维网（World Wide Web），从此可以在网上浏览网页文件。最早的网页只能在操作系统的终端里浏览，也就是说只能使用命令行操作，网页都是在字符窗口中显示，这当然非常不方便。\n\n1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做 Mosaic。这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。\n\n1994年10月，NCSA 的一个主要程序员 Marc Andreessen 联合风险投资家 Jim Clark，成立了 Mosaic 通信公司（Mosaic Communications），不久后改名为 Netscape。这家公司的方向，就是在 Mosaic 的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。\n\n1994年12月，Navigator 发布了1.0版，市场份额一举超过90%。\n\nNetscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。\n\n管理层对这种浏览器脚本语言的设想是：功能不需要太强，语法较为简单，容易学习和部署。那一年，正逢 Sun 公司的 Java 语言问世，市场推广活动非常成功。Netscape 公司决定与 Sun 公司合作，浏览器支持嵌入 Java 小程序（后来称为 Java applet）。但是，浏览器脚本语言是否就选用 Java，则存在争论。后来，还是决定不使用 Java，因为网页小程序不需要 Java 这么“重”的语法。但是，同时也决定脚本语言的语法要接近 Java，并且可以支持 Java 程序。这些设想直接排除了使用现存语言，比如 Perl、Python 和 TCL。\n\n1995年，Netscape 公司雇佣了程序员 Brendan Eich 开发这种网页脚本语言。Brendan Eich 有很强的函数式编程背景，希望以 Scheme 语言（函数式语言鼻祖 LISP 语言的一种方言）为蓝本，实现这种新语言。\n\n1995年5月，Brendan Eich 只用了10天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源。\n\n基本语法：借鉴 C 语言和 Java 语言。\n数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。\n函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。\n原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。\n正则表达式：借鉴 Perl 语言。\n字符串和数组处理：借鉴 Python 语言。\n为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法。这种功能的不足，直接导致了后来 JavaScript 的一个显著特点：对于其他语言，你需要学习语言的各种功能，而对于 JavaScript，你常常需要学习各种解决问题的模式。而且由于来源多样，从一开始就注定，JavaScript 的编程风格是函数式编程和面向对象编程的一种混合体。\n\nNetscape 公司的这种浏览器脚本语言，最初名字叫做 Mocha，1995年9月改为 LiveScript。12月，Netscape 公司与 Sun 公司（Java 语言的发明者和所有者）达成协议，后者允许将这种语言叫做 JavaScript。这样一来，Netscape 公司可以借助 Java 语言的声势，而 Sun 公司则将自己的影响力扩展到了浏览器。\n\n之所以起这个名字，并不是因为 JavaScript 本身与 Java 语言有多么深的关系（事实上，两者关系并不深，详见下节），而是因为 Netscape 公司已经决定，使用 Java 语言开发网络应用程序，JavaScript 可以像胶水一样，将各个部分连接起来。当然，后来的历史是 Java 语言的浏览器插件失败了，JavaScript 反而发扬光大。\n\n1995年12月4日，Netscape 公司与 Sun 公司联合发布了 JavaScript 语言，对外宣传 JavaScript 是 Java 的补充，属于轻量级的 Java，专门用来操作网页。\n\n1996年3月，Navigator 2.0 浏览器正式内置了 JavaScript 脚本语言。\n\n## JavaScript 与 Java 的关系\n这里专门说一下 JavaScript 和 Java 的关系。它们是两种不一样的语言，但是彼此存在联系。\n\nJavaScript 的基本语法和对象体系，是模仿 Java 而设计的。但是，JavaScript 没有采用 Java 的静态类型。正是因为 JavaScript 与 Java 有很大的相似性，所以这门语言才从一开始的 LiveScript 改名为 JavaScript。基本上，JavaScript 这个名字的原意是“很像Java的脚本语言”。\n\nJavaScript 语言的函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与 Java 语法最大的两点区别。JavaScript 语法要比 Java 自由得多。\n\n另外，Java 语言需要编译，而 JavaScript 语言则是运行时由解释器直接执行。\n\n总之，JavaScript 的原始设计目标是一种小型的、简单的动态语言，与 Java 有足够的相似性，使得使用者（尤其是 Java 程序员）可以快速上手。\n\n## JavaScript 与 ECMAScript 的关系\n1996年8月，微软模仿 JavaScript 开发了一种相近的语言，取名为JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。\n\n1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共25个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。\n\n1997年7月，ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。\n\nECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C组织（World Wide Web Consortium）制定的。\n\nECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。\n\n## JavaScript 的版本\n1997年7月，ECMAScript 1.0发布。\n\n1998年6月，ECMAScript 2.0版发布。\n\n1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。\n\n2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。\n\n2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。\n\n2009年12月，ECMAScript 5.0版 正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。第六版发布以后，将指 ECMAScript 7。TC39 预计，ECMAScript 5 会在2013年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。\n\n2011年6月，ECMAScript 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。\n\n2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。\n\n2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。\n\n2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在2016年发布，称为“ECMAScript 2016”，2017年发布“ECMAScript 2017”，以此类推。\n\n## 周边大事记\nJavaScript 伴随着互联网的发展一起发展。互联网周边技术的快速发展，刺激和推动了 JavaScript 语言的发展。下面，回顾一下 JavaScript 的周边应用发展。\n\n1996年，样式表标准 CSS 第一版发布。\n\n1997年，DHTML（Dynamic HTML，动态 HTML）发布，允许动态改变网页内容。这标志着 DOM 模式（Document Object Model，文档对象模型）正式应用。\n\n1998年，Netscape 公司开源了浏览器，这导致了 Mozilla 项目的诞生。几个月后，美国在线（AOL）宣布并购 Netscape。\n\n1999年，IE 5部署了 XMLHttpRequest 接口，允许 JavaScript 发出 HTTP 请求，为后来大行其道的 Ajax 应用创造了条件。\n\n2000年，KDE 项目重写了浏览器引擎 KHTML，为后来的 WebKit 和 Blink 引擎打下基础。这一年的10月23日，KDE 2.0发布，第一次将 KHTML 浏览器包括其中。\n\n2001年，微软公司时隔5年之后，发布了 IE 浏览器的下一个版本 Internet Explorer 6。这是当时最先进的浏览器，它后来统治了浏览器市场多年。\n\n2001年，Douglas Crockford 提出了 JSON 格式，用于取代 XML 格式，进行服务器和网页之间的数据交换。JavaScript 可以原生支持这种格式，不需要额外部署代码。\n\n2002年，Mozilla 项目发布了它的浏览器的第一版，后来起名为 Firefox。\n\n2003年，苹果公司发布了 Safari 浏览器的第一版。\n\n2004年，Google 公司发布了 Gmail，促成了互联网应用程序（Web Application）这个概念的诞生。由于 Gmail 是在4月1日发布的，很多人起初以为这只是一个玩笑。\n\n2004年，Dojo 框架诞生，为不同浏览器提供了同一接口，并为主要功能提供了便利的调用方法。这标志着 JavaScript 编程框架的时代开始来临。\n\n2004年，WHATWG 组织成立，致力于加速 HTML 语言的标准化进程。\n\n2005年，苹果公司在 KHTML 引擎基础上，建立了 WebKit 引擎。\n\n2005年，Ajax 方法（Asynchronous JavaScript and XML）正式诞生，Jesse James Garrett 发明了这个词汇。它开始流行的标志是，2月份发布的 Google Maps 项目大量采用该方法。它几乎成了新一代网站的标准做法，促成了 Web 2.0时代的来临。\n\n2005年，Apache 基金会发布了 CouchDB 数据库。这是一个基于 JSON 格式的数据库，可以用 JavaScript 函数定义视图和索引。它在本质上有别于传统的关系型数据库，标识着 NoSQL 类型的数据库诞生。\n\n2006年，jQuery 函数库诞生，作者为John Resig。jQuery 为操作网页 DOM 结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让 JavaScript 语言的应用难度大大降低，推动了这种语言的流行。\n\n2006年，微软公司发布 IE 7，标志重新开始启动浏览器的开发。\n\n2006年，Google推出 Google Web Toolkit 项目（缩写为 GWT），提供 Java 编译成 JavaScript 的功能，开创了将其他语言转为 JavaScript 的先河。\n\n2007年，Webkit 引擎在 iPhone 手机中得到部署。它最初基于 KDE 项目，2003年苹果公司首先采用，2005年开源。这标志着 JavaScript 语言开始能在手机中使用了，意味着有可能写出在桌面电脑和手机中都能使用的程序。\n\n2007年，Douglas Crockford 发表了名为《JavaScript: The good parts》的演讲，次年由 O'Reilly 出版社出版。这标志着软件行业开始严肃对待 JavaScript 语言，对它的语法开始重新认识，\n\n2008年，V8 编译器诞生。这是 Google 公司为 Chrome 浏览器而开发的，它的特点是让 JavaScript 的运行变得非常快。它提高了 JavaScript 的性能，推动了语法的改进和标准化，改变外界对 JavaScript 的不佳印象。同时，V8 是开源的，任何人想要一种快速的嵌入式脚本语言，都可以采用 V8，这拓展了 JavaScript 的应用领域。\n\n2009年，Node.js 项目诞生，创始人为 Ryan Dahl，它标志着 JavaScript 可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js 可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。\n\n2009年，Jeremy Ashkenas 发布了 CoffeeScript 的最初版本。CoffeeScript 可以被转换为 JavaScript 运行，但是语法要比 JavaScript 简洁。这开启了其他语言转为 JavaScript 的风潮。\n\n2009年，PhoneGap 项目诞生，它将 HTML5 和 JavaScript 引入移动设备的应用程序开发，主要针对 iOS 和 Android 平台，使得 JavaScript 可以用于跨平台的应用程序开发。\n\n2009，Google 发布 Chrome OS，号称是以浏览器为基础发展成的操作系统，允许直接使用 JavaScript 编写应用程序。类似的项目还有 Mozilla 的 Firefox OS。\n\n2010年，三个重要的项目诞生，分别是 NPM、BackboneJS 和 RequireJS，标志着 JavaScript 进入模块化开发的时代。\n\n2011年，微软公司发布 Windows 8操作系统，将 JavaScript 作为应用程序的开发语言之一，直接提供系统支持。\n\n2011年，Google 发布了 Dart 语言，目的是为了结束 JavaScript 语言在浏览器中的垄断，提供更合理、更强大的语法和功能。Chromium浏览器有内置的 Dart 虚拟机，可以运行 Dart 程序，但 Dart 程序也可以被编译成 JavaScript 程序运行。\n\n2011年，微软工程师Scott Hanselman提出，JavaScript 将是互联网的汇编语言。因为它无所不在，而且正在变得越来越快。其他语言的程序可以被转成 JavaScript 语言，然后在浏览器中运行。\n\n2012年，单页面应用程序框架（single-page app framework）开始崛起，AngularJS 项目和 Ember 项目都发布了1.0版本。\n\n2012年，微软发布 TypeScript 语言。该语言被设计成 JavaScript 的超集，这意味着所有 JavaScript 程序，都可以不经修改地在 TypeScript 中运行。同时，TypeScript 添加了很多新的语法特性，主要目的是为了开发大型程序，然后还可以被编译成 JavaScript 运行。\n\n2012年，Mozilla 基金会提出 asm.js 规格。asm.js 是 JavaScript 的一个子集，所有符合 asm.js 的程序都可以在浏览器中运行，它的特殊之处在于语法有严格限定，可以被快速编译成性能良好的机器码。这样做的目的，是为了给其他语言提供一个编译规范，使其可以被编译成高效的 JavaScript 代码。同时，Mozilla 基金会还发起了 Emscripten 项目，目标就是提供一个跨语言的编译器，能够将 LLVM 的位代码（bitcode）转为 JavaScript 代码，在浏览器中运行。因为大部分 LLVM 位代码都是从 C / C++ 语言生成的，这意味着 C / C++ 将可以在浏览器中运行。此外，Mozilla 旗下还有 LLJS （将 JavaScript 转为 C 代码）项目和 River Trail （一个用于多核心处理器的 ECMAScript 扩展）项目。目前，可以被编译成 JavaScript 的语言列表，共有将近40种语言。\n\n2013年，Mozilla 基金会发布手机操作系统 Firefox OS，该操作系统的整个用户界面都使用 JavaScript。\n\n2013年，ECMA 正式推出 JSON 的国际标准，这意味着 JSON 格式已经变得与 XML 格式一样重要和正式了。\n\n2013年5月，Facebook 发布 UI 框架库 React，引入了新的 JSX 语法，使得 UI 层可以用组件开发，同时引入了网页应用是状态机的概念。\n\n2014年，微软推出 JavaScript 的 Windows 库 WinJS，标志微软公司全面支持 JavaScript 与 Windows 操作系统的融合。\n\n2014年11月，由于对 Joyent 公司垄断 Node 项目、以及该项目进展缓慢的不满，一部分核心开发者离开了 Node.js，创造了 io.js 项目，这是一个更开放、更新更频繁的 Node.js 版本，很短时间内就发布到了2.0版。三个月后，Joyent 公司宣布放弃对 Node 项目的控制，将其转交给新成立的开放性质的 Node 基金会。随后，io.js 项目宣布回归 Node，两个版本将合并。\n\n2015年3月，Facebook 公司发布了 React Native 项目，将 React 框架移植到了手机端，可以用来开发手机 App。它会将 JavaScript 代码转为 iOS 平台的 Objective-C 代码，或者 Android 平台的 Java 代码，从而为 JavaScript 语言开发高性能的原生 App 打开了一条道路。\n\n2015年4月，Angular 框架宣布，2.0 版将基于微软公司的TypeScript语言开发，这等于为 JavaScript 语言引入了强类型。\n\n2015年5月，Node 模块管理器 NPM 超越 CPAN，标志着 JavaScript 成为世界上软件模块最多的语言。\n\n2015年5月，Google 公司的 Polymer 框架发布1.0版。该项目的目标是生产环境可以使用 WebComponent 组件，如果能够达到目标，Web 开发将进入一个全新的以组件为开发基础的阶段。\n\n2015年6月，ECMA 标准化组织正式批准了 ECMAScript 6 语言标准，定名为《ECMAScript 2015 标准》。JavaScript 语言正式进入了下一个阶段，成为一种企业级的、开发大规模应用的语言。这个标准从提出到批准，历时10年，而 JavaScript 语言从诞生至今也已经20年了。\n\n2015年6月，Mozilla 在 asm.js 的基础上发布 WebAssembly 项目。这是一种 JavaScript 引擎的中间码格式，全部都是二进制，类似于 Java 的字节码，有利于移动设备加载 JavaScript 脚本，执行速度提高了 20+ 倍。这意味着将来的软件，会发布 JavaScript 二进制包。\n\n2016年6月，《ECMAScript 2016 标准》发布。与前一年发布的版本相比，它只增加了两个较小的特性。\n\n2017年6月，《ECMAScript 2017 标准》发布，正式引入了 async 函数，使得异步操作的写法出现了根本的变化。\n\n2017年11月，所有主流浏览器全部支持 WebAssembly，这意味着任何语言都可以编译成 JavaScript，在浏览器运行。\n\n## 参考链接\n- [JavaScript 教程](https://wangdoc.com/javascript/index.html)","tags":["JavaScript"],"categories":["前端"]},{"title":"基于Dubbo-Spring-Cloud构建微服务项目","url":"/2019/062356747.html","content":"\nDubbo 生态体系已发生巨大变化，Dubbo Spring Cloud 作为 Spring Cloud Alibaba3 的最核心组件，完全地拥抱 Spring Cloud 技术栈，不但无缝地整合 Spring Cloud 注册中心，包括 Nacos4、Eureka5、Zookeeper6 以及 Consul7，而且完全地兼容 Spring Cloud Open Feign8 以及 @LoadBalanced RestTemplate，本文将讨论 Dubbo Spring Cloud 对 Spring Cloud 技术栈所带来的革命性变化。\n\n##  Dubbo Spring Cloud 简介\nDubbo Spring Cloud 基于 Dubbo Spring Boot 2.7.19 和 Spring Cloud 2.x 开发，无论开发人员是 Dubbo 用户还是 Spring Cloud 用户，都能轻松地驾驭，并以接近“零”成本的代价使应用向上迁移。Dubbo Spring Cloud 致力于简化 Cloud Native 开发成本，提高研发效能以及提升应用性能等目的。\n\n由于 Spring 官方宣布 Spring Cloud Edgware(下文简称为 “E” 版) 将在 2019 年 8 月 1 号后停止维护13，因此，目前 Dubbo Spring Cloud 发布版本并未对 “E” 版提供支持，仅为 “F” 版 和 “G” 版开发，同时也建议和鼓励 Spring Cloud 用户更新至 “F” 版 或 “G” 版。\n\n同时，Dubbo Spring Cloud 基于 Apache Dubbo Spring Boot 2.7.1 开发（最低 Java 版本为 1.8），提供完整的 Dubbo 注解驱动、外部化配置以及 Production-Ready 的特性，详情请参考：[dubbo-spring-boot-project](https://github.com/apache/incubator-dubbo-spring-boot-project)\n\n##  Spring Cloud Alibaba 简介\n[Spring Cloud Alibaba](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/README-zh.md) 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n\n依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n\n参考文档 请查看 WIKI 。\n\n## 简单示例\n开发 Dubbo Spring Cloud 应用的方法与传统 Dubbo 或 Spring Cloud 应用类似，按照以下步骤就能完整地实现Dubbo 服务提供方和消费方的应用，完整的示例代码请访问一下资源：\n\n - Dubbo 服务提供方应用 - [spring-cloud-dubbo-server-sample](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/spring-cloud-dubbo-server-sample)\n - Dubbo 服务消费方应用 - [spring-cloud-dubbo-client-sample](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/spring-cloud-dubbo-client-sample)\n\n### 构建Spring Cloud Alibaba\nSpring Cloud 使用 Maven 来构建，最快的使用方式是将本项目 clone 到本地，然后执行以下命令：\n```\n./mvnw install\n```\n执行完毕后，项目将被安装到本地 Maven 仓库。\n\n### 开发 Dubbo Spring Cloud 应用\n使用IDEA导入示例应用（服务提供方及服务消费方），参照[Dubbo Spring Cloud 示例工程](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/README_CN.md)进行操作。\n\n## 高阶示例\n进一步了解 Dubbo Spring Cloud 使用细节，可参考官方 Samples：https://github.com/spring-clo...\n\n其子模块说明如下：\n\n- spring-cloud-dubbo-sample-api：API 模块，存放 Dubbo 服务接口和模型定义\n- spring-cloud-dubbo-provider-web-sample：Dubbo Spring Cloud 服务提供方示例（Web 应用）\n- spring-cloud-dubbo-provider-sample：Dubbo Spring Cloud 服务提供方示例（非 Web 应用）\n  vspring-cloud-dubbo-consumer-sample：Dubbo Spring Cloud 服务消费方示例\n- spring-cloud-dubbo-servlet-gateway-sample：Dubbo Spring Cloud Servlet 网关简易实现示例\n\n## Spring Cloud Alibaba 演示 Demo\n\nSpring Cloud Alibaba 项目包含了一个子模块`spring-cloud-alibaba-examples`。此模块中提供了演示用的 example ，您可以阅读对应的 example 工程下的 readme 文档，根据里面的步骤来体验。\n\nExample 列表：\n- [Sentinel Example](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/sentinel-example/sentinel-core-example/readme-zh.md)\n- [Nacos Config Example](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md)\n- [Nacos Discovery Example](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/readme-zh.md)\n- [RocketMQ Example](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/rocketmq-example/readme-zh.md)\n- [Fescar Example](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/fescar-example/readme-zh.md)\n- [Alibaba Cloud OSS Example](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/oss-example/readme-zh.md)\n- [Alibaba Cloud ANS Example](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/ans-example/ans-provider-example/readme-zh.md)\n- [Alibaba Cloud ACM Example](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/acm-example/acm-local-example/readme-zh.md)\n- [Alibaba Cloud SchedulerX Example](https://github.com/xiaolongzuo/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/schedulerx-example/schedulerx-simple-task-example/readme-zh.md)\n\n## 参考文章\n- [Dubbo Spring Cloud 重塑微服务治理](https://segmentfault.com/a/1190000018991721)\n- [Spring Cloud Alibaba](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/README-zh.md)\n- [Dubbo Spring Cloud 示例工程](https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/README_CN.md) \n- [Dubbo中文文档](http://dubbo.apache.org/zh-cn/docs/user/quick-start.html)","tags":["SpringBoot","SpringCloud","Dubbo"],"categories":["微服务","开发框架"]},{"title":"基于Spring boot + Cloud构建微服务项目","url":"/2019/06187172.html","content":"\n基于Spring boot + Cloud构建微服务项目....\n## 待补充\n\n\n## 参考文章\n- [十分钟带你掌握springboot微服务架构的基本使用](https://blog.csdn.net/helloworld_in_java/article/details/81519267)\n- [SpringCloud新手入门实战教程](https://github.com/qqxx6661/springcloud_for_noob)","tags":["SpringBoot","SpringCloud","Thymeleaf"],"categories":["开发框架","微服务"]},{"title":"基于Pages+Jekyll+Minimal-Mistakes搭建个人博客","url":"/2019/061036412.html","content":"\nGithub pages官方推荐使用Jekyll生成静态网页，jekyll支持各种不同的主题。Minimal Mistakes 是一个灵活的两栏 Jekyll 简约风格主题，非常适合建立个人网站、博客和作品集。除了外观设置外，还支持文章评论、文章搜索、文章标签、文章分类等增强和定制。\n\n## 安装Github pages + Jekyll\n1. 在github上Fork[mmistakes/minimal-mistakes](https://github.com/mmistakes/minimal-mistakes)\n1. 参考[github pages主页](https://pages.github.com/), 设置Fork来的仓库名为 {username}.github.io/blog，并启用GitHub Pages\n1. clone `{username}.github.io/blog` 到本地 $Github/lxl80/blog目录\n1. 本地安装jekyll并建立博客\n\n```bash\ngem install jekyll bundler\n//建立myblog并复制内容到根目录后删除myblog\n//如果直接在根目录建立，github在编译时可能会软连接错误，暂不知原因\ncd $Github/lxl80/blog\nrm Gemfile\njekyll new blogtemp\ncd blogtemp\ncp -r * ../\ncd ..\nrm -rf blogtemp\n```\n## 使用Minimal-Mistakes主题\n1. 修改Gemfile:\n替换`gem \"jekyll\"` 为 `gem \"github-pages\", group: :jekyll_plugins`\n\n1. 修改_config.yml:\n替换`theme`为`remote_theme: \"mmistakes/minimal-mistakes\"`\n1. 运行`bundle update`更新主题\n1. 更改about.md和 _posts/0000-00-00-welcome-to-jekyll.markdown 中 layout为single。\n1. 在根目录下删除`index.md`，添加`index.html`，内容如下：\n\n```bash\n---\nlayout: home\nauthor_profile: true\n---\n```\n1. 运行`bundle exec jekyll serve`\n如果碰到No GitHub API authentication could be found.的问题，参考[Resolve ERRORS](https://link.jianshu.com/?t=http%3A%2F%2Fidratherbewriting.com%2Fdocumentation-theme-jekyll%2Fmydoc_install_jekyll_on_mac.html%23githuberror)。\n1. 访问`127.0.0.1:4000`查看页面\n1. push到github，访问commits页面查看部署状态。\n1. 访问`{username}.github.io`查看博客主页。\n\n## 相关配置\n\n### 修改Markdown 高亮配色\nJekyll使用rough作为代码高亮工具，不同的皮肤设置(minimal_mistakes_skin)有不同的高亮配色，这里我使用contrast皮肤，但代码高亮希望将背景从深色改为白色。\n\n1. 在gems目录/usr/local/lib/ruby/gems/2.4.0/gems/minimal-mistakes-jekyll-{version}下复制 _sass 到博客根目录。\n1. 修改_sass/minimal-mistakes/skins/_contrast.scss，替换 syntax highlighting (base16) 设置，参考[Sylesheet/Color](https://link.jianshu.com/?t=https%3A%2F%2Fmmistakes.github.io%2Fminimal-mistakes%2Fdocs%2Fstylesheets%2F%23colors)。\n\n```bash\n/* solarized light syntax highlighting (base16) */\n$base00: #fafafa !default;\n$base01: #073642 !default;\n$base02: #586e75 !default;\n$base03: #657b83 !default;\n$base04: #839496 !default;\n$base05: #586e75 !default;\n$base06: #eee8d5 !default;\n$base07: #fdf6e3 !default;\n$base08: #dc322f !default;\n$base09: #cb4b16 !default;\n$base0a: #b58900 !default;\n$base0b: #859900 !default;\n$base0c: #2aa198 !default;\n$base0d: #268bd2 !default;\n$base0e: #6c71c4 !default;\n$base0f: #d33682 !default;\n```\n1. 运行bundle update\n### 设置文字大小\n修改 _sass/minimal-mistakes/_variables.scss 对应font-size。\n\n## 添加Disqus评论支持\n1. 参考I want to install disqus on my site注册，添加网站并得到shortname。\n1. 设置_config.yml\n\n```yaml\ncomments:\nprovider: \"disqus\"\ndisqus:\n    shortname: \"your-disqus-shortname\"\n//......\ndefault:\n    comments: true\n```\n\n## 参考文章\n- [Minimal Mistakes Jekyll theme](https://github.com/mmistakes/minimal-mistakes)\n- [Minimal Mistakes Quick-Start Guide](https://github.com/mmistakes/minimal-mistakes)\n- [Jekyll docs](https://jekyllrb.com/docs/)\n- [Github pages + Minimal-Mistakes + Disqus建立个人博客记录](https://www.jianshu.com/p/d19eede28520)","tags":["Blog","Jekyll","Minimal-Mistakes"],"categories":["前端"]},{"title":"Fabric生产网络动态添加新组织","url":"/2019/060423381.html","content":"\n一个商用的区块链网络，随着业务的发展变化，经常需要动态的新增/移除组织，以满足业务/安全等管理需要。本文在既有组织/节点的基础上，新增一个组织两个节点。\n\nFabric 是联盟链，一个 Channel 就好比一个子链，如果有新的机构需要加入，则必须得到联盟内的成员的认可。基于这样的场景，Fabric 在为 channel 新增 org 时，会涉及诸多的权限和证书操作。\n\n## 为 Channel 动态新增 Org 有以下几步：\n\n1. 为新 org 生成证书\n1. 为新 org 生成配置文件\n1. 生成和提交新 org 的配置\n    1. peer channel fetch config 创建添加新 org 的配置交易，为网络新增 org\n    1. peer channel signconfigtx 为配置交易签名，需网络中 MAJORITY 的 org 都签名\n    1. peer channel update 提交签名后的配置交易至 orderer\n1. 将新 org 添加入 channel\n    1. 启动新 org 集群，一般会有一个 cli 和多个 peer\n    1. peer channel fetch 于 cli 中从 orderer 中获取 channel 创世块\n    1. peer channel join 将新 org 下的 peer 加入 channel\n1. 升级chaincode和背书策略\n    1. peer chaincode install 为新 org 的 peer 安装 chaincode，于新 org 的 cli 中完成\n    1. peer chaincode install, 为其他 org 升级 chaincode，于原 org 的 cli 中完成\n    1. peer chaincode upgrade 升级背书策略，于原 org 的 cli 中完成\n此文通过 fabric-samples 下的 first-network 样例为基础，在其区块链网络上，为通道 cfichannel 新增一个组织Cfec，CfecOrg 包含个 peer。\n\n## 一、新组织基础环境安装\n### 1、安装epel源\n```bash\nyum install epel-release\n```\n### 2、安装依赖包\n```bash\nyum install snappy-devel.x86_64 zlib-devel.x86_64 bzip2-devel.x86_64 libtool-ltdl-devel.x86_64 libtool git\n```\n### 3、安装docker\n```bash\nyum localinstall docker-ce-18.05.0.ce-3.el7.centos.x86_64.rpm (安装包见附件)\n```\n### 4、安装docker-compose\n```bash\ncurl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\n```\n### 5、配置docker源（如果不配置拉取的是国外的镜像源）\n```bash\n[ -d /etc/docker ] && echo \"docker dir Already exist\" || mkdir /etc/docker\n \ntee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"https://k03hynjl.mirror.aliyuncs.com\"]\n}\nEOF\n```\n### 6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下：\n```bash\nsudo scp -r cfichain@xxx.xxx.xxx.xxx:/home/cfichain/cfi_network .\nsudo scp -r cfichain@xxx.xxx.xxx.xxx:/home/cfichain/bin .\n```\n\n### 7、清理数据\n```bash\nrm -fr /data/fabric/bin/channel-artifacts/*\nrm -fr /data/fabric/bin/crypto-config/*\nrm -fr /data/fabric/bin/chaindata/*/*/*\nrm -fr /data/fabric/bin/chainData/*/*/*\n```\n## 二、在联盟管理节点创建新channel \n（MBFA组织任意节点上执行）\n\n### 1、创建交易文件\n```bash\nexport PATH=$PATH:/data/fabric/bin\nexport ORDERER_GENERAL_GENESISPROFILE=MbfaGenesis\nconfigtxgen -profile MbfaChannel -outputCreateChannelTx ./channel-artifacts/sycfinchannel.tx -channelID syfinchannel\n```\n### 2、为新组织创建channel\n登录docker cli\n```\ndocker exec -it cli bash\n```\n### 3、发起创建channel交易\n```bash\nexport CORE_PEER_ADDRESS=am.mbfa.fabric.mbfa.cn:7051\nexport CORE_PEER_LOCALMSPID=MbfaMSP\nexport CORE_PEER_TLS_ENABLED=false\nexport CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/server.crt\nexport CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/server.key\nexport CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/ca.crt\nexport CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/users/Admin@mbfa.fabric.mbfa.cn/msp\npeer channel create -o orderer0.fabric.mbfa.cn:7050 -c syfinchannel -f ./channel-artifacts/syfinchannel.tx\n```\n\n## 三、在新组织节点（ORG）生成证书\n### 1、生成证书命令\n(依据 crypto-config.yaml 生成，生成后的文件位于 org3-artifacts/crypto-config/ 下)：\n```bash\ncd org3-artifacts\n./cryptogen generate --config=./crypto-config.yaml --output ./crypto-config\n```\n### 2、crypto-config.yamll 文件如下：\n```yaml\nPeerOrgs:\n  - Name: SyOrg\n    Domain: sy.fabric.mbfa.cn\n    CA:\n        Country: CN\n        Province: Beijing\n        Locality: Beijing\n    Specs:\n      - Hostname: peer\n    Users:\n      Count: 1\n```\n\n## 四、在新组织节点使用configtxgen生成SyOrg配置JSON文件\n### 1、生成组织配置文件\nconfigtx会在当前目录中寻找configtx.yaml配置文件并从中读取SyOrg相关配置。\n```bash\ncd org3-artifacts\n./configtxgen -printOrg SyOrg -profile ./configtx.yaml > ../channel-artifacts/syorg.json\n```\n### 2、configtx.yaml配置文件如下：\n```yaml\nOrganizations:\n    - &SyOrg\n        Name: SyOrg\n        ID: SyMSP\n        MSPDir: crypto-config/peerOrganizations/sy.fabric.mbfa.cn/msp\n        Policies: &SyOrgPolicies\n            Readers:\n                Type: Signature\n                Rule: \"OR('SyMSP.member')\"\n            Writers:\n                Type: Signature\n                Rule: \"OR('SyMSP.member')\"\n            Admins:\n                Type: Signature\n                Rule: \"OR('SyMSP.admin')\"\n        AnchorPeers:\n            - Host: peer.sy.fabric.mbfa.cn\n              Port: 7051\n```\n## 五、配置新组织节点\n修改cfi.yaml配置文件，需要检查环境差异。需要注意docker配置文件中对应的fabric链镜像版本号。\n```bash\nmv org3-artifacts/crypto-config .\n\ncat /etc/resolv.conf \n//此为正常配置 \n    nameserver 127.0.0.11\n    options ndots:0\n//如果输出结果如下，需要在docker compose yaml模板增加环境变量，GODEBUG=netdns=go以强制使用pure Go resolver\n    nameserver 127.0.0.11\n    options timeout:2 attempts:3 rotate single-request-reopen ndots:0\n```\n## 六、既有联盟组织生成和提交新 org 的配置\n通过 step 3~4，已经生成了 Sy 的证书和配置，但这仅仅是在本地文件系统，还未于区块链网络产生关联。为 channel 新加 Org，对 Fabric而言，是以一笔交易的形式提交的。因此要使得这笔交易能顺利完成，需要提交Sy的配置，到channel中，获得权限认证；然后于网络中发起更新的交易。\n\n### 1、登录联盟管理组织的cli\n```bash\ndocker exec -it cli bash\n```\n\n### 2、安装 jq 工具\njq 是 Linux 下命令行处理 JSON 的工具，可以对 JSON 进行过滤、格式化、修改等等操作。\n```bash\napt-get -y update && apt-get -y install jq\n```\n### 3、设置orderer TLS CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）\n```bash\nexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem\n```\n### 4、获取准备加入channel的配置\n```bash\npeer channel fetch config vtm_config_block.pb -o orderer0.fabric.mbfa.cn:7050 -c cfitestchannel --cafile $ORDERER_CA\n```\n### 5、联盟管理组织修改原channel配置文件, 增加新组织\n#### 5.1、解码原有网络的配置文件 \n```bash\n将准备加入channel的pb格式配置信息转换成json格式\nconfigtxlator proto_decode --input vtm_config_block.pb --type common.Block | jq .data.data[0].payload.data.config > vtm_config.json\n```\n生成文件内容类似set2中syorg.json内容\n#### 5.2、使用jq工具，合并cfiorg.json与cfi_config.json, 形成增加新组织后的完整json格式的配置更新文件。\n```bash\njq -s '.[0] * {\"channel_group\":{\"groups\":{\"Application\":{\"groups\": {\"VtmMSP\":.[1]}}}}}' vtm_config.json ./channel-artifacts/vtmorg.json > vtm_modified_config.json\n```\n#### 5.3、将 config.json 和 modified_config.json 转为 protobuf 格式\n```bash\nconfigtxlator proto_encode --input vtm_config.json --type common.Config > vtm_config.pb\nconfigtxlator proto_encode --input vtm_modified_config.json --type common.Config > vtm_modified_config.pb\n```\n\n#### 5.4、根据 config.pb 和 modified_config.pb 计算出 org3_update.pb ，计算出增量更新内容。 (类似于 diff 操作，但是针对 protobuf 格式，因此会多出好多操作。)\n```bash\nconfigtxlator compute_update --channel_id cfitestchannel --original vtm_config.pb --updated vtm_modified_config.pb > vtm_config_update.pb\n```\n\n#### 5.5、解码 config_update.pb 为 json，然后用 jq 修改，然后在编码为 protobuf 格式，最终输出 syorg_update_in_envelope.pb\n```bash\nconfigtxlator proto_decode --input cfi_config_update.pb  --type common.ConfigUpdate > cfi_config_update.json\necho '{\"payload\":{\"header\":{\"channel_header\":{\"channel_id\":\"cfitestchannel\", \"type\":2}},\"data\":{\"config_update\":'$(cat cfi_config_update.json)'}}}' | jq . > cfi_config_update_in_envelope.json\nconfigtxlator proto_encode --input cfi_config_update_in_envelope.json --type common.Envelope > cfiorg_update_in_envelope.pb\n```\n\n### 6、为新组织配置签名\n为配置交易签名，需要 channel 中的大多数 Org 对其进行签名。\n对于 mychannel 而言，已有了 org1，org2，因此新增 org3 时需要 org1、org2 都签名。\n签名操作于 cli 中完成，需采用 Anchor Peer，可通过更改环境变量，改变签名者的身份。\n#### 6.1、MBFA组织签名\n```bash\ndocker exec -it cli bash\n\n组织签名\npeer channel signconfigtx -f cfiorg_update_in_envelope.pb\n```\n#### 6.2、登录MSC组织CLI继续签名\n（下载MBFA签名后的syorg_update_in_envelope.pb上传到msc组织CLI中，参照MBFA将syorg_update_in_envelope.pb进行签名。）\n\n### 7、提交签名后的配置交易至orderer\n注意：需要将syorg_update_in_envelope.pb注意上传到老组织，并逐一叠加签名。然后由生产此pb文件的组织提交更新。\n```bash\nexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem\npeer channel update -f cfiorg_update_in_envelope.pb -c cfitestchannel -o orderer0.fabric.mbfa.cn:7050 --cafile $ORDERER_CA\n```\n若成功入链，可以看到以下输出：\n```bash\n2018-11-01 13:45:17.982 UTC [kvledger] CommitWithPvtData -> INFO 066 [mbfastorechannel] Committed block [2] with 1 transaction(s) in 19ms (state_validation=0ms block_commit=13ms state_commit=3ms)\n```\n输出显示，当前提交的块号是 6。块 0 是创世块；1~2 是一些初始化；3~4 是实例化与调用 chaincode ，更新配置。\n\n## 七、新组织申请添加到channel中\n启动新组织节点，登录cli，加入到新channel：\n```bash\ndocker-compose -f cfi.yaml up\ndocker exec -it cli bash\n\nexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem\nexport CHANNEL_NAME=cfitestchannel\n\n//从 orderer 中获取 channel 创世块配置\npeer channel fetch 0 cfitestchannel.block -o orderer0.fabric.mbfa.cn:7050 -c $CHANNEL_NAME --cafile $ORDERER_CA\n\npeer channel join -b cfitestchannel.block\n```\n## 八、升级chaincode和背书策略\n### 1、为新组织安装 2.0 版本的 chaincode\n其他组织的 chaincode 版本号是 1，新组织需要更新此版本的 chaincode，因此为新组织直接安装版本为 2 的 chaincode，省得先安装再升级。\n```bash\npeer chaincode install -n cfistore -v 2 -p github.com/hyperledger/fabric/chaincode/go/cfistore\n```\n### 2、为其他组织安装 2.0 版本 chaincode\n登录每个联盟原有组织 cli，逐一进行更新。\n```bash\ndocker exec -it cli bash\n \npeer chaincode install -n cfistore -v 2 -p github.com/hyperledger/fabric/chaincode/go/cfistore\n \npeer chaincode upgrade -n cfistore -v 7 -c '{\"Args\":[\"init\"]}' -o orderer0.fabric.mbfa.cn:7050 -C cfichannel -P \"OR ('MbfaMSP.member','MscMSP.member','CfecMSP.member','VteamMSP.member')\"\n\n// 查看channel中已经实例化的链码\npeer chaincode list --instantiated -C cfichannel\n```\n### 3、升级背书策略\n升级背书策略，-v 2 指明版本号，-P \"AND ('MbfaMSP.peer','CfecMSP.peer')\"指明新的背书策略（添加了 CfecOrg）。\n```bash\n peer chaincode upgrade -n cfistore -v 2 -c '{\"Args\":[\"init\"]}' -o orderer0.fabric.mbfa.cn:7050 -C cfichannel -P \"AND ('MbfaMSP.peer','CfecMSP.peer')\"\n```\npeer chaincode upgrade 命令将为区块链新增一个块，可以在其他的 peer 的输出中查看。\n\n查询链码\n```bash\npeer chaincode query -C cfichannel -n cfistore -c '{\"Args\":[\"query\",\"a\"]}'\n```\n","tags":["Blockchain","Fabric"],"categories":["区块链"]},{"title":"Java面向对象设计之桥接模式","url":"/2018/121928602.html","content":"\n## 模式动机\n\n设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：\n\n- 第一种设计方案是为每一种形状都提供一套各种颜色的版本。\n- 第二种设计方案是根据实际需要对形状和颜色进行组合\n\n对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。\n\n## 模式定义\n\n> **桥接模式**(`Bridge Pattern`)：将抽象和实现解耦，使得两者可以独立地变化。它是一种对象结构型模式，又称为桥梁模式。\n\n### 模式角色\n\n桥接模式包含如下角色：\n\n- `Abstraction`：抽象类角色\n- `RefinedAbstraction`：扩充抽象类\n- `Implementor`：实现化角色\n- `ConcreteImplementor`：具体实现化角色的实现类\n\n### UML类图\n\n![桥接模式UML](http://static.blinkfox.com/java-design-bridge.jpg)\n\n## 代码示例\n\n首先，是实现化角色`Abstraction`类：\n\n```java\n/**\n * 实现化角色 Implementor.\n *\n * @author blinkfox on 2018-12-17.\n */\npublic interface Implementor {\n\n    /**\n     * 基本方法1.\n     */\n    void doSomething();\n\n    /**\n     * 基本方法2.\n     */\n    void doAnything();\n\n}\n```\n\n然后，是各个具体的实现化角色类：\n\n```java\n/**\n * ConcreteImplementor1.\n *\n * @author blinkfox on 2018-12-17.\n */\npublic class ConcreteImplementor1 implements Implementor {\n\n    /**\n     * 基本方法1.\n     */\n    @Override\n    public void doSomething() {\n        System.out.println(\"ConcreteImplementor1 的业务逻辑 doSomething.\");\n    }\n\n    /**\n     * 基本方法2.\n     */\n    @Override\n    public void doAnything() {\n        System.out.println(\"ConcreteImplementor1 的业务逻辑 doAnything.\");\n    }\n\n}\n```\n\n```java\n/**\n * ConcreteImplementor2.\n *\n * @author blinkfox on 2018-12-17.\n */\npublic class ConcreteImplementor2 implements Implementor {\n\n    /**\n     * 基本方法1.\n     */\n    @Override\n    public void doSomething() {\n        System.out.println(\"ConcreteImplementor2 的业务逻辑 doSomething.\");\n    }\n\n    /**\n     * 基本方法2.\n     */\n    @Override\n    public void doAnything() {\n        System.out.println(\"ConcreteImplementor2 的业务逻辑 doAnything.\");\n    }\n\n}\n```\n\n接下来，是抽象类角色`Abstraction`类：\n\n```java\npackage com.blinkfox.patterns.bridge;\n\n/**\n * 抽象化角色 Abstraction.\n *\n * @author blinkfox on 2018-12-17.\n */\npublic abstract class Abstraction {\n\n    /** 定义对实现化角色的引用. */\n    private Implementor impl;\n\n    /**\n     * 构造方法.\n     *\n     * @param impl 实现类的实例\n     */\n    public Abstraction(Implementor impl) {\n        this.impl = impl;\n    }\n\n    /**\n     * impl 的 getter方法.\n     *\n     * @return impl\n     */\n    public Implementor getImpl() {\n        return impl;\n    }\n\n    /**\n     * 自身的请求处理方法.\n     */\n    public void request() {\n        this.impl.doSomething();\n    }\n\n}\n```\n\n再次，是扩展的具体抽象化角色类`RefinedAbstraction`：\n\n```java\n/**\n * RefinedAbstraction.\n *\n * @author blinkfox on 2018-12-17.\n */\npublic class RefinedAbstraction extends Abstraction {\n\n    /**\n     * 构造方法.\n     *\n     * @param impl 实现类的实例\n     */\n    public RefinedAbstraction(Implementor impl) {\n        super(impl);\n    }\n\n    /**\n     * 覆盖后的请求处理方法.\n     */\n    @Override\n    public void request() {\n        System.out.println(\"RefinedAbstraction 开始做业务处理.\");\n        super.request();\n        super.getImpl().doAnything();\n    }\n\n}\n```\n\n最后，是客户端场景类：\n\n```java\n/**\n * Client.\n *\n * @author blinkfox on 2018-12-17.\n */\npublic class Client {\n\n    /**\n     * main方法.\n     *\n     * @param args 数组参数\n     */\n    public static void main(String[] args) {\n        // 定义一个实现化角色和抽象化角色,并执行请求方法.\n        Implementor impl = new ConcreteImplementor1();\n        Abstraction abs = new RefinedAbstraction(impl);\n        abs.request();\n    }\n\n}\n```\n\n## 模式分析\n\n理解桥接模式，重点需要理解如何将抽象化(`Abstraction`)与实现化(`Implementation`)脱耦，使得二者可以独立地变化。\n\n- **抽象化**：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。\n- **实现化**：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。\n- **脱耦**：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。**桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。**\n\n### 优点\n\n桥接模式的优点:\n\n- 分离抽象接口及其实现部分。\n- 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。\n- 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。\n- 实现细节对客户透明，可以对用户隐藏实现细节。\n\n### 缺点\n\n桥接模式的缺点:\n\n- 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 \n- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。\n\n### 适用环境\n\n在以下情况下可以使用桥接模式：\n\n- 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。\n- 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。\n- 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\n- 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。\n- 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。\n\n### 模式应用\n\n一个Java桌面软件总是带有所在操作系统的视感(`LookAndFeel`)，如果一个Java软件是在Unix系统上开发的，那么开发人员看到的是`Motif`用户界面的视感；在Windows上面使用这个系统的用户看到的是Windows用户界面的视感；而一个在`Macintosh`上面使用的用户看到的则是`Macintosh`用户界面的视感，Java语言是通过所谓的Peer架构做到这一点的。Java为AWT中的每一个GUI构件都提供了一个Peer构件，在AWT中的Peer架构就使用了桥接模式。\n\n### 模式扩展\n\n适配器模式与桥接模式的联用:\n\n桥接模式和适配器模式用于设计的不同阶段，**桥接模式用于系统的初步设计**，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，**当发现系统与已有类无法协同工作时，可以采用适配器模式**。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。\n\n## 总结\n\n- 桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。\n- 桥接模式包含如下四个角色：抽象类中定义了一个实现类接口类型的对象并可以维护该对象；扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。\n- 在桥接模式中，抽象化(`Abstraction`)与实现化(`Implementation`)脱耦，它们可以沿着各自的维度独立变化。\n- 桥接模式的主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节；其主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情。\n- 桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。\n\n参考自：[桥接模式](https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html)","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java面向对象设计之适配器模式","url":"/2018/12121265.html","content":"\n## 模式动机\n\n- 在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。\n- 通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。\n- 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。\n- 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(`Adapter`)，它所包装的对象就是适配者(`Adaptee`)，即被适配的类。\n- 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。\n\n## 模式定义\n\n> **适配器模式**(`Adapter Pattern`) ：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(`Wrapper`)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。适配器模式是一种**结构型模式**。\n\n## 模式结构\n\n### 参与角色\n\n适配器模式包含如下角色：\n\n- `Target`：目标抽象类\n- `Adapter`：适配器类\n- `Adaptee`：适配者类\n- `Client`：客户类\n\n### UML类图\n\n![适配器模式UML](http://static.blinkfox.com/java-design-adapter.jpg)\n\n## 代码示例\n\n首先，是目标角色接口和具体目标实现类：\n\n```java\n/**\n * Target 目标角色类.\n *\n * @author blinkfox on 2018-12-11.\n */\npublic interface Target {\n\n    /**\n     * 目标角色自己的方法.\n     */\n    void request();\n\n}\n```\n\n```java\n/**\n * 具体的目标角色实现类.\n *\n * @author blinkfox on 2018-12-11.\n */\npublic class ConcreteTarget implements Target {\n\n    /**\n     * 目标角色自己的方法.\n     */\n    @Override\n    public void request() {\n        System.out.println(\"hello, I'm concrete target method.\");\n    }\n\n}\n```\n\n其次，是适配者类：\n\n```java\n/**\n * 适配者类.\n *\n * @author blinkfox on 2018-12-11.\n */\npublic class Adaptee {\n\n    /**\n     * 这是原有的业务逻辑方法.\n     */\n    public void doSomething() {\n        System.out.println(\"Hello, I'm Adaptee method.\");\n    }\n\n}\n```\n\n然后，是适配器角色类：\n\n```java\n/**\n * 适配器类.\n *\n * @author blinkfox on 2018-12-11.\n */\npublic class Adapter extends Adaptee implements Target {\n\n    /**\n     * 适配了目标角色自己的方法.\n     */\n    @Override\n    public void request() {\n        super.doSomething();\n        System.out.println(\"适配器适配了目标角色方法.\");\n    }\n\n}\n```\n\n最后，是客户端场景类：\n\n```java\n/**\n * 客户端场景类.\n *\n * @author blinkfox on 2018-12-11.\n */\npublic class Client {\n\n    /**\n     * main方法.\n     *\n     * @param args 数组参数\n     */\n    public static void main(String[] args) {\n        // 原有业务逻辑.\n        Target target = new ConcreteTarget();\n        target.request();\n\n        // 增加了适配器角色后的业务逻辑.\n        Target adaptTarget = new Adapter();\n        adaptTarget.request();\n    }\n\n}\n```\n\n## 模式分析\n\n### 适用环境\n\n在以下情况下可以使用适配器模式：\n\n- 系统需要使用现有的类，而这些类的接口不符合系统的需要。\n- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。\n\n### 优点\n\n- 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。\n- 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。\n- 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。\n\n### 缺点\n\n如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。\n\n### 模式应用\n\nSun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。\n\n## 总结\n\n- 结构型模式描述如何将类或者对象结合在一起形成更大的结构。\n- 适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n- 适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。\n- 在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。\n- 适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。\n- 适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。\n\n参考自：[适配器模式](https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html)","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"软件程序设计原则","url":"/2018/112425424.html","content":"\n## 一、前言\n\n软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。\n\n软件设计原则是一组帮助我们避开不良设计的指导方针。根据`Robert Martin`的理论，应该避免不良设计的以下三个重要特点：\n\n- **僵化**：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能\n- **脆弱**：每当你做一次改动，总会引起系统中预期之外的部分出现故障\n- **死板**：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来\n\n下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。\n\n## 二、通用设计原则\n\n### 1. KISS\n\n所谓`KISS`原则，即：`Keep It Simple,Stupid`，指**设计时要坚持简约原则，避免不必要的复杂化，并且易于修改**。\n\n> Everything should be made as simple as possible, but not simpler. - Albert Einstein\n\n简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。\n\n- 让别的软件工程师以一种最容易的方式使用你的方案。\n- 简单不是走捷径，不是为手边的问题找一个最快的方案。\n- 当系统变得更庞大更复杂的时候依然能够被理解。\n- 如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。\n\n> **我的理解**：保持简单但不能掩盖软件丰富的内涵。即**简约而不简单**！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。\n\n### 2. DRY\n\n所谓`DRY`原则，即：`Don't Repeat Yourself`，**不要让自己重复**。\n\n**重复代码是软件程序变烂的万恶之首**。`DRY`并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。\n\n所以，**去掉重复的信息会让你的代码结构发生本质的变化**。\n\n“重复代码”有很多变体：\n\n- 魔法数字、魔法字符串等\n- 相同代码块\n- 相似的代码逻辑及操作\n\n对于消除重复的代码有**事不过三**法则。\n\n- 第一次先写了一段代码。\n- 第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。\n- 再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。\n\n> **我的理解**：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是**立即行动**去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。\n\n### 3. Maximize Cohesion， Minimize Coupling\n\n所谓`Maximize Cohesion,Minimize Coupling`原则，即：**高内聚低耦合**。这是判断设计好坏的标准，主要是看**模块内的内聚性是否高，模块间的耦合度是否低。**\n\n- **耦合性**：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。\n- **内聚性**：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。\n\n内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。\n\nJava中实现高内聚低耦合的常用方式：\n\n- 少使用类的继承，多用接口隐藏实现的细节。\n- 模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。\n- 遵循一个定义只在一个地方出现。\n- 少使用全局变量。\n- 类属性和方法的声明少用`public`，多用`private`关键字，\n- 多用设计模式，比如采用`MVC`的设计模式就可以降低界面与业务逻辑的耦合度。\n- 尽量不用“硬编码”的方式写程序。\n- 最后当然就是避免直接操作或调用其它模块或类（内容耦合）。\n\n### 4. SOC\n\n所谓`SOC`原则，即：**关注点分离**（`Separation of Concerns`）。**不同领域的功能，应该由不同的代码和最小重迭的模块组成。**关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。\n\n`MVC`就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。`MVC`的基本结构：\n\n- `Model`层表示应用程序的数据核心，通常负责在数据库中存取数据。\n- `View`是应用程序的显示层，通常是依据模型的数据而建立。\n- `Controller`是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（`Model`层）发送数据。\n\n`MVC`的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。\n\n> 好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)\n\n#### 分离方式\n\n下面将介绍一些分层的思想和方式:\n\n- **纵向分离**: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。\n- **横向分离**: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。\n- **切面分离**: 有些内容是多个层之间都需要的，比如日志（`log`），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。\n- **依赖方向分离**: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。\n- **关注数据分离**: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联`customer`类，应该是用订单类来把他们联系在一起。\n- **关注行为分离**: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做`CreateNewCustomer()`，那么`CreateNewCustomer()`的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。\n- **扩展分离**: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。\n- **反转分离**: 很多依赖注入的框架，如`Spring`、`Guice`等等，这些帮助我们做依赖反转，从而倒置依赖关系。\n\n### 5. YAGNI\n\n所谓`YAGNI`原则，即：`You Ain’t Gonna Need It`，**你不需要它**。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。`YAGNI`很像`KISS`原则，因为它也是致力于构建简单的方案。然而，`KISS`是通过尽可能容易的完成某件事情来实现精简方案；但`YAGNI`是通过根本就不实现它来达到精简。`YAGNI`的观点是你应该**为了眼前的需求做设计而不是未来**。\n\n> 只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries\n\n即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：\n\n- 你节约了时间，因为你避免了编写最终证明不必要的代码。\n- 你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。\n\n> **我的理解**：YAGNI 原则，本质上是告诫我们**写代码不要画蛇添足，否则就会弄巧成拙了**。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。\n\n### 6. Boy-Scout Rule\n\n`Boy-Scout Rule`，译为：**童子军规则**。美国童子军有一个简单的规则：“让营地比你刚来时更干净(`Always leave the campground cleaner than you found it`)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。\n\n童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要**始终保持代码整洁**。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。\n\n关于童子军规则中所提倡的**对代码坏味道的尽早修复**，我也想起来了我们所熟知的“**破窗效应**”和“**讳疾忌医**”的典故：\n\n#### 破窗效应\n\n> 如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论\n\n- “环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”\n- “这个代码以前的其他人也都是这样写的。”\n- “反正也不是只有我才这么写代码的。”\n\n不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“**千里之堤，溃于蚁穴**”、**勿以善小而不为，勿以恶小而为之**。\n\n#### 讳疾忌医的典故\n\n![扁鹊三连](http://static.blinkfox.com/20181123-hjjy.png)\n\n《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。\n\n代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。\n\n> 所以，请记住童子军规则对我们的启示：**始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治**。\n\n### 其他原则：\n\n- **避免过早优化**（`Avoid Premature Optimization`）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“**过早的优化是一切罪恶之源**。”——Donald Knuth\n- **最小惊讶原则**(`Principle of least astonishment`): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。\n- **代码重用原则**（`Code Reuse is Good`）: 重用代码能提高代码的可读性，缩短开发时间。\n- **别让我思考**(`Don’t Make Me Think`): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。\n- **为维护者写代码**(`Write Code for the Maintainer`): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”\n- **正交原则(Orthogonality)**: 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：`CSS`)。\n- **做最简单的事儿就让代码可运行**（`Do the simplest thing that could possibly work`）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。\n- **隐藏实现细节**（`Hide Implementation Details`）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。\n- **科里定律**(`Curly's Law`): 是为任何特定的代码选择一个明确定义的目标：**只做一件事**。\n- **墨菲定律**（`Murphy's Law`）:根本内容是：**如果事情有变坏的可能，不管这种可能性有多小，它总会发生**。主要内容如下：\n  - 任何事都没有表面看起来那么简单；\n  - 所有的事都会比你预计的时间长；\n  - 会出错的事总会出错；\n  - 如果你担心某种情况发生，那么它就更有可能发生。\n\n## 三、面向对象设计原则\n\n### 1. SRP\n\n所谓`SRP`原则，即：`Single Responsibility Principle`，**单一职责原则**。原始定义如下：\n\n> There should never be more than one reason for a class to change.(**只有一个引起类改变的原因**)\n\n在面向对象编程领域中，单一职责原则（`Single responsibility principle`）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。\n\n如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是**解耦**和**增强内聚性**。\n\n#### 单一职责的好处：\n\n- 类的复杂性降低，实现什么职责都有清晰明确的定义;\n- 可读性提高，复杂性降低，可维护性提高;\n- 变更引起的风险降低。\n\n#### 单一职责原则的注意点：\n\n- 单一职责最难划分的是**职责**。\n- 单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。\n- 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。\n\n### 2. LSP\n\n所谓`LSP`原则，即：`Liskov Substitution principle`，**里氏替换原则**。原始定义如下：\n\n> Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（**所有引用基类的地方必须能透明地使用其子类的对象**）\n\n更通俗的定义即为：**子类可以扩展父类的功能，但不能改变父类原有的功能**。里氏替换原则包含了一下4层含义：\n\n- 子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了`LSP`原则。\n- 子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。\n- 覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。\n- 覆盖或实现父类的方法时输出结果可以被缩小。\n\n#### 优点：\n\n- 提高代码的重用性，子类拥有父类的方法和属性；\n- 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；\n\n#### 缺点：\n\n- 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；\n- 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。\n\n### 3. ISP\n\n所谓`ISP`原则，即：`Interface Segregation Principle`，**接口隔离原则**。原始定义如下：\n\n> Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)\n\n> The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)\n\n即，**接口尽量细化，接口中的方法尽量少**。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。\n\n采用接口隔离原则对接口进行约束时，要注意以下几点：\n\n- 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。\n- 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。\n- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\n\n运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。\n\n### 4. OCP\n\n所谓`OCP`原则，即：`Open Closed Principle`，**开闭原则**。原始定义如下：\n\n> software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭)\n\n开闭原则（`OCP`）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：**对扩展开放，对修改关闭**。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。\n\n软件系统中包含的各种组件，例如模块（`Module`）、类（`Class`）以及功能（`Function`）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。\n\n实现开闭原则的关键就在于“**抽象**”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。\n\n开闭原则的好处：\n\n- 可复用性好;\n- 可维护性好。\n\n### 5. DIP\n\n所谓`DIP`原则，即：`Dependency Inversion Principle`，**依赖倒置原则**。原始定义如下：\n\n> High-level modules should not depend on low-level modules. Both should depend on abstractions.(**高层模块不应该依赖低层模块，两者都应该依赖其抽象**)\n\n> Abstractions should not depend on details. Details should depend on abstractions.(**抽象不应该依赖细节；细节应该依赖抽象**)\n\n面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。\n\n依赖倒置原则主要有以下三层含义：\n\n- 高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）；\n- 抽象不应该依赖细节（具体实现）；  \n- 细节（具体实现）应该依赖抽象。\n\n依赖倒置原则基于这样一个事实：**相对于细节的多变性，抽象的东西要稳定的多**。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。**依赖倒置原则的核心思想就是面向接口编程**。\n\n### 6. LOD | LKP\n\n所谓`LOD`原则，即：`Law of Demeter`，**迪米特法则**，又叫**最少知识原则**（`Least Knowledge Principle`，简写`LKP`），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下：\n\n> talk only to your immediate friends.(**只与直接的朋友通信**)\n\n**迪米特法则的初衷在于降低类之间的耦合**。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。\n\n迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。\n\n### 7. CRP\n\n所谓`CRP`原则，即：`Composite Reuse Principle`，**组合复用原则**。\n\n组合复用原则的核心思想是：**尽量使用对象组合，而不是继承来达到复用的目的**。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。\n\n继承的缺点主要有以下几点：\n\n- 继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。\n- 基类的实现发生了改变，派生类的实现也不得不改变。\n- 从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。\n\n由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：\n\n- 新对象存取`组成对象`的唯一方法是通过`组成对象`的`getter/setter`方法。\n- 组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。\n- 组合复用所需要的依赖较少。\n- 每一个新的类可以将焦点集中到一个任务上。\n- 组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。\n\n组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。\n\n组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。\n\n使用继承时必须满足`Is-A`的关系是才能使用继承，而组合却是一种`Has-A`的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把`Has-A`当成了`Is-A`。\n","tags":["Java","面向对象编程","设计原则"],"categories":["软件设计"]},{"title":"GitLab CI/CD 介绍和使用","url":"/2018/112229073.html","content":"\n## 一、持续集成介绍\n\n> 持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。—— Martin Fowler\n\n### 1 概念\n\n- **持续集成**(`Continuous Integration`)：**频繁地(一天多次)将代码集成到主干。**让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。“持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”\n- **持续交付**(`Continuous Delivery`)：**频繁地将软件的新版本，交付给质量团队或者用户，以供评审。**如果评审通过，代码就进入生产阶段。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。\n- **持续部署**(`continuous Deployment`)：**代码通过评审以后，自动部署到生产环境。**是持续部署是持续交付的下一步，持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。\n\n### 2 持续集成的好处\n\n- **自动化构建且状态对每个人可见**。可以使用`Maven`、`Gradle`等来实现自动化构建，可以在构建过程中实现自动化测试（前提是有写单元测试用例）。集成服务器在持续集成过程中发现问题可以及时发送警告给相关的干系人。\n- **解放了重复性劳动。**自动化部署工作可以解放集成、测试、部署等重复性劳动，而机器集成的频率明显比手工高很多。\n- **更快地发现和修复问题。**持续集成更早的获取变更，更早的进入测试，更早的发现问题，解决问题的成本显著下降。\n- **更快的交付成果。**更早发现错误减少解决错误所需的工作量。集成服务器在构建环节发现错误可以及时通知开发人员修复。集成服务器在部署环节发现错误可以回退到上一版本，服务器始终有一个可用的版本。\n- **减少手工的错误。**在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。\n- **减少了等待时间。**缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时机。持续集成，意味着开发、集成、测试、部署也得以持续。\n- **更高的产品质量。**集成服务器往往提供代码质量检测等功能，对不规范或有错误的地方会进行标致，也可以设置邮件和短信等进行警告。\n\n### 3 常用持续集成工具\n\n- [Jenkins](https://jenkins.io/)\n- [GitLab CI](https://docs.gitlab.com/ee/ci/README.html)\n- [TeamCity](https://www.jetbrains.com/teamcity/)\n- [Travis CI](https://www.travis-ci.org/)\n- [Bamboo](https://www.atlassian.com/software/bamboo)\n- [CircleCI](https://circleci.com/)\n- ...\n\n## 二、Gitlab 持续集成\n\n![GitLab CI/CD](https://docs.gitlab.com/ee/ci/img/cicd_pipeline_infograph.png)\n\n### 1 概念介绍\n\n#### (1) GitLab\n\n[GitLab](https://about.gitlab.com/) 是一个利用`Ruby on Rails`开发的开源应用程序，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与[GitHub](https://github.com/)类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。\n\n#### (2) GitLab CI/CD\n\n[GitLab CI/CD](https://docs.gitlab.com/ee/ci/README.html) 是`GitLab Continuous Integration`（Gitlab持续集成）的简称。GitLab 自`GitLab 8.0`开始提供了持续集成的功能，且对所有项目默认开启。只要在项目仓库的根目录添加`.gitlab-ci.yml`文件，并且配置了Runner（运行器），那么每一次`push`或者合并请求（`Merge Request`）都会触发[CI Pipeline](https://docs.gitlab.com/ce/ci/pipelines.html)。\n\n#### (3) GitLab Runner\n\n[GitLab Runner](https://docs.gitlab.com/runner/) `GitLab Runner`是一个开源项目，可以运行在 GNU / Linux，macOS 和 Windows 操作系统上。每次`push`的时候 GitLab CI 会根据`.gitlab-ci.yml`配置文件运行你流水线（`Pipeline`）中各个阶段的任务（`Job`），并将结果发送回 GitLab。GitLab Runner 是基于 Gitlab CI 的 API 进行构建的相互隔离的机器（或虚拟机）。GitLab Runner 不需要和 Gitlab 安装在同一台机器上，且考虑到 GitLab Runner 的资源消耗问题和安全问题，也不建议这两者安装在同一台机器上。\n\nGitlab Runner 分为三种：\n\n- 共享Runner(`Shared runners`)\n- 专享Runner(`Specific runners`)\n- 分组Runner(`Group Runners`)\n\n#### (4) Pipelines\n\n[Pipelines](https://docs.gitlab.com/ce/ci/pipelines.html) 中文称为流水线，是分阶段执行的构建任务。如：安装依赖、运行测试、打包、部署开发服务器、部署生产服务器等流程。每一次`push`或者`Merge Request`都会触发生成一条新的Pipeline。\n\n下面是流水线示例图：\n\n![Pipeline Status](https://docs.gitlab.com/ce/ci/img/pipelines_index.png)\n\n#### (5) Stages\n\n[Stages](https://docs.gitlab.com/ce/ci/yaml/README.html#stages) 表示构建阶段，可以理解为上面所说“安装依赖”、“运行测试”等环节的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：\n\n- 所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始（当然可以在`.gitlab-ci.yml`文件中配置上一阶段失败时下一阶段也执行）\n- 只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功\n- 如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败\n\n下面是一个流水线内的阶段任务示例图：\n\n![Job Status](https://docs.gitlab.com/ce/ci/img/pipelines.png)\n\n#### (6) Jobs\n\n[Jobs](https://docs.gitlab.com/ce/ci/pipelines.html#jobs) 表示构建的作业（或称之为任务），表示某个 Stage 里面执行的具体任务。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：\n\n- 相同 Stage 中的 Jobs 无执行顺序要求，会并行执行\n- 相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功\n- 如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 也失败（可以在`.gitlab-ci.yml`文件中配置允许某 Job 可以失败，也算该 Stage 成功）\n\n#### (7) .gitlab-ci.yml\n\nGitLab 中默认开启了 Gitlab CI/CD 的支持，且使用[YAML](http://yaml.org/)文件[.gitlab-ci.yml](https://docs.gitlab.com/ee/ci/yaml/README.html#examples)来管理项目构建配置。该文件需要存放于项目仓库的根目录（默认路径，可在 GitLab 中修改），它定义该项目的 CI/CD 如何配置。所以，我们只需要在`.gitlab-ci.yml`配置文件中定义流水线的各个阶段，以及各个阶段中的若干作业（任务）即可。\n\n下面是`.gitlab-ci.yml`文件的一个简单的`Hello World`示例：\n\n```yaml\n# 定义 test 和 package 两个 Stages\nstages:\n  - test\n  - package\n\n# 定义 package 阶段的一个 job\npackage-job:\n  stage: package\n  script:\n    - echo \"Hello, package-job\"\n    - echo \"I am in package stage\"\n\n# 定义 test 阶段的一个 job\ntest-job:\n  stage: test\n  script:\n    - echo \"Hello, test-job\"\n    - echo \"I am in test stage\"\n```\n\n以上配置中，用 stages 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。每个 job 中可以可以再用 stage 关键字来指定该 job 对应哪个 stage。job 里面的`script`关键字是每个 job 中必须要包含的，它表示每个 job 要执行的命令。\n\n> **注**：猜猜上面例子的运行结果？\n\n#### (8) Badges\n\n[Badges](https://docs.gitlab.com/ce/ci/pipelines.html#badges) 即：**徽章**，当 Pipelines 执行过程中或者执行完成时会生成徽章，你可以将这些徽章加入到你的`README.md`文件中，便于从仓库主页看到最新的构建状态。\n\n徽章的链接形如下：\n\n```bash\nhttp://example.gitlab.com/namespace/project/badges/branch/build.svg \n```\n\n我们用 GitLab 项目的徽章作为例子，效果如下：\n\n![Gitlab build badges](https://gitlab.com/gitlab-org/gitlab-ce/badges/master/build.svg) ![Gitlab coverage badges](https://gitlab.com/gitlab-org/gitlab-ce/badges/master/coverage.svg?job=coverage)\n\n### 2 安装 GitLab Runner\n\n[这里](https://docs.gitlab.com/runner/install/index.html)有 GitLab Runner安装相关的资源和文档可供大家参考。以下仅以咱们公司常用的`Centos`为例来做安装说明。\n\n#### (1) 在线安装\n\n```bash\n# 添加官方的repo.\ncurl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash\n\n# yum 安装Gtilab Runner.\nsudo yum install gitlab-runner\n```\n\n#### (2) 离线安装\n\n```bash\n# 安装Git\nsudo yum –y install git\n\n# rpm离线安装事先下载好的 Gitlab Runner rpm包.\nrpm -ivh gitlab-runner-10.5.0-1.x86_64.rpm\n```\n\n> **注**：Gitlab Runner 依赖了`Git`，所以，离线安装 Gitlab Runner 之前得首先安装Git，离线安装包可以从[这里](https://packages.gitlab.com/runner/gitlab-runner)下载。\n\n### 3 注册 Gitlab Runner\n\n安装了 GitLab Runner 之后,就可以为 GitLab 中的仓库[注册一个 Runner](https://docs.gitlab.com/runner/register/index.html)，注册的交互式命令如下：\n\n```bash\nsudo gitlab-runner register\n```\n\n命令的交互式的过程如下：\n\n```bash\n# 输入注册命令\nsudo gitlab-runner register\n\n# 输入公司的 GitLab 网站地址\nPlease enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )\nhttp://gitlab.xxxx.com/\n\n# 你项目仓库的token，token可以在 Settings -> CI/CD -> Runners settings 中找到.\nPlease enter the gitlab-ci token for this runner\nxxx\n\n# 输入描述这个 runner 的名称\nPlease enter the gitlab-ci description for this runner\n[hostame] my-runner\n\n# 输入 runner 的标签\nPlease enter the gitlab-ci tags for this runner (comma separated):\nmy-tag,another-tag\n\n# 输入 runner 的执行器.\nPlease enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:\nshell\n```\n\n以上流程注册成功之后，就可以在你的项目仓库中 `Settings` -> `CI/CD` -> `Runners settings` 看到这个 Runner 了。\n\n### 4 Gitlab Runner 常用命令汇总\n\n下面的表格中列出了一些常用的[Gitlab Runner命令](https://docs.gitlab.com/runner/commands/README.html#gitlab-runner-list)，以供参考：\n\n| 命令                     | 描述                                                         |\n| ------------------------ | :----------------------------------------------------------- |\n| gitlab-runner run        | 运行一个runner服务                                           |\n| gitlab-runner register   | 注册一个新的runner                                           |\n| gitlab-runner start      | 启动服务                                                     |\n| gitlab-runner stop       | 关闭服务                                                     |\n| gitlab-runner restart    | 重启服务                                                     |\n| gitlab-runner status     | 查看各个runner的状态                                         |\n| gitlab-runner unregister | 注销掉某个runner                                             |\n| gitlab-runner list       | 显示所有运行着的runner                                       |\n| gitlab-runner verify     | 检查已注册的运行程序是否可以连接到GitLab，但它不验证GitLab Runner服务是否正在使用运行程序。 |\n\n## 三、一个Web项目 CI/CD 简单示例\n\n接下来，用一个实际项目来演示 GitLab CI/CD 的配置和使用，其中主要包括：编译测试、项目打包、部署服务、Sonar手动检查、Sonar定时检查五个阶段。\n\n下面用一个传统的 Java web 项目(这里称之为`cidemo`)和`Tomcat`来作为示例，并用来展示常用配置的使用。当我每次`push`代码或者`Merge Request`时，都会生成一条流水线，且会自动执行我们上面所说的一些阶段，而Sonar手动检查我们设置为手动操作，且再额外配置Sonar定时检查的任务。\n\n> **注**：我 Gitlab Runner 是安装在`Centos`环境中，并使用的`shell`执行器。\n\n```yaml\n# 定义stages\nstages:\n  - test\n  - install\n  - run\n  - sonar\n\n# 定义安装包的存放位置和Tomcat服务器的地址的变量，便于后续部署使用.\nvariables:\n  CIDEMO_PACKAGE_DIR: '/home/gitlab-runner/packages/cidemo/'\n  SERVER_HOME_DIR: '/home/gitlab-runner/tomcat/cidemo-tomcat/'\n\n###################### 构建编译和单元测试的job. #######################\n\n编译测试任务:\n  stage: test\n  only:\n    - branches\n  script:\n    - mvn clean test\n\n###################### Maven安装得到war包的job. #######################\n\n打包任务:\n  stage: install\n  only:\n    - develop\n  script:\n    - mvn install\n    - echo '准备将最新的war包复制、保存到某个目录里面供后续使用.'\n    - rm -rf $CIDEMO_PACKAGE_DIR/*.war\n    - cp target/*.war $CIDEMO_PACKAGE_DIR/cidemo.war\n\n####################### 部署运行war包的job. #######################\n\n部署运行任务:\n  stage: run\n  only:\n    - develop\n  script:\n    - echo '准备部署和运行war包！(为了方便部署到了Tomcat中运行)'\n    - cd $SERVER_HOME_DIR\n    - sh bin/shutdown.sh\n    - rm -rf webapps/cidemo.war\n    - cp $CIDEMO_PACKAGE_DIR/cidemo.war $SERVER_HOME_DIR/webapps/cidemo.war\n    - nohup sh ./bin/startup.sh > logs/cidemo_nohup.log 2>&1 &\n\n###################### Sonar手动构建的job. #######################\n\nSonar手动检查:\n  stage: sonar\n  when: manual\n  only:\n    - develop\n  script:\n    - echo '准备对项目代码做sonar的质量检查！'\n    - mvn compile && mvn sonar:sonar -Dsonar.host.url=http://172.16.34.102:9000 -Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34\n\n###################### Sonar每晚定时构建的job. #######################\n\nSonar定时检查:\n  stage: sonar\n  only:\n    - schedules\n  script:\n    - echo '开始定时对项目代码做sonar的质量检查！'\n    - mvn compile && mvn sonar:sonar -Dsonar.host.url=http://172.16.34.102:9000 -Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34\n```\n\n## 四、Gitlab CI/CD yaml 常用配置介绍\n\n开始构建之前`.gitlab-ci.yml`文件定义了一系列带有约束说明的任务。这些任务都是以任务名开始并且至少要包含script部分，`.gitlab-ci.yml`允许指定无限量 jobs。每个 jobs 必须有一个唯一的名字，且名字不能是下面列出的保留字段：\n\n- `image`\n- `services`\n- `stages`\n- `types`\n- `before_script`\n- `after_script`\n- `variables`\n- `cache`\n\njob由一列参数来定义 jobs 的行为：\n\n| Keyword       | Required | Description                                                  |\n| ------------- | -------- | ------------------------------------------------------------ |\n| script        | yes      | Runner执行的命令或脚本                                       |\n| extends       | no       | 定义此作业将继承的配置条目                                   |\n| image         | no       | 所使用的docker镜像，查阅[使用docker镜像](https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml) |\n| services      | no       | 所使用的docker服务，查阅[使用docker镜像](https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml) |\n| stage         | no       | 定义job stage（默认：`test`）                                |\n| type          | no       | `stage`的别名（已弃用）                                      |\n| variables     | no       | 定义job级别的变量                                            |\n| only          | no       | 定义一列git分支，并为其创建job                               |\n| except        | no       | 定义一列git分支，不创建job                                   |\n| tags          | no       | 定义一列tags，用来指定选择哪个Runner（同时Runner也要设置tags） |\n| allow_failure | no       | 允许job失败。失败的job不影响commit状态                       |\n| when          | no       | 定义何时开始job。可以是`on_success`，`on_failure`，`always`或者`manual` |\n| dependencies  | no       | 定义job依赖关系，这样他们就可以互相传递artifacts             |\n| cache         | no       | 定义应在后续运行之间缓存的文件列表                           |\n| before_script | no       | 重写一组在作业前执行的命令                                   |\n| after_script  | no       | 重写一组在作业后执行的命令                                   |\n| environment   | no       | 定义此作业完成部署的环境名称                                 |\n| coverage      | no       | 定义给定作业的代码覆盖率设置                                 |\n| etry          | no       | 定义在发生故障时可以自动重试作业的时间和次数                 |\n| parallel      | no       | 定义应并行运行的作业实例数                                   |\n\n### extends\n\n> 是在 GitLab 11.3 中引入的。\n\n`extends`定义了一个使用`extends`的作业将继承的条目名称。它是使用[YAML锚点](https://docs.gitlab.com/ee/ci/yaml/README.html#anchors)的替代方案，并且更加灵活和可读：\n\n```yaml\n.tests:\n  script: rake test\n  stage: test\n  only:\n    refs:\n      - branches\n\nrspec:\n  extends: .tests\n  script: rake rspec\n  only:\n    variables:\n      - $RSPEC\n```\n\n在上面的示例中，`rspec`作业继承自`.tests`模板作业。 GitLab 将根据键执行反向深度合并。 GitLab将：\n\n- 将`rspec`内容以递归方式合并到`.tests`中。\n- 不合并键的值。\n\n这实际生成的是以下`rspec`作业：\n\n```yaml\nrspec:\n  script: rake rspec\n  stage: test\n  only:\n    refs:\n      - branches\n    variables:\n      - $RSPEC\n```\n\n> **注**: `rake test`已被`rake rspec`脚本覆盖。\n\n### image 和 services\n\n这两个关键字允许使用一个自定义的 Docker 镜像和一系列的服务，并且可以用于整个 job 周期。详细配置文档请查看[a separate document](https://docs.gitlab.com/ee/ci/docker/README.html)。\n\n### before_script 和 after_script\n\n`before_script`用来定义所有 job 之前运行的命令，`after_script`用来定义所有 job 之后运行的命令。它们可以是一个数组或者是多行字符串。\n\n### stages\n\nstages 用来定义可以被 job 调用的 stages。stages 的规范允许有灵活的多级 pipelines。\n\nstages中的元素顺序决定了对应job的执行顺序：\n\n1. 相同 stage 的 job 可以平行执行。\n2. 下一个 stage 的 job 会在前一个 stage 的 job 成功后开始执行。\n\n接下仔细看看这个例子，它包含了3个 stage：\n\n```yaml\nstages:\n - build\n - test\n - deploy\n```\n\n1. 首先，所有 build 的 jobs 都是并行执行的。\n2. 所有 build 的 jobs 执行成功后，test 的 jobs 才会开始并行执行。\n3. 所有 test 的 jobs 执行成功，deploy 的 jobs 才会开始并行执行。\n4. 所有的 deploy 的 jobs 执行成功，`commit`才会标记为`success`。\n5. 任何一个前置的 jobs 失败了，`commit`会标记为`failed`并且下一个 stages 的 jobs 都不会执行。\n\n这有两个特殊的例子值得一提：\n\n1. 如果`.gitlab-ci.yml`中没有定义stages，那么 job's stages 会默认定义为`build`，`test`和`deploy`。\n2. 如果一个 job 没有指定 stage，那么这个任务会分配到 test stage。\n\n### only 和 except\n\n`only`和`except`是两个参数用分支策略来限制 jobs 构建：\n\n- `only`定义哪些分支和标签的git项目将会被job执行。\n- `except`定义哪些分支和标签的git项目将不会被job执行。\n\n下面是refs策略的使用规则：\n\n- only 和 except 可同时使用。如果`only`和`except`在一个 job 配置中同时存在，则以 only 为准，跳过 except(从下面示例中得出)。\n- only 和 except 可以使用正则表达式。\n- only 和 except 允许使用特殊的关键字：`branches`，`tags`和`triggers`。\n- only 和 except 允许使用指定仓库地址但不是forks的仓库(查看示例3)。\n  \n在下面这个例子中，job 将只会运行以`issue-`开始的refs(分支)，然而`except`中设置将被跳过。\n\n```yaml\njob:\n  # use regexp\n  only:\n    - /^issue-.*$/\n  # use special keyword\n  except:\n    - branches\n```\n\n在下面这个例子中，job 将只会执行有`tags`的refs，或者通过`API`触发器明确地请求构建。\n\n```yaml\njob:\n  # use special keywords\n  only:\n    - tags\n    - triggers\n```\n\n下面这个例子将会为所有的分支执行job，但 master 分支除外。\n\n```yaml\njob:\n  only:\n    - branches@gitlab-org/gitlab-ce\n  except:\n    - master@gitlab-org/gitlab-ce\n```\n\n### variables\n\nGItLab CI 允许在`.gitlab-ci.yml`文件中添加变量，并在 job 环境中起作用。因为这些配置是存储在 git 仓库中，所以**最好是存储项目的非敏感配置**，例如：\n\n```yaml\nvariables:\n  DATABASE_URL:\"postgres://postgres@postgres/my_database\"\n```\n\n这些变量可以被后续的命令和脚本使用。\n\n除了用户自定义的变量外，Runner 也可以定义它自己的变量。`CI_COMMIT_REG_NAME`就是一个很好的例子，它的值表示用于构建项目的分支或tag名称。除了在`.gitlab-ci.yml`中设置变量外，还有可以通过 GitLab 的界面上设置私有变量。\n\n这里有更多关于[variables](https://docs.gitlab.com/ce/ci/variables/README.html)的介绍。\n\n### cache\n\n#### cache: paths\n\n使用`paths`指令选择要缓存的文件或目录。也可以使用通配符。\n\n如果 cache 定义在 jobs 的作用域之外，那么它就是全局缓存，所有 jobs 都可以使用该缓存。\n\n缓存`binaries`和`.config`中的所有文件：\n\n```yaml\nrspec:\n  script: test\n  cache:\n    paths:\n    - binaries/\n    - .config\n```\n\n缓存`git`中没有被跟踪的文件：\n\n```yaml\nrspec:\n  script: test\n  cache:\n    untracked: true\n```\n\n缓存`binaries`下没有被`git`跟踪的文件：\n\n```yaml\nrspec:\n  script: test\n  cache:\n    untracked: true\n    paths:\n    - binaries/\n```\n\njob 中优先级高于全局的。下面这个`rspec` job中将只会缓存`binaries/`下的文件：\n\n```yaml\ncache:\n  paths:\n  - my/files\n\nrspec:\n  script: test\n  cache:\n    key: rspec\n    paths:\n    - binaries/\n```\n\n注意，缓存是在 jobs 之前进行共享的。如果你不同的 jobs 缓存不同的文件路径，必须设置不同的`cache:key`，否则缓存内容将被重写。缓存只是尽力而为之，所以别期望缓存会一直存在。\n\n#### cache: key\n\n`key`指令允许我们定义缓存的作用域(亲和性)，可以是所有 jobs 的单个缓存，也可以是每个 job，也可以是每个分支或者是任何你认为合适的地方。它也可以让你很好的调整缓存，允许你设置不同 jobs 的缓存，甚至是不同分支的缓存。\n\n`cache:key`可以使用任何的[预定义变量](https://docs.gitlab.com/ce/ci/variables/README.html)。\n\n默认key是默认设置的这个项目缓存，因此默认情况下，从GitLab 9.0开始，每个 pipelines 和 jobs 中可以共享一切。\n\n配置示例\n\n缓存每个job：\n\n```yaml\ncache:\n  key: \"$CI_JOB_NAME\"\n  untracked: true\n```\n\n缓存每个分支：\n\n```yaml\ncache:\n  key: \"$CI_COMMIT_REF_NAME\"\n  untracked: true\n```\n\n缓存每个 job 且每个分支：\n\n```yaml\ncache:\n  key: \"$CI_JOB_NAME/$CI_COMMIT_REF_NAME\"\n  untracked: true\n```\n\n缓存每个分支且每个stage：\n\n```yaml\ncache:\n  key: \"$CI_JOB_STAGE/$CI_COMMIT_REF_NAME\"\n  untracked: true\n```\n\n如果使用的Windows Batch(windows批处理)来跑脚本需要用%替代$：\n\n```yaml\ncache:\n  key: \"%CI_JOB_STAGE%/%CI_COMMIT_REF_NAME%\"\n  untracked: true\n```\n\n### allow_failure\n\n`allow_failure`可以用于当你想设置一个 job 失败的之后并不影响后续的CI组件的时候。失败的 jobs 不会影响到`commit`状态。\n\n当开启了允许 job 失败，所有的 intents 和 purposes 里的 pipeline 都是成功/绿色，但是也会有一个\"`CI build passed with warnings`\"信息显示在`Merge Request`或`commit`或`job page`。这被允许失败的作业使用，但是如果失败表示其他地方应采取其他（手动）步骤。\n\n下面的这个例子中，job1和job2将会并列进行，如果job1失败了，它也不会影响进行中的下一个 stage，因为这里有设置了`allow_failure: true`。\n\n```yaml\njob1:\n  stage: test\n  script:\n    - execute_script_that_will_fail\n  allow_failure: true\n\njob2:\n  stage: test\n  script:\n    - execute_script_that_will_succeed\n\njob3:\n  stage: deploy\n  script:\n    - deploy_to_staging\n```\n\n### when\n\n`when`用于实现在发生故障或尽管失败时运行的作业。when可以设置以下值：\n\n- `on_success` - 只有前面 stages 的所有工作成功时才执行。这是默认值。\n- `on_failure` - 当前面 stages 中任意一个jobs失败后执行。\n- `always` - 无论前面 stages 中 jobs 状态如何都执行。\n- `manual` - 手动执行(GitLab8.10增加)。更多请查看手动操作。\n\n### artifacts\n\n`artifacts`用于指定成功后应附加到 job 的文件和目录的列表。只能使用项目工作间内的文件或目录路径。在job成功完成后artifacts将会发送到GitLab中，同时也会在 GitLab UI 中提供下载。如果想要在不通的 job 之间传递`artifacts`，请查阅[依赖关系](https://docs.gitlab.com/ce/ci/yaml/README.html#dependencies)。以下是一些例子：\n\n发送`binaries`和`.config`中的所有文件：\n\n```yaml\nartifacts:\n  paths:\n  - binaries/\n  - .config\n```\n\n发送所有没有被Git跟踪的文件：\n\n```yaml\nartifacts:\n  untracked: true\n```\n\n发送没有被Git跟踪和`binaries`中的所有文件：\n\n```yaml\nartifacts:\n  untracked: true\n  paths:\n  - binaries/\n```\n\n## 五、其他相关内容\n\n### 1 API触发器 Triggers\n\nTriggers 可用于强制使用API调用重建特定分支，`tag`或`commits`。API的使用示例可以在`Settings` -> `CI/CD` -> `Pipeline triggers`中找到。\n\n在`triggers`文档中[查看更多](https://docs.gitlab.com/ce/ci/triggers/README.html)。\n\n### 2 配置定时任务\n\nGitLab CI 中可以在 GitLab `Settings` -> `CI/CD` -> `Schedules`中配置定时任务，点击`New Schedule`按钮，可以配置你流水线的定时执行任务，包括：描述信息、定时的Cron表达式、目标分支、变量等信息。\n\n然后在需要定时执行的作业的`only`分支写上`schedules`即可。\n\n### 3 校验 .gitlab-ci.yml\n\nGitLab CI 的每个实例都有一个名为`Lint`的嵌入式调试工具。 你可以在 GitLab 实例的`-/ci/lint`下找到该链接。\n\n### 4 配置邮件发送\n\n如果希望在每次构建完成后（或者在仅构建失败的情况下），想邮件发送给相关开发人员，则可以在 GitLab `Settings` -> `Integrations` 中找到`Pipelines emails`，点击进去就可以配置邮件发送相关的内容了。\n\n### 5 GitLab Pages\n\n[GitLab Pages](https://gitlab.com/pages/)是用于托管静态文件的服务。而`pages`是一个特殊的job，用于将静态的内容上传到GitLab，可用于为您的网站提供服务。它有特殊的语法，因此必须满足以下两个要求：\n\n- 任何静态内容必须放在`public/`目录下\n- artifacts必须定义在`public/`目录下\n\n下面的这个例子是将所有文件从项目根目录移动到`public/`目录。`.public`工作流是`cp`，并且它不会循环复制`public/`本身。\n\n```yaml\npages:\n  stage: deploy\n  script:\n  - mkdir .public\n  - cp -r * .public\n  - mv .public public\n  artifacts:\n    paths:\n    - public\n  only:\n  - master\n```\n\n更多内容请查看[GitLab Pages用户文档](https://docs.gitlab.com/ce/user/project/pages/index.html)。\n\n### 6 跳过 jobs\n\n如果你的`commit`信息中包含`[ci skip]`或者`[skip ci]`，不论大小写，那么这个`commit`将会创建但是 jobs 也会跳过。\n\n---\n\n## 参考文档\n\n- [官方文档地址](https://docs.gitlab.com/ce/ci/yaml/README.html)\n- [segmentfault yaml配置中文翻译](https://segmentfault.com/a/1190000010442764#articleHeader24)","tags":["GitLab CI","DevOps","Jenkins"],"categories":["软件工具"]},{"title":"CPU多级缓存","url":"/2018/11186549.html","content":"\n## 一、什么是CPU缓存\n\n### 1. CPU缓存的来历\n\n众所周知,CPU是计算机的大脑，它负责执行程序的指令，而内存负责存数据, 包括程序自身的数据。在很多年前，CPU的频率与内存总线的频率在同一层面上。内存的访问速度仅比寄存器慢一些。但是，这一局面在上世纪90年代被打破了。CPU的频率大大提升，但内存总线的频率与内存芯片的性能却没有得到成比例的提升。并不是因为造不出更快的内存，只是因为太贵了。内存如果要达到目前CPU那样的速度，那么它的造价恐怕要贵上好几个数量级。所以，CPU的运算速度要比内存读写速度快很多，这样会使CPU花费很长的时间等待数据的到来或把数据写入到内存中。所以，**为了解决CPU运算速度与内存读写速度不匹配的矛盾**，就出现了CPU缓存。\n\n### 2. CPU缓存的概念\n\n**CPU缓存是位于CPU与内存之间的临时数据交换器，它的容量比内存小的多但是交换速度却比内存要快得多。CPU缓存一般直接跟CPU芯片集成或位于主板总线互连的独立芯片上**。\n\n为了简化与内存之间的通信，高速缓存控制器是针对数据块，而不是字节进行操作的。高速缓存其实就是一组称之为**缓存行**(Cache Line)的固定大小的数据块组成的，典型的一行是`64`字节。\n\n### 3. CPU缓存的意义\n\nCPU往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令CPU能在CPU缓存中找到，CPU就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。所以，缓存的意义满足以下两种**局部性原理**：\n\n- **时间局部性（Temporal Locality）**：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。\n- **空间局部性（Spatial Locality）**：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。\n\n## 二、CPU的三级缓存\n\n### 1. CPU的三级缓存\n\n随着多核CPU的发展，CPU缓存通常分成了三个级别：`L1`，`L2`，`L3`。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。L1 是最接近CPU的, 它容量最小（例如：`32K`），速度最快，每个核上都有一个 L1 缓存，L1 缓存每个核上其实有两个 L1 缓存, 一个用于存数据的 L1d Cache（Data Cache），一个用于存指令的 L1i Cache（Instruction Cache）。L2 缓存 更大一些（例如：`256K`），速度要慢一些, 一般情况下每个核上都有一个独立的L2 缓存; L3 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 L3 缓存。\n\n下面是三级缓存的处理速度参考表：\n\n| 从CPU到  | 大约需要的CPU周期 | 大约需要的时间(单位ns) |\n| -------- | ----------------- | ---------------------- |\n| 寄存器   | 1 cycle           |                        |\n| L1 Cache | ~3-4 cycles       | ~0.5-1 ns              |\n| L2 Cache | ~10-20 cycles     | ~3-7 ns                |\n| L3 Cache | ~40-45 cycles     | ~15 ns                 |\n| 跨槽传输 |                   | ~20 ns                 |\n| 内存     | ~120-240 cycles   | ~60-120ns              |\n\n下图是Intel Core i5-4285U的CPU三级缓存示意图：\n\n![CPU三级缓存](http://static.blinkfox.com/javabf_cpu_01.png)\n\n就像数据库缓存一样，获取数据时首先会在最快的缓存中找数据，如果缓存没有命中(Cache miss) 则往下一级找, 直到三级缓存都找不到时，那只有向内存要数据了。一次次地未命中，代表取数据消耗的时间越长。\n\n### 2. 带有高速缓存CPU执行计算的流程\n\n1. 程序以及数据被加载到主内存\n2. 指令和数据被加载到CPU的高速缓存\n3. CPU执行指令，把结果写到高速缓存\n4. 高速缓存中的数据写回主内存\n\n目前流行的多级缓存结构如下图：\n\n![多级缓存结构](http://static.blinkfox.com/javabf_cpu_02.png)\n\n## 三、CPU缓存一致性协议(MESI)\n\n**MESI**（`Modified Exclusive Shared Or Invalid`）(也称为**伊利诺斯协议**，是因为该协议由伊利诺斯州立大学提出的）是一种广泛使用的支持写回策略的缓存一致性协议。为了保证多个CPU缓存中共享数据的一致性，定义了缓存行(Cache Line)的四种状态，而CPU对缓存行的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的缓存行的状态进行一致性修改，从而保证数据在多个缓存之间保持一致性。\n\n### 1. MESI协议中的状态\n\nCPU中每个缓存行（Caceh line)使用`4`种状态进行标记，使用`2bit`来表示:\n\n| 状态                     | 描述                                                         | 监听任务                                                     | 状态转换                                                     |\n| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| M 修改 (Modified)        | 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 | 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。 | 当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。 |\n| E 独享、互斥 (Exclusive) | 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 | 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。 | 当CPU修改该缓存行中内容时，该状态可以变成Modified状态        |\n| S 共享 (Shared)          | 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 | 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 | 当有一个CPU修改该缓存行时，其它CPU中该缓存行可以被作废（变成无效状态 Invalid）。 |\n| I 无效 (Invalid)         | 该Cache line无效。                                           | 无                                                           | 无                                                           |\n\n> **注意**：\n**对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的**。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。\n\n从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。\n\nMESI状态转换图：\n\n![MESI状态转换图](http://static.blinkfox.com/javabf_cpu_03.png)\n\n下图表示了当一个缓存行(Cache line)的调整的状态的时候，另外一个缓存行(Cache line)需要调整的状态。\n\n| 状态  | M    | E    | S    | **I** |\n| ----- | ---- | ---- | ---- | ----- |\n| **M** | ×    | ×    | ×    | √     |\n| **E** | ×    | ×    | ×    | √     |\n| **S** | ×    | ×    | √    | √     |\n| **I** | √    | √    | √    | √     |\n\n举个示例：\n\n> 假设cache 1 中有一个变量`x = 0`的 Cache line 处于S状态(共享)。\n> 那么其他拥有x变量的 cache 2、cache 3 等`x`的 Cache line调整为`S`状态（共享）或者调整为`I`状态（无效）。\n\n### 2. 多核缓存协同操作\n\n#### (1) 内存变量\n\n假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、c。在主内存中定义了`x`的引用值为0。\n\n![内存变量](http://static.blinkfox.com/javabf_cpu_04.png)\n\n#### (2) 单核读取\n\n执行流程是：\n\n- CPU A发出了一条指令，从主内存中读取`x`。\n- 从主内存通过 bus 读取到 CPU A 的缓存中（远端读取 Remote read）,这时该 Cache line 修改为 E 状态（独享）。\n\n![单核读取](http://static.blinkfox.com/javabf_cpu_05.png)\n\n#### (3) 双核读取\n\n执行流程是：\n\n- CPU A发出了一条指令，从主内存中读取`x`。\n- CPU A从主内存通过bus读取到 cache a 中并将该 Cache line 设置为E状态。\n- CPU B发出了一条指令，从主内存中读取`x`。\n- CPU B试图从主内存中读取`x`时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时`x`存储于 cache a 和 cache b 中，`x`在 chche a 和 cache b 中都被设置为S状态(共享)。\n\n![双核读取](http://static.blinkfox.com/javabf_cpu_06.png)\n\n#### (4) 修改数据\n\n执行流程是：\n\n- CPU A 计算完成后发指令需要修改`x`.\n- CPU A 将`x`设置为M状态（修改）并通知缓存了`x`的 CPU B, CPU B 将本地 cache b 中的`x`设置为`I`状态(无效)\n- CPU A 对`x`进行赋值。\n\n![修改数据](http://static.blinkfox.com/javabf_cpu_07.png)\n\n#### (5) 同步数据\n\n那么执行流程是：\n\n- CPU B 发出了要读取x的指令。\n- CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）\n- CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）。\n\n![同步数据](http://static.blinkfox.com/javabf_cpu_08.png)\n\n### 3. CPU 存储模型简介\n\nMESI协议为了保证多个 CPU cache 中共享数据的一致性，定义了 Cache line 的四种状态，而 CPU 对 cache 的`4`种操作可能会产生不一致状态，因此 cache 控制器监听到本地操作和远程操作的时候，需要对地址一致的 Cache line 状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。\n\n但是，缓存的一致性消息传递是要时间的，这就使得状态切换会有更多的延迟。某些状态的切换需要特殊的处理，可能会阻塞处理器。这些都将会导致各种各样的稳定性和性能问题。比如你需要修改本地缓存中的一条信息，那么你必须将`I`（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。因为这个等待远远比一个指令的执行时间长的多。所以，为了为了避免这种阻塞导致时间的浪费，引入了存储缓存(`Store Buffer`)和无效队列(`Invalidate Queue`)。\n\n#### (1) 存储缓存\n\n在没有存储缓存时，CPU 要写入一个量，有以下情况：\n\n- 量不在该 CPU 缓存中，则需要发送 Read Invalidate 信号，再等待此信号返回，之后再写入量到缓存中。\n- 量在该 CPU 缓存中，如果该量的状态是 Exclusive 则直接更改。而如果是 Shared 则需要发送 Invalidate 消息让其它 CPU 感知到这一更改后再更改。\n\n这些情况中，很有可能会触发该 CPU 与其它 CPU 进行通讯，接着需要等待它们回复。这会浪费大量的时钟周期！为了提高效率，可以使用**异步**的方式去处理：先将值写入到一个 Buffer 中，再发送通讯的信号，等到信号被响应，再应用到 cache 中。并且此 Buffer 能够接受该 CPU 读值。这个 Buffer 就是 Store Buffer。而不须要等待对某个量的赋值指令的完成才继续执行下一条指令，直接去 Store Buffer 中读该量的值，这种优化叫**Store Forwarding**。\n\n#### (2) 无效队列\n\n同理，解决了主动发送信号端的效率问题，那么，接受端 CPU 接受到 Invalidate 信号后如果立即采取相应行动(去其它 CPU 同步值)，再返回响应信号，则时钟周期也太长了，此处也可优化。接受端 CPU 接受到信号后不是立即采取行动，而是将 Invalidate 信号插入到一个队列 Queue 中，立即作出响应。等到合适的时机，再去处理这个 Queue 中的 Invalidate 信号，并作相应处理。这个 Queue 就是**Invalidate Queue**。\n\n## 四、乱序执行\n\n**乱序执行（`out-of-orderexecution`）**：是指CPU允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。这样将根据各电路单元的状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路。\n\n这好比请A、B、C三个名人为晚会题写横幅“春节联欢晚会”六个大字，每人各写两个字。如果这时在一张大纸上按顺序由A写好\"春节\"后再交给B写\"联欢\"，然后再由C写\"晚会\"，那么这样在A写的时候，B和C必须等待，而在B写的时候C仍然要等待而A已经没事了。\n\n但如果采用三个人分别用三张纸同时写的做法， 那么B和C都不必须等待就可以同时各写各的了，甚至C和B还可以比A先写好也没关系（就象乱序执行），但当他们都写完后就必须重新在横幅上（自然可以由别人做，就象CPU中乱序执行后的重新排列单元）按\"春节联欢晚会\"的顺序排好才能挂出去。\n\n所以，CPU 为什么会有乱序执行优化？本质原因是**CPU为了效率**，将长费时的操作“异步”执行，排在后面的指令不等前面的指令执行完毕就开始执行后面的指令。而且允许排在前面的长费时指令后于排在后面的指令执行完。\n\nCPU 执行乱序主要有以下几种：\n\n- **写写乱序(store store)**：`a=1;b=2; -> b=2;a=1;`\n- **写读乱序(store load)**：`a=1;load(b); -> load(b);a=1;`\n- **读读乱序(load load)**：`load(a);load(b); -> load(b);load(a);`\n- **读写乱序(load store)**：`load(a);b=2; -> b=2;load(a);`\n\n总而言之，**CPU的乱序执行优化指的是处理器为提高运算速度而做出违背代码原有顺序的优化**。\n\n---\n\n参考文章：\n\n- [从Java视角理解系统结构（二）CPU缓存](http://ifeve.com/from-javaeye-cpu-cache/)\n- [CPU缓存一致性协议MESI](http://www.cnblogs.com/yanlong300/p/8986041.html)","tags":["CPU缓存"],"categories":["软件工具"]},{"title":"单元测试指南","url":"/2018/111555206.html","content":"\n## 一、必要性\n\n在我们公司中要做单元测试，确实比较难，因为公司缺少这种氛围，有也只是局部的，大多数工程师没有这方面的习惯和素养，很多人都是有一定的抵触的心理，经过我私下的了解大概有以下几种原因吧。\n\n- 写单元测试太**耗费时间**了，项目要赶进度，编写单元测试会导致不能按时完成开发任务，**导致项目延期**；\n- 做*传统xx管理系统*的项目，业务逻辑比较简单，主要就是对业务数据做**增删改查**，单元测试意义和价值不高；\n- 公司有专门的测试人员，很多问题在集成测试时一定能发现。\n- 以前项目上从没写过单元测试，没有经验，不知道怎么编写单元测试；\n\n这其中对单元测试就有些误解了，单元测试有几个比较常见的典型场景：\n\n- 开发前写单元测试，通过测试描述需求，即[测试驱动开发](https://www.ibm.com/developerworks/cn/linux/l-tdd/)。\n- 在开发过程中及时得到反馈，提前规避隐患和发现问题。\n- 应用于自动化构建或持续集成流程，对每次代码修改做回归测试。\n- 作为重构的基础，验证重构是否可靠。\n\n还有最重要的一点：**编写单元测试的难易程度能够直接反应出代码的设计水平，能写出单元测试和写不出单元测试之间体现了编程能力上的巨大的鸿沟。无论是什么样的程序员，坚持编写一段时间的单元测试之后，都会明显感受到代码设计能力的巨大提升**。\n\n公司开发人员的代码质量往往不是很高，尤其是对代码的拆分和逻辑的抽象还处于懵懂阶段。要对这类代码写单测，即使是工作了3，4年的高级码农也是一个挑战，对新人来说几乎是不可能完成的任务。这也让很多开发人员有了**写单元测试很难**的感觉。所以，**写单元测试的难易程度跟代码的质量关系最大，并且是决定性的**。项目里无论用了哪个测试框架都不能解决代码本身难以测试的问题。\n\n诚然，写单元测试在开发期间的确是会耗费更多时间的，尤其是要追求很高(超过`80%`，甚至`100%`)的代码覆盖率，更是需要耗费大量心血才能达到的。对于一些只需一次交付，很少维护的项目来说，意义和价值确实不是很大。但这本质上是属于为了赚快钱，不负责任的行为了，毕竟谁都无法保障自己写的程序，真的没有丝毫问题。这个问题的出现并不是个人的问题，而是反映了公司项目管理中的问题。当然，个人的原因也存在，就是如何在有限的时间里，提高效率。\n\n目前公司的大多数项目其实都有着至少两年的维护时间的，很多开发人员都不愿意把自己的时间耗在一个代码很烂、没有单元测试保障且经常变更需求的项目里面。总之，包括我本人在内，都是有项目**维护恐惧症**的，更愿意投入到新项目的开发中。但是新项目里面还是没有单元测试的保障，代码质量逐渐低劣，如此就又形成了一个不断的循环之中。无法挣脱这个循环的人员就只能选择离职了，也许不慎又到了新的漩涡里面。\n\n> 一个 bug 被隐藏的时间越长，修复这个 bug 的代价就越大。\n\n单元测试能帮助我们在早期就规避、发现和修复很多不易察觉的 bug 和漏洞，而且更能保障后期的需求变动和代码重构时所带来的隐患，减少测试成本和维护成本。所以，在新项目中逐步推广和编写单元测试是有必要的，这将大大提高项目中代码的质量和可靠性，有些老项目中就算了吧，往往维护人员的负面情绪可能会更多，一些新的功能特性倒是可以试试。虽然写好单元测试很难，但**写单元测试的难度其实是小于决定写单元测试的勇气的**。\n\n## 二、基本概念\n\n**单元测试**：单元测试又称模块测试，属于白盒测试，是最小单位的测试。模块分为程序模块和功能模块。功能模块指实现了一个完整功能的模块（单元），一个完整的程序单元具备输入、加工和输出三个环节。而且每个程序单元都应该有正规的规格说明，使之对其输入、加工和输出的关系做出名明确的描述。\n\n**驱动测试**：驱动被测试模块正常运行起来的实体。通俗的说法就是你负责测试模块/方法是中间的，没有`main()`方法入口，怎么编译，怎么启动呢？就需要写一个带`main()`的方法来调用你的模块/方法，这个就是驱动测试。\n\n**测试桩**：代替被测模块调用的子模块的实体，该实体一般为桩函数（stub）。通俗的说法就是你负责测试的模块/方法所调用的模块/方法，所以你需要模仿他们做一个返回值（假的，但符合设计）。\n\n**测试覆盖**：评测测试过程中已经执行的代码的多少。\n\n**测试覆盖率**：代码的覆盖程度，一种度量方式。针对代码的测试覆盖率有很多种度量方式，常见的有以下几种:\n\n- 语句覆盖\n- 判定覆盖\n- 路径覆盖\n\n测试覆盖率数据到底有多大意义。主要有以下几个观点：\n\n- 路径覆盖率 > 判定覆盖 > 语句覆盖\n- 覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。\n- 不要过于相信覆盖率数据，100%的测试覆盖率并不能保证bug的不出现。\n- 代码覆盖率只是一个最基本的前提，一定要保证，但不是意味着达到指标就代表测试的完成\n- 测试人员不能盲目追求代码覆盖率，而应该想办法设计更多更好的案例，哪怕多设计出来的案例对覆盖率一点影响也没有。\n\n## 三、单元测试工具\n\n在Java中有非常多的单元测试的工具或框架可供选择，我这里只选择一些常用的、主流的单元测试框架或者工具来作介绍和使用。\n\n- [JUnit](https://junit.org/junit5/)：Java中最有名、使用最广泛的单元测试框架\n- [Mockito](http://site.mockito.org/)：模拟框架，可以让你用干净而简单的API编写测试\n- [Spring Test](https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html): 使用 Spring Test 来对Spring相关的项目做单元测试，其中会结合或者集成其他测试框架和工具\n- [spring-boot-starter-test](https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-testing): SpringBoot项目中的单元测试\n- [JaCoCo](https://www.eclemma.org/jacoco/trunk/index.html): 使用离线和运行时字节码工具来收集代码覆盖率指标的框架。\n\n### 1. JUnit4\n\nJUnit 是使用 Java 语言编写的用于编写和运行可重复的自动化测试的开源测试框架。除了 Junit 之外，[TestNg](http://testng.org/doc/)也是Java中非常受欢迎的单元测试框架。两种框架在功能上看起来非常相似，这里有一篇关于[JUnit 4 与 TestNG 的对比](https://www.mkyong.com/unittest/junit-4-vs-testng-comparison/)，还有一篇较为全面的介绍[TestNG的教程](https://www.guru99.com/all-about-testng-and-selenium.html)，总体来说，TestNG 比 Junit4 功能更强大一些，但是相比 Junit5 而言，TestNG 又落后了一代。开源的轮子滚滚向前，都是一代新的轮子超越一代老的轮子。所以，我们这里就只选择 Junit 来作单元测试框架的介绍了吧。\n\n![JUnit4 和 TestNG 的功能比较](http://static.blinkfox.com/junitvstestng.jpg)\n\n目前最新版本是 JUnit5.2.0，相比 JUnit4 而言有很大的改变，这里主要讲解 JUnit4 的使用(目前的新老项目中应该使用的更多)，并对 JUnit5 做简要介绍。学习了 Junit4 的主要使用方式之后，大家再去看[JUnit5 用户指南](http://sjyuan.cc/junit5/user-guide-cn/)在将来逐渐使用起来更好些。\n\n#### (1). 简单示例\n\n```java\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\n\npublic class CalculateTest {\n\n    @Test\n    public void testSum() {\n        Calculate calculation = new Calculate();\n        int sum = calculation.sum(2, 5);\n        int testSum = 7;\n\n        System.out.println(\"@Test sum(): \" + sum + \" = \" + testSum);\n        assertEquals(sum, testSum);\n    }\n\n}\n```\n\n#### (2). 注解\n\n- `@Test`: 测试方法，在这里还可以测试**期望异常**和**超时时间**。\n- `@Before`: 每个测试方法执行之前执行的方法。\n- `@BeforeClass`: 一个测试类中所有测试方法执行之前执行的方法，只执行一次，且方法必须为`static`的。\n- `@After`: 每个测试方法执行之后执行的方法。\n- `@AfterClass`: 一个测试类中所有测试方法执行之后执行的方法，只执行一次，且方法必须为`static`的。\n- `@Ignore`: 忽略的测试方法。\n- `@RunWith`: 指定测试类使用某个运行器。\n- `@Parameters`: 参数化测试，指定测试类的测试数据集合。\n- `@FixMethodOrder`: 注解在测试类上指定测试方法按一定顺序规则来执行，有三种。\n\n一个测试类单元测试的执行顺序为：\n\n> @BeforeClass –> @Before –> @Test –> @After –> @AfterClass\n\n每一个测试方法的执行顺序为：\n\n> @Before –> @Test –> @After\n\n综合示例：\n\n```java\nimport static org.junit.Assert.*;\nimport java.util.*;\nimport org.junit.*;\n\npublic class AnnotationsTest {\n\n    private ArrayList testList;\n\n    @BeforeClass\n    public static void onceExecutedBeforeAll() {\n        System.out.println(\"@BeforeClass: onceExecutedBeforeAll\");\n    }\n\n    @Before\n    public void executedBeforeEach() {\n        testList = new ArrayList();\n        System.out.println(\"@Before: executedBeforeEach\");\n    }\n\n    @AfterClass\n    public static void onceExecutedAfterAll() {\n        System.out.println(\"@AfterClass: onceExecutedAfterAll\");\n    }\n\n    @After\n    public void executedAfterEach() {\n        testList.clear();\n        System.out.println(\"@After: executedAfterEach\");\n    }\n\n    @Test\n    public void EmptyCollection() {\n        assertTrue(testList.isEmpty());\n        System.out.println(\"@Test: EmptyArrayList\");\n\n    }\n\n    @Test\n    public void OneItemCollection() {\n        testList.add(\"oneItem\");\n        assertEquals(1, testList.size());\n        System.out.println(\"@Test: OneItemArrayList\");\n    }\n\n    @Ignore\n    public void executionIgnored() {\n        System.out.println(\"@Ignore: This execution is ignored\");\n    }\n\n}\n```\n\n如果我们运行上面的测试，控制台输出将是以下几点：\n\n```bash\n@BeforeClass: onceExecutedBeforeAll\n@Before: executedBeforeEach\n@Test: EmptyArrayList\n@After: executedAfterEach\n@Before: executedBeforeEach\n@Test: OneItemArrayList\n@After: executedAfterEach\n@AfterClass: onceExecutedAfterAll\n```\n\n#### (3). 断言\n\n断言是编写测试用例的核心实现方式，即期望值是多少，测试的结果是多少，以此来判断测试是否通过。JUnit4.x中的断言核心方法如下：\n\n- `assertArrayEquals(expecteds, actuals)`: 查看两个数组是否相等。\n- `assertEquals(expected, actual)`: 查看两个对象是否相等。类似于字符串比较使用的equals()方法。\n- `assertNotEquals(first, second)`: 查看两个对象是否不相等。\n- `assertNull(object)`: 查看对象是否为空。\n- `assertNotNull(object)`: 查看对象是否不为空。\n- `assertSame(expected, actual)`: 查看两个对象的引用是否相等。类似于使用“==”比较两个对象。\n- `assertNotSame(unexpected, actual)`: 查看两个对象的引用是否不相等。类似于使用“!=”比较两个对象。\n- `assertTrue(condition)`: 查看运行结果是否为true。\n- `assertFalse(condition)`: 查看运行结果是否为false。\n- `assertThat(actual, matcher)`: 查看实际值是否满足指定的条件。\n- `fail()`: 让测试失败。\n\n#### (4). 套件测试\n\n测试套件意味着捆绑几个单元测试用例并且一起执行他们。在 JUnit 中，`@RunWith`和`@Suite`注释用来运行套件测试。简单示例如下：\n\n```java\npublic class TestJunit1 {\n\n   @Test\n   public void testPrint1() {\n      System.out.println(\"Test Junit 1...\");\n   }\n}\n```\n\n```java\npublic class TestJunit2 {\n\n   @Test\n   public void testPrint2() {\n      System.out.println(\"Test Junit 2...\");\n   }\n}\n```\n\n```java\n@RunWith(Suite.class)\n@Suite.SuiteClasses({\n   TestJunit1.class,\n   TestJunit2.class\n})\npublic class JunitTestSuite {\n\n}\n```\n\n#### (5). 参数化测试\n\n一个测试类也可以被看作是一个参数化测试类。但它要满足下列所有要求：\n\n- 该类被注解为`@RunWith(Parameterized.class)`。\n- 这个类有一个构造函数，存储测试数据。\n- 这个类有一个静态方法生成并返回测试数据，并注明`@Parameters`注解。\n- 这个类有一个测试，它需要注解`@Test`到方法。\n\n简单示例如下：\n\n```java\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\n@RunWith(Parameterized.class)\npublic class CalculateTest {\n\n    private int expected;\n    private int first;\n    private int second;\n\n    public CalculateTest(int expectedResult, int firstNumber, int secondNumber) {\n        this.expected = expectedResult;\n        this.first = firstNumber;\n        this.second = secondNumber;\n    }\n\n    @Parameters\n    public static Collection addedNumbers() {\n        return Arrays.asList(new Integer[][] { { 3, 1, 2 }, { 5, 2, 3 },\n                { 7, 3, 4 }, { 9, 4, 5 }, });\n    }\n\n    @Test\n    public void sum() {\n        Calculate add = new Calculate();\n        System.out.println(\"Addition with parameters : \" + first + \" and \" + second);\n        assertEquals(expected, add.sum(first, second));\n    }\n\n}\n```\n\n运行`CalculateTest`测试用例，控制台输出如下：\n\n```bash\nAddition with parameters : 1 and 2\nAdding values: 1 + 2\nAddition with parameters : 2 and 3\nAdding values: 2 + 3\nAddition with parameters : 3 and 4\nAdding values: 3 + 4\nAddition with parameters : 4 and 5\nAdding values: 4 + 5\n```\n\n#### (6). 忽略测试\n\n有时可能会发生我们的代码还没有准备好的情况，这时测试用例去测试这个方法或代码的时候会造成失败。`@Ignore`注释会在这种情况时帮助我们。\n\n- 一个含有`@Ignore`注释的测试方法将不会被执行。\n- 如果一个测试类有`@Ignore`注释，则它的测试方法将不会执行\n\n```java\npublic class JunitTest3 {\n\n    @Test\n    @Ignore(\"该测试方法还没准备好运行.\")\n    public void testHello() {\n        System.out.println(\"Hello World!\");\n    }\n\n}\n```\n\n在上面的示例中，JUnit将不会执行`testHello()`方法。\n\n#### (7). 异常测试\n\n它用于测试由方法抛出的异常。\n\n```java\nimport org.junit.*;\n\npublic class JunitTest4 {\n\n    @Test(expected = ArithmeticException.class)\n    public void testWithException() {\n      int i = 1 / 0;\n    }\n\n}\n```\n\n在上面的示例中，`testWithException()`方法将抛出`ArithmeticException`异常，因为这是一个预期的异常，因此单元测试会通过。\n\n#### (8). 超时测试\n\n**超时测试**是指，一个单元测试运行时间是否超过指定的毫秒数，测试将终止并标记为失败。\n\n```java\nimport org.junit.*;\n\npublic class JunitTest5 {\n\n    @Test(timeout = 1000)\n    public void testTimeout() {\n        while (true) {\n            // do nothing.\n        }\n    }\n\n}\n```\n\n在上面的示例中，`testTimeout()`方法将不会返回，因此JUnit引擎会将其标记为失败，并抛出一个异常。`java.lang.Exception:test timed out after 1000 milliseconds`。\n\n#### (9). Hamcrest\n\n在实际开发中，一些基本的断言，如`eqaul`, `null`, `true`它们的可读性并不是很好。而且很多时候我们要比较对象、集合、Map等数据结构。这样我们要么进行大段的字段获取再断言。或者干脆自己编写表达式并断言其结果。JUnit4.4 引入了 Hamcrest 框架，Hamcest 提供了一套匹配符 Matcher，这些匹配符更接近自然语言，可读性高，更加灵活。\n\n[Hamcrest](http://hamcrest.org/)提供了大量被称为“匹配器”的方法。其中每个匹配器都设计用于执行特定的比较操作。Hamcrest 的可扩展性很好，让你能够创建自定义的匹配器。最重要的是，JUnit 也包含了 Hamcrest 的核心，提供了对 Hamcrest 的原生支持，可以直接使用 Hamcrest。当然要使用功能齐备的Hamcrest，还是要引入对它的依赖。\n\n看个对比例子，前者使用Junit的 断言，后者使用 Hamcrest 的断言。\n\n```java\n@Test\npublic void test_with_junit_assert() {\n    int expected = 51;\n    int actual = 51;\n\n    assertEquals(\"failure - They are not same!\", expected, actual);\n}\n\n@Test\npublic void test_with_hamcrest_assertThat() {\n    int expected = 51;\n    int actual = 51;\n\n    assertThat(\"failure - They are not same!\", actual, equalTo(expected));\n}\n```\n\n```java\n// 联合匹配符not和equalTo表示“不等于”\nassertThat( something, not( equalTo( \"developer\" ) ) ); \n// 联合匹配符not和containsString表示“不包含子字符串”\nassertThat( something, not( containsString( \"Works\" ) ) ); \n// 联合匹配符anyOf和containsString表示“包含任何一个子字符串”\nassertThat(something, anyOf(containsString(\"developer\"), containsString(\"Works\")));\n\n```\n\n使用 assertThat 的优点：\n\n1. Hamcrest 一条 assertThat 即可以替代其他所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。\n2. assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活\n3. assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：`assertEquals(3, x);`），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：`assertThat(x,is(3));`），使得代码更加直观、易读。\n4. 可以将这些 Matcher 匹配符联合起来灵活使用，达到更多目的。\n\nJUnit 4.4 自带了一些 Hamcrest 的匹配符 Matcher，但是只有有限的几个，在类`org.hamcrest.CoreMatchers`中定义，要想使用他们，必须导入包 `org.hamcrest.CoreMatchers.*`。\n\nHamcrest 提供了很强大的一些api 供我们进行测试断言。\n\n```bash\n核心：\n    anything - 总是匹配,如果你不关心测试下的对象是什么是有用的\n    describedAs - 添加一个定制的失败表述装饰器\n    is - 改进可读性装饰器 - 见下 “Sugar”\n逻辑：\n    allOf - 如果所有匹配器都匹配才匹配,像Java里的&&\n    anyOf - 如果任何匹配器匹配就匹配,像Java里的||\n    not - 如果包装的匹配器不匹配器时匹配,反之亦然\n对象：\n    equalTo - 测试对象相等使用Object.equals方法\n    hasToString - 测试Object.toString方法\n    instanceOf, isCompatibleType - 测试类型\n    notNullValue, nullValue - 测试null\n    sameInstance - 测试对象实例\nBeans：\n    hasProperty - 测试JavaBeans属性\n集合：\n    array - 测试一个数组元素test an array’s elements against an array of matchers\n    hasEntry, hasKey, hasValue - 测试一个Map包含一个实体,键或者值\n    hasItem, hasItems - 测试一个集合包含一个元素\n    hasItemInArray - 测试一个数组包含一个元素\n数字：\n    closeTo - 测试浮点值接近给定的值\n    greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - 测试次序\n文本：\n    equalToIgnoringCase - 测试字符串相等忽略大小写\n    equalToIgnoringWhiteSpace - 测试字符串忽略空白\n    containsString, endsWith, startsWith - 测试字符串匹配\n```\n\n以下示例代码列举了大部分 assertThat 的使用例子，供大家学习使用时参考：\n\n```java\n//---------------- 字符相关匹配符 ----------------\n/**equalTo匹配符断言被测的testedValue等于expectedValue，\n* equalTo可以断言数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法\n*/\nassertThat(testedValue, equalTo(expectedValue));\n\n/**equalToIgnoringCase匹配符断言被测的字符串testedString\n*在忽略大小写的情况下等于expectedString\n*/\nassertThat(testedString, equalToIgnoringCase(expectedString));\n\n/**equalToIgnoringWhiteSpace匹配符断言被测的字符串testedString\n*在忽略头尾的任意个空格的情况下等于expectedString，\n*注意：字符串中的空格不能被忽略\n*/\nassertThat(testedString, equalToIgnoringWhiteSpace(expectedString);\n\n/**containsString匹配符断言被测的字符串testedString包含子字符串subString**/\nassertThat(testedString, containsString(subString));\n\n/**endsWith匹配符断言被测的字符串testedString以子字符串suffix结尾*/\nassertThat(testedString, endsWith(suffix));\n\n/**startsWith匹配符断言被测的字符串testedString以子字符串prefix开始*/\nassertThat(testedString, startsWith(prefix));\n\n// ---------------- 一般匹配符 ----------------\n/**nullValue()匹配符断言被测object的值为null*/\nassertThat(object,nullValue());\n\n/**notNullValue()匹配符断言被测object的值不为null*/\nassertThat(object,notNullValue());\n\n/**is匹配符断言被测的object等于后面给出匹配表达式*/\nassertThat(testedString, is(equalTo(expectedValue)));\n\n/**is匹配符简写应用之一，is(equalTo(x))的简写，断言testedValue等于expectedValue*/\nassertThat(testedValue, is(expectedValue));\n\n/**is匹配符简写应用之二，is(instanceOf(SomeClass.class))的简写，\n*断言testedObject为Cheddar的实例\n*/\nassertThat(testedObject, is(Cheddar.class));\n\n/**not匹配符和is匹配符正好相反，断言被测的object不等于后面给出的object*/\nassertThat(testedString, not(expectedString));\n\n/**allOf匹配符断言符合所有条件，相当于“与”（&&）*/\nassertThat(testedNumber, allOf(greaterThan(8), lessThan(16)));\n\n/**anyOf匹配符断言符合条件之一，相当于“或”（||）*/\nassertThat(testedNumber, anyOf(greaterThan(16), lessThan(8)));\n\n// ---------------- 数值相关匹配符 ----------------\n/**closeTo匹配符断言被测的浮点型数testedDouble在20.0¡À0.5范围之内*/\nassertThat(testedDouble, closeTo(20.0, 0.5));\n\n/**greaterThan匹配符断言被测的数值testedNumber大于16.0*/\nassertThat(testedNumber, greaterThan(16.0));\n\n/** lessThan匹配符断言被测的数值testedNumber小于16.0*/\nassertThat(testedNumber, lessThan (16.0));\n\n/** greaterThanOrEqualTo匹配符断言被测的数值testedNumber大于等于16.0*/\nassertThat(testedNumber, greaterThanOrEqualTo (16.0));\n\n/** lessThanOrEqualTo匹配符断言被测的testedNumber小于等于16.0*/\nassertThat(testedNumber, lessThanOrEqualTo (16.0));\n\n// ---------------- 集合相关匹配符 ----------------\n/**hasEntry匹配符断言被测的Map对象mapObject含有一个键值为\"key\"对应元素值为\"value\"的Entry项*/\nassertThat(mapObject, hasEntry(\"key\", \"value\"));\n\n/**hasItem匹配符表明被测的迭代对象iterableObject含有元素element项则测试通过*/\nassertThat(iterableObject, hasItem (element));\n\n/** hasKey匹配符断言被测的Map对象mapObject含有键值“key”*/\nassertThat(mapObject, hasKey (\"key\"));\n\n/** hasValue匹配符断言被测的Map对象mapObject含有元素值value*/\nassertThat(mapObject, hasValue(value));\n```\n\n### 2. JUnit5\n\n#### (1). Junit5简介\n\nJUnit 5 跟以前的JUnit版本不一样，它由几大不同的模块组成，这些模块分别来自三个不同的子项目。\n\n> JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage\n\n`JUnit Platform`是在JVM上 启动测试框架 的基础平台。它还定义了`TestEngine API`，该API可用于开发在平台上运行的测试框架。此外，平台还提供了一个从命令行或者 Gradle 和 Maven 插件来启动的 控制台启动器 ，它就好比一个 基于 JUnit4 的 Runner 在平台上运行任何`TestEngine`。\n\n`JUnit Jupiter`是一个组合体，它是由在JUnit 5中编写测试和扩展的新 编程模型 和 扩展模型 组成。另外，`Jupiter`子项目还提供了一个TestEngine，用于在平台上运行基于Jupiter的测试。\n\n`JUnit Vintage` 提供了一个`TestEngine`，用于在平台上运行基于JUnit 3和JUnit 4的测试。\n\nJUnit 5需要`Java 8`（或更高）的运行时环境。不过，你仍然可以测试那些由老版本JDK编译的代码。\n\n#### (2). 简单示例\n\n```java\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass FirstJUnit5Tests {\n\n    @Test\n    void myFirstTest() {\n        assertEquals(2, 1 + 1);\n    }\n\n}\n```\n\n表面上来看，使用方式和 Junit4 差别不大，但是与 JUnit4 比较起来还是有些不同的。\n\n1. 导入测试测试注解（`@Test`）和断言方法（`assertEquals`）的包路径不同。\n2. 不需要手动把测试和测试方法声明为`public`了。\n\n#### (3). 注解\n\n`JUnit Jupiter`支持使用下面表格中的注解来配置测试和扩展框架。\n\n所有的核心注解都位于`junit-jupiter-api`模块的org.junit.jupiter.api`包中。\n\n- `@Test`: 表示该方法是一个测试方法。与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖。\n- `@ParameterizedTest`: 表示该方法是一个参数化测试（可以用不同的参数多次运行试）。这样的方法会被继承，除非它们被覆盖。\n- `@RepeatedTest`: 表示该方法是一个重复测试的测试模板(让某个测试方法运行多次)。这样的方法会被继承，除非它们被覆盖。\n- `@TestFactory`: 表示该方法是一个动态测试的测试工厂。这样的方法会被继承，除非它们被覆盖。\n- `@TestInstance`: 用于配置所标注的测试类的测试实例生命周期。这些注解会被继承。\n- `@TestTemplate`: 表示该方法是一个测试模板，它会依据注册的提供者所返回的调用上下文的数量被多次调用。这样的方法会被继承，除非它们被覆盖。\n- `@DisplayName`: 为测试类或测试方法声明一个自定义的显示名称(空格、特殊字符甚至是emojis表情)。该注解不能被继承。\n- `@BeforeEach`: 表示使用了该注解的方法应该在当前类中每一个使用了`@Test`、`@RepeatedTest`、`@ParameterizedTest`或者`@TestFactory`注解的方法之前执行；类似于 JUnit4 的`@Before`。这样的方法会被继承，除非它们被覆盖。\n- `@AfterEach`: 表示使用了该注解的方法应该在当前类中每一个使用了`@Test`、`@RepeatedTest`、`@ParameterizedTest`或者`@TestFactory`注解的方法之后执行；类似于 JUnit4 的`@After`。这样的方法会被继承，除非它们被覆盖。\n- `@BeforeAll`: 表示使用了该注解的方法应该在当前类中所有使用了`@Test`、`@RepeatedTest`、`@ParameterizedTest`或者`@TestFactory`注解的方法之前执行；类似于 JUnit4 的`@BeforeClass`。这样的方法会被继承（除非它们被隐藏或覆盖），并且它必须是`static`方法（除非\"per-class\" 测试实例生命周期被使用）。\n- `@AfterAll`: 表示使用了该注解的方法应该在当前类中所有使用了`@Test`、`@RepeatedTest`、`@ParameterizedTest`或者`@TestFactory`注解的方法之后执行；类似于 JUnit4 的`@AfterClass`。这样的方法会被继承（除非它们被隐藏 或覆盖），并且它必须是`static`方法（除非\"per-class\" 测试实例生命周期被使用）。\n- `@Nested`: 表示使用了该注解的类是一个内嵌、非静态的测试类(让测试编写者能够表示出几组测试用例之间的关系)。`@BeforeAll`和@`AfterAll`方法不能直接在`@Nested`测试类中使用，（除非\"per-class\"测试实例生命周期被使用）。该注解不能被继承。\n- `@Tag`: 用于声明过滤测试的tags，该注解可以用在方法或类上；类似于`TesgNG`的测试组或 JUnit4 的分类。该注解能被继承，但仅限于类级别，而非方法级别。\n- `@Disable`: 用于禁用一个测试类或测试方法；类似于 JUnit4 的`@Ignore`。该注解不能被继承。\n- `@ExtendWith`: 用于注册自定义扩展。该注解不能被继承。\n\n>**注**：被@Test、@TestTemplate、@RepeatedTest、@BeforeAll、@AfterAll、@BeforeEach 或 @AfterEach 注解标注的方法不可以有返回值。\n\n\n在 JUnit5 中的一个测试类的基本生命周期示例如下：\n\n```java\n@DisplayName(\"Junit5的测试示例类\")\nclass LifecycleTest {\n\n    @BeforeAll\n    @DisplayName(\"资源初始化方法\")\n    static void initializeExternalResources() {\n        System.out.println(\"Initializing external resources...\");\n    }\n\n    @BeforeEach\n    void initializeMockObjects() {\n        System.out.println(\"Initializing mock objects...\");\n    }\n\n    @Test\n    void someTest() {\n        System.out.println(\"Running some test...\");\n        assertTrue(true);\n    }\n\n    @Test\n    void otherTest() {\n        assumeTrue(true);\n\n        System.out.println(\"Running another test...\");\n        assertNotEquals(1, 42, \"Why wouldn't these be the same?\");\n    }\n\n    @Test\n    @Disabled\n    @DisplayName(\"该方法先不执行.\")\n    void disabledTest() {\n        System.exit(1);\n    }\n\n    @AfterEach\n    void tearDown() {\n        System.out.println(\"Tearing down...\");\n    }\n\n    @AfterAll\n    static void freeExternalResources() {\n        System.out.println(\"Freeing external resources...\");\n    }\n\n}\n```\n\n由于 JUnit5 中的新特性很多，限于篇幅就简单介绍到这里了，如想详细了解 Junit5 的更多特性，请前往[Junit5官网](https://junit.org/junit5/)和[JUnit5用户指南中文版](http://sjyuan.cc/junit5/user-guide-cn/)去查看。\n\n### 3. Mockito\n\n在软件开发中提及**Mock**，通常理解为模拟对象。为什么需要模拟? 在我们一开始学编程时,我们所写的对象通常都是独立的，并不依赖其他的类，也不会操作别的类。但实际上，软件中是充满依赖关系的，比如我们会基于 service 业务操作类,而 service 类又是基于数据访问类(DAO)的，依次下去，形成复杂的依赖关系。\n\n单元测试的思路就是我们想在不涉及依赖关系的情况下测试代码。这种测试可以让你无视代码的依赖关系去测试代码的有效性。核心思想就是如果代码按设计正常工作，并且依赖关系也正常，那么他们应该会同时工作正常。\n\n有些时候，我们代码所需要的依赖可能尚未开发完成，甚至还不存在，那如何让我们的开发进行下去呢？使用mock可以让开发进行下去，mock技术的目的和作用就是**模拟一些在应用中不容易构造或者比较复杂的对象，从而把测试与测试边界以外的对象隔离开**。\n\n我们可以自己编写自定义的 Mock 对象实现 Mock 技术，但是编写自定义的 Mock 对象需要额外的编码工作，同时也可能引入错误。现在实现 Mock 技术的优秀开源框架有很多，[Mockito](http://site.mockito.org/)就是一个优秀的用于单元测试的 Mock 框架。\n\n除了Mockito以外，还有一些类似的框架，比如：\n\n- **[EasyMock](http://easymock.org/)**：早期比较流行的 MocK 测试框架。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。\n- **[PowerMock](https://github.com/powermock/powermock)**：这个工具是在 EasyMock 和 Mockito 上扩展出来的，目的是为了解决 EasyMock 和 Mockito 不能解决的问题（比如对`static`, `final`, `private`方法均不能 Mock）。其实测试架构设计良好的代码，一般并不需要这些功能，但如果是在已有项目上增加单元测试，老代码有问题且不能改时，就不得不使用这些功能了。\n- **[JMockit](http://jmockit.org/)**：JMockit 是一个轻量级的mock框架是用以帮助开发人员编写测试程序的一组工具和API，该项目完全基于`Java 5 SE`的 java.lang.instrument`包开发，内部使用`ASM`库来修改Java的`Bytecode`。\n- **[WireMock](http://wiremock.org/)**: 模拟您的API以进行快速、可靠和全面的测试。`WireMock`是一个基于 HTTP 的 API 的模拟器。有些人可能认为它是一个服务虚拟化工具或模拟服务器。\n\nMockito 已经被广泛应用，所以这里重点介绍 Mockito，其他的Mock框架也各自有自己的特点，大家下来自己学习或者分享，参考的[Mockito中文文档](https://github.com/hehonghui/mockito-doc-zh)在这里。\n\n下面的例子大多都会模拟一个 List，因为大多数人都熟悉它（比如`add()`，`get()`，`clear()`等方法）。实际上，请不要模拟List类，改用真实的实例。\n\n#### (1). 验证行为\n\n一旦创建，mock会记录所有交互，你可以验证所有你想要验证的东西。\n\n```java\n// 静态导入会使代码更简洁\nimport static org.mockito.Mockito.*;\n\n// 创建mock对象\nList mockedList = mock(List.class);\n\n// 使用mock对象\nmockedList.add(\"one\");\nmockedList.clear();\n\n// 验证行为\nverify(mockedList).add(\"one\");\nverify(mockedList).clear();\n```\n\nMock一旦创建，模拟对象将记住你的所有的交互。然后，您可以选择性地验证您感兴趣的任何行为。\n\n#### (2). 如何做一些测试打桩(stubbing)\n\n```java\n// 你可以mock具体的类型,不仅只是接口\nLinkedList mockedList = mock(LinkedList.class);\n\n// 测试桩\nwhen(mockedList.get(0)).thenReturn(\"first\");\nwhen(mockedList.get(1)).thenThrow(new RuntimeException());\n\n// 输出“first”\nSystem.out.println(mockedList.get(0));\n\n// 抛出异常\nSystem.out.println(mockedList.get(1));\n\n// 因为get(999) 没有打桩，因此输出null\nSystem.out.println(mockedList.get(999));\n\n// 验证get(0)被调用的次数\nverify(mockedList).get(0);\n```\n\n- 默认情况下，所有的函数都有返回值。mock函数默认返回的是null，一个空的集合或者一个被对象类型包装的内置类型，例如`0`、`false`对应的对象类型为`Integer`、`Boolean`；\n- 测试桩函数可以被覆写: 例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法；\n- 一旦测试桩函数被调用，该函数将会一致返回固定的值；\n- 上一次调用测试桩函数有时候极为重要，当你调用一个函数很多次时，最后一次调用可能是你所感兴趣的。\n\n#### (3). 参数匹配器(matchers)\n\nMockito以自然的java风格来验证参数值: 使用`equals()`函数。有时，当需要额外的灵活性时你可能需要使用参数匹配器，也就是`argument matchers`:\n\n```java\n// 使用内置的anyInt()参数匹配器\nwhen(mockedList.get(anyInt())).thenReturn(\"element\");\n\n// 使用自定义的参数匹配器( 在isValid()函数中返回你自己的匹配器实现 )\nwhen(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n\n// 输出element\nSystem.out.println(mockedList.get(999));\n\n// 你也可以验证参数匹配器\nverify(mockedList).get(anyInt());\n```\n\n参数匹配器使验证和测试桩变得更灵活。点击[这里](https://static.javadoc.io/org.mockito/mockito-core/2.18.3/org/mockito/Matchers.html)可以查看更多内置的匹配器以及自定义参数匹配器或者hamcrest 匹配器的示例。\n\n#### (4). 验证函数的确切、最少、从未调用次数\n\n```java\n// 使用模拟对象\nmockedList.add(\"once\");\n\nmockedList.add(\"twice\");\nmockedList.add(\"twice\");\n\nmockedList.add(\"three times\");\nmockedList.add(\"three times\");\nmockedList.add(\"three times\");\n\n// 下面的两个验证函数效果一样,因为verify默认验证的就是times(1)\nverify(mockedList).add(\"once\");\nverify(mockedList, times(1)).add(\"once\");\n\n// 验证具体的执行次数\nverify(mockedList, times(2)).add(\"twice\");\nverify(mockedList, times(3)).add(\"three times\");\n\n// 使用never()进行验证,never相当于times(0)\nverify(mockedList, never()).add(\"never happened\");\n\n// 使用atLeast()/atMost()\nverify(mockedList, atLeastOnce()).add(\"three times\");\nverify(mockedList, atLeast(2)).add(\"five times\");\nverify(mockedList, atMost(5)).add(\"three times\");\n```\n\n`verify`函数默认验证的是执行了`times(1)`，也就是某个测试函数是否执行了1次.因此，`times(1)`通常被省略了。\n\n#### (5). 为返回值为void的函数通过Stub抛出异常\n\n```java\ndoThrow(new RuntimeException()).when(mockedList).clear();\n\n// 调用这句代码会抛出异常\nmockedList.clear();\n```\n\n当你调用`doThrow()`, `doAnswer()`, `doNothing()`, `doReturn()` and `doCallRealMethod()` 这些函数时可以在适当的位置调用`when()`函数. 当你需要下面这些功能时这是必须的:\n\n- 测试void函数\n- 在受监控的对象上测试函数\n- 不知一次的测试为同一个函数，在测试过程中改变mock对象的行为。\n\n但是在调用`when()`函数时你可以选择是否调用这些上述这些函数。\n\n#### (6). 验证执行执行顺序\n\n```java\n// A. 验证mock一个对象的函数执行顺序\n// 创建Mock对象\nList singleMock = mock(List.class);\n\n// 使用mock对象\nsingleMock.add(\"was added first\");\nsingleMock.add(\"was added second\");\n\n// 为该mock对象创建一个inOrder对象\nInOrder inOrder = inOrder(singleMock);\n\n// 确保add函数首先执行的是add(\"was added first\"),然后才是add(\"was added second\")\ninOrder.verify(singleMock).add(\"was added first\");\ninOrder.verify(singleMock).add(\"was added second\");\n\n// B .验证多个mock对象的函数执行顺序\nList firstMock = mock(List.class);\nList secondMock = mock(List.class);\n\n// 使用mock对象\nfirstMock.add(\"was called first\");\nsecondMock.add(\"was called second\");\n\n// 为这两个Mock对象创建inOrder对象\nInOrder inOrder = inOrder(firstMock, secondMock);\n\n// 验证它们的执行顺序\ninOrder.verify(firstMock).add(\"was called first\");\ninOrder.verify(secondMock).add(\"was called second\");\n```\n\n验证执行顺序是非常灵活的。你不需要一个一个的验证所有交互,只需要验证你感兴趣的对象即可。另外，你可以仅通过那些需要验证顺序的mock对象来创建`InOrder`对象。\n\n#### (7). 确保交互(interaction)操作不会执行在mock对象上\n\n```java\n// 使用Mock对象\nmockOne.add(\"one\");\n\n// 普通验证\nverify(mockOne).add(\"one\");\n\n// 验证某个交互是否从未被执行\nverify(mockOne, never()).add(\"two\");\n\n// 验证mock对象没有交互过\nverifyZeroInteractions(mockTwo, mockThree);\n```\n\n#### (8). 查找冗余的调用\n\n```java\n// 使用mock对象\nmockedList.add(\"one\");\nmockedList.add(\"two\");\n\nverify(mockedList).add(\"one\");\n\n// 下面的验证将会失败\nverifyNoMoreInteractions(mockedList);\n```\n\n一些用户可能会在频繁地使用`verifyNoMoreInteractions()`，甚至在每个测试函数中都用。但是`verifyNoMoreInteractions()`并不建议在每个测试函数中都使用。`verifyNoMoreInteractions()`在交互测试套件中只是一个便利的验证，它的作用是当你需要验证是否存在冗余调用时。滥用它将导致测试代码的可维护性降低。你可以阅读这篇文档来了解更多相关信息。\n\n#### (9). 简化mock对象的创建\n\n- 最小化重复的创建代码;\n- 使测试类的代码可读性更高;\n- 使验证错误更易于阅读，因为字段名可用于标识mock对象;\n\n```java\npublic class ArticleManagerTest {\n\n   @Mock private ArticleCalculator calculator;\n   @Mock private ArticleDatabase database;\n   @Mock private UserProvider userProvider;\n\n   private ArticleManager manager;\n```\n\n注意！下面这句代码需要在运行测试函数之前被调用,一般放到测试类的基类或者test runner中:\n\n```java\nMockitoAnnotations.initMocks(testClass);\n```\n\n关于mock注解的更多信息可以阅读[MockitoAnnotations文档](https://static.javadoc.io/org.mockito/mockito-core/2.18.3/org/mockito/MockitoAnnotations.html)。\n\n#### (10). 为连续的调用做测试打桩 (stub)\n\n有时我们需要为同一个函数调用的不同的返回值或异常做测试桩。\n\n```java\nwhen(mock.someMethod(\"some arg\"))\n    .thenThrow(new RuntimeException())\n    .thenReturn(\"foo\");\n\n// 第一次调用 : 抛出运行时异常\nmock.someMethod(\"some arg\");\n\n// 第二次调用 : 输出\"foo\"\nSystem.out.println(mock.someMethod(\"some arg\"));\n\n// 后续调用 : 也是输出\"foo\"\nSystem.out.println(mock.someMethod(\"some arg\"));\n```\n\n另外，连续调用的另一种更简短的版本 :\n\n```java\n// 第一次调用时返回\"one\",第二次返回\"two\",第三次返回\"three\"\nwhen(mock.someMethod(\"some arg\"))\n    .thenReturn(\"one\", \"two\", \"three\");\n```\n\n#### (11). 为回调做测试桩\n\n```java\nwhen(mock.someMethod(anyString())).thenAnswer(new Answer() {\n     Object answer(InvocationOnMock invocation) {\n         Object[] args = invocation.getArguments();\n         Object mock = invocation.getMock();\n         return \"called with arguments: \" + args;\n     }\n});\n\n// 输出 : \"called with arguments: foo\"\nSystem.out.println(mock.someMethod(\"foo\"));\n```\n\n#### (12). 监控真实对象\n\n你可以为真实对象创建一个监控(spy)对象。当你使用这个`spy`对象时真实的对象也会也调用，除非它的函数被stub了。**尽量少使用spy对象**，使用时也需要小心形式，例如spy对象可以用来处理遗留代码。\n\n```java\nList list = new LinkedList();\nList spy = spy(list);\n\n// 你可以为某些函数打桩\nwhen(spy.size()).thenReturn(100);\n\n// 通过spy对象调用真实对象的函数\nspy.add(\"one\");\nspy.add(\"two\");\n\n// 输出第一个元素\nSystem.out.println(spy.get(0));\n\n// 因为size()函数被打桩了,因此这里返回的是100\nSystem.out.println(spy.size());\n\n// 交互验证\nverify(spy).add(\"one\");\nverify(spy).add(\"two\");\n```\n\nMockito 并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互，不要期望从监控对象得到正确的结果。当你在监控对象上调用一个没有被stub的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果。\n\n因此结论就是: 当你在监控一个真实对象时，你想在stub这个真实对象的函数，那么就是在自找麻烦。或者你根本不应该验证这些函数。\n\n#### (13). 重置mocks对象\n\n聪明的 Mockito 使用者很少会用到这个特性，因为他们知道这是出现糟糕测试单元的信号。通常情况下你不会需要重设你的测试单元，只需要为每一个测试方法重新创建一个测试单元就可以了。\n\n如果你真的想通过`reset()`方法满足某些需求的话，请考虑实现简单，小而且专注于测试方法而不是冗长，精确的测试。首先可能出现的代码异味就是测试方法中间那的`reset()`方法。这可能意味着你已经过度测试了。\n\n添加 reset() 方法的唯一原因就是让它能与容器注入的测试单元协作。\n\n```java\nList mock = mock(List.class);\nwhen(mock.size()).thenReturn(10);\nmock.add(1);\n\nreset(mock);\n//at this point the mock forgot any interactions & stubbing\n```\n\n#### (14). 更多的注解\n\n- `@Captor`: 创建`ArgumentCaptor`。\n- `@Spy`: 可以代替`spy(Object)`。\n- `@InjectMocks`: 如果此注解声明的变量需要用到mock对象，mockito会自动注入mock或spy成员。\n\n```java\n//可以这样写\n@Spy\nBeerDrinker drinker = new BeerDrinker();\n\n//也可以这样写，mockito会自动实例化drinker.\n@Spy\nBeerDrinker drinker;\n\n//会自动实例化LocalPub\n@InjectMocks\nLocalPub pub;\n```\n\n#### (15). BDD 风格的验证(Since 1.10.0)\n\n开启`Behavior Driven Development`(BDD，即行为驱动开发)风格的验证可以通过`BBD`的关键词`then`开始验证。\n\n```java\ngiven(dog.bark()).willReturn(2);\n\n// when\n...\n\nthen(person).should(times(2)).ride(bike);\n```\n\n以上就是 Mockito 的主要使用方式，关于更详细的介绍可参考[Mockito官方文档](https://static.javadoc.io/org.mockito/mockito-core/2.18.3/org/mockito/Mockito.html)和[Mockito中文文档](https://github.com/hehonghui/mockito-doc-zh)。\n\n### 4. Spring Test\n\n目前几乎大多数 Java web 项目都是有基于 Spring 来开发的。通过 Spring 进行 bean 管理后，仅仅通过 JUnit 来做测试会有各种麻烦，比如：Spring容器初始化问题、使用硬编码方式手工获取Bean、不方便对数据操作的正确性做检查等。这时我们就可以通过 Spring 全家桶中的另一位成员**spring-test**来帮助我们在 Spring 工程中做单元测试了。以下通过简单的示例来演示其使用。\n\n#### (1). 加入依赖包\n\n通过Maven加入`JUnit`、`spring-test`的Jar包(最好其他Spring包版本一致)。\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>xxxx</version>\n    <scope>test</scope>\n</dependency>\n```\n\n#### (2). 创建测试类\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"/application-context-test.xml\")\npublic class UserDaoTest {\n\n    /** 自动注入baseDao,默认按名称. */\n    @Resource\n    private IBaseDao baseDao;\n\n    @Test\n    @Transactional\n    @Rollback\n    public void insert() {\n        String sql = \"INSERT INTO t_user(c_name, c_password) values(?, ?)\";\n        Object[] objs = new Object[]{\"zhangsan\", \"123456\"};\n        baseDao.insert(sql , objs);\n\n        String sql2 = \"SELECT * FROM t_user WHERE c_name = ? and c_password = ?\";\n        List<Map<String,Object>> list = baseDao.queryForList(sql1, objs);\n        assertTrue(list.size() > 0);\n        System.out.println(list);\n    }\n\n}\n```\n\n- 使用Spring Test 可以使用`@Autowired`自动注入相关的bean信息，而不需要自己手动通过`getBean`去获取相应的bean信息。\n- 使用Spring Test 测试，可以`@Transaction`注解，表示该方法使用spring的事务，在单元测试中，执行完毕后默认会回滚。\n- 使用`@Rollback`注解，标明使用完此方法后事务回滚，可以`@Rollback(false)`这个注解来使对数据库操作的测试结果不回滚。\n\n#### (3). 对 Spring MVC 的测试\n\n为了测试 web 项目，需要一些 Servlet 相关的模拟对象，比如：`MockMVC`/`MockHttpServletRequest`/`MockHttpServletResponse`/`MockHttpSession`。使用示例如下：\n\n```java\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.forwardedUrl;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.model;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.mock.web.MockHttpServletRequest;\nimport org.springframework.mock.web.MockHttpSession;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.test.context.web.WebAppConfiguration;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\nimport org.springframework.web.context.WebApplicationContext;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"/application-context-test.xml\")\n@WebAppConfiguration(\"src/main/resources\") // 此注解指定web资源的位置，默认为src/main/webapp\npublic class TestControllerIntegrationTests {\n\n    private MockMvc mockMvc; // 模拟MVC对象\n\n    @Autowired\n    private DemoService demoService;// 在测试用例注入spring的bean\n\n    @Autowired\n    WebApplicationContext wac; // 注入WebApplicationContext\n\n    @Autowired\n    MockHttpSession session; // 注入模拟的http session\n\n    @Autowired\n    MockHttpServletRequest request; // 模拟request\n\n    @Before // 测试开始前的初始化工作\n    public void setup() {\n        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(); //2\n    }\n\n    @Test\n    public void testNormalController() throws Exception{\n        String exp_str = demoService.saySomething(); // expect str\n        mockMvc.perform(get(\"/normal\")) // 模拟GET /normal\n            .andExpect(status().isOk())// 预期返回状态为200\n            .andExpect(view().name(\"page\"))// 预期view的名称\n            .andExpect(forwardedUrl(\"/WEB-INF/classes/views/page.jsp\"))// 预期页面转向的真正路径\n            .andExpect(model().attribute(\"msg\", exp_str));// 预期model里的值\n    }\n\n    @Test\n    public void testRestController() throws Exception{\n        mockMvc.perform(get(\"/testRest\")) // HTTP GET 方法\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(\"text/plain;charset=UTF-8\"))//14\n            .andExpect(content().string(demoService.saySomething()));//15\n    }\n}\n```\n\n> **注**: `demoService`及相关方法的调用，也可以通过`Mockito`工具Mock出来，更符合单元测试对**单元性**的要求，否则这些测试又额外附带了一定集成测试的性质了。\n\n### 4. spring-boot-starter-test\n\n#### (1). 简单介绍\n\n现在越来越多的应用都采用SpringBoot的方式来构建，在SpringBoot应用中单元测试变得更加容易了，只需要加入`spring-boot-starter-test`的 Starter 即可，其中默认导入了 Spring Boot 测试模块以及`JUnit`，`AssertJ`，`Hamcrest`和其他一些有用的库。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n`spring-boot-starter-test`的 Starter (Scope为test)，包括了以下提供的类库：\n\n- [JUnit](https://junit.org/)：单元测试Java应用程序的事实标准。\n- [Spring Test](https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/testing.html#integration-testing) 和 Spring Boot Test：Spring Boot应用程序的实用程序和集成测试支持。\n- [AssertJ](https://joel-costigliola.github.io/assertj/)：流畅的断言库。\n- [Hamcrest](http://hamcrest.org/JavaHamcrest/)：匹配器对象库。\n- [Mockito](http://mockito.org/)：Java Mock 框架。\n- [JSONassert](https://github.com/skyscreamer/JSONassert)：JSON的断言库。\n- [JsonPath](JsonPath)：JSON的XPath。\n\n我们通常在编写测试时发现这些通用库都是比较有用的。如果这些库还不适合您的需求，您还可以添加您自己的附加测试依赖库。\n\nSpring Boot 提供了一个`@SpringBootTest`注释，当您需要 Spring Boot 功能时，它可以用作标准 spring-test `@ContextConfiguration`注释的替代方法。注解的工作原理是通过`SpringApplication`创建用于测试的`ApplicationContext`。除了`@SpringBootTest`之外，还提供了许多其他注释来测试应用程序的更具体的切片。\n\n> **提示**：不要忘记在测试中添加`@RunWith(SpringRunner.class)`，否则注释将被忽略。\n\n#### (2). 一个简单示例\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class UserServiceTest {\n\n    @Value(\"${msg}\")\n    private String msg;\n\n    @Autowired\n    private UserService userService;\n\n    @Test\n    public void getUser() {\n        User user = userService.selectByKey(20180302325L);\n        Assert.assertThat(user.getName(), is(\"Blinkfox\"));\n        System.out.println(\"获取的配置信息为:\" + msg);\n    }\n}\n```\n\n上面就是最简单的单元测试写法，测试类上只需要`@RunWith(SpringRunner.class)`和`@SpringBootTest`两个注解即可测试任何类和方法。\n\n#### (3). web模块的单元测试\n\n要测试 Spring MVC 控制器是否按预期工作，请使用`@WebMvcTest`注释。`@WebMvcTest`自动配置`Spring MVC`基础结构，并将扫描的bean限制为`@Controller`，`@ControllerAdvice`，`@JsonComponent`，`Converter`，`GenericConverter`，`Filter`，`WebMvcConfigurer`和`HandlerMethodArgumentResolver`。 使用此注释时，不会扫描常规的`@Component` bean。\n\n您还可以使用`@AutoConfigureMockMvc`对其进行注释，从而在非`@WebMvcTest`（如`@SpringBootTest`）中自动配置`MockMvc`。 以下示例使用MockMvc：\n\n```java\n@RunWith(SpringRunner.class)\n@WebMvcTest(UserVehicleController.class)\npublic class MyControllerTests {\n\n    @Autowired\n    private MockMvc mvc;\n\n    @MockBean\n    private UserVehicleService userVehicleService;\n\n    @Test\n    public void testExample() throws Exception {\n        given(this.userVehicleService.getVehicleDetails(\"sboot\"))\n                .willReturn(new VehicleDetails(\"Honda\", \"Civic\"));\n        this.mvc.perform(get(\"/sboot/vehicle\").accept(MediaType.TEXT_PLAIN))\n                .andExpect(status().isOk()).andExpect(content().string(\"Honda Civic\"));\n    }\n\n}\n```\n\nSpringBoot对各种单元测试的场景支持的比较全，更多的示例可直接在[Spiring Boot Test 官方指南](https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-testing)中去查看，这里就不再一一列举了。\n\n### 5. JaCoCo\n\n在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，比如，代码覆盖率必须达到80％或 90％。\n目前Java常用覆盖率工具[clover](https://www.atlassian.com/software/clover)、[Jacoco](http://www.eclemma.org/jacoco/)和[Cobertura](https://cobertura.github.io/cobertura/)等。关于这些代码覆盖率工具的对比可参看[这里](https://confluence.atlassian.com/clover/comparison-of-code-coverage-tools-681706101.html?_ga=2.7075890.1253300005.1526228675-143716968.1468426926)。这里我们就选取 Jacoco 来作为代码覆盖率工具来做介绍。\n\nJacoco 是一个开源的覆盖率工具。Jacoco 可以嵌入到Ant 、Maven中，并提供了 Eclipse、IDEA 插件,也可以使用Java Agent技术监控Java程序。很多第三方的工具提供了对 Jacoco 的集成，如sonar、Jenkins。\n\nJacoco与Maven的集成很简单，只需要在plugins中添加如下插件即可。\n\n```xml\n<plugin>\n    <groupId>org.jacoco</groupId>\n    <artifactId>jacoco-maven-plugin</artifactId>\n    <version>0.7.7.201606060606</version>\n    <configuration>\n        <destFile>target/coverage-reports/jacoco-unit.exec</destFile>\n        <dataFile>target/coverage-reports/jacoco-unit.exec</dataFile>\n    </configuration>\n    <executions>\n        <execution>\n            <id>jacoco-initialize</id>\n            <goals>\n                <goal>prepare-agent</goal>\n            </goals>\n        </execution>\n        <execution>\n            <id>jacoco-site</id>\n            <phase>package</phase>\n            <goals>\n                <goal>report</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n做单元测试时，测试覆盖率是不是越高代表代码质量越好呢？Martin Fowler（重构那本书的作者）曾经写过一篇博客来讨论这个问题，他指出：**把测试覆盖作为质量目标没有任何意义，而我们应该把它作为一种发现未被测试覆盖的代码的手段**。\n\n所以，代码覆盖率统计是用来发现没有被测试覆盖的代码；代码覆盖率统计不能完全用来衡量代码质量。\n\n---\n\n参考资料\n\n- [单元测试大揭密](https://blog.csdn.net/vincetest/article/details/1378507)\n- [JUnit教程](https://www.yiibai.com/junit/)\n- [JUnit5用户指南中文版](http://sjyuan.cc/junit5/user-guide-cn/)\n- [Mockito中文文档](https://blog.csdn.net/bboyfeiyu/article/details/52127551)\n- [单元测试准则](https://github.com/yangyubo/zh-unit-testing-guidelines/blob/master/readme.rst)","tags":["Java","单元测试"],"categories":["后端"]},{"title":"Java8新特性及使用(二)","url":"/2018/111427877.html","content":"\n## 扩展注解的支持\n\nJava 8扩展了注解的上下文。**现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解**。下面演示几个例子：\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class Annotations {\n\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target({ ElementType.TYPE_USE, ElementType.TYPE_PARAMETER })\n    public @interface NonEmpty {\n    }\n\n    public static class Holder<@NonEmpty T> extends @NonEmpty Object {\n        public void method() throws @NonEmpty Exception {\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    public static void main(String[] args) {\n        final Holder<String> holder = new @NonEmpty Holder<String>();\n        @NonEmpty Collection<@NonEmpty String> strings = new ArrayList<>();\n    }\n\n}\n```\n\n## Base64\n\n在Java 8中，Base64编码已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：\n\n```java\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class Base64s {\n\n    public static void main(String[] args) {\n        final String text = \"Base64 finally in Java 8!\";\n\n        final String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));\n        System.out.println(encoded);\n\n        final String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);\n        System.out.println(decoded);\n    }\n\n}\n```\n\n程序在控制台上输出了编码后的字符与解码后的字符：\n\n```bash\nQmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==\nBase64 finally in Java 8!\n```\n\nBase64类同时还提供了对URL、MIME友好的编码器与解码器（`Base64.getUrlEncoder() / Base64.getUrlDecoder()`, `Base64.getMimeEncoder() / Base64.getMimeDecoder()`）。\n\n## JavaFX\n\n`JavaFX`是一个强大的图形和多媒体处理工具包集合，它允许开发者来设计、创建、测试、调试和部署富客户端程序，并且和Java一样跨平台。从Java8开始，JavaFx已经内置到了JDK中。关于JavaFx更详细的文档可参考[JavaFX中文文档](http://www.javafxchina.net/blog/docs/)。\n\n## 其它\n\n### 1. JDBC4.2规范\n\nJDBC4.2主要有以下几点改动：\n\n- 增加了对`REF Cursor`的支持\n- 修改返回值大小范围（update count）\n- 增加了`java.sql.DriverAction`接口\n- 增加了`java.sql.SQLType`接口\n- 增加了`java.sql.JDBCtype`枚举\n- 对`java.time`包时间类型的支持\n\n### 2. 更好的类型推测机制\n\nJava 8在类型推测方面有了很大的提高。在很多情况下，编译器可以推测出确定的参数类型，这样就能使代码更整洁。让我们看一个例子：\n\n```java\npublic class Value<T> {\n\n    public static<T> T defaultValue() {\n        return null;\n    }\n\n    public T getOrDefault(T value, T defaultValue) {\n        return (value != null) ? value : defaultValue;\n    }\n\n}\n```\n\n这里是`Value<String>`类型的用法。\n\n```java\npublic class TypeInference {\n\n    public static void main(String[] args) {\n        final Value<String> value = new Value<>();\n        value.getOrDefault(\"22\", Value.defaultValue());\n    }\n\n}\n```\n\n`Value.defaultValue()`的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是`Value.<String>defaultValue()`。\n\n### 3. HashMap性能提升\n\nJava8中，HashMap内部实现又引入了红黑树，使得HashMap的总体性能相较于Java7有比较明显的提升。以下是对Hash均匀和不均匀的情况下的性能对比\n\n#### (1). Hash较均匀的情况\n\n![Hash较均匀时的性能对比](https://images2017.cnblogs.com/blog/647994/201801/647994-20180105204924753-361068557.png)\n\n#### (2). Hash极不均匀的情况\n\n![Hash极不均匀时的性能对比](https://images2017.cnblogs.com/blog/647994/201801/647994-20180105205031643-1765887276.png)\n\n### 4. IO/NIO 的改进\n\nJava8 对`IO/NIO`也做了一些改进。主要包括：改进了`java.nio.charset.Charset`的实现，使编码和解码的效率得以提升，也精简了`jre/lib/charsets.jar`包；优化了`String(byte[], *)`构造方法和`String.getBytes()`方法的性能；还增加了一些新的`IO/NIO`方法，使用这些方法可以从文件或者输入流中获取流（`java.util.stream.Stream`），通过对流的操作，可以简化文本行处理、目录遍历和文件查找。\n\n新增的 API 如下：\n\n- `BufferedReader.line()`: 返回文本行的流`Stream<String>`\n- `File.lines(Path, Charset)`: 返回文本行的流`Stream<String>`\n- `File.list(Path)`: 遍历当前目录下的文件和目录\n- `File.walk(Path, int, FileVisitOption)`: 遍历某一个目录下的所有文件和指定深度的子目录\n- `File.find(Path, int, BiPredicate, FileVisitOption...)`: 查找相应的文件\n\n下面就是用流式操作列出当前目录下的所有文件和目录：\n\n```java\nFiles.list(new File(\".\").toPath()).forEach(System.out::println);\n```\n\n### 5. JavaScript引擎Nashorn\n\nJava 8提供了一个新的`Nashorn javascript`引擎，它允许我们在JVM上运行特定的javascript应用。Nashorn javascript引擎只是`javax.script.ScriptEngine`另一个实现，而且规则也一样，允许Java和JavaScript互相操作。这里有个小例子：\n\n```java\nScriptEngineManager manager = new ScriptEngineManager();\nScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n\nSystem.out.println(engine.getClass().getName());\nSystem.out.println(\"Result:\" + engine.eval(\"function f(){return 1;}; f() + 1;\"));\n```\n\n输出如下：\n\n```bash\njdk.nashorn.api.scripting.NashornScriptEngine\nResult: 2\n```\n\n### 6. 并发（Concurrency）\n\n在新增`Stream`机制与`Lambda`的基础之上，在`java.util.concurrent.ConcurrentHashMap`中加入了一些新方法来支持聚集操作。同时也在`java.util.concurrent.ForkJoinPool`类中加入了一些新方法来支持共有资源池（common pool）（请查看我们关于Java 并发的免费课程）。\n\n新增的`java.util.concurrent.locks.StampedLock`类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的`java.util.concurrent.locks.ReadWriteLock`类的替代者）。\n\n在`java.util.concurrent.atomic`包中还增加了下面这些类：\n\n- DoubleAccumulator\n- DoubleAdder\n- LongAccumulator\n- LongAdder\n\n### 7. 类依赖分析器jdeps\n\n`Jdeps`是一个功能强大的命令行工具，它可以帮我们显示出包层级或者类层级java类文件的依赖关系。它接受class文件、目录、jar文件作为输入，默认情况下，`jdeps`会输出到控制台。\n\n作为例子，让我们看看现在很流行的Spring框架的库的依赖关系报告。为了让报告短一些，我们只分析一个jar: `org.springframework.core-3.0.5.RELEASE.jar`.\n\n`jdeps org.springframework.core-3.0.5.RELEASE.jar`这个命令输出内容很多，我们只看其中的一部分，这些依赖关系根绝包来分组，如果依赖关系在classpath里找不到，就会显示not found.\n\n```bash\nC:\\Program Files\\Java\\jdk1.8.0\\jre\\lib\\rt.jar\n   org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar)\n      -> java.io\n      -> java.lang\n      -> java.lang.annotation\n      -> java.lang.ref\n      -> java.lang.reflect\n      -> java.util\n      -> java.util.concurrent\n      -> org.apache.commons.logging                         not found\n      -> org.springframework.asm                            not found\n      -> org.springframework.asm.commons                    not found\n   org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar)\n      -> java.lang\n      -> java.lang.annotation\n      -> java.lang.reflect\n      -> java.util\n```\n\n### 8. JVM的PermGen空间被移除\n\n`PermGen`空间被移除了，取而代之的是`Metaspace（JEP 122）`。JVM选项`-XX:PermSize`与`-XX:MaxPermSize`分别被`-XX:MetaSpaceSize`与`-XX:MaxMetaspaceSize`所代替。\n\n---\n\n参考文档：\n\n- [What's New in JDK 8](http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html)\n- [Java 8新特性终极指南](http://www.importnew.com/11908.html)","tags":["Java"],"categories":["后端"]},{"title":"Java8新特性及使用(一)","url":"/2018/111344097.html","content":"\n## 新特性列表\n\n以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考[这里](http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html)。\n\n- 接口默认方法和静态方法\n- Lambda 表达式\n- 函数式接口\n- 方法引用\n- Stream\n- Optional\n- Date/Time API\n- 重复注解\n- 扩展注解的支持\n- Base64\n- JavaFX\n- 其它\n  - JDBC4.2规范\n  - 更好的类型推测机制\n  - HashMap性能提升\n  - IO/NIO 的改进\n  - JavaScript引擎Nashorn\n  - 并发（Concurrency）\n  - 类依赖分析器jdeps\n  - JVM的PermGen空间被移除\n\n## 一、接口默认方法和静态方法\n\nJava 8用默认方法与静态方法这两个新概念来扩展接口的声明。与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。\n\n### 1. 接口默认方法\n\n默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：\n\n```java\nprivate interface Defaulable {\n    // Interfaces now allow default methods, the implementer may or\n    // may not implement (override) them.\n    default String notRequired() {\n        return \"Default implementation\";\n    }\n}\n\nprivate static class DefaultableImpl implements Defaulable {\n}\n\nprivate static class OverridableImpl implements Defaulable {\n    @Override\n    public String notRequired() {\n        return \"Overridden implementation\";\n    }\n}\n```\n\n`Defaulable`接口用关键字`default`声明了一个默认方法`notRequired()`，`Defaulable`接口的实现者之一`DefaultableImpl`实现了这个接口，并且让默认方法保持原样。`Defaulable`接口的另一个实现者`OverridableImpl`用自己的方法覆盖了默认方法。\n\n#### (1). 多重继承的冲突说明\n\n由于同一个方法可以从不同的接口引入，自然而然的会有冲突的现象，规则如下：\n\n- 一个声明在类里面的方法优先于任何默认方法\n- 优先选取最具体的实现\n\n```java\npublic interface A {\n\n    default void hello() {\n        System.out.println(\"Hello A\");\n    }\n\n}\n```\n\n```java\npublic interface B extends A {\n\n    default void hello() {\n        System.out.println(\"Hello B\");\n    }\n\n}\n```\n\n```java\npublic class C implements A, B {\n\n    public static void main(String[] args) {\n        new C().hello(); // 输出 Hello B\n    }\n\n}\n```\n\n#### (2). 优缺点\n\n- **优点**: 可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。\n- **缺点**: 使得**接口作为协议，类作为具体实现**的界限开始变得有点模糊。\n\n#### (3). 接口默认方法不能重载Object类的任何方法\n\n**接口不能提供对Object类的任何方法的默认实现**。简单地讲，每一个java类都是Object的子类，也都继承了它类中的`equals()`/`hashCode()`/`toString()`方法，那么在类的接口上包含这些默认方法是没有意义的，它们也从来不会被编译。\n\n在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到`java.util.Collection`接口中去：`stream()`，`parallelStream()`，`forEach()`，`removeIf()`等。尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法。\n\n### 2. 接口静态方法\n\nJava 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。在接口中定义静态方法，使用`static`关键字，例如：\n\n```java\npublic interface StaticInterface {\n\n    static void method() {\n        System.out.println(\"这是Java8接口中的静态方法!\");\n    }\n\n}\n```\n\n下面的一小段代码是上面静态方法的使用。\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        StaticInterface.method(); // 输出 这是Java8接口中的静态方法!\n    }\n\n}\n```\n\nJava支持一个实现类可以实现多个接口，如果多个接口中存在同样的`static`方法会怎么样呢？如果有两个接口中的静态方法一模一样，并且一个实现类同时实现了这两个接口，此时并不会产生错误，因为Java8中只能通过接口类调用接口中的静态方法，所以对编译器来说是可以区分的。\n\n二、Lambda 表达式\n\n`Lambda`表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：**行为参数化**，函数作为参数传递进方法中）。\n\n一个`Lambda`可以由用逗号分隔的参数列表、`–>`符号与函数体三部分表示。\n\n首先看看在老版本的Java中是如何排列字符串的：\n\n```java\nList<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\nCollections.sort(names, new Comparator<String>() {\n\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n\n});\n```\n\n只需要给静态方法`Collections.sort`传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。\n在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：\n\n```java\nCollections.sort(names, (String a, String b) -> {\n    return b.compareTo(a);\n});\n```\n\n看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：\n\n```java\nCollections.sort(names, (String a, String b) -> b.compareTo(a));\n```\n\n对于函数体只有一行代码的，你可以去掉大括号`{}`以及`return`关键字，但是你还可以写得更短点：\n\n```java\nCollections.sort(names, (a, b) -> b.compareTo(a));\n```\n\nJava编译器可以自动推导出参数类型，所以你可以不用再写一次类型。\n\n## 三、函数式接口\n\n`Lambda`表达式是如何在Java的类型系统中表示的呢？每一个Lambda表达式都对应一个类型，通常是接口类型。而**函数式接口**是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。因为**默认方法**不算抽象方法，所以你也可以给你的函数式接口添加默认方法。\n\n我们可以将Lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加`@FunctionalInterface`注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。\n\n示例如下：\n\n```java\n@FunctionalInterface\ninterface Converter<F, T> {\n    T convert(F from);\n}\n\nConverter<String, Integer> converter = (from) -> Integer.valueOf(from);\nInteger converted = converter.convert(\"123\");\nSystem.out.println(converted); // 123\n```\n\n> **注**：如果`@FunctionalInterface`如果没有指定，上面的代码也是对的。\n\nJava8 API包含了很多内建的函数式接口，在老Java中常用到的比如`Comparator`或者`Runnable`接口，这些接口都增加了`@FunctionalInterface`注解以便能用在`Lambda`上。\n\nJava8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。\n\n### 1. Comparator (比较器接口)\n\n`Comparator`是老Java中的经典接口， Java 8在此之上添加了多种默认方法。源代码及使用示例如下:\n\n```java\n@FunctionalInterface\npublic interface Comparator<T> {\n\n    int compare(T o1, T o2);\n\n}\n```\n\n```java\nComparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);\nPerson p1 = new Person(\"John\", \"Doe\");\nPerson p2 = new Person(\"Alice\", \"Wonderland\");\ncomparator.compare(p1, p2);             // > 0\ncomparator.reversed().compare(p1, p2);  // < 0\n```\n\n### 2. Consumer (消费型接口)\n\n`Consumer`接口表示执行在单个参数上的操作。源代码及使用示例如下:\n\n```java\n@FunctionalInterface\npublic interface Consumer<T> {\n\n    void accept(T t);\n\n}\n```\n\n```java\nConsumer<Person> greeter = (p) -> System.out.println(\"Hello, \" + p.firstName);\ngreeter.accept(new Person(\"Luke\", \"Skywalker\"));\n```\n\n#### 更多的Consumer接口\n\n- `BiConsumer：void accept(T t, U u);`: 接受两个参数的二元函数\n- `DoubleConsumer：void accept(double value);`: 接受一个double参数的一元函数\n- `IntConsumer：void accept(int value);`: 接受一个int参数的一元函数\n- `LongConsumer：void accept(long value);`: 接受一个long参数的一元函数\n- `ObjDoubleConsumer：void accept(T t, double value);`: 接受一个泛型参数一个double参数的二元函数\n- `ObjIntConsumer：void accept(T t, int value);`: 接受一个泛型参数一个int参数的二元函数\n- `ObjLongConsumer：void accept(T t, long value);`: 接受一个泛型参数一个long参数的二元函数\n\n### 3. Supplier (供应型接口)\n\n`Supplier`接口是不需要参数并返回一个任意范型的值。其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同Consumer相反，是一个只声明了返回值，不需要参数的函数。也就是说Supplier其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力，因为我们常见的场景中不止是要consume（Consumer）或者是简单的map（Function），还包括了new这个动作。而Supplier就表达了这种能力。源代码及使用示例如下:\n\n```java\n@FunctionalInterface\npublic interface Supplier<T> {\n\n    T get();\n}\n```\n\n```java\nSupplier<Person> personSupplier = Person::new;\npersonSupplier.get();   // new Person\n```\n\n#### 更多Supplier接口\n\n- `BooleanSupplier：boolean getAsBoolean();`: 返回boolean的无参函数\n- `DoubleSupplier：double getAsDouble();`: 返回double的无参函数\n- `IntSupplier：int getAsInt();`: 返回int的无参函数\n- `LongSupplier：long getAsLong();`: 返回long的无参函数\n\n### 4. Predicate (断言型接口)\n\n`Predicate`接口只有一个参数，返回`boolean`类型。该接口包含多种默认方法来将`Predicate`组合成其他复杂的逻辑（比如：**与**，**或**，**非**）。`Stream`的`filter`方法就是接受`Predicate`作为入参的。这个具体在后面使用`Stream`的时候再分析深入。源代码及使用示例如下:\n\n```java\n@FunctionalInterface\npublic interface Predicate<T> {\n\n    boolean test(T t);\n\n}\n```\n\n```java\nPredicate<String> predicate = (s) -> s.length() > 0;\npredicate.test(\"foo\");            // true\npredicate.negate().test(\"foo\");     // false\nPredicate<Boolean> nonNull = Objects::nonNull;\nPredicate<Boolean> isNull = Objects::isNull;\nPredicate<String> isEmpty = String::isEmpty;\nPredicate<String> isNotEmpty = isEmpty.negate();\n```\n\n#### 更多的Predicate接口\n\n- `BiPredicate：boolean test(T t, U u);`: 接受两个参数的二元断言函数\n- `DoublePredicate：boolean test(double value);`: 入参为double的断言函数\n- `IntPredicate：boolean test(int value);`: 入参为int的断言函数\n- `LongPredicate：boolean test(long value);`: 入参为long的断言函数\n\n### 5. Function (功能型接口)\n\n`Function`接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（`compose`, `andThen`）。源代码及使用示例如下:\n\n```java\n@FunctionalInterface\npublic interface Function<T, R> {\n\n    R apply(T t);\n\n}\n```\n\n```java\nFunction<String, Integer> toInteger = Integer::valueOf;\nFunction<String, String> backToString = toInteger.andThen(String::valueOf);\nbackToString.apply(\"123\");     // \"123\"\n```\n\n#### 更多的Function接口\n\n- `BiFunction ：R apply(T t, U u);`: 接受两个参数，返回一个值，代表一个二元函数；\n- `DoubleFunction ：R apply(double value);`: 只处理double类型的一元函数；\n- `IntFunction ：R apply(int value);`: 只处理int参数的一元函数；\n- `LongFunction ：R apply(long value);`: 只处理long参数的一元函数；\n- `ToDoubleFunction：double applyAsDouble(T value);`: 返回double的一元函数；\n- `ToDoubleBiFunction：double applyAsDouble(T t, U u);`: 返回double的二元函数；\n- `ToIntFunction：int applyAsInt(T value);`: 返回int的一元函数；\n- `ToIntBiFunction：int applyAsInt(T t, U u);`: 返回int的二元函数；\n- `ToLongFunction：long applyAsLong(T value);`: 返回long的一元函数；\n- `ToLongBiFunction：long applyAsLong(T t, U u);`: 返回long的二元函数；\n- `DoubleToIntFunction：int applyAsInt(double value);`: 接受double返回int的一元函数；\n- `DoubleToLongFunction：long applyAsLong(double value);`: 接受double返回long的一元函数；\n- `IntToDoubleFunction：double applyAsDouble(int value);`: 接受int返回double的一元函数；\n- `IntToLongFunction：long applyAsLong(int value);`: 接受int返回long的一元函数；\n- `LongToDoubleFunction：double applyAsDouble(long value);`: 接受long返回double的一元函数；\n- `LongToIntFunction：int applyAsInt(long value);`: 接受long返回int的一元函数；\n\n### 6. Operator\n\n`Operator`其实就是`Function`，函数有时候也叫作算子。算子在Java8中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。算子Operator包括：`UnaryOperator`和`BinaryOperator`。分别对应单（一）元算子和二元算子。\n\n算子的接口声明如下：\n\n```java\n@FunctionalInterface\npublic interface UnaryOperator<T> extends Function<T, T> {\n\n    static <T> UnaryOperator<T> identity() {\n        return t -> t;\n    }\n}\n```\n\n```java\n@FunctionalInterface\npublic interface BinaryOperator<T> extends BiFunction<T,T,T> {\n\n    public static <T> BinaryOperator<T> minBy(Comparator<? super T> comparator) {\n        Objects.requireNonNull(comparator);\n        return (a, b) -> comparator.compare(a, b) <= 0 ? a : b;\n    }\n\n    public static <T> BinaryOperator<T> maxBy(Comparator<? super T> comparator) {\n        Objects.requireNonNull(comparator);\n        return (a, b) -> comparator.compare(a, b) >= 0 ? a : b;\n    }\n}\n```\n\n`Operator`只需声明一个泛型参数T即可。对应的使用示例如下：\n\n```java\nUnaryOperator<Integer> increment = x -> x + 1;\nSystem.out.println(\"递增:\" + increment.apply(2)); // 输出 递增:3\n\nBinaryOperator<Integer> add = (x, y) -> x + y;\nSystem.out.println(\"相加:\" + add.apply(2, 3)); // 输出 相加:5\n\nBinaryOperator<Integer> min = BinaryOperator.minBy((o1, o2) -> o1 - o2);\nSystem.out.println(\"最小值:\" + min.apply(2, 3)); // 输出 最小值:2\n```\n\n#### 更多的Operator接口\n\n- `LongUnaryOperator：long applyAsLong(long operand);`: 对long类型做操作的一元算子\n- `IntUnaryOperator：int applyAsInt(int operand);`: 对int类型做操作的一元算子\n- `DoubleUnaryOperator：double applyAsDouble(double operand);`: 对double类型做操作的一元算子\n- `DoubleBinaryOperator：double applyAsDouble(double left, double right);`: 对double类型做操作的二元算子\n- `IntBinaryOperator：int applyAsInt(int left, int right);`: 对int类型做操作的二元算子\n- `LongBinaryOperator：long applyAsLong(long left, long right);`: 对long类型做操作的二元算子\n\n### 6. 其它函数式接口\n\n- java.lang.Runnable\n- java.util.concurrent.Callable\n- java.security.PrivilegedAction\n- java.io.FileFilter\n- java.nio.file.PathMatcher \n- java.lang.reflect.InvocationHandler\n- java.beans.PropertyChangeListener\n- java.awt.event.ActionListener  \n- javax.swing.event.ChangeListener\n\n## 四、方法引用\n\n### 1. 概述\n\n在学习了Lambda表达式之后，我们通常使用Lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：\n\n```java\nArrays.sort(strArray, (s1, s2) -> s1.compareToIgnoreCase(s2));\n```\n\n在Java8中，我们可以直接通过方法引用来简写Lambda表达式中已经存在的方法。\n\n```java\nArrays.sort(strArray, String::compareToIgnoreCase);\n```\n\n这种特性就叫做**方法引用**(`Method Reference`)。\n\n**方法引用**是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。\n\n> **注意**: 方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号`::`。\n\n### 2. 分类\n\n方法引用的标准形式是：`类名::方法名`。（注意：只需要写方法名，不需要写括号）\n\n有以下四种形式的方法引用：\n\n- 引用静态方法: ContainingClass::staticMethodName\n- 引用某个对象的实例方法: containingObject::instanceMethodName\n- 引用某个类型的任意对象的实例方法:ContainingType::methodName\n- 引用构造方法: ClassName::new\n\n### 3. 示例\n\n使用示例如下：\n\n```java\npublic class Person {\n\n    String name;\n\n    LocalDate birthday;\n\n    public Person(String name, LocalDate birthday) {\n        this.name = name;\n        this.birthday = birthday;\n    }\n\n    public LocalDate getBirthday() {\n        return birthday;\n    }\n\n    public static int compareByAge(Person a, Person b) {\n        return a.birthday.compareTo(b.birthday);\n    }\n\n    @Override\n    public String toString() {\n        return this.name;\n    }\n}\n```\n\n```java\npublic class MethodReferenceTest {\n\n    @Test\n    public static void main() {\n        Person[] pArr = new Person[] {\n            new Person(\"003\", LocalDate.of(2016,9,1)),\n            new Person(\"001\", LocalDate.of(2016,2,1)),\n            new Person(\"002\", LocalDate.of(2016,3,1)),\n            new Person(\"004\", LocalDate.of(2016,12,1))\n        };\n\n        // 使用匿名类\n        Arrays.sort(pArr, new Comparator<Person>() {\n            @Override\n            public int compare(Person a, Person b) {\n                return a.getBirthday().compareTo(b.getBirthday());\n            }\n        });\n\n        //使用lambda表达式\n        Arrays.sort(pArr, (Person a, Person b) -> {\n            return a.getBirthday().compareTo(b.getBirthday());\n        });\n\n        //使用方法引用，引用的是类的静态方法\n        Arrays.sort(pArr, Person::compareByAge);\n    }\n\n}\n```\n\n## 五、Stream\n\nJava8添加的`Stream API(java.util.stream)`把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为`Stream API`可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\n\n流可以是无限的、有状态的，可以是顺序的，也可以是并行的。在使用流的时候，你首先需要从一些来源中获取一个流，执行一个或者多个中间操作，然后执行一个最终操作。中间操作包括`filter`、`map`、`flatMap`、`peel`、`distinct`、`sorted`、`limit`和`substream`。终止操作包括`forEach`、`toArray`、`reduce`、`collect`、`min`、`max`、`count`、`anyMatch`、`allMatch`、`noneMatch`、`findFirst`和`findAny`。 `java.util.stream.Collectors`是一个非常有用的实用类。该类实现了很多归约操作，例如将流转换成集合和聚合元素。\n\n### 1. 一些重要方法说明\n\n- `stream`: 返回数据流，集合作为其源\n- `parallelStream`: 返回并行数据流， 集合作为其源\n- `filter`: 方法用于过滤出满足条件的元素\n- `map`: 方法用于映射每个元素对应的结果\n- `forEach`: 方法遍历该流中的每个元素\n- `limit`: 方法用于减少流的大小\n- `sorted`: 方法用来对流中的元素进行排序\n- `anyMatch`: 是否存在任意一个元素满足条件（返回布尔值）\n- `allMatch`: 是否所有元素都满足条件（返回布尔值）\n- `noneMatch`: 是否所有元素都不满足条件（返回布尔值）\n- `collect`: 方法是终端操作，这是通常出现在管道传输操作结束标记流的结束\n\n### 2. 一些使用示例\n\n#### (1). Filter 过滤\n\n```java\nstringCollection\n    .stream()\n    .filter((s) -> s.startsWith(\"a\"))\n    .forEach(System.out::println);\n```\n\n### (2). Sort 排序\n\n```java\nstringCollection\n    .stream()\n    .sorted()\n    .filter((s) -> s.startsWith(\"a\"))\n    .forEach(System.out::println);\n```\n\n### (3). Map 映射\n\n```java\nstringCollection\n    .stream()\n    .map(String::toUpperCase)\n    .sorted((a, b) -> b.compareTo(a))\n    .forEach(System.out::println);\n```\n\n### (4). Match 匹配\n\n```java\nboolean anyStartsWithA = stringCollection\n        .stream()\n        .anyMatch((s) -> s.startsWith(\"a\"));\nSystem.out.println(anyStartsWithA);      // true\n\nboolean allStartsWithA = stringCollection\n        .stream()\n        .allMatch((s) -> s.startsWith(\"a\"));\nSystem.out.println(allStartsWithA);      // false\n\nboolean noneStartsWithZ = stringCollection\n        .stream()\n        .noneMatch((s) -> s.startsWith(\"z\"));\nSystem.out.println(noneStartsWithZ);      // true\n```\n\n### (5). Count 计数\n\n```java\nlong startsWithB = stringCollection\n        .stream()\n        .filter((s) -> s.startsWith(\"b\"))\n        .count();\nSystem.out.println(startsWithB);    // 3\n```\n\n### (6). Reduce 规约\n\n这是一个最终操作，允许通过指定的函数来将`stream`中的多个元素规约为一个元素，规越后的结果是通过`Optional`接口表示的。代码如下:\n\n```java\nOptional<String> reduced = stringCollection\n        .stream()\n        .sorted()\n        .reduce((s1, s2) -> s1 + \"#\" + s2);\nreduced.ifPresent(System.out::println);\n```\n\n## 六、Optional\n\n到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的`Guava`项目引入了`Optional`类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，`Optional`类已经成为Java 8类库的一部分。\n\n`Optional`实际上是个容器：它可以保存类型T的值，或者仅仅保存null。`Optional`提供很多有用的方法，这样我们就不用显式进行空值检测。\n\n我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。\n\n```java\nOptional<String> fullName = Optional.ofNullable(null);\nSystem.out.println(\"Full Name is set? \" + fullName.isPresent());\nSystem.out.println(\"Full Name: \" + fullName.orElseGet(() -> \"[none]\"));\nSystem.out.println(fullName.map(s -> \"Hey \" + s + \"!\").orElse(\"Hey Stranger!\"));\n```\n\n如果`Optional`类的实例为非空值的话，`isPresent()`返回`true`，否从返回`false`。为了防止Optional为空值，`orElseGet()`方法通过回调函数来产生一个默认值。`map()`函数对当前`Optional`的值进行转化，然后返回一个新的`Optional`实例。`orElse()`方法和`orElseGet()`方法类似，但是`orElse`接受一个默认值而不是一个回调函数。下面是这个程序的输出：\n\n```bash\nFull Name is set? false\nFull Name: [none]\nHey Stranger!\n```\n\n让我们来看看另一个例子：\n\n```java\nOptional<String> firstName = Optional.of(\"Tom\");\nSystem.out.println(\"First Name is set? \" + firstName.isPresent());\nSystem.out.println(\"First Name: \" + firstName.orElseGet(() -> \"[none]\"));\nSystem.out.println(firstName.map(s -> \"Hey \" + s + \"!\").orElse(\"Hey Stranger!\"));\nSystem.out.println();\n```\n\n下面是程序的输出：\n\n```bash\nFirst Name is set? true\nFirst Name: Tom\nHey Tom!\n```\n\n## 七、Date/Time API\n\nJava 8 在包`java.time`下包含了一组全新的时间日期API。新的日期API和开源的`Joda-Time`库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：\n\n### 1. Clock 时钟\n\n`Clock`类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代`System.currentTimeMillis()`来获取当前的微秒数。某一个特定的时间点也可以使用`Instant`类来表示，`Instant`类也可以用来创建老的`java.util.Date`对象。代码如下:\n\n```java\nClock clock = Clock.systemDefaultZone();\nlong millis = clock.millis();\nInstant instant = clock.instant();\nDate legacyDate = Date.from(instant);   // legacy java.util.Date\n```\n\n### 2. Timezones 时区\n\n在新API中时区使用`ZoneId`来表示。时区可以很方便的使用静态方法`of`来获取到。时区定义了到UTS时间的时间差，在`Instant`时间点对象到本地日期对象之间转换的时候是极其重要的。代码如下:\n\n```java\nSystem.out.println(ZoneId.getAvailableZoneIds());\n// prints all available timezone ids\nZoneId zone1 = ZoneId.of(\"Europe/Berlin\");\nZoneId zone2 = ZoneId.of(\"Brazil/East\");\nSystem.out.println(zone1.getRules());\nSystem.out.println(zone2.getRules());\n// ZoneRules[currentStandardOffset=+01:00]\n// ZoneRules[currentStandardOffset=-03:00]\n```\n\n### 3. LocalTime 本地时间\n\n`LocalTime`定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差。代码如下:\n\n```java\nLocalTime now1 = LocalTime.now(zone1);\nLocalTime now2 = LocalTime.now(zone2);\nSystem.out.println(now1.isBefore(now2));  // false\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\nSystem.out.println(hoursBetween);       // -3\nSystem.out.println(minutesBetween);     // -239\n```\n\n`LocalTime`提供了多种工厂方法来简化对象的创建，包括解析时间字符串。代码如下:\n\n```java\nLocalTime late = LocalTime.of(23, 59, 59);\nSystem.out.println(late);       // 23:59:59\nDateTimeFormatter germanFormatter = DateTimeFormatter\n        .ofLocalizedTime(FormatStyle.SHORT)\n        .withLocale(Locale.GERMAN);\nLocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);\nSystem.out.println(leetTime);   // 13:37\n```\n\n### 4. LocalDate 本地日期\n\n`LocalDate`表示了一个确切的日期，比如`2014-03-11`。该对象值是不可变的，用起来和`LocalTime`基本一致。下面的例子展示了如何给`Date`对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。代码如下:\n\n```java\nLocalDate today = LocalDate.now();\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\nLocalDate yesterday = tomorrow.minusDays(2);\nLocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\n\nSystem.out.println(dayOfWeek);    // FRIDAY\n```\n\n从字符串解析一个LocalDate类型和解析LocalTime一样简单。代码如下:\n\n```java\nDateTimeFormatter germanFormatter = DateTimeFormatter\n        .ofLocalizedDate(FormatStyle.MEDIUM)\n        .withLocale(Locale.GERMAN);\nLocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter);\nSystem.out.println(xmas);   // 2014-12-24\n```\n\n### 5. LocalDateTime 本地日期时间\n\n`LocalDateTime`同时表示了时间和日期，相当于前两节内容合并到一个对象上了。`LocalDateTime`和`LocalTime`还有`LocalDate`一样，都是不可变的。`LocalDateTime`提供了一些能访问具体字段的方法。代码如下:\n\n```java\nLocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\nSystem.out.println(dayOfWeek);      // WEDNESDAY\nMonth month = sylvester.getMonth();\nSystem.out.println(month);          // DECEMBER\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\nSystem.out.println(minuteOfDay);    // 1439\n```\n\n只要附加上时区信息，就可以将其转换为一个时间点`Instant`对象，`Instant`时间点对象可以很容易的转换为老式的`java.util.Date`。代码如下:\n\n```java\nInstant instant = sylvester\n        .atZone(ZoneId.systemDefault())\n        .toInstant();\nDate legacyDate = Date.from(instant);\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n```\n\n格式化`LocalDateTime`和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式。代码如下:\n\n```java\nDateTimeFormatter formatter =\n    DateTimeFormatter\n        .ofPattern(\"MMM dd, yyyy - HH:mm\");\nLocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);\nString string = formatter.format(parsed);\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\n```\n\n和`java.text.NumberFormat`不一样的是新版的`DateTimeFormatter`是不可变的，所以它是线程安全的。\n\n关于Java8中日期API更多的使用示例可以参考[Java 8中关于日期和时间API的20个使用示例](http://blinkfox.com/java-8zhong-guan-yu-ri-qi-he-shi-jian-apide-20ge-shi-yong-shi-li/)。\n\n## 八、重复注解\n\n自从Java 5引入了注解机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。\n\n重复注解机制本身必须用`@Repeatable`注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\npublic class RepeatingAnnotations {\n\n    @Target(ElementType.TYPE)\n    @Retention(RetentionPolicy.RUNTIME)\n    public @interface Filters {\n        Filter[] value();\n    }\n\n    @Target(ElementType.TYPE)\n    @Retention(RetentionPolicy.RUNTIME)\n    @Repeatable(Filters.class)\n    public @interface Filter {\n        String value();\n    };\n\n    @Filter(\"filter1\")\n    @Filter(\"filter2\")\n    public interface Filterable {\n    }\n\n    public static void main(String[] args) {\n        for(Filter filter: Filterable.class.getAnnotationsByType(Filter.class)) {\n            System.out.println(filter.value());\n        }\n    }\n\n}\n```\n\n正如我们看到的，这里有个使用`@Repeatable(Filters.class)`注解的注解类`Filter`，`Filters`仅仅是`Filter`注解的数组，但Java编译器并不想让程序员意识到`Filters`的存在。这样，接口`Filterable`就拥有了两次`Filter`（并没有提到`Filter`）注解。\n\n同时，反射相关的API提供了新的函数`getAnnotationsByType()`来返回重复注解的类型（请注意`Filterable.class.getAnnotation(Filters.class`)`经编译器处理后将会返回Filters的实例）。","tags":["Java"],"categories":["后端"]},{"title":"Java7新特性及使用","url":"/2018/111238926.html","content":"\n## 新特性列表\n\n以下是Java7中的引入的部分新特性。关于Java7更详细的介绍可参考[这里](http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html)。\n\n- switch支持String\n- try-with-resources\n- catch多个异常\n- 实例创建类型推断\n- 数字字面量下划线分割\n- 二进制字面量\n- 增强的文件系统\n- Fork/Join框架\n- 其它\n  - JDBC4.1规范\n  - 支持动态类型语言\n  - JSR341-Expression Language Specification\n  - JSR203-More New I/O APIs for the Java Platform\n  - 桌面客户端增强\n\n## 一、switch支持String\n\n`switch`现在可以接受`String`类型的参数。示例代码如下：\n\n```java\nString s = ...\nswitch(s) {\ncase \"quux\":\n    processQuux(s);\n// fall-through\ncase \"foo\":\ncase \"bar\":\n    processFooOrBar(s);\n    break;\ncase \"baz\":\n    processBaz(s);\n    // fall-through\ndefault:\n    processDefault(s);\n    break;\n}\n```\n\n## 二、try-with-resources\n\nJava中某些资源是需要手动关闭的，如`InputStream`，`Writer`，`Sockets`，`Connection`等。这个新的语言特性允许try语句本身申请更多的资源，这些资源作用于try代码块，并自动关闭。\n\nJava7之前的写法：\n\n```java\nBufferedReader br = null;\ntry {\n    br = new BufferedReader(new FileReader(path));\n    return br.readLine();\n} catch (Exception e) {\n    log.error(\"BufferedReader Exception\", e);\n} finally {\n    if (br != null) {\n        try {\n            br.close();\n        } catch (Exception e) {\n            log.error(\"BufferedReader close Exception\", e);\n        }\n    }\n}\n```\n\nJava7及之后的写法：\n\n```java\ntry (BufferedReader br = new BufferedReader(new FileReader(path)) {\n    return br.readLine();\n} catch (Exception e) {\n    log.error(\"BufferedReader Exception\", e);\n}\n```\n\n## 三、catch多个异常\n\n自Java7开始，`catch`中可以一次性捕捉多个异常做统一处理。示例如下：\n\nJava7之前的写法：\n\n```java\npublic void handle() {\n    ExceptionThrower thrower = new ExceptionThrower();\n    try {\n        thrower.manyExceptions();\n    } catch (ExceptionA a) {\n        System.out.println(a.getClass());\n    } catch (ExceptionB b) {\n        System.out.println(b.getClass());\n    } catch (ExceptionC c) {\n        System.out.println(c.getClass());\n    }\n}\n```\n\nJava7及之后的写法：\n\n```java\npublic void handle() {\n    ExceptionThrower thrower = new ExceptionThrower();\n    try {\n        thrower.manyExceptions();\n    } catch (ExceptionA | ExceptionB ab) {\n        System.out.println(ab.getClass());\n    } catch (ExceptionC c) {\n        System.out.println(c.getClass());\n    }\n}\n```\n\n## 四、实例创建类型推断\n\n从Java7开始，泛型类的实例化也不用繁琐的将泛型声明再写一遍。示例如下：\n\nJava7之前的写法：\n\n```java\nMap<String, List<String>> map = new HashMap<String, List<String>>();\n```\n\nJava7及之后的写法：\n\n```java\nMap<String, List<String>> map = new HashMap<>();\n```\n\n## 五、数字字面量下划线分割\n\n很长的数字可读性不好，在Java 7中可以使用下划线分隔长`int`以及`long`型整数了。如：\n\n```java\nlong creditCardNumber = 1234_5678_9012_3456L;\npublic static final int ONE_MILLION = 1_000_000;\npublic static final float PI = 3.14_15F;\n```\n\n## 六、二进制字面量\n\n现在可以使用0b前缀创建二进制字面量：\n\n```java\nint binary = 0b1001_1001;\n```\n\n使用二进制字面量这种表示方式，使用非常简短的代码就可将二进制字符转换为数据类型，如在`byte`或`short`。\n\n```java\nbyte aByte = (byte) 0b001;\nshort aShort = (short) 0b010;\n```\n\n## 七、增强的文件系统\n\nJava7 推出了全新的`NIO2.0 API`以此改变针对文件管理的不便，使得在`java.nio.file`包下使用`Path`、`Paths`、`Files`、`WatchService`、`FileSystem`等常用类型可以很好的简化开发人员对文件管理的编码工作。\n\n### 1. Path接口和Paths类\n\n`Path`接口的某些功能其实可以和`java.io`包下的`File`类等价，当然这些功能仅限于只读操作。在实际开发过程中，开发人员可以联用`Path`接口和`Paths`类，从而获取文件的一系列上下文信息。\n\n- `int getNameCount()`: 获取当前文件节点数\n- `Path getFileName()`: 获取当前文件名称\n- `Path getRoot()`: 获取当前文件根目录\n- `Path getParent()`: 获取当前文件上级关联目录\n\n联用`Path`接口和`Paths`类型获取文件信息：\n\n```java\nPath path = Paths.get(\"G:/test/test.xml\");\nSystem.out.println(\"文件节点数:\" + path.getNameCount());\nSystem.out.println(\"文件名称:\" + path.getFileName());\nSystem.out.println(\"文件根目录:\" + path.getRoot());\nSystem.out.println(\"文件上级关联目录:\" + path.getParent());\n```\n\n### 2. Files类\n\n联用`Path`接口和`Paths`类可以很方便的访问到目标文件的上下文信息。当然这些操作全都是只读的，如果开发人员想对文件进行其它非只读操作，比如文件的创建、修改、删除等操作，则可以使用`Files`类型进行操作。\n\nFiles类型常用方法如下：\n\n- `Path createFile()`: 在指定的目标目录创建新文件\n- `void delete()`: 删除指定目标路径的文件或文件夹\n- `Path copy()`: 将指定目标路径的文件拷贝到另一个文件中\n- `Path move()`: 将指定目标路径的文件转移到其他路径下，并删除源文件\n\n使用`Files`类型复制、粘贴文件示例：\n\n```java\nFiles.copy(Paths.get(\"/test/src.xml\"), Paths.get(\"/test/target.xml\"));\n```\n\n使用`Files`类型来管理文件，相对于传统的I/O方式来说更加方便和简单。因为具体的操作实现将全部移交给`NIO2.0 API`，开发人员则无需关注。\n\n### 3. WatchService\n\nJava7 还为开发人员提供了一套全新的文件系统功能，那就是文件监测。在此或许有很多朋友并不知晓文件监测有何意义及目，那么请大家回想下调试成热发布功能后的Web容器。当项目迭代后并重新部署时，开发人员无需对其进行手动重启，因为Web容器一旦监测到文件发生改变后，便会自动去适应这些“变化”并重新进行内部装载。Web容器的热发布功能同样也是基于文件监测功能，所以不得不承认，文件监测功能的出现对于Java文件系统来说是具有重大意义的。\n\n文件监测是基于事件驱动的，事件触发是作为监测的先决条件。开发人员可以使用`java.nio.file`包下的`StandardWatchEventKinds`类型提供的3种字面常量来定义监测事件类型，值得注意的是监测事件需要和`WatchService`实例一起进行注册。\n\n`StandardWatchEventKinds`类型提供的监测事件：\n\n- `ENTRY_CREATE`：文件或文件夹新建事件；\n- `ENTRY_DELETE`：文件或文件夹删除事件；\n- `ENTRY_MODIFY`：文件或文件夹粘贴事件；\n\n使用`WatchService`类实现文件监控完整示例：\n\n```java\npublic static void testWatch() {\n    /* 监控目标路径 */\n    Path path = Paths.get(\"G:/\");\n    try {\n        /* 创建文件监控对象. */\n        WatchService watchService = FileSystems.getDefault().newWatchService();\n\n        /* 注册文件监控的所有事件类型. */\n        path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE,\n                StandardWatchEventKinds.ENTRY_MODIFY);\n\n        /* 循环监测文件. */\n        while (true) {\n            WatchKey watchKey = watchService.take();\n\n            /* 迭代触发事件的所有文件 */\n            for (WatchEvent<?> event : watchKey.pollEvents()) {\n                System.out.println(event.context().toString() + \" 事件类型：\" + event.kind());\n            }\n\n            if (!watchKey.reset()) {\n                return;\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n通过上述程序示例我们可以看出，使用`WatchService`接口进行文件监控非常简单和方便。首先我们需要定义好目标监控路径，然后调用`FileSystems`类型的`newWatchService()`方法创建`WatchService`对象。接下来我们还需使用`Path`接口的`register()`方法注册`WatchService`实例及监控事件。当这些基础作业层全部准备好后，我们再编写外围实时监测循环。最后迭代`WatchKey`来获取所有触发监控事件的文件即可。\n\n## 八、Fork/Join框架\n\n### 1. 什么是Fork/Join框架\n\nJava7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。\n\nFork/Join的运行流程图如下：\n\n![Fork/Join的运行流程图](https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png)\n\n### 2. 工作窃取算法\n\n工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：\n\n![工作窃取的运行流程图](https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png)\n\n工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。\n\n### 3. Fork/Join框架的介绍\n\n设计一个Fork/Join框架，主要有以下两步骤：\n\n第一步分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。\n\n第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。\n\nFork/Join使用两个类来完成以上两件事情：\n\nForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：\nRecursiveAction：用于没有返回结果的任务。\nRecursiveTask ：用于有返回结果的任务。\nForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。\n\n### 4. Fork/Join框架使用示例\n\n让我们通过一个简单的需求来使用下`Fork／Join`框架，需求是：计算`1 + 2 + 3 + 4`的结果。\n\n使用`Fork/Join`框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是`2`，由于是`4`个数字相加，所以`Fork/Join`框架会把这个任务`fork`成两个子任务，子任务一负责计算`1 + 2`，子任务二负责计算`3 + 4`，然后再`join`两个子任务的结果。\n\n因为是有结果的任务，所以必须继承`RecursiveTask`，实现代码如下：\n\n```java\npackage com.blinkfox.test.other;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RecursiveTask;\n\n/**\n * CountTask.\n *\n * @author blinkfox on 2018-01-03.\n */\npublic class CountTask extends RecursiveTask<Integer> {\n\n    /** 阈值. */\n    public static final int THRESHOLD = 2;\n\n    /** 计算的开始值. */\n    private int start;\n\n    /** 计算的结束值. */\n    private int end;\n\n    /**\n     * 构造方法.\n     *\n     * @param start 计算的开始值\n     * @param end 计算的结束值\n     */\n    public CountTask(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    /**\n     * 执行计算的方法.\n     *\n     * @return int型结果\n     */\n    @Override\n    protected Integer compute() {\n        int sum = 0;\n\n        // 如果任务足够小就计算任务.\n        if ((end - start) <= THRESHOLD) {\n            for (int i = start; i <= end; i++) {\n                sum += i;\n            }\n        } else {\n            // 如果任务大于阈值，就分裂成两个子任务来计算.\n            int middle = (start + end) / 2;\n            CountTask leftTask = new CountTask(start, middle);\n            CountTask rightTask = new CountTask(middle + 1, end);\n\n            // 等待子任务执行完，并得到结果，再合并执行结果.\n            leftTask.fork();\n            rightTask.fork();\n            sum = leftTask.join() + rightTask.join();\n        }\n        return sum;\n    }\n\n    /**\n     * main方法.\n     *\n     * @param args 数组参数\n     */\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ForkJoinPool fkPool = new ForkJoinPool();\n        CountTask task = new CountTask(1, 4);\n        Future<Integer> result = fkPool.submit(task);\n        System.out.println(\"result:\" + result.get());\n    }\n\n}\n```\n\n## 九、其它\n\n### 1. JDBC4.1规范\n\nJDBC4.1主要更新了两个新特性，分别是：\n\n#### (1). Connection，ResultSet 和 Statement 都实现了Closeable 接口\n\n`Connection`，`ResultSet`和`Statement`都实现了`Closeable`接口，所有在`try-with-resources`语句中调用，就可以自动关闭相关资源了。\n\n#### (2). RowSet 1.1\n\n引入`RowSetFactory`接口和`RowSetProvider`类，可以创建JDBC driver支持的各种`Rowsets。\n\n```java\nRowSetFactory myRowSetFactory = null;\nJdbcRowSet jdbcRs = null;\nResultSet rs = null;\nStatement stmt = null;\n\ntry {\n  myRowSetFactory = RowSetProvider.newFactory();//用缺省的RowSetFactory 实现\n  jdbcRs = myRowSetFactory.createJdbcRowSet();\n\n  //创建一个 JdbcRowSet 对象，配置数据库连接属性\n  jdbcRs.setUrl(\"jdbc:myDriver:myAttribute\");\n  jdbcRs.setUsername(username);\n  jdbcRs.setPassword(password);\n\n  jdbcRs.setCommand(\"select ID from TEST\");\n  jdbcRs.execute();\n}\n```\n\n`RowSetFactory`接口包括了创建不同类型的RowSet的方法：\n\n- createCachedRowSet\n- createFilteredRowSet\n- createJdbcRowSet\n- createJoinRowSet\n- createWebRowSet\n\n### 2. 略\n\n---\n\n参考文档：\n\n- [JavaSE7 Features and Enhancements](http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html)\n- [Java7的新特性](https://segmentfault.com/a/1190000004417830)\n- [Fork/Join框架介绍](http://www.infoq.com/cn/articles/fork-join-introduction)","tags":["Java"],"categories":["后端"]},{"title":"Java6新特性及使用","url":"/2018/111125651.html","content":"\n## 新特性列表\n\n以下是Java6中的引入的部分新特性，相比Java5的新特性就少了很多了。关于Java6更详细的介绍可参考[这里](http://www.oracle.com/technetwork/java/javase/features-141434.html)。\n\n- Web Services Metadata\n- Scripting\n- Compiler API\n- Light-weight HTTP server\n- Common annotations(JSR 250)\n- StAX\n- JAXB2\n- Console\n- Java DB(Derby)\n- JDBC 4.0\n- 值得关注的\n  - 集合框架增强\n- 其它\n  - GUI增强\n\n## 一、Web Services Metadata\n\n`WebService`是一种独立于特定语言、特定平台，基于网络的、分布式的模块化组件。是一个能够使用`xml`消息通过网络来访问的接口，这个接口描述了一组可访问的操作。在Java6中，在想要发布为`WebService`的类上加上`@WebService`的注解，这个类的方法就变为`WebService`方法了，再通过`Endpoint.publish()`方法发布这个服务。到此，一个最简单的`WebService`搞定。运行`main`方法，在浏览器里输入`http://localhost:8080/com.blinkfox.test.Hello?wsdl`，即可查看你WebService的WSDL信息。\n\n```java\nimport javax.jws.WebService;\nimport javax.xml.ws.Endpoint;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Hello.\n * @author blinkfox on 2017-11-28.\n */\n@WebService\npublic class Hello {\n\n    private static final Logger log = LoggerFactory.getLogger(Hello.class);\n\n    /**\n     * sayHello.\n     * @param name 名称\n     * @return 结果\n     */\n    public String sayHello(String name) {\n        return \"Hello \".concat(name);\n    }\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        Endpoint.publish(\"http://localhost:8080/com.blinkfox.test.Hello\", new Hello());\n        log.info(\"调用成功!\");\n    }\n\n}\n```\n\nJava 自从JDK5中添加了元数据功能(注解)之后,SUN几乎重构了整个J2EE体系，由于变化很大，干脆将名字也重构为Java EE，Java EE(当前版本为5.0)将元数据纳入很多规范当中，这其中就包括`Web Services`的相关规范，这显然比以前的JAX-RPC编程模型简单(当然, Axis的编程模型也很简单)。这里要谈的Web服务元数据(JSR 181)只是Java Web 服务规范中的一个,它跟Common Annotations, JAXB2, StAX, SAAJ和JAX-WS等共同构成Java EE 5的Web Services技术堆栈。\n\n下面介绍`JSR-181`里面各个元数据的相关参数及用途。\n\n| Annotation   | Retention | Target            | Description                              |\n| ------------ | --------- | ----------------- | ---------------------------------------- |\n| WebService   | Runtime   | Type              | 标注要暴露为Web Services的类或接口                  |\n| WebParam     | Runtime   | Parameter         | 自定义服务方法参数到WSDL的映射                        |\n| WebResult    | Runtime   | Method            | 自定义服务方法返回值到WSDL的映射                       |\n| WebMethod    | Runtime   | Method            | 自定义单个服务方法到WSDL的映射                        |\n| Oneway       | Runtime   | Method            | 必须与@WebMethod连用,表明被标注方法只有输入没有输出,这就要求被标注方法不能有返回值,也不能声明checked exception |\n| HandlerChain | Runtime   | Type,Method,Field | 将Web服务与外部Handler chain关联起来               |\n| SOAPBinding  | Runtime   | Type,Method       | 自定义`SOAPBinding`                         |\n\n\n\n## 二、Scripting\n\nJava6增加了对动态语言的支持，原理上是将脚本语言编译成字节码，这样脚本语言也能享用Java平台的诸多优势，包括可移植性，安全等。另外由于现在是编译成字节码后再执行，所以比原来边解释边执行效率要高很多。可以很好的利用脚本语言的动态特性，主要支持的有`JavaSrcipt`、`Ruby`、`Python`等。\n\n以下使用`JavaScript`的脚本，代码示例如下：\n\n```java\nimport javax.script.Invocable;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * JsTest.\n * @author blinkfox\n * @version 1.0\n *\n */\npublic class JsTest {\n\n    private static final Logger log = LoggerFactory.getLogger(Hello.class);\n\n    /**\n     * main方法.\n     * @param args 数组参数\n     * @throws ScriptException 脚本异常\n     * @throws NoSuchMethodException 无方法异常\n     */\n    public static void main(String[] args) throws ScriptException, NoSuchMethodException {\n        ScriptEngineManager enjineManager = new ScriptEngineManager();\n        ScriptEngine engine = enjineManager.getEngineByName(\"JavaScript\");\n\n        String script=\"function hello(name){return 'Hello ' + name}\";\n        engine.eval(script);\n        Invocable inv=(Invocable) engine;\n        String result = (String) inv.invokeFunction(\"hello\", \"blinkfox\");\n        log.info(\"脚本执行结果:{}\", result);\n    }\n\n}\n```\n\n## 三、Compiler API\n\n在Java6中提供了一套`Compiler API`，定义在`JSR199`中, 提供在运行期动态编译java代码为字节码的功能。一套API就好比是在java程序中模拟javac程序，将Java源文件编译为class文件；其提供的默认实现也正是在文件系统上进行查找、编译工作的。`Compiler API`结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。\n\n基本使用示例如下：\n\n```java\npublic class JavaCompilerAPICompiler {\n\n    public void compile(Path src, Path output) throws IOException {\n        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n        try (StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null)) {\n            Iterable<? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjects(src.toFile());\n            Iterable<String> options = Arrays.asList(\"-d\", output.toString());\n            JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, options, null, compilationUnits);\n            boolean result = task.call();\n        }\n    }\n\n}\n```\n\n## 四、轻量级HTTP server\n\nJDK6提供了一个轻量级的`Http Server API`，据此我们可以构建自己的嵌入式Http Server，它支持`Http`和`Https`协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现，程序员必须自己实现`HttpHandler`接口，HttpServer会调用`HttpHandler`实现类的回调方法来处理客户端请求，在这里，我们把一个Http请求和它的响应称为一个交换,包装成`HttpExchange`类,HttpServer负责将`HttpExchange`传给`HttpHandler`实现类的回调方法。\n\n以下是通过JDK6新特性能够实现的HttpServer的示例：\n\n```java\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\nimport com.sun.net.httpserver.HttpServer;\nimport com.sun.net.httpserver.spi.HttpServerProvider;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\n\n/**\n * 自定义的http服务器.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic class MyHttpServer {\n\n    /**\n     * 启动服务，监听来自客户端的请求.\n     *\n     * @throws IOException IO异常\n     */\n    private static void httpserverService() throws IOException {\n        HttpServerProvider provider = HttpServerProvider.provider();\n        HttpServer httpserver = provider.createHttpServer(new InetSocketAddress(8888), 200); // 监听端口8888,能同时接受100个请求\n        httpserver.createContext(\"/mytest\", new MyHttpHandler());\n        httpserver.setExecutor(null);\n        httpserver.start();\n        System.out.println(\"server started\");\n    }\n\n    /**\n     * Http请求处理类.\n     */\n    private static class MyHttpHandler implements HttpHandler {\n\n        public void handle(HttpExchange httpExchange) throws IOException {\n            String responseMsg = \"ok\"; //响应信息\n            InputStream in = httpExchange.getRequestBody(); //获得输入流\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            String temp = null;\n            while((temp = reader.readLine()) != null) {\n                System.out.println(\"client request:\" + temp);\n            }\n            httpExchange.sendResponseHeaders(200, responseMsg.length()); //设置响应头属性及响应信息的长度\n            OutputStream out = httpExchange.getResponseBody();  //获得输出流\n            out.write(responseMsg.getBytes());\n            out.flush();\n            httpExchange.close();\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException {\n        httpserverService();\n    }\n\n}\n```\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * Http服务器测试类.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic class HttpTest {\n\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newCachedThreadPool();\n        // 测试并发对MyHttpServer的影响\n        for (int i = 0; i < 20; i++) {\n            Runnable run = new Runnable() {\n                public void run() {\n                    try {\n                        startWork();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            };\n            exec.execute(run);\n        }\n        exec.shutdown();// 关闭线程池\n    }\n\n    public static void startWork() throws IOException {\n        URL url = new URL(\"http://127.0.0.1:8888/mytest\");\n        HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n        urlConn.setDoOutput(true);\n        urlConn.setDoInput(true);\n        urlConn.setRequestMethod(\"POST\");\n        // 测试内容包\n        String teststr = \"this is a test message\";\n        OutputStream out = urlConn.getOutputStream();\n        out.write(teststr.getBytes());\n        out.flush();\n        while (urlConn.getContentLength() != -1) {\n            if (urlConn.getResponseCode() == 200) {\n                InputStream in = urlConn.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n                String temp = \"\";\n                while ((temp = reader.readLine()) != null) {\n                    System.err.println(\"server response:\" + temp);// 打印收到的信息\n                }\n                reader.close();\n                in.close();\n                urlConn.disconnect();\n            }\n        }\n    }\n\n}\n```\n\n## 五、Common annotations\n\n`Common annotations`原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。\n\n下面列举出`Common Annotations 1.0`里面的10个`Annotations`：\n\n| **Annotation** | **Retention** | **Target**                               | **Description**                          |\n| :------------- | :-----------: | :--------------------------------------- | :--------------------------------------- |\n| Generated      |    Source     | ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE | 用于标注生成的源代码                               |\n| Resource       |    Runtime    | TYPE, METHOD, FIELD                      | 用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式 |\n| Resources      |    Runtime    | TYPE                                     | 同时标注多个外部依赖，容器会把所有这些外部依赖注入                |\n| PostConstruct  |    Runtime    | METHOD                                   | 标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct |\n| PreDestroy     |    Runtime    | METHOD                                   | 当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy |\n| RunAs          |    Runtime    | TYPE                                     | 用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的 |\n| RolesAllowed   |    Runtime    | TYPE, METHOD                             | 用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的 |\n| PermitAll      |    Runtime    | TYPE, METHOD                             | 允许所有角色执行被标注的类或方法                         |\n| DenyAll        |    Runtime    | TYPE, METHOD                             | 不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行 |\n| DeclareRoles   |    Runtime    | TYPE                                     | 用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色 |\n\n## 六、StAX\n\nStAX(JSR 173)是JDK6中新增的除了DOM和SAX之外的又一种处理XML文档的API。\n\n`StAX`是`The Streaming API for XML`的缩写，一种利用拉模式解析(pull-parsing)XML文档的API。StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。\n\n下面是这几种XML解析API的特性比较：\n\n| Feature                      | StAX            | SAX             | DOM            | TrAX      |\n| ---------------------------- | --------------- | --------------- | -------------- | --------- |\n| API Type                     | Pull, streaming | Push, streaming | In memory tree | XSLT Rule |\n| Ease of Use                  | High            | Medium          | High           | Medium    |\n| XPath Capability             | No              | No              | Yes            | Yes       |\n| CPU and Memory Efficiency    | Good            | Good            | Varies         | Varies    |\n| Forward Only                 | Yes             | Yes             | No             | No        |\n| Read XML                     | Yes             | Yes             | Yes            | Yes       |\n| Write XML                    | Yes             | No              | Yes            | Yes       |\n| Create, Read, Update, Delete | No              | No              | Yes            | No        |\n\n下面代码演示了如何通过StAX读取xml文档和生成xml文档：\n\n需要读取的xml文件：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<catalogs>\n    <catalog id=\"001\">Book</catalog>\n    <catalog id=\"002\">Video</catalog>\n</catalogs>\n```\n\n读和写XML文件的Java代码：\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport javax.xml.namespace.QName;\nimport javax.xml.stream.*;\nimport javax.xml.stream.events.StartElement;\nimport javax.xml.stream.events.XMLEvent;\n\n/**\n * Stax测试类.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic class StaxTester {\n\n    /**\n     * 根据StAX读取XML文件.\n     *\n     * @throws XMLStreamException XML流异常\n     * @throws FileNotFoundException 文件未找到异常\n     */\n    private static void readXxmlByStax() throws XMLStreamException, FileNotFoundException {\n        XMLInputFactory xmlif = XMLInputFactory.newInstance();\n        XMLEventReader xmler = xmlif.createXMLEventReader(new FileInputStream(\"G:\\\\test\\\\test.xml\"));\n        XMLEvent event;\n        StringBuilder sb = new StringBuilder();\n        while (xmler.hasNext()) {\n            event = xmler.nextEvent();\n            if (event.isStartElement()) { //如果解析的是起始标记\n                StartElement element = event.asStartElement();\n                sb.append(\"<\");\n                sb.append(element.getName());\n                if(element.getName().getLocalPart().equals(\"catalog\")) {\n                    sb.append(\" id=/\");\n                    sb.append(element.getAttributeByName(new QName(\"id\")).getValue());\n                    sb.append(\"/\");\n                }\n                sb.append(\">\");\n            } else if (event.isCharacters()) { //如果解析的是文本内容\n                sb.append(event.asCharacters().getData());\n            } else if(event.isEndElement()) { //如果解析的是结束标记\n                sb.append(\"</\");\n                sb.append(event.asEndElement().getName());\n                sb.append(\">\");\n            }\n        }\n        System.out.println(sb);\n    }\n\n    /**\n     * 根据StAX写入XML文件.\n     *\n     * @throws XMLStreamException XML流异常\n     * @throws FileNotFoundException 文件未找到异常\n     */\n    private static void writeXmlByStax() throws XMLStreamException, FileNotFoundException {\n        XMLOutputFactory xmlof = XMLOutputFactory.newInstance();\n        XMLStreamWriter xmlw = xmlof.createXMLStreamWriter(new FileOutputStream(\"G:\\\\test\\\\output.xml\"));\n        // 写入默认的 XML 声明到xml文档\n        xmlw.writeStartDocument();\n        xmlw.writeCharacters(\"\\n\");\n        // 写入注释到xml文档\n        xmlw.writeComment(\"testing comment\");\n        xmlw.writeCharacters(\"\\n\");\n        // 写入一个catalogs根元素\n        xmlw.writeStartElement(\"catalogs\");\n        xmlw.writeNamespace(\"myNS\", \"http://blinkfox.com\");\n        xmlw.writeAttribute(\"owner\",\"Chinajash\");\n        xmlw.writeCharacters(\"\\n\");\n        // 写入子元素catalog\n        xmlw.writeCharacters(\"    \");\n        xmlw.writeStartElement(\"http://blinkfox.com\", \"catalog\");\n        xmlw.writeAttribute(\"id\",\"007\");\n        xmlw.writeCharacters(\"Apparel\");\n        // 写入catalog元素的结束标签\n        xmlw.writeEndElement();\n        // 写入catalogs元素的结束标签\n        xmlw.writeCharacters(\"\\n\");\n        xmlw.writeEndElement();\n        // 结束 XML 文档\n        xmlw.writeEndDocument();\n        xmlw.close();\n        System.out.println(\"生成xml文件成功!\");\n    }\n\n    /**\n     * main方法.\n     *\n     * @param args 数组参数\n     * @throws XMLStreamException XML流异常\n     * @throws FileNotFoundException 文件未找到异常\n     */\n    public static void main(String[] args) throws XMLStreamException, FileNotFoundException {\n        readXxmlByStax();\n        writeXmlByStax();\n    }\n\n}\n```\n\n运行上面程序后，控制台输出如下:\n\n```bash\n<catalogs>\n    <catalog id=/001/>Book</catalog>\n    <catalog id=/002/>Video</catalog>\n</catalogs>\n生成xml文件成功!\n```\n\n产生的`output.xml`文件如下:\n\n```xml\n<?xml version=\"1.0\" ?>\n<!--testing comment-->\n<catalogs xmlns:myNS=\"http://blinkfox.com\" owner=\"Chinajash\">\n    <myNS:catalog id=\"007\">Apparel</myNS:catalog>\n</catalogs>\n```\n\n## 七、JAXB2\n\n`JAXB`是`Java Architecture for XML Binding`的缩写，可以将一个Java对象转变成为XML格式，反之亦然。我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为`OXM`(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性`Annotation`来标识要作绑定的类和属性等，这就极大简化了开发的工作量。实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。 下面用代码演示在JDK6中如何来用`JAXB2`：\n\n```java\n/**\n * Gender性别枚举类.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic enum Gender {\n\n    MALE(true),\n\n    FEMALE (false);\n\n    private boolean code;\n\n    /**\n     * 构造方法.\n     * @param code 性别值\n     */\n    Gender(boolean code) {\n        this.code = code;\n    }\n\n}\n```\n\n```java\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\n\n/**\n * Address地址类.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic class Address {\n\n    @XmlAttribute\n    String country;\n\n    @XmlElement\n    String state;\n\n    @XmlElement\n    String city;\n\n    @XmlElement\n    String street;\n\n    /** 由于没有添加@XmlElement,所以该元素不会出现在输出的xml中. */\n    String zipcode;\n\n    /**\n     * 默认的空构造方法.\n     */\n    public Address() {\n        super();\n    }\n\n    public Address(String country, String state, String city, String street, String zipcode) {\n        this.country = country;\n        this.state = state;\n        this.city = city;\n        this.street = street;\n        this.zipcode = zipcode;\n    }\n\n    /**\n     * country的getter方法.\n     *\n     * @return country\n     */\n    public String getCountry() {\n        return country;\n    }\n\n}\n```\n\n```java\nimport java.util.Calendar;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n/**\n * Person类.\n *\n * @author blinkfox on 2017-12-04.\n */\n@XmlRootElement\npublic class Person {\n\n    /** birthday将作为person的子元素. */\n    @XmlElement\n    Calendar birthDay;\n\n    /** name将作为person的的一个属性. */\n    @XmlAttribute\n    String name;\n\n    /** address将作为person的子元素. */\n    @XmlElement\n    Address address;\n\n    /** gender将作为person的子元素. */\n    @XmlElement\n    Gender gender;\n\n    /** job将作为person的子元素. */\n    @XmlElement\n    String job;\n\n    /**\n     * 默认的空构造方法.\n     */\n    public Person() {\n        super();\n    }\n\n    public Person(Calendar birthDay, String name, Address address, Gender gender, String job) {\n        this.birthDay = birthDay;\n        this.name = name;\n        this.address = address;\n        this.gender = gender;\n        this.job = job;\n    }\n\n    /**\n     * address的getter方法.\n     * @return address\n     */\n    public Address getAddress() {\n        return address;\n    }\n\n}\n```\n\n```java\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.util.Calendar;\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.Marshaller;\nimport javax.xml.bind.Unmarshaller;\n\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * JAXB2测试类.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic class JAXB2Test {\n\n    private static final Logger log = LoggerFactory.getLogger(JAXB2Test.class);\n\n    public static void main(String[] args) {\n        Address address = new Address(\"中国\", \"北京\", \"北京\", \"上地\", \"100080\");\n        Person p = new Person(Calendar.getInstance(),\"JAXB2\", address, Gender.MALE, \"软件工程师\");\n\n        FileReader reader = null;\n        FileWriter writer = null;\n        try {\n            // 生成xml文件.\n            JAXBContext context = JAXBContext.newInstance(Person.class);\n            writer = new FileWriter(\"G:/test/person.xml\");\n            Marshaller m = context.createMarshaller();\n            m.marshal(p, writer);\n            log.info(\"生成person.xml文件成功!\");\n\n            // 读取xml文件.\n            reader = new FileReader(\"G:/test/person.xml\");\n            Unmarshaller um = context.createUnmarshaller();\n            Person p2 = (Person) um.unmarshal(reader);\n            log.info(\"Country:{}\", p2.getAddress().getCountry());\n        } catch (Exception e) {\n            log.error(\"生成和读取XML文件出错！\", e);\n        } finally {\n            IOUtils.closeQuietly(writer);\n            IOUtils.closeQuietly(reader);\n        }\n    }\n\n}\n```\n\n运行该程序，我们会得到一个`person.xml`的文件，内容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<person name=\"JAXB2\">\n    <birthDay>2017-12-04T17:16:19.226+08:00</birthDay>\n    <address country=\"中国\">\n        <state>北京</state>\n        <city>北京</city>\n        <street>上地</street>\n    </address>\n    <gender>MALE</gender>\n    <job>软件工程师</job>\n</person>\n```\n\n## 八、Console\n\nJDK6中提供了`java.io.Console`类专用来访问基于字符的控制台设备。你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的Console实例。下面代码演示了Console类的用法:\n\n```java\nimport java.io.Console;\n\n/**\n * Jdk6之Console测试类.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic class ConsoleTest {\n\n    public static void main(String[] args) {\n        // 获得Console实例，并判断console是否可用\n        Console console = System.console();\n        if (console != null) {\n            // 读取整行字符和密码，密码输入时不会显示\n            String user = new String(console.readLine(\"请输入用户名:\"));\n            String pwd = new String(console.readPassword(\"再输入密码:\"));\n            console.printf(\"用户名是:\" + user + \"\\n\");\n            console.printf(\"密码是:\" + pwd + \"\\n\");\n        } else {\n            System.out.println(\"Console不可用!\");\n        }\n    }\n\n}\n```\n\n编译该代码，并在命令行中输入：`java ConsoleTest`，然后即可运行，运行示例如下：\n\n```bash\n请输入用户名:张三\n再输入密码:\n打印出的用户名是:张三\n打印出的密码是:123456\n```\n\n> **注**: 在这里可以看到输入密码时,控制台时不显示这些密码字符的,但是程序可以得到输入的密码字符串,这与Linux下面输入密码的情况是一样的。\n\n## 九、Java DB(Derby)\n\n从JDK6开始，JDK目录中新增了一个名为`db`的目录。这便是 Java 6 的新成员：Java DB。这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目`Derby`。它只有 2MB 大小，对比动辄上 G 的数据库来说可谓袖珍。但这并不妨碍 Derby 功能齐备，支持几乎大部分的数据库应用所需要的特性。JDK6.0里面带的这个Derby的版本是10.2.1.7,支持存储过程和触发器；有两种运行模式，一种是作为嵌入式数据库，另一种是作为网络数据库。前者的数据库服务器和客户端都在同一个JVM里面运行，后者允许数据库服务器端和客户端不在同一个JVM里面，而且允许这两者在不同的物理机器上。值得注意的是JDK6里面的这个Derby支持JDK6的新特性`JDBC 4.0`规范(JSR 221)。\n\n下面分两种情况演示一下如何用代码操作Derby数据库，一种是嵌入式数据库，一种是网络数据库。\n\n### 1. 嵌入式数据库\n\n```java\nimport com.blinkfox.learn.jdbc.JdbcDaoHelper;\n\nimport java.sql.*;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Derby内嵌数据库测试示例.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic class EmbeddedDerbyTest {\n\n    private static final Logger log = LoggerFactory.getLogger(EmbeddedDerbyTest.class);\n\n    /** Derby驱动,在derby.jar里面. */\n    private static final String DRIVER = \"org.apache.derby.jdbc.EmbeddedDriver\";\n\n    /** 连接Derby的url，create=true表示当数据库不存在时就创建它. */\n    private static final String URL = \"jdbc:derby:EmbeddedDB;create=true\";\n\n    /**\n     * main方法.\n     *\n     * @param args 数组参数\n     */\n    public static void main(String[] args) {\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n        try {\n            Class.forName(DRIVER);\n            conn = DriverManager.getConnection(URL);//启动嵌入式数据库\n            st = conn.createStatement();\n            st.execute(\"create table foo (FOOID INT NOT NULL, FOONAME VARCHAR(30) NOT NULL)\"); //创建foo表\n            st.executeUpdate(\"insert into foo(FOOID,FOONAME) values (1, 'blinkfox')\"); //插入一条数据\n            rs = st.executeQuery(\"select * from foo\");//读取刚插入的数据\n            while (rs.next()) {\n                int id = rs.getInt(1);\n                String name = rs.getString(2);\n                log.info(\"查询结果：id = {}; name = {}\", id, name);\n            }\n        } catch (Exception e) {\n            log.error(\"使用Derby数据库出错!\", e);\n        } finally {\n            JdbcDaoHelper.close(rs);\n            JdbcDaoHelper.close(st);\n            JdbcDaoHelper.close(conn);\n        }\n    }\n\n}\n```\n\n运行上面程序后，会在当前目录生成名为`EmbeddedDB`的文件夹，既是`EmbeddedDB`数据库的数据文件存放的地方，控制台将输出：\n\n```bash\n查询结果：id = 1; name = blinkfox\n```\n\n### 2. 网络数据库\n\n```java\nimport java.io.PrintWriter;\nimport java.sql.DriverManager;\n\nimport org.apache.derby.drda.NetworkServerControl;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Derby网络数据库测试示例.\n *\n * @author blinkfox on 2017-12-04.\n */\npublic class NetworkServerDerbyTest {\n\n    private static final Logger log = LoggerFactory.getLogger(NetworkServerDerbyTest.class);\n\n    /** Derby驱动,在derbyclient.jar里面. */\n    private static final String DRIVER = \"org.apache.derby.jdbc.ClientDriver\";\n\n    /** 连接Derby的url. */\n    private static final String URL = \"jdbc:derby://localhost:1527/NetworkDB;create=true\";\n\n    /**\n     * main方法.\n     * <p>创建Derby网络服务器,默认端口是1527,也可以通过运行<Derby_Home>/frameworks/NetworkServer/bin/startNetworkServer.bat\n     来创建并启动Derby网络服务器,如果是Unix,用startNetworkServer.ksh</p>\n     *\n     * @param args 数组参数\n     */\n    public static void main(String[] args) {\n        NetworkServerControl derbyServer = null;\n        try {\n            //NetworkServerControl类在derbynet.jar里面\n            derbyServer = new NetworkServerControl();\n            PrintWriter pw = new PrintWriter(System.out); //用系统输出作为Derby数据库的输出\n            derbyServer.start(pw); //启动Derby服务器\n            Class.forName(DRIVER);\n            DriverManager.getConnection(URL);\n        } catch (Exception e) {\n            log.error(\"操作Derby网络数据库异常!\", e);\n        } finally {\n            if (derbyServer != null) {\n                try {\n                    derbyServer.shutdown();\n                } catch (Exception e) {\n                    log.error(\"关闭Derby网络数据库异常!\", e);\n                }\n            }\n        }\n    }\n\n}\n```\n\n运行上面程序后,会在当前目录生成名为`NetworkDB`的文件夹。关于`Derby`的详细情况,请参考[http://db.apache.org/derby](http://db.apache.org/derby)。\n\n## 十、JDBC 4.0\n\n在 Java SE 6 所提供的诸多新特性和改进中，值得一提的是为 Java 程序提供数据库访问机制的 JDBC 版本升级到了 4.0, 这个以 JSR-221 为代号的版本，提供了更加便利的代码编写机制及柔性，并且支持更多的数据类型。JDBC4.0 主要有以下改进和新特性。\n\n- 自动加载`java.sql.Driver`，而不需要再调用`class.forName`；\n- 添加了`java.sql.RowId`数据类型用来可以访问`sql rowid`；\n- 添加了`National Character Set`的支持；\n- 增强了`BLOB`和`CLOB`的支持功能；\n- `SQL/XML`和`XML`支持；\n- `Wrapper Pattern`；\n- `SQLException`增强；\n- `Connection`和`Statement`接口增强；\n- `New Scalar Funtions`；\n- `JDBC API changes`。\n\n## 十一、值得关注的\n\n### 1. 集合框架增强\n\nJdk6中的集合框架的API更改数量要少于JDK5，更多地关注了规范的准确性和清晰度。即使在编写旧版本的程序时，我们也建议使用Java SE 6规范。\nAPI更改的主要主题是更好的双向收集访问。\n\n新增了以下几个接口：\n\n- `Deque`: 双端队列接口，继承了Queue接口，队列两头都可以实现入队和出队。\n- `BlockingDeque`: 双端阻塞队列接口，继承了BlockingQueue、Deque接口。\n- `NavigableSet`: 可导航Set接口，继承自SortedSet接口。\n- `NavigableMap`: 可导航Map接口，继承自SortedMap接口。\n- `ConcurrentNavigableMap`: 支持并发的可导航Map，继承自`ConcurrentMap`接口和`NavigableMap`接口。\n\n新增了以下几个实现类：\n\n- `ArrayDeque`: 底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用Stack，而是推荐使用更高效的`ArrayDeque`来实现栈的功能，非线程安全。\n- `ConcurrentSkipListSet`: 底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeSet功能相似，线程安全。\n- `ConcurrentSkipListMap`: 底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeMap功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补ConcurrentHashMap不支持排序的问题。\n- `LinkedBlockingDeque`: 底层采用了双向链表实现的双端阻塞并发队列，无限扩展且可选容量。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。\n- `AbstractMap.SimpleEntry`: `Map.Entry`的简单可变实现。\n- `AbstractMap.SimpleImmutableEntry`: `Map.Entry`的简单不可变实现。\n\n以下的类已经被改进来用来实现新的接口：\n\n- `LinkedList`: 改进以实现Deque接口。\n- `TreeSet`: 改进以实现NavigableSet接口。\n- `TreeMap`: 改进以实现NavigableMap接口。\n\n新增了两个新的方法到`Collections`的工具类中：\n\n- `newSetFromMap(Map)`: 从通用的Map实现中创建一个通用的Set实现。Java集合中有`IdentityHashMap`，但是没有`IdentityHashSet`类，我们可以通过这样的方式来实现：\n\n```java\nSet<Object> identityHashSet = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());\n```\n\n- `asLifoQueue(Deque)`: 通过传入`Deque`得到一个后进先出(LIFO)的队列。\n\n现在`Arrays`工具类，具有`copyOf`和`copyOfRange`方法，可以有效地调整，截断或复制所有类型的数组的子数组。\n\n以前是这样实现的：\n\n```java\nint[] newArray = new int[newLength];\nSystem.arraycopy(oldArray, 0, newArray, 0, oldArray.length);\n```\n\n现在可以这样实现：\n\n```java\nint[] newArray = Arrays.copyOf(a, newLength);\n```\n\n---\n\n参考文档：\n\n-[JavaSE6 Features and Enhancements](http://www.oracle.com/technetwork/java/javase/features-141434.html)\n-[Java6的新特性](https://segmentfault.com/a/1190000004417536)\n-[chinajash](http://my.csdn.net/Chinajash)","tags":["Java"],"categories":["后端"]},{"title":"Java5新特性及使用","url":"/2018/11098311.html","content":"\n## 新特性列表\n\n以下是Java5中的引入的部分新特性，关于更详细的新特性了解，可参考[这里](https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html)。\n\n- 泛型(Generics)\n- 增强for循环(Enhanced for Loop)\n- 自动装箱拆箱(Autoboxing/Unboxing)\n- 枚举(Enums)\n- 可变参数(Varargs)\n- 静态导入(Static Import)\n- 注解(Annotations)\n- 值得关注\n  - 进程构建器(ProcessBuilder)\n  - 格式化(Formatter)\n  - 扫描器(Scanner)\n  - 反射(Reflection)\n  - 集合框架(Collections Framework)\n  - 并发工具类(Concurrency Utilities)\n  - StringBuilder\n- 其它(others)\n\n## 一、泛型(Generics)\n\n### 1. 概述\n\nJava语言引入泛型的好处是安全简单。可以将运行时错误提前到编译时错误。在Java5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的**任意化**，**任意化**带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。\n\n泛型的本质是**参数化类型**，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法中，分别称为泛型类、泛型接口、泛型方法。\n\n### 2. 泛型类、泛型接口\n\n泛型类中的类型参数几乎可以用于任何可以使用接口名、类名的地方。以下是Jdk中Map接口的定义：\n\n```java\npublic interface Map<K,V> {\n\n    V get(Object key);\n\n    V put(K key, V value);\n\n}\n```\n\n当声明或者实例化一个泛型的对象时，必须指定类型参数的值：\n\n```java\nMap<Integer, String> map = new HashMap<Integer, String>();\n```\n\n对于常见的泛型模式，推荐的名称是：\n\n- K: 键\n- V: 值\n- E: 异常类\n- T: 泛型\n\n### 3. 泛型方法\n\n#### (1). 定义泛型方法\n\n泛型方法使得该方法能独立于类而产生变化。以下是一个基本的指导原则：**无论何时，只要你能做到，你就应该尽量使用泛型方法**。也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。要定义泛型方法，只需**将泛型参数列表置于返回值之前**，就像下面这样：\n\n```java\npublic class GenericMethods {\n\n    //当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上\n    public <T> void f(T x){\n        System.out.println(x.getClass().getName());\n    }\n\n    public static void main(String[] args) {\n        GenericMethods gm = new GenericMethods();\n        gm.f(99);\n        gm.f(\"abc\");\n    }\n\n}\n```\n\n#### (2). 可变参数泛型方法\n\n泛型方法与可变参数列表能很好地共存。\n\n```java\npublic class GenericVarargs {\n\n    public static <T> List<T> makeList(T... args) {\n        List<T> result = new ArrayList<T>();\n        for(T item:args) {\n            result.add(item);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List ls = makeList(\"A\");\n        System.out.println(ls);\n        ls = makeList(\"A\",\"B\",\"C\");\n        System.out.println(ls);\n        ls = makeList(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\"));\n        System.out.println(ls);\n    }\n\n}\n```\n\n> **注**：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。\n\n### 4. 泛型擦除\n\n看以下一段代码：\n\n```java\npublic class ErasedTypeEquivalence {\n\n    public static void main(String[] args) {\n        Class c1 = new ArrayList<String>().getClass();\n        Class c2 = new ArrayList<Integer>().getClass();\n        System.out.println(c1 == c2); // 输出true.\n    }\n\n}\n```\n\n从以上代码的执行结果可以知道，`ArrayList<String>`和`ArrayList<Integer>`是相同的类型。Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。\n\n要想在表达式中使用类型，需要显式地传递类型的class对象。\n\n```java\nclass Building {\n\n}\n```\n\n```java\nclass House extends Building {\n\n}\n```\n\n```java\npublic class ClassTypeCapture<T> {\n\n    Class<T> kind;\n\n    public ClassTypeCapture(Class<T> kind) {\n        this.kind = kind;\n    }\n\n    public boolean f(Object arg) {\n        return kind.isInstance(arg);\n    }\n\n    public static void main(String[] args) {\n        ClassTypeCapture<Building> ctt1 = new ClassTypeCapture<Building>(Building.class);\n        System.out.println(ctt1.f(new Building())); // true\n        System.out.println(ctt1.f(new House())); // true\n        ClassTypeCapture<House> ctt2 = new ClassTypeCapture<House>(House.class);\n        System.out.println(ctt2.f(new Building())); // false\n        System.out.println(ctt2.f(new House())); // true\n    }\n}\n```\n\n### 5. 通配符及泛型边界\n\n- 通配符(`?`): 当操作类型时，不需要使用类型的具体功能时，只使用`Object`类中的功能。那么可以用`?`通配符来表未知类型。例如：`Class<?> classType = Class.forName(\"java.lang.String\");`。\n- 上界(`? extends T`): 可以接收`T`类型或者其子类型的对象。\n- 下界(`? super E`): 可以接收`T`类型或者其父类型的对象。\n\n### 6. 泛型总结\n\n- 泛型的类型参数只能是类类型，不能是基本数据类型。\n- 泛型的类型参数可以有多个。\n- 所有泛型类的类型参数在编译时都会被擦除。\n- 创建泛型对象时请指明类型，让编译器尽早的做参数检查。\n- 不能创建泛型数组。如果想要创建泛型数组，建议使用`ArrayList`。\n- 使用带泛型的类创建对象时，等式两边指定的泛型必须一致。\n- 泛型的好处：\n  - 类型安全。\n  - 消除强制类型转换。\n  - 提高性能。\n\n## 二、增强for循环(Enhanced for Loop)\n\n在Java5中，引入了另一种形式的for循环来对集合、数组、Map等进行遍历。如以下示例：\n\n```java\nint[] integers = {1, 2, 3, 4};\n/* 开始遍历 */\nfor (int i : integers) {\n    System.out.println(i);/* 依次输出“1”、“2”、“3”、“4” */\n}\n```\n\n借助增强for循环，可以用一种更简单地方式来完成遍历。能用这种方法遍历的对象的类型，可以是数组、`Collection`、`Map`或者任何其它实现了`java.lang.Iterable`接口的类。通过跟同样是在Java5中引入的泛型机制配合使用，可以精确的控制能采用的循环变量的类型。而且，因为这么编写的代码，会在编译期间被自动当成是和传统写法相同的形式，所以不必担心要额外付出性能方面的代价。\n\n> **注**：Java采用`for`（而不是意义更明确的`foreach`）来引导这种一般被叫做**for-each循环**的循环，并使用`:`（而不是意义更明确的`in`）来分割循环变量名称和要被遍历的对象。这样做的主要原因，是为了避免因为引入新的关键字，造成兼容性方面的问题——在Java语言中，不允许把关键字当作变量名来使用，虽然使用`foreach`这名字的情况并不是非常多，但是`in`却是一个经常用来表示输入流的名字（例如`java.lang.System`类里，就有一个名字叫做`in`的`static`属性，表示**标准输入流**）。\n\n## 三、自动装箱拆箱(Autoboxing/Unboxing)\n\n### 1. 概述\n\n自动装箱就是Java自动将原始类型值转换成对应的对象，比如将`int`的变量转换成`Integer`对象，这个过程叫做装箱，反之将`Integer`对象转换成`int`类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型`byte`, `short`, `char`, `int`, `long`, `float`, `double`和`boolean`对应的封装类分别为`Byte`, `Short`, `Character`, `Integer`, `Long`, `Float`, `Double`, `Boolean`。\n\n自动装箱时编译器调用`valueOf`将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似`intValue()`, `doubleValue()`这类的方法将对象转换成原始类型值。自动装箱和拆箱在Java中很常见，比如我们有一个方法，接受一个对象类型的参数，如果我们传递一个原始类型值，那么Java会自动将这个原始类型值转换成与之对应的对象。最经典的一个场景就是当我们向`ArrayList`这样的容器中增加原始类型数据时，就会发生自动装箱。代码示例如下：\n\n```java\nArrayList<Integer> intList = new ArrayList<Integer>();\nintList.add(1); //自动装箱\nintList.add(2); // 自动装箱\n\nint number = intList.get(0); // 自动拆箱\n```\n\n### 2. 对象相等的比较\n\n这是一个比较容易出错的地方，`==`可以用于原始值进行比较，也可以用于对象进行比较，当用于对象与对象之间比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象，这个比较过程中**没有自动装箱**发生。进行对象值比较不应该使用`==`，而应该使用对象对应的`equals`方法。看一个能说明问题的例子。\n\n```java\npublic class AutoboxingTest {\n\n    public static void main(String args[]) {\n        // 示例 1: 使用'=='号进行原始类型的比较(没有自动装箱)\n        int i1 = 1;\n        int i2 = 1;\n        System.out.println(\"i1==i2 : \" + (i1 == i2)); // true\n\n        // 示例 2: 使用'=='号进行原始类型和对象类型混合的比较(自动装箱)\n        Integer num1 = 1;\n        int num2 = 1;\n        System.out.println(\"num1 == num2 : \" + (num1 == num2)); // true\n\n        // 示例 3: 使用'=='号进行Integer对象类型的比较(会有缓存的特殊情况)\n        Integer obj1 = 127; // 自动装箱将调用`Integer.valueOf()`且缓存该对象，以便重用\n        Integer obj2 = 127; // 获取已经缓存过的对象\n        System.out.println(\"obj1 == obj2 : \" + (obj1 == obj2)); // true\n\n       // 示例 4: 使用'=='号进行Integer对象类型的比较(不会缓存)\n        Integer obj3 = 128; // 自动装箱将调用`Integer.valueOf()`不缓存该对象\n        Integer obj4 = 128; // 同样是自动装箱将调用`Integer.valueOf()`\n        System.out.println(\"obj3 == obj4 : \" + (obj3 == obj4)); // false\n\n        // 示例 5: 使用'=='号进行`new`出来的新`Integer`对象类型的比较\n        Integer one = new Integer(1); // no autoboxing\n        Integer anotherOne = new Integer(1);\n        System.out.println(\"one == anotherOne : \" + (one == anotherOne)); // false\n    }\n\n}\n```\n\n### 3. 缓存部分对象\n\n输出结果：\n\n```bash\ni1==i2 : true\nnum1 == num2 : true\nobj1 == obj2 : true\nobj3 == obj4 : false\none == anotherOne : false\n```\n\n在 Java5 中，为`Integer`的操作引入了一个新的特性，会对`-128`到`127`的`Integer`对象进行缓存，当创建新的`Integer`对象时，如果符合这个这个范围，并且已有存在的相同值的对象，则返回这个对象，否则创建新的`Integer`对象。这种`Integer`缓存策略仅在**自动装箱（autoboxing）**的时候有用，使用构造器创建的`Integer`对象不能被缓存。\n\n`Integer`类中有一个专门的私有静态内部类`IntegerCache`来负责`Integer`的缓存。代码如下：\n\n```java\n/**\n * Cache to support the object identity semantics of autoboxing for values between\n * -128 and 127 (inclusive) as required by JLS.\n *\n * The cache is initialized on first usage.  The size of the cache\n * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.\n * During VM initialization, java.lang.Integer.IntegerCache.high property\n * may be set and saved in the private system properties in the\n * sun.misc.VM class.\n */\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n\nJavadoc详细的说明这个类是用来实现缓存支持，并支持`-128`到`127`之间的自动装箱过程。最大值`127`可以通过JVM的启动参数`-XX:AutoBoxCacheMax=size`修改。 缓存通过一个`for`循环实现。从小到大的创建尽可能多的整数并存储在一个名为`cache`的整数数组中。这个缓存会在`Integer`类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。\n\n这种缓存行为不仅适用于`Integer`对象。我们针对所有整数类型的类都有类似的缓存机制。\n\n- `ByteCache`用于缓存`Byte`对象\n- `ShortCache`用于缓存`Short`对象\n- `LongCache`用于缓存`Long`对象\n- `CharacterCache`用于缓存`Character`对象\n\n`Byte`，`Short`，`Long`有固定范围:`-128`到`127`。对于`Character`, 范围是`0`到`127`。除了`Integer`可以通过参数改变范围外，其它的都不行。\n\n> **注**：在Java中另一个节省内存的例子就是**字符串常量池**。\n\n### 4. 自动装箱拆箱的隐患\n\n另一个需要避免的问题就是混乱使用对象和原始数据值，一个具体的例子就是当我们在一个原始数据值与一个对象进行比较时，如果这个对象没有进行初始化或者为`null`，在自动拆箱过程中`obj.xxxValue`，会抛出`NullPointerException`，如下面的代码:\n\n```java\nprivate static Integer count;\n\n//NullPointerException on unboxing\nif (count <= 0) {\n    System.out.println(\"Count is not started yet\");\n}\n```\n\n因为自动装箱会隐式地创建对象，像前面提到的那样，如果在一个循环体中，会创建无用的中间对象，这样会增加GC压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。\n\n## 四、枚举(Enums)\n\n枚举（`enum`全称为`enumeration`）类型是 Java5 新增的类型，存放在`java.lang`包中，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。\n\n关于枚举的介绍，这里就不再细讲了，请参考我以前所整理的[Java 枚举知识整理](http://blinkfox.com/java-mei-ju-zhi-shi-zheng-li/)一文。\n\n## 五、可变参数(Varargs)\n\n### 1. 基本使用\n\n在 Java5 中提供了可变参数（`Varargs`），也就是在方法定义中可以使用个数不确定的参数，对于同一方法可以使用不同个数的参数调用，例如`print(\"hello\");`、`print(\"hello\",\"lisi\");`等。下面介绍如何定义可变长参数以及如何使用可变长参数。\n\n使用`...`表示可变长参数，例如：\n\n```java\nprint(String... args) {\n   // 方法代码\n}\n```\n\n在具有可变长参数的方法中可以把参数当成数组使用，例如可以循环输出所有的参数值。\n\n```java\nprint(String... args) {\n    for(String temp:args) {\n        System.out.println(temp);\n    }\n}\n```\n\n调用的时候可以给出任意多个参数也可不给参数，例如：\n\n```java\nprint();\nprint(\"hello\");\nprint(\"hello\",\"lisi\");\n```\n\n### 2. 可变参数的使用规则\n\n- 拥有可变参数的方法可以被重载，在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变参数的方法匹配，则执行时会选择固定参数的方法。\n- 如果要调用的方法可以和两个可变参数匹配，则编译不会通过。\n- 一个方法只能有一个可变参数，并且这个可变参数必须是该方法的最后一个参数。\n- 可变参数可以兼容数组参数，但数组参数无法兼容可变参数。即在方法中定义可变参数后，我们可以像操作数组一样操作该参数；\n\n### 3. 可变参数的使用规范\n\n- 避免带有可变参数的方法重载，容易让人陷入调用的陷阱及误区。\n- 别让`null`值和空值威胁到可变参数的方法。\n- 覆写可变参数方法也要满足以下的条件:\n  - 重写方法不能缩小访问权限。\n  - 参数列表必须与被重写方法相同（包括显示形式）。\n  - 返回类型必须与被重写方法的相同或是其子类。\n  - 重写方法不能抛出新的异常，或者超过了父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常。\n\n## 六、静态导入(Static Import)\n\n`import static`，即静态导入是JDK5中的新特性。一般我们导入一个类都用`import com.xxx.ClassName;`，而静态导入是这样的：`import static com.xxx.ClassName.*;`。这里多了个`static`，还有就是类名`ClassName`后面多了个`.*`，意思是导入这个类里的所有静态方法。当然，也可以只导入某个静态方法，只要把`.*`换成具体的静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用`ClassName.方法名`的方式来调用。\n\n静态导入之前的代码：\n\n```java\ndouble r = Math.cos(Math.PI * theta);\n```\n\n使用静态导入之后的代码：\n\n```java\nimport static java.lang.Math.*;\n\ndouble r = cos(PI * theta);\n```\n\n**当你需要频繁访问一个或两个类的静态成员、静态方法时才使用静态导入**。如果您过度的使用了静态导入功能，则可能导致您的程序无法读取且无法维护，从而导致您导入的所有静态成员和方法污染其名称空间。你的代码读者（包括你，在你写了几个月后）不会知道静态成员来自哪个类。从类中导入所有静态成员对可读性尤其有害，如果您只需要一个或两个成员，请单独导入它们。使用适当的，静态导入可以使您的程序更具可读性，通过删除重复的类名称，来减少样板代码。\n\n## 七、注解(Annotations)\n\n关于注解的介绍，这里就不再细讲了，请参考我前段时间所写的[Java注解的理解和应用](http://blinkfox.com/javazhu-jie-de-li-jie-he-ying-yong/)一文。\n\n## 八、值得关注\n\n### 1. 新增ProcessBuilder类\n\n`ProcessBuilder`类是Java5在`java.lang`包中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在此之前，都是由`Process`类处来实现进程的控制管理。每个`ProcessBuilder`实例管理一个进程属性集。它的`start()`方法利用这些属性创建一个新的`Process`实例。`start()`方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。\n\n`ProcessBuilder`是一个`final`类，有两个带参数的构造方法，你可以通过构造方法来直接创建`ProcessBuilder`的对象。而`Process`是一个抽象类，一般都通过`Runtime.exec()`和`ProcessBuilder.start()`来间接创建其实例。`ProcessBuilder`为进程提供了更多的控制，例如，可以设置当前工作目录，还可以改变环境参数。而`Process`类的功能相对来说简单的多。`ProcessBuilder`类不是同步的。如果多个线程同时访问一个`ProcessBuilder`，而其中至少一个线程从结构上修改了其中一个属性，它必须保持外部同步。\n\n若要使用`ProcessBuilder`创建一个进程，只需要创建`ProcessBuilder`的一个实例，指定该进程的名称和所需参数。要执行此程序，调用该实例上的`start()`即可。下面是一个执行打开`Windows`记事本的例子。注意它将要编辑的文件名指定为一个参数。\n\n```java\nclass PBDemo {\n\n    public static void main(String args[]) {\n        try {\n            ProcessBuilder proc = new ProcessBuilder(\"notepad.exe\", \"testfile\");\n            proc.start();\n        } catch (Exception e) {\n            System.out.println(\"Error executing notepad.\");\n        }\n    }\n\n}\n```\n\n### 2. 新增Formatter格式化器(Formatter)\n\n`Formatter`类是Java5中新增的`printf-style`格式化字符串的解释器，它提供对布局和对齐的支持，提供了对数字，字符串和日期/时间数据的常用格式以及特定于语言环境的输出。常见的Java类型，如`byte`，`java.math.BigDecimal`和`java.util.Calendar`都支持。 通过`java.util.Formattable`接口提供了针对任意用户类型的有限格式定制。\n\n更详细的介绍见[这里](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html)。主要使用方法的代码示例如下：\n\n```java\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.text.MessageFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * 格式化测试使用的示例类.\n *\n * @author blinkfox on 2017-11-28.\n */\npublic class FormatTester {\n\n    private static final Logger log = LoggerFactory.getLogger(FormatTester.class);\n\n    /**\n     * 格式化.\n     */\n    private static void formatter() {\n        StringBuilder sb = new StringBuilder();\n        Formatter formatter = new Formatter(sb, Locale.US);\n\n        // 可重新排序输出.\n        formatter.format(\"%n%4$2s %3$2s %2$2s %1$2s %n\", \"a\", \"b\", \"c\", \"d\"); // -> \" d  c  b  a\"\n        formatter.format(Locale.FRANCE, \"e = %+10.4f\", Math.E); // -> \"e =    +2,7183\"\n        formatter.format(\"%nAmount gained or lost since last statement: $ %(,.2f\", 6217.58);\n        // -> \"Amount gained or lost since last statement: $ 6,217.58\"\n\n        log.info(\"打印出格式化后的字符串:{}\", formatter);\n        formatter.close();\n    }\n\n    /**\n     * printf打印.\n     */\n    private static void printf() {\n        String filename = \"testfile\";\n        try (FileReader fileReader = new FileReader(filename)) {\n            BufferedReader reader = new BufferedReader(fileReader);\n            String line;\n            int i = 1;\n            while ((line = reader.readLine()) != null) {\n                System.out.printf(\"Line %d: %s%n\", i++, line);\n            }\n        } catch (Exception e) {\n            System.err.printf(\"Unable to open file named '%s': %s\", filename, e.getMessage());\n        }\n    }\n\n    /**\n     * stringFormat使用.\n     */\n    private static void stringFormat() {\n        // 格式化日期.\n        Calendar c = new GregorianCalendar(1995, Calendar.MAY, 23);\n        String s = String.format(\"Duke's Birthday: %1$tm %1$te,%1$tY\", c);\n        // -> s == \"Duke's Birthday: May 23, 1995\"\n        log.info(s);\n    }\n\n    /**\n     * 格式化消息.\n     */\n    private static void messageFormat() {\n        String msg = \"欢迎光临，当前（{0}）等待的业务受理的顾客有{1}位，请排号办理业务！\";\n        MessageFormat mf = new MessageFormat(msg);\n        String fmsg = mf.format(new Object[]{new Date(), 35});\n        log.info(fmsg);\n    }\n\n    /**\n     * 格式化日期.\n     */\n    private static void dateFormat() {\n        String str = \"2010-1-10 17:39:21\";\n        SimpleDateFormat format = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n        try {\n            log.info(\"格式化后的日期:{}\", format.format(format.parse(str)));\n        } catch (Exception e) {\n            log.error(\"日期格式化出错！\", e);\n        }\n    }\n\n    public static void main(String[] args) {\n        formatter();\n        stringFormat();\n        messageFormat();\n        dateFormat();\n        printf();\n    }\n\n}\n```\n\n### 3. 新增Scanner类(Scanner)\n\n`java.util.Scanner`是Java5的新特征，主要功能是简化文本扫描，但这个类最实用的地方还是在获取控制台输入。\n\n#### (1). Scanner概述\n\n可以从字符串(`Readable`)、输入流、文件、Channel等来直接构造Scanner对象，有了Scanner了，就可以逐段（根据正则分隔式）来扫描整个文本，并对扫描后的结果做想要的处理。\n\n`Scanner`默认使用**空格**作为分割符来分隔文本，但允许你使用`useDelimiter(Pattern pattern)`或`useDelimiter(String pattern)`方法来指定新的分隔符。\n\n主要API如下：\n\n- `delimiter()`: 返回此`Scanner`当前正在用于匹配分隔符的`Pattern`。\n- `hasNext()`: 判断扫描器中当前扫描位置后是否还存在下一段。\n- `hasNextLine()`: 如果在此扫描器的输入中存在另一行，则返回true。\n- `next()`: 查找并返回来自此扫描器的下一个完整标记。\n- `nextLine()`: 此扫描器执行当前行，并返回跳过的输入信息。\n\n#### (2). 扫描控制台输入\n\n当通过`new Scanner(System.in)`创建了一个`Scanner`实例时，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给`Scanner`，作为扫描对象。如果要获取输入的内容，则只需要调用`Scanner`的`nextLine()`方法即可。\n\n```java\n/**\n* 扫描控制台输入.\n*\n* @author blinkfox 2017-11-28\n*/\npublic class ScannerTest {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        System.out.println(\"请输入字符串：\");\n        while (true) {\n            String line = s.nextLine();\n            if (line.equals(\"exit\")) break;\n            System.out.println(\">>>\" + line);\n        }\n    }\n\n}\n```\n\n#### (3).其它示例\n\n该示例中会从`myNumbers`文件中读取长整型`long`的数据。\n\n```java\nScanner sc = new Scanner(new File(\"myNumbers\"));\nwhile (sc.hasNextLong()) {\n    long aLong = sc.nextLong();\n}\n```\n\n以下示例可以使用除空格之外的分隔符来从一个字符串中读取几个条目：\n\n```java\nString input = \"1 fish 2 fish red fish blue fish\";\nScanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");\nSystem.out.println(s.nextInt());\nSystem.out.println(s.nextInt());\nSystem.out.println(s.next());\nSystem.out.println(s.next());\ns.close();\n```\n\n将输出：\n\n```bash\n1\n2\nred\nblue\n```\n\n### 4. 增强反射功能(Reflection)\n\nJava5反射功能方面的增强主要在`java.lang.Class`和`java.lang.reflect`类中。\n\n主要有以下内容增强：\n\n- **支持泛型**: 可以检查类型、方法、构造方法或字段的声明并获取泛型所对应的类型信息。\n- **支持注解**: 通过使用`getAnnotation()`方法获取已经在运行时标记为可用的方法和构造方法的类型，方法，字段，构造方法和形式参数的注释。人们还可以确定一个接口是否是一个注解类型。\n- **支持枚举**: 可以确定一个类是否是一个枚举，以及一个字段是否代表一个枚举常量。\n- **支持可变参数**: 可以确定一个方法或构造方法是否是可变参数方法。\n- **便利的方法**: 用于确定一个类是否是本地的、匿名的还是成员类，以及一个类型的简单名称是什么。\n- **java.lang.Class类型标记**: 允许使用`java.lang.Class`的实例作为类型标记。\n\n### 5. 增强集合框架(Collections Framework)\n\n在Java5中[集合框架的增强](https://docs.oracle.com/javase/1.5.0/docs/guide/collections/changes5.html)主要在以下几个方面：\n\n- 三种新语言特性都有针对集合，包括**泛型**，**增强for循环**和**自动装箱**。\n- 三个新的接口已被添加到集合框架中，分别是：`Queue`，`BlockingQueue`和`ConcurrentMap`（后两个位于`java.util.concurrent`包中）。\n- 提供了两个新的具体队列实现(`PriorityQueue`、`ConcurrentLinkedQueue`)，一个现有的列表实现已经被改造来实现队列(`LinkedList`)，并且提供了一个抽象队列实现(`AbstractQueue`)。\n- 已经添加了五个阻塞队列实现，以及一个ConcurrentMap实现，分别是：`ArrayBlockingQueue`, `LinkedBlockingQueue`, `PriorityBlockingQueue`, `DelayQueue`, `SynchronousQueue`、`ConcurrentHashMap`。\n- 为类型安全的枚举提供了特殊用途的Map和Set实现。(`EnumMap`和`EnumSet`)\n- 添加了特殊用途的`copy-on-write`List和Set实现，分别是：`CopyOnWriteArrayList`和`CopyOnWriteArraySet`。\n- 提供了包装器的实现来对大多数`Collection`接口添加动态类型安全性的检查(`Collections.checkedInterface`)。检查要添加的元素的类型并返回结果。任何尝试添加非法类型的变量都会抛出一个`ClassCastException`异常。这个功能可以防止在运行的时候出错。\n- 提供了几个新的算法来处理集合。\n  - `frequency(Collection<?> c, Object o)` - 计算指定集合中指定元素出现的次数。\n  - `disjoint(Collection<?> c1, Collection<?> c2)` - 判断两个集合是否不相交，换句话说，是否它们不包含任何共同的元素。\n  - `addAll(Collection<? super T> c, T... a)` - 将指定数组中的所有元素添加到指定的集合中。\n  - `Comparator<T> reverseOrder(Comparator<T> cmp)` - 返回一个比较器，表示指定比较器的反向排序。\n- 提供了计算哈希代码和字符串表示的方法。`Arrays`工具类已经为所有类型的数组提供了基于内容的`hashCode`和`toString`方法。 这些方法补充了现有的`equals`方法。现在可以打印任何数组的内容。\n\n### 6. 并发工具类(Concurrency Utilities)\n\n`java.util.concurrent`，`java.util.concurrent.atomic`和`java.util.concurrent.locks`包为开发并发类应用程序提供了一个强大的，可扩展的高性能，可伸缩，线程安全构建框架，包括 线程池，线程安全集合，信号量，任务调度框架，任务同步实用程序，原子变量和锁。将这些软件包添加到核心类库可以使程序员免去手工制作这些工具的需要，这与集合框架用于数据结构的方式大致相同。关于并发相关的的介绍会在以后更详细的来讲解。\n\n### 7. StringBuilder\n\n`StringBuilder`也是Java5中新增的类，主要用来代替`+`号和`StringBuffer`来更加高效的拼接字符串。`StringBuffer`与`StringBuilder`都是继承于`AbstractStringBuilder`，主要的区别就是`StringBuffer`的函数上都有`synchronized`关键字，保证线程安全。\n\n关于`StringBuilder`的使用这里就不再详细介绍了，网上文章也有很多。总之，对于**动态字符串**的拼接推荐使用`StringBuilder`。**静态字符串**的拼接直接使用`+`号或者字符串的`concat(String str)`方法，甚至也使用`StringBuilder`亦可。\n\n## 九、其它(others)\n\n- **Instrumentation**: 使用`java.lang.instrument`，开发者可以构建一个代理，用来监测运行在JVM上的程序。它类似一种更低级，更松耦合的AOP，可以从底层来改变一个类的行为。\n- **Networking**: 网络编程功能增强。\n- **Internationalization**: 国际化是设计一个应用程序的过程，以便它可以适应各种语言和地区而无需改变工程。国际化这个术语缩写为`i18n`，因为在第一个`i`和最后一个`n`之间有`18`个字母。\n- **改善了环境变量的支持**: `System.getenv(String)`方法不再被弃用。新的`System.getenv()`方法允许作为`Map <String，String>`访问进程环境。\n- **JAXP**: 用于XML处理的`Java API(JAXP)`包括通过标准化的Java平台API来处理XML文档的基本设施。\n- **Serialization**: 已经添加了支持来处理5.0版本中新增的枚举类型。序列化枚举实例的规则与序列化**普通**可序列化对象的规则不同：枚举实例的序列化形式仅由其枚举常量名以及标识其基本枚举类型的信息组成。 反序列化行为也不相同 - 类信息用于查找适当的枚举类，并且`Enum.valueOf`方法与该类和所接收的常量名称一起被调用，以便获取返回的枚举常量。\n- **监控和管理**: Java5为Java平台的监视和管理提供了显着的增强。\n- ...\n\n---\n\n参考文档:\n\n- [Java5的新特性](https://segmentfault.com/a/1190000004417288)\n- [Oracle Java文档](https://docs.oracle.com/javase/1.5.0/docs/relnotes/features.html)","tags":["Java"],"categories":["后端"]},{"title":"Java注解的理解和应用","url":"/2018/110822033.html","content":"\n## 概述\n\n### 1. 什么是注解\n\n注解(`Annotation`)是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符，它是一种由JSR-175标准选择用来描述元数据的一种工具。Java从`Java5`开始引入了注解。在注解出现之前，程序的元数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。\n\n比如，下面这段代码：\n\n```java\n@Override\npublic String toString() {\n    return \"This is String.\";\n}\n```\n\n上面的代码中，我重写了`toString()`方法并使用了`@Override`注解。但是，即使我们不使用`@Override`注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，`@Override`告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将`toString()`写成了`toStrring(){double r}`，而且我也没有使用`@Override`注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。\n\n### 2. 为什么要引入注解\n\n使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。\n\n假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用注解会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。\n\n另一个很重要的因素是注解定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记接口，注释，`transient`关键字等等。每个程序员按照自己的方式定义元数据，而不像注解这种标准的方式。\n\n目前，许多框架将`XML`和`Annotation`两种方式结合使用，平衡两者之间的利弊。\n\n## Java基本注解\n\n在`java.lang`包下，JAVA提供了5个基本注解。\n\n### 1. @Override\n\n`@Override`用于标注重写了父类的方法。对于子类中被`@Override`修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。`@Override`只能作用于方法，不能作用于其他程序元素。\n\n### 2. @Deprecated\n\n`@Deprecated`用于表示某个程序元素（类、方法等）已过时。如果使用了被`@Deprecated`修饰的类或方法等，编译器会发出警告。\n\n### 3. @SuppressWarnings\n\n`@SuppressWarnings`用于抑制编译器的警告。指示被`@SuppressWarnings`修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法）取消显示指定的编译器警告。例如，常见的`@SuppressWarnings（value=\"unchecked\"）`。\n\n`SuppressWarnings`注解的常见参数值主要有以下几种：\n\n- `deprecation`：使用了不赞成使用的类或方法时的警告(使用`@Deprecated`使得编译器产生的警告)；\n- `unchecked`：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告\n- `fallthrough`：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;\n- `path`：在类路径、源文件路径等中有不存在的路径时的警告;\n- `serial`：当在可序列化的类上缺少 serialVersionUID 定义时的警告;\n- `finally`：任何 finally 子句不能正常完成时的警告;\n- `all`：关于以上所有情况的警告。\n\n### 4. @SafeVarargs\n\n`@SafeVarargs`是JDK 7 专门为抑制**堆污染**警告提供的。\n\n### 5. @FunctionalInterface\n\n`@FunctionalInterface`是Java8中新增的函数式接口。Java8规定：如果接口中只有一个抽象方法（可以包含多个默认方法或多个`static`方法），该接口称为函数式接口。如以下代码：\n\n```java\n@FunctionalInterface\npublic interface Fun {\n\n    static void foo() {\n        System.out.println(\"foo类方法\")；\n    }\n\n    default void bar() {\n        System.out.println(\"bar默认方法\")；\n    }\n\n    void test(); //只定义了一个抽象方法\n\n}\n```\n\n> **注**：如在上面的接口中再加一个抽象方法`abc()`，则会编译出错。\n\n## 元注解\n\n**元注解(`meta-annotation`)**是指注解的注解。Java5定义了5个标准的元注解类型，它们被用来提供对其它注解的类型作说明。接下来介绍这五个元注解。\n\n### 1. @Retention\n\n`@Retention`指明了该注解被保留的时间长短。包含一个名为`value`的成员变量，该value成员变量是`RetentionPolicy`枚举类型。使用`@Retention`时，必须为其value指定值。value成员变量的值只能是如下3个：\n\n- `SOURCE`：只保留在源代码中，编译器编译时，直接丢弃这种注解，不记录在`.class`文件中。\n- `CLASS`：编译器把注解记录在`class`文件中。当运行Java程序时，JVM中不可获取该注解信息，这是默认值。\n- `RUNTIME`：编译器把注解记录在`class`文件中。当运行Java程序时，JVM可获取该注解信息，程序可以通过反射获取该注解的信息。\n\n### 2. @Target\n\n`@Target`指定注解用于修饰哪些程序元素。`@Target`也包含一个名为`value`的成员变量，该value成员变量类型为`ElementType[]`，`ElementType`也为枚举类型，值有如下几个：\n\n- `TYPE`：修饰类、接口或枚举类型\n- `FIELD`：修饰成员变量（包括枚举常量）\n- `METHOD`：修饰方法\n- `PARAMETER`：修饰参数\n- `CONSTRUCTOR`：修饰构造器\n- `LOCAL_VARIABLE`：修饰局部变量\n- `ANNOTATION_TYPE`：修饰注解\n- `PACKAGE`：修饰包\n- `TYPE_PARAMETER`：Java8新增，修饰类型参数。\n- `TYPE_USE`：Java8新增，可以在任何类型上使用\n\n#### 类型注解（Java8新增）\n\n在 Java8 之前的版本中，只能允许在声明式前使用注解。而在 Java8 版本中，注解可以被用在任何使用 Type 的地方，例如：初始化对象时 (new)，对象类型转化时，使用 implements 表达式时，或者使用 throws 表达式时。\n\n```java\n//初始化对象时\nString myString = new @NotNull String();\n\n//对象类型转化时\nmyString = (@NonNull String) str;\n\n//使用 implements 表达式时\nclass MyList<T> implements @ReadOnly List<@ReadOnly T>{\n    ...\n}\n //使用 throws 表达式时\npublic void validateValues() throws @Critical ValidationFailedException{\n    ...\n }\n```\n\n定义一个类型的方法与普通的注解类似，只需要指定`Target`为`ElementType.TYPE_PARAMETER`或者`ElementType.TYPE_USE`，或者同时指定这两个`Target`。\n\n```java\n@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\npublic  @interface MyAnnotation {\n    ...\n}\n```\n\n`ElementType.TYPE_PARAMETER`表示这个注解可以用在 Type 的声明式前，而`ElementType.TYPE_USE`表示这个注解可以用在所有使用 Type 的地方（如：泛型，类型转换等）\n\n与 Java 8 之前的注解类似的是，类型也可以通过设置 Retention 在编译后保留在 class 文件中（RetentionPolicy.CLASS）或者运行时可访问（RetentionPolicy.RUNTIME）。但是与之前不同的是，类型注解有两个新的特性：在本地变量上的注解可以保留在`class`文件中，以及泛型类型可以被保留甚至在运行时被访问。\n\n虽然类型可以保留在 class 文件中，但是它并不会改变程序代码本身的行为。例如在一个方法前加上注解，调用此方法返回的结果和不加注解的时候一致。\n\nJava8 通过引入类型，使得开发者可以在更多的地方使用注解，从而能够更全面地对代码进行分析以及进行更强的类型检查。\n\n### 3. @Inherited\n\n`@Inherited`指定注解具有继承性。如果某个类使用了`@xxx`注解（定义该注解时使用了`@Inherited`修饰）修饰，则其子类将自动被`@xxx`修饰。\n\n### 4. @Documented\n\n如果定义注解A时，使用了`@Documented`修饰定义，则在用Javadoc命令生成API文档后，所有使用注解A修饰的程序元素，将会包含注解A的说明。\n\n### 5. @Repeatable（Java8新增）\n\n`@Repeatable`表示可重复注解。在实际应用中，可能会出现需要对同一个声明式或者类型加上相同的注解（包含不同的属性值）的情况。例如系统中除了管理员之外，还添加了超级管理员这一权限，对于某些只能由这两种角色调用的特定方法，可以使用可重复注解。\n\n```java\n@Access(role=\"SuperAdministrator\")\n@Access(role=\"Administrator\")\npublic void doCheck() {\n    ...\n}\n```\n\nJava8之前版本的 JDK 并不允许开发者在同一个声明式前加注同样的注解，（即使属性值不同）这样的代码在编译过程中会提示错误。而 Java8 解除了这一限制，开发者可以根据各自系统中的实际需求在所有可以使用注解的地方使用可重复注解。\n\n由于兼容性的缘故，可重复注解并不是所有新定义的注解的默认特性，需要开发者根据自己的需求决定新定义的注解是否可以重复注解。Java 编译器会自动把可重复注解储存到指定的注解容器中。而为了触发编译器进行这一操作，开发者需要进行以下的定义：\n\n首先，在需要重复标注特性的注解前加上`@Repeatable`标签，示例如下：\n\n```java\n@Repeatable(AccessContainer.class)\npublic @interface Access {\n\n    String role();\n\n}\n```\n\n`@Repeatable`标签后括号中的值即为指定的注解容器的类型。在这个例子中，注解容器的类型是`AccessContainer`，Java 编译器会把重复的 Access 对象保存在 AccessContainer 中。\n\nAccessContainer 中必须定义返回数组类型的 value 方法。数组中元素的类型必须为对应的可重复注解类型。具体示例如下：\n\n```java\npublic @interface AccessContainer {\n    Access[] value();\n}\n```\n\n可以通过 Java 的反射机制获取注解的 Annotation。一种方式是通过 AnnotatedElement 接口的`getAnnotationByType(Class<T>)`。首先获得 Container Annotation，然后再通过 Container Annotation 的 value 方法获得可重复注解。另一种方式是用过 AnnotatedElement 接口的`getAnnotations(Class<T>)`方法一次性返回可重复注解。\n\n可重复注解使得开发者可以根据具体的需求对同一个声明式或者类型加上同一类型的注解，从而增加代码的灵活性和可读性。\n\n## 自定义注解及解析\n\n### 1. 自定义注解\n\n创建Java的自定义注解和创建一个接口相似，但是注解的`interface`关键字需要以`@`符号开头。我们可以为注解声明方法。我们先来看看一个自定义注解的示例：\n\n```java\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Inherited;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Inherited\n@Documented\npublic @interface MethodInfo {\n\n    String author() default 'blinkfox';\n\n    String date();\n\n    int revision() default 1;\n\n    String comments();\n\n}\n```\n\n自定义注解就需要用到上面所介绍到的几种元注解，可以看出元注解就是用来注解其它注解。自定义注解和接口类似，只能定义**方法**，注解中的**方法**需要遵循以下几种规则：\n\n- 注解方法不能带有参数；\n- 注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组；\n- 注解方法可以有默认值。\n\n### 2. 注解的解析\n\n要解析Java中的注解需要使用Java反射技术。那么注解的`RetentionPolicy`应该设置为`RUNTIME`，否则Java类的注解信息在执行过程中将不可用，我们也就不能从中得到任何和注解有关的数据。以下是解析注解常用的几种方法的示例代码：\n\n```java\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class AnnotationParsing {\n\n    private static final Logger log = LoggerFactory.getLogger(AnnotationParsing.class);\n\n    public static void main(String[] args) {\n        try {\n            for (Method method : AnnotationParsing.class.getClassLoader()\n                .loadClass(('com.journaldev.annotations.AnnotationExample')).getMethods()) {\n                // checks if MethodInfo annotation is present for the method\n                if (method.isAnnotationPresent(com.journaldev.annotations.MethodInfo.class)) {\n                // iterates all the annotations available in the method\n                    for (Annotation anno : method.getDeclaredAnnotations()) {\n                        System.out.println('Annotation in Method ''+ method + '' : ' + anno);\n                    }\n\n                    MethodInfo methodAnno = method.getAnnotation(MethodInfo.class);\n                    if (methodAnno.revision() == 1) {\n                        System.out.println('Method with revision no 1 = '+ method);\n                    }\n                }\n            }\n        } catch (Exception e) {\n                log.error(\"解析Java注解出错!\", e);\n        }\n    }\n\n}\n```\n\n## 注解的应用之监控方法执行耗时\n\n通过前面对元注解的介绍，我们就可以自定义我们需要的注解了。假如，我们需要监控某些方法的执行，最原始的办法就是在方法执行的开头和结尾分别记录时间，最后计算前后的时间差即可，但是这些代码与核心业务无关，且大量重复、分散在各处，维护起来也困难。这时我们可以[使用Spring AOP来统计方法的执行耗时](http://blinkfox.com/shi-yong-spring-aoplai-tong-ji-fang-fa-de-zhi-xing-shi-jian/)，同时我们也可以使用注解的方式来实现，更自由灵活。\n\n首先，定义我们的执行耗时的方法上的注解：\n\n```java\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 自定义'统计方法耗时'并打印日志的注解.\n *\n * @author blinkfox on 2017-01-04.\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\n@Documented\npublic @interface CostTime {\n\n    /**\n     * 执行超过某毫秒数时数则打印'warn'级别的日志，默认 0ms，即默认都打印.\n     *\n     * @return 毫秒数\n     */\n    long value() default 0;\n\n}\n```\n\n然后，书写监控所标注有`@CostTime`注解的方法代理类：\n\n```java\nimport java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * 被标注为'@CostTime'注解的方法执行耗时的代理方法.\n * <p>实现了cglib中的`MethodInterceptor`的方法拦截接口.</p>\n *\n * @author blinkfox on 2017-01-04.\n */\npublic class CostTimeProxy implements MethodInterceptor {\n\n    private static final Logger log = LoggerFactory.getLogger(CostTimeProxy.class);\n\n    private Enhancer enhancer = new Enhancer();\n\n    /**\n     * 获取代理类.\n     *\n     * @param cls 代理类的class\n     * @return 代理类实例\n     */\n    public Object getProxy(Class cls) {\n        enhancer.setSuperclass(cls);\n        enhancer.setCallback(this);\n        return enhancer.create();\n    }\n\n    /**\n     * 拦截方法,判断是否有'@CostTime'的注解，如果有则拦截执行.\n     *\n     * @param o 对象\n     * @param method 方法\n     * @param args 参数\n     * @param methodProxy 代理方法\n     * @return 对象\n     * @throws Throwable 问题\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        // 判断该方法上是否有 CostTime 注解\n        if (!method.isAnnotationPresent(CostTime.class)) {\n            return methodProxy.invokeSuper(o, args);\n        }\n        // 获取注解信息\n        CostTime costTime = method.getAnnotation(CostTime.class);\n        long limitTime = costTime.value();\n\n        // 记录方法执行前后的耗时时间，并做差，判断是否需要打印方法执行耗时\n        long startTime = System.currentTimeMillis();\n        Object result = methodProxy.invokeSuper(o, args);\n        long diffTime = System.currentTimeMillis() - startTime;\n        if (limitTime <= 0 || (diffTime >= limitTime)) {\n            String methodName = method.getName();\n            // 打印耗时的信息\n            log.warn(\"【CostTime监控】通过注解监控方法'{}'的执行耗时为:{}\", methodName, diffTime);\n        }\n        return result;\n    }\n\n}\n```\n\n接着，可以写一些业务类及方法，这里就以`A`类为例：\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A类.\n *\n * @author blinkfox on 2017/1/1.\n */\npublic class A {\n\n    private static final Logger log = LoggerFactory.getLogger(A.class);\n\n    /**\n     * 始终打印方法执行耗时的方法.\n     */\n    @CostTime\n    public void doSomeThing() {\n        log.info(\"执行A类中doSomeThing()方法！\");\n    }\n\n    /**\n     * 当方法执行耗时大于等于'50ms'时打印出方法执行耗时.\n     */\n    @CostTime(50)\n    public void doSomeThing2() {\n        log.info(\"执行A类中doSomeThing2()方法！\");\n    }\n\n}\n```\n\n最后，是用来测试`A`类某些业务方法执行耗时的测试类：\n\n```java\npackage com.blinkfox.test.reflect;\n\n/**\n * 耗时注解使用测试示例\n * Created by blinkfox on 2017-01-04.\n */\npublic class CostTimeTest {\n\n    /** A类的全局实例. */\n    private static A a;\n\n    static {\n        CostTimeProxy aproxy = new CostTimeProxy();\n        a = (A) aproxy.getProxy(A.class);\n    }\n\n    /**\n     * main 方法.\n     *\n     * @param args 数组参数\n     */\n    public static void main(String[] args) {\n        a.doSomeThing();\n        a.doSomeThing2();\n    }\n\n}\n```\n\n这就完成了对A类被标注了`@CostTime`注解的方法执行耗时的监控。当然你可以配置需要扫描的包(`package`)下的所有类中被标注为`@CostTime`注解的方法的执行耗时，这里就不介绍了。\n\n---\n\n参考文档：\n\n- [Java注解教程及自定义注解](http://www.importnew.com/17413.html)\n- [Java 8 Annotation 新特性在软件质量和开发效率方面的提升](https://www.ibm.com/developerworks/cn/java/j-lo-java8annotation/)\n- [Java内置系统注解和元注解](http://blog.csdn.net/u014207606/article/details/52291951)","tags":["Java"],"categories":["后端"]},{"title":"Java反射基础","url":"/2018/110753.html","content":"\n## 一、概述\n\n### 1. 简介\n\nJava反射(`Reflection`)机制就是在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。对于任意一个对象能够调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能称为Java语言的反射机制。Java程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。\n\n反射的核心是JVM在**运行时**才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。反射机制就是通过`java.lang.Class`类来实现的，在Java中，Object 类是所有类的根类，而Class类就是描述Java类的类。\n\n> **注**：因为Class类也是类，所以Object也包括Class类。\n\n### 2. 主要功能\n\nJava反射框架主要提供以下功能：\n\n- 在运行时判断任意一个对象所属的类；\n- 在运行时构造任意一个类的对象；\n- 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；\n- 在运行时调用任意一个对象的方法；\n- 修改构造函数、方法、属性的可见性。\n\n### 3. 主要用途\n\n**反射最重要的用途就是开发各种通用框架**。很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。\n\n## 二、反射的使用\n\n### 1. 获取Class对象\n\n反射的各种功能都需要通过Class对象来实现，因此，需要知道如何获取Class对象，主要有以下几种方式。\n\n#### 使用 Class.forName() 的静态方法\n\n`Class.forName(String className)`方法可以通过类或接口的名称（一个字符串或完全限定名）来获取对应的Class对象。\n\n```java\nClass<?> cls = Class.forName(\"com.blinkfox.Zealot\");\n```\n\n#### 直接获取某个类的class(最安全/性能最好)\n\n```java\nClass<String> cls = String.class;\n```\n\n#### 调用某个对象的 getClass() 方法\n\n```java\nClass<String> cls = str.getClass();\n```\n\n### 2. 判断是否为某个类的实例\n\n一般地，我们用`instanceof`关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的`isInstance()`方法来判断是否为某个类的实例，它是一个Native方法：\n\n```java\npublic native boolean isInstance(Object obj);\n```\n\n### 3. 创建实例\n\n通过反射来生成对象主要有两种方式。\n\n#### 使用Class对象的newInstance()方法\n\n```java\nClass<?> c = String.class;\nObject str = c.newInstance();\n```\n\n#### 通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法\n\n```java\n// 获取String所对应的Class对象\nClass<?> c = String.class;\n// 获取String类带一个String参数的构造器\nConstructor constructor = c.getConstructor(String.class);\n// 根据构造器创建实例\nObject obj = constructor.newInstance(\"23333\");\nSystem.out.println(obj);\n```\n\n> **注**：这种方法可以用指定的构造器构造类的实例。\n\n### 4. 获取方法\n\n获取某个Class对象的方法集合，主要有以下几个方法：\n\n- `getDeclaredMethods()`方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\n\n```java\npublic Method[] getDeclaredMethods() throws SecurityException\n```\n\n- `getMethods()`方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。\n\n```java\npublic Method[] getMethods() throws SecurityException\n```\n\n- `getMethod()`方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。\n\n```java\npublic Method getMethod(String name, Class<?>... parameterTypes)\n```\n\n代码示例：\n\n```java\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Test {\n\n    public static void test() throws IllegalAccessException,\n            InstantiationException, NoSuchMethodException, InvocationTargetException {\n        Class<?> c = MethodClass.class;\n        Object object = c.newInstance();\n        Method[] methods = c.getMethods();\n        Method[] declaredMethods = c.getDeclaredMethods();\n        //获取MethodClass类的add方法\n        Method method = c.getMethod(\"add\", int.class, int.class);\n\n        //getMethods()方法获取的所有方法\n        System.out.println(\"getMethods获取的方法：\");\n        for(Method m: methods) {\n            System.out.println(m);\n        }\n\n        //getDeclaredMethods()方法获取的所有方法\n        System.out.println(\"getDeclaredMethods获取的方法：\");\n        for(Method m: declaredMethods) {\n            System.out.println(m);\n        }\n    }\n}\n\nclass MethodClass {\n\n    public final int fuck = 3;\n\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public int sub(int a, int b) {\n        return a - b;\n    }\n\n}\n```\n\n> **注**：通过`getMethods()`获取的方法可以获取到父类的方法,比如`java.lang.Object`下定义的各个方法。\n\n### 5. 获取构造方法\n\n获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的`getConstructor`方法得到`Constructor`类的一个实例，而Constructor类有一个`newInstance`方法可以创建一个对象实例:\n\n```java\npublic T newInstance(Object ... initargs)\n```\n\n> **注**：此方法可以根据传入的参数来调用对应的Constructor创建对象实例。\n\n### 6. 获取类的成员变量信息\n\n获取的方法同Method相似，主要是这几个方法，在此不再赘述：\n\n- `Field getField(String name)`: 访问公有的成员变量。\n- `Field[] getDeclaredFields()`：所有已声明的成员变量。但不能得到其父类的成员变量。\n- `Field[] getFields()`和`Field[] getDeclaredFields()`用法同上。\n\n### 7. 调用方法\n\n当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:\n\n```java\npublic Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException,\n InvocationTargetException\n```\n\n代码示例：\n\n```java\npublic class Test {\n\n    public static void main(String[] args) throws IllegalAccessException,\n            InstantiationException, NoSuchMethodException, InvocationTargetException {\n        Class<?> klass = MethodClass.class;\n        //创建 MethodClass 的实例\n        Object obj = klass.newInstance();\n        //获取 MethodClass 类的add方法\n        Method method = klass.getMethod(\"add\", int.class, int.class);\n        //调用 method 对应的方法 => add(1,4)\n        Object result = method.invoke(obj, 1, 4);\n        System.out.println(result);\n    }\n}\n\nclass MethodClass {\n\n    public final int fuck = 3;\n\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public int sub(int a, int b) {\n        return a - b;\n    }\n\n}\n```\n\n### 8. 利用反射创建数组\n\n数组在Java里是比较特殊的一种类型，它可以赋值给一个`Object Reference`。下面我们看一看利用反射创建数组的例子：\n\n```java\npublic static void testArray() throws ClassNotFoundException {\n    // 使用`java.lang.reflect.Array`反射创建长度为25的字符串数组.\n    Class<?> cls = Class.forName(\"java.lang.String\");\n    Object array = Array.newInstance(cls, 25);\n    // 往数组里添加内容\n    Array.set(array,0, \"hello\");\n    Array.set(array,1, \"Java\");\n    Array.set(array,2, \"Go\");\n    Array.set(array,3, \"Scala\");\n    Array.set(array,4, \"Clojure\");\n    // 获取某一项的内容\n    System.out.println(Array.get(array, 3));\n}\n```\n\n## 三、使用反射获取信息\n\nClass类提供了大量的实例方法来获取该Class对象所对应的详细信息，Class类大致包含如下方法，其中每个方法都包含多个重载版本，因此我们只是做简单的介绍，详细请参考[JDK文档](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html)。\n\n### 1. 获取类内信息\n\n- 构造器: `Constructor<T> getConstructor(Class<?>... parameterTypes)`\n- 包含的方法: `Method getMethod(String name, Class<?>... parameterTypes)`\n- 包含的属性: `Field getField(String name)`\n- 包含的Annotation: `<A extends Annotation> A getAnnotation(Class<A> annotationClass)`\n- 内部类: `Class<?>[] getDeclaredClasses()`\n- 外部类: `Class<?> getDeclaringClass()`\n- 所实现的接口: `Class<?>[] getInterfaces()`\n- 修饰符: `int getModifiers()`\n- 所在包: `Package getPackage()`\n- 类名: `String getName()`\n- 简称: `String getSimpleName()`\n\n### 2. 判断类本身信息的方法\n\n- 是否注解类型: `boolean isAnnotation()`\n- 是否使用了该Annotation修饰: `boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)`\n- 是否匿名类: `boolean isAnonymousClass()`\n- 是否数组: `boolean isArray()`\n- 是否枚举: `boolean isEnum()`\n- 是否原始类型: `boolean isPrimitive()`\n- 是否接口: `boolean isInterface()`\n- obj是否是该Class的实例: `boolean isInstance(Object obj)`\n\n### 3. 使用反射获取泛型信息\n\n为了通过反射操作泛型以迎合实际开发的需要, Java新增了`java.lang.reflect.ParameterizedType`、`java.lang.reflect.GenericArrayType`、`java.lang.reflect.TypeVariable`、`java.lang.reflect.WildcardType`几种类型来代表不能归一到Class类型但是又和原始类型同样重要的类型。\n\n- `ParameterizedType`: 一种参数化类型, 比如Collection<String>\n- `GenericArrayType`: 一种元素类型是参数化类型或者类型变量的数组类型\n- `TypeVariable`: 各种类型变量的公共接口\n- `WildcardType`: 一种通配符类型表达式, 如`?`、`? extends Number`、`? super Integer`\n\n代码示例：\n\n```java\npublic class Client {\n\n    private Map<String, Object> objectMap;\n\n    public void test(Map<String, User> map, String string) {\n    }\n\n    public Map<User, Bean> test() {\n        return null;\n    }\n\n    /**\n     * 测试属性类型\n     *\n     * @throws NoSuchFieldException\n     */\n    @Test\n    public void testFieldType() throws NoSuchFieldException {\n        Field field = Client.class.getDeclaredField(\"objectMap\");\n        Type gType = field.getGenericType();\n        // 打印type与generic type的区别\n        System.out.println(field.getType());\n        System.out.println(gType);\n        System.out.println(\"**************\");\n        if (gType instanceof ParameterizedType) {\n            ParameterizedType pType = (ParameterizedType) gType;\n            Type[] types = pType.getActualTypeArguments();\n            for (Type type : types) {\n                System.out.println(type.toString());\n            }\n        }\n    }\n\n    /**\n     * 测试参数类型\n     *\n     * @throws NoSuchMethodException\n     */\n    @Test\n    public void testParamType() throws NoSuchMethodException {\n        Method testMethod = Client.class.getMethod(\"test\", Map.class, String.class);\n        Type[] parameterTypes = testMethod.getGenericParameterTypes();\n        for (Type type : parameterTypes) {\n            System.out.println(\"type -> \" + type);\n            if (type instanceof ParameterizedType) {\n                Type[] actualTypes = ((ParameterizedType) type).getActualTypeArguments();\n                for (Type actualType : actualTypes) {\n                    System.out.println(\"\\tactual type -> \" + actualType);\n                }\n            }\n        }\n    }\n\n    /**\n     * 测试返回值类型\n     *\n     * @throws NoSuchMethodException\n     */\n    @Test\n    public void testReturnType() throws NoSuchMethodException {\n        Method testMethod = Client.class.getMethod(\"test\");\n        Type returnType = testMethod.getGenericReturnType();\n        System.out.println(\"return type -> \" + returnType);\n\n        if (returnType instanceof ParameterizedType) {\n            Type[] actualTypes = ((ParameterizedType) returnType).getActualTypeArguments();\n            for (Type actualType : actualTypes) {\n                System.out.println(\"\\tactual type -> \" + actualType);\n            }\n        }\n    }\n}\n```\n\n---\n\n参考文档：[Java反射基础](http://www.sczyh30.com/posts/Java/java-reflection-1/)","tags":["Java"],"categories":["后端"]},{"title":"Java面向对象设计之责任链模式","url":"/2018/110429724.html","content":"\n## 模式动机\n\n很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。\n\n## 模式定义\n\n> **定义**：责任链模式(`Chain of Responsibility Pattern`)是使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。\n\n**实质**：责任链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。\n\n## 模式结构\n\n### 参与角色\n\n- `Handler`（抽象处理者）：处理请求的接口，一般设计为具有抽象请求处理方法的抽象类，以便于不同的具体处理者进行继承，从而实现具体的请求处理方法。此外，由于每一个请求处理者的下家还是一个处理者，因此抽象处理者本身还包含了一个本身的引用(`nextHandler`)作为其对下家的引用，以便将处理者链成一条链；\n- `ConcreteHandler`（具体处理者）：抽象处理者的子类，可以处理用户请求，其实现了抽象处理者中定义的请求处理方法。在具体处理请求时需要进行判断，若其具有相应的处理权限，那么就处理它；否则，其将请求转发给后继者，以便让后面的处理者进行处理。\n\n在责任链模式里，由每一个请求处理者对象对其下家的引用而连接起来形成一条请求处理链。请求将在这条链上一直传递，直到链上的某一个请求处理者能够处理此请求。**发出这个请求的客户端并不知道链上的哪一个请求处理者将处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任**。\n\n### UML类图\n\n![责任链模式UML类图](http://static.blinkfox.com/chain_of_responsibility.png)\n\n## 代码示例\n\n首先，责任链模式的核心在于对请求处理者的抽象。在实现过程中，抽象处理者一般会被设定为**抽象类**，其典型实现代码如下所示：\n\n```java\n/**\n * 责任连模式的抽象处理者角色.\n *\n * Created by blinkfox on 16/7/11.\n */\npublic abstract class Handler {\n\n    /** 后继处理者角色. */\n    protected Handler nextHandler;\n\n    /**\n     * 处理请求的抽象方法.\n     *\n     * @param condition 条件\n     */\n    public abstract void handle(String condition);\n\n    /**\n     * nextHandler的Setter方法.\n     *\n     * @param nextHandler 后继处理器\n     */\n    public void setNextHandler(Handler nextHandler) {\n        this.nextHandler = nextHandler;\n    }\n\n}\n```\n\n其次，是若干个具体的处理角色类。\n\n```java\n/**\n * 具体处理角色1.\n *\n * Created by blinkfox on 16/7/11.\n */\npublic class ConcreteHandler1 extends Handler {\n\n    /**\n     * 具体处理角色1的处理方法.\n     *\n     * @param condition 条件\n     */\n    @Override\n    public void handle(String condition) {\n        // 如果是自己的责任，就自己处理，负责传给下家处理\n        if (\"ConcreteHandler1\".equals(condition)) {\n            System.out.println( \"具体处理角色1的处理方法handled1...\");\n        } else {\n            System.out.println( \"具体处理角色1 通过...\");\n            nextHandler.handle(condition);\n        }\n    }\n\n}\n```\n\n```java\n/**\n * 具体处理角色2.\n *\n * Created by blinkfox on 16/7/11.\n */\npublic class ConcreteHandler2 extends Handler {\n\n    /**\n     * 具体处理角色2的处理方法.\n     *\n     * @param condition 条件\n     */\n    @Override\n    public void handle(String condition) {\n        // 如果是自己的责任，就自己处理，负责传给下家处理\n        if (\"ConcreteHandler2\".equals(condition)) {\n            System.out.println( \"具体处理角色2的处理方法handled1...\");\n        } else {\n            System.out.println( \"具体处理角色2 通过...\");\n            nextHandler.handle(condition);\n        }\n    }\n\n}\n```\n\n```java\n/**\n * 具体处理角色n.\n *\n * Created by blinkfox on 16/7/11.\n */\npublic class ConcreteHandlerN extends Handler {\n\n    /**\n     * 这里假设n是链的最后一个节点必须处理掉.\n     * 在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点.\n     *\n     * @param condition 参数条件\n     */\n    @Override\n    public void handle(String condition) {\n        System.out.println( \"具体处理角色n的处理方法 结束...\");\n    }\n\n}\n```\n\n最后，是客户端场景类，代码调用示例如下：\n\n```java\n/**\n * 责任连模式的客户端场景类.\n *\n * Created by blinkfox on 16/7/11.\n */\npublic class ChainClient {\n\n    /**\n     * 主入口方法.\n     *\n     * @param args 数组参数\n     */\n    public static void main(String[] args) {\n        Handler handler1 = new ConcreteHandler1();\n        Handler handler2 = new ConcreteHandler2();\n        Handler handlern = new ConcreteHandlerN();\n\n        handler1.setNextHandler(handler2);\n        handler2.setNextHandler(handlern);\n\n        //假设这个请求是ConcreteHandler2的责任\n        handler1.handle(\"ConcreteHandler2\");\n    }\n\n}\n```\n\n> **注**：责任链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般由使用该责任链的客户端创建。职责链模式降低了请求的发送者和请求处理者之间的耦合，从而使得多个请求处理者都有机会处理这个请求。\n\n## 模式分析\n\n### 使用场景\n\n在实际软件开发中，如果遇到有多个对象可以处理同一请求时可以考虑使用职责链模式，最常见的例子包括在 Java Web 应用开发中创建一个过滤器（Filter）链来对请求数据进行过滤（中文字符乱码的处理）、在工作流系统中实现公文的分级审批、在Struts应用中添加不同的拦截器(常用的有类型转化、异常处理，数据校验…)以增强Struts2的功能等。\n\n### 纯与不纯的责任链模式\n\n- **纯的责任链模式**要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况；\n- 在纯责任链模式里面，一个请求必须被某一个处理者对象所接收；\n- 在不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。\n\n纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。\n\n### 优点\n\n- 降低耦合度，使请求的发送者和接收者解耦，便于灵活的、可插拔的定义请求处理过程；\n- 简化、封装了请求的处理过程，并且这个过程对客户端而言是透明的，以便于动态地重新组织链以及分配责任，增强请求处理的灵活性；\n- 可以从职责链任何一个节点开始，也可以随时改变内部的请求处理规则，每个请求处理者都可以去动态地指定他的继任者；\n- 职责链可简化对象间的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用；\n- 增加新的请求处理类很方便。\n\n### 缺点\n\n- 不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理；\n- 该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理；\n- 系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。\n\n## 总结\n\n- 在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。\n- 职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java面向对象设计之单例模式","url":"/2018/102929438.html","content":"\n## 模式动机\n\n对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。\n\n如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。\n\n一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。\n\n## 模式定义\n\n> **单例模式(`Singleton Pattern`)**：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种**对象创建型模式**。单例模式又名单件模式或单态模式。\n\n单例模式的要点有三个：\n\n- 一是某个类只能有一个实例；\n- 二是它必须自行创建这个实例；\n- 三是它必须自行向整个系统提供这个实例。\n\n## 模式结构\n\n### 参与角色\n\n- `Singleton`: 单例\n\n### UML类图\n\n![单例模式UML类图](http://static.blinkfox.com/Java_design_singleton_uml.jpg)\n\n### 时序图\n\n![单例模式时序图](http://static.blinkfox.com/Java_design_singleton_seq.jpg)\n\n## 代码实现方式\n\n### 1. 饿汉式（推荐使用）\n\n```java\n/**\n * 饿汉式单例模式.\n *\n * @author blinkfox on 2017-10-23.\n */\npublic class Singleton {\n\n    /** 全局唯一实例. */\n    private static final Singleton singleton = new Singleton();\n\n    private Singleton() {}\n\n    public static Singleton getSingleton() {\n        return singleton;\n    }\n\n}\n```\n\n> **注**：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。\n\n### 2. 非线程安全懒汉式（不推荐使用）\n\n```java\n/**\n * 非线程安全的懒汉式.\n *\n * @author blinkfox on 2017-10-23.\n */\npublic class Singleton {\n\n    private static Singleton singleton;\n\n    private Singleton() {}\n\n    /**\n     * 通过懒加载的方式获取实例，但是非线程安全.\n     * @return Singleton实例\n     */\n    public static Singleton getSingleton() {\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n\n}\n```\n\n> **注**：是懒加载的方式，但非线程安全。不推荐使用。\n\n### 3. 低效的线程安全懒汉式（不推荐使用）\n\n```java\n/**\n * 低效的线程安全的懒汉式.\n *\n * @author blinkfox on 2017-10-23.\n */\npublic class Singleton {\n\n    private static Singleton singleton;\n\n    private Singleton() {}\n\n    /**\n     * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例.\n     * @return Singleton实例\n     */\n    public static synchronized Singleton getSingleton() {\n        if (singleton == null) {\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n\n}\n```\n\n> **注**：是懒加载的方式，也线程安全，但是效率很低。因为99%的情况下是不需要去同步的。不推荐使用。\n\n### 4. 双重校验锁线程安全懒汉式（不推荐使用）\n\n```java\n/**\n * 双重校验锁线程安全懒汉式.\n *\n * @author blinkfox on 2017-10-23.\n */\npublic class Singleton {\n\n    private static Singleton singleton;\n\n    private Singleton() {}\n\n    /**\n     * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例.\n     * @return Singleton实例\n     */\n    public static Singleton getSingleton() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n```\n\n> **注**：是懒加载的方式，也线程安全，效率也不错。但受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。\n\n### 5. 枚举式（强烈推荐使用）\n\n```java\n/**\n * 枚举方式的单例.\n *\n * @author blinkfox on 2017-10-23.\n */\npublic enum Singleton {\n\n    INSTANCE;\n\n}\n```\n\n> **注**：在`《Effective Java》`一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。\n\n### 6. 静态内部类（推荐使用）\n\n```java\n/**\n * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例.\n *\n * @author blinkfox on 2017-10-23.\n */\npublic class Singleton {\n\n    private Singleton() {}\n\n    /**\n     * 静态内部类.\n     */\n    private static final class SingletonHolder {\n\n        private SingletonHolder() {}\n\n        private static Singleton4 instance = new Singleton();\n\n    }\n\n    /**\n     * 通过懒加载的方式获取Singleton唯一实例的方法.\n     * @return Singleton实例\n     */\n    public static Singleton getInstance() {\n        return SingletonHolder.instance;\n    }\n\n}\n```\n\n> **注**：这种方式利用了`ClassLoader`的机制保证初始化`instance`时只有一个线程，其只有显示通过调用`getInstance`方法时，才会显示装载`SingletonHolder`类，从而实例化`instance`。\n\n## 模式分析\n\n单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——`Singleton`。\n\n### 优点\n\n- 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。\n- 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。\n- 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。\n\n### 缺点\n\n- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。\n- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。\n- 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如`Java`、`C#`)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。\n\n### 适用环境\n\n在以下情况下可以使用单例模式：\n\n- 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。\n- 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。\n- 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。\n\n## 总结\n\n- 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。\n- 单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。\n- 实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。\n- 单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。\n- 单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java异常知识汇总","url":"/2018/102843025.html","content":"\n## 前言\n\n### 为什么要使用异常\n\n在我们的程序中，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：\n\n- 容易混淆。如果约定返回值为 -1 时表示出现异常，那么当程序最后的计算结果真的为 -1 呢？\n- 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。\n- 由调用函数来分析异常，这要求程序员对库函数有很深的了解。\n\n> 在面向对象编程中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。\n\n### 基本定义\n\n> 异常情形是指阻止当前方法或者作用域继续执行的问题。——《Think in java》\n\n总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。\n\n## 异常体系\n\n在Java中，所有的事件都能由类描述，Java中的异常就是由`java.lang`包下的异常类来描述的。Java定义了一个异常类的层次结构，其以`Throwable`（万物即可抛）开始，派生出了`Error`和`Exception`，而`Exception`又派生出了`CheckedException`和`RuntimeException`。如下图所示：\n\n![Java异常体系](http://static.blinkfox.com/java_exception.png)\n\n### Throwable\n\nThrowable（可抛出）是异常类的最终父类，它有两个子类，`Error`与`Exception`。\n\nThrowable 中常用方法有：\n\n- `synchronized Throwable getCause()`：此方法返回异常产生的原因，如果不知道原因的话返回`null`。\n- `String getMessage()`：方法返回`Throwable`的`String`型信息，当异常通过构造器创建后可用。\n- `String getLocalizedMessage()`：此方法通过被重写来得到用本地语言表示的异常信息返回给调用程序。`Throwable`类通常只是用`getMessage()`方法来实现返回异常信息。\n- `void printStackTrace()`：该方法打印栈轨迹信息到标准错误流。该方法能接受`PrintStream`和`PrintWriter`作为参数实现重载，这样就能实现打印栈轨迹到文件或流中。\n- `String toString()`：方法返回`String`格式的`Throwable`信息，此信息包括`Throwable`的名字和本地化信息。\n\n### Error\n\nError（错误）：表示程序无法处理的错误，一般与程序员的执行操作无关。理论上这些错误是不允许发生的，如果发生，也不应该试图通过程序去处理，所以 Error 不是`try-catch`的处理对象，而 JVM 一般的处理方式是终止发生错误的线程。Error 类常见子类有`VirtualMachineError`、`StackOverFlowError`、`OutOfMemoryError`等。\n\n在Java运行时内存中，除程序计数器外的虚拟机栈、堆、方法区在请求的内存无法被满足时都会抛出`OutOfMemoryError`；而如果线程请求的栈深度超出虚拟机允许的深度时，就会抛出`StackOverFlowError`。\n\n### Exception\n\nException（异常）：出现原因取决于程序，所以程序也理应通过`try-catch`处理。Exception 异常分为两类：`CheckedException`和`RuntimeException`，即**检查异常**与**运行时异常**。\n\n- 检查异常：编译器要求必须处理，否则不能通过编译，使用`try-catch`捕获或者`throws`抛出。常见的检查异常有`IOException`及其子类、`EOFExcption`(文件已结束异常)、`FileNotFoundException`（文件未找到异常）。\n- 运行时异常（也叫非检查异常）：编译期不会检查，所以在程序中可不处理，但如果发生，会在运行时抛出。\n\n## 异常处理\n\n### 处理机制\n\n在 Java 应用程序中，异常处理机制为：**抛出异常**、**捕捉异常**。\n\n- **抛出异常**：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。\n- **捕获异常**：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。\n\n对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。\n\n- 对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数 Error 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。\n- 对于所有的检查异常，Java规定：**一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉检查异常时，它必须声明将抛出异常**。\n- 对于所有运行时异常，Java规定：**运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常**。\n\n能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，**一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的**。\n\n任何Java代码都可以通过 Java 的`throw`语句抛出异常。\n\n从方法中抛出的任何异常都必须使用`throws`子句。\n\n捕捉异常通过`try-catch`语句或者`try-catch-finally`语句实现。\n\n> 总体来说，Java规定：对于检查异常必须捕捉、或者声明抛出。允许忽略非检查的`RuntimeException`和`Error`。\n\n### 处理方式\n\n`try-catch`语句还可以包括第三部分，就是`finally`子句。它表示无论是否出现异常，都应当执行的内容。`try-catch-finally`语句的一般语法形式为：\n\n```java\ntry {\n    // 可能会发生异常的程序代码\n} catch (Exception1 e1) {\n    // 捕获并处理try抛出的异常类型Type1\n} catch (Exception2 e2) {\n    // 捕获并处理try抛出的异常类型Type2\n} finally {\n    // 无论是否发生异常，都将执行的语句块\n}\n```\n\nJava7及之后的版本可这样使用：\n\n```java\ntry (MyResource mr = new MyResource()) {\n    System.out.println(\"MyResource created in try-with-resources\");\n} catch (Exception1 | Exception2 e) {\n    // 捕获并统一处理 try 抛出的多种异常类型，不需要finally块\n}\n```\n\n- `try`块：用于捕获异常。其后可接零个或多个`catch`块，如果没有`catch`块，则必须跟一个`finally`块。\n- `catch`块：用于处理`try`捕获到的异常。\n- `finally`块：无论是否捕获或处理异常，`finally`块里的语句都会被执行。当在`try`块或`catch`块中遇到`return`语句时，`finally`语句块将在方法返回之前被执行。在以下 4 种特殊情况下，`finally`块不会被执行：\n  - 在`finally`语句块中发生了异常\n  - 在前面的代码中用了`System.exit()`退出程序\n  - 程序所在的线程死亡\n  - 关闭`CPU`\n\n### 异常处理语句的语法规则\n\n- 必须在`try`之后添加`catch`或`finally`块。`try`块后可同时接`catch`和`finally`块，但至少有一个块。\n- 必须遵循块顺序：若代码同时使用`catch`和`finally`块，则必须将`catch`块放在`try`块之后。\n- `catch`块与相应的异常类的类型相关。\n- 一个`try`块可能有多个`catch`块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个`catch`代码块，不会再执行其他的`catch`代码块。\n- 可嵌套`try-catch-finally`结构。\n- 在`try-catch-finally`结构中，可重新抛出异常。\n- 除了下列情况，总将执行`finally`做为结束：\n  - JVM 过早终止（调用 System.exit(int)）；\n  - 在`finally`块中抛出一个未处理的异常；\n  - 计算机断电、失火、或遭遇病毒攻击。\n\n## 异常抛出\n\n任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的`throw`语句抛出异常。从方法中抛出的任何异常都必须使用`throws`子句。\n\n### throws抛出异常\n\n如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用`throws`子句来声明抛出异常。`throws`语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是`Exception`异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。`throws`语句的语法格式为：\n\n```java\nmethodname throws Exception1, Exception2, ... , ExceptionN {\n\n}\n```\n\n方法名后的`throws Exception1, Exception2, ... , ExceptionN`为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。使用`throws`关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。\n\nthrows抛出异常的规则：\n\n- 如果是非检查异常（`unchecked exception`），即`Error`、`RuntimeException`或它们的子类，那么可以不使用`throws`关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。\n- 必须声明方法可抛出的任何检查异常（`checked exception`）。即如果一个方法可能出现受检查异常，要么用`try-catch`语句捕获，要么用`throws`子句声明将它抛出，否则会导致编译错误。\n- 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。\n- 调用方法必须遵循任何检查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。\n\n### 使用throw抛出异常\n\n`throw`总是出现在函数体中，用来抛出一个`Throwable`类型的异常。程序会在`throw`语句后立即终止，它后面的语句执行不到，然后在包含它的所有`try`块中（可能在上层调用函数中）从里向外寻找含有与其匹配的`catch`子句的`try`块。异常是异常类的实例对象，我们可以创建异常类的实例对象通过`throw`语句抛出。该语句的语法格式为：\n\n```java\nthrow new ExceptionName();\n```\n\n> **注**：如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。\n\n### 异常链\n\n在设计模式中有一个设计模式叫做**责任链模式**，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：**异常链**。\n\n我们知道每遇到一个异常信息，我们都需要进行`try-catch-finally`,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个`Exception`解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。\n\n我们有两种方式处理异常，一是`throws`抛出交给上级处理，二是`try-catch`做具体处理。但是这个与上面有什么关联呢？`try-catch`的`catch`块我们可以不需要做任何处理，仅仅只用`throw`这个关键字将我们封装异常信息主动抛出来。然后在通过关键字`throws`继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。\n\n**通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性**。\n\n同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。\n\n在异常链的使用中，`throw`抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在`Throwable`及其子类中的构造器中都可以接受一个`cause`参数，该参数保存了原有的异常信息，通过`getCause()`就可以获取该原始异常信息。使用方式如下：\n\n```java\npublic class Test {\n\n    public void f() throws MyException{\n         try {\n             FileReader reader = new FileReader(\"test.txt\");\n             Scanner in = new Scanner(reader);\n             System.out.println(in.next());\n        } catch (FileNotFoundException e) {\n            //e 保存异常信息\n            throw new MyException(\"文件没有找到--01\", e);\n        }\n    }\n\n    public void g() throws MyException{\n        try {\n            f();\n        } catch (MyException e) {\n            //e 保存异常信息\n            throw new MyException(\"文件没有找到--02\", e);\n        }\n    }\n\n    public static void main(String[] args) {\n        Test t = new Test();\n        try {\n            t.g();\n        } catch (MyException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n如果在程序中,去掉`e`，也就是：`throw new MyException(“文件没有找到–02″);`那么异常信息就保存不了。\n\n## 自定义异常\n\nJava确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误。所以，Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。\n\nJava自定义异常的使用要经历如下四个步骤：\n\n- 定义一个类继承`Throwable`或其子类。\n- 添加构造方法(当然也可以不用添加，使用默认构造方法)。\n- 在某个方法类抛出该异常。\n- 捕捉该异常。\n\n示例如下：\n\n```java\n/**\n *自定义异常 继承Exception类.\n */\npublic class MyException extends Exception {\n\n    public MyException(){\n\n    }\n\n    public MyException(String message){\n        super(message);\n    }\n\n}\n\n/**\n * 测试抛出和捕捉异常的类.\n */\npublic class Test {\n\n    public void display(int i) throws MyException{\n        if (i == 0) {\n            throw new MyException(\"该值不能为0.......\");\n        } else{\n            System.out.println( i / 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        Test test = new Test();\n        try {\n            test.display(0);\n            System.out.println(\"---------------------\");\n        } catch (MyException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 最佳实践\n\n- 尽可能的减小`try`块。\n- 不要在构造函数中抛出异常。\n- 如果使用Java7及以后的版本，一个catch子句中可以捕获多个异常。\n- 充分使用`finally`块，保证所有资源都被正确释放；如果使用Java7及以后的版本，那么更推荐使用`try-with-resource`语法。\n- `catch`语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的`Exception`类。 不要一个`Exception`试图处理所有可能出现的异常。\n- 不要忽略异常。既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。\n- 在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。\n- 减轻`finally`的任务，finally块仅仅用来释放资源是最合适的。不要在`finally`中使用`return`、抛出异常等。\n- 为了给调用者提供尽可能多的信息，从而可以更好地避免/处理异常。对异常进行Javadoc文档说明，并且描述抛出异常的场景。\n- 不要捕获`Throwable`。`Throwable`是所有异常和错误的父类。如果`catch`了`throwable`，那么不仅仅会捕获所有`Exception`，还会捕获`Error`。而`Error`是表明无法恢复的JVM错误。因此除非绝对肯定能够处理或者被要求处理`Error`，不要捕获`Throwable`。\n- 包装异常时要包含原始的异常。包装异常时，一定要把原始的异常设置为`cause`(`Exception`有构造方法可以传入`cause`)。否则，丢失了原始的异常信息会让错误的分析变得困难。\n\n## 常见异常及解释\n\n以下是常见[Java异常](http://rymden.nu/exceptions.html)的**非技术角度**的理解。阅读有风险，理解需谨慎。\n\n### java.lang\n\n- `ArithmeticException`：你正在试图使用电脑解决一个自己解决不了的数学问题，请重新阅读你的算术表达式并再次尝试。\n- `ArrayIndexOutOfBoundsException`：请查看[IndexOutOfBoundsException](http://rymden.nu/exceptions.html#IndexOutOfBoundsException)。不同之处在于这个异常越界的元素不止一个。\n- `ArrayStoreException`：你已用光了所有数组，需要从数组商店中购买更多的数组。\n- `ClassCastException`：你需要呆在自己出生的种姓或阶级。Java 不会允许达利特人表现得像刹帝利或者高贵种族的人假装成为工人阶级。为了保持向前兼容，Java 1.0中把Caste误写为Cast保留到了现在。\n- `ClassNotFoundException`：你似乎创造了自己的类。这也是目前 Java 还未实现的种姓制度，但是 Java 明显使用了巴厘岛的种姓制度。也就是说，如果你是一个武士，也就相当于印度种姓制度中的第三层——吠舍。\n- `CloneNotSupportedException`：你是一名克隆人。找到你的原型，告诉他你想做什么，然后自杀。\n- `IllegalAccessException`：你是一个正在运行 Java 程序入室盗窃的小偷，请结束对电脑的盗窃行为，离开房子，然后再试一次。\n- `IllegalArgumentException`：你试图反对之前的异常。\n- `IllegalMonitorStateException`：请打开你的电脑屏幕背面。\n- `IllegalStateException`：你来自一个尚未被联合国承认的国家，也许是库尔德斯坦或者巴勒斯坦。拿到真正的国籍后重新编译你的 Java 代码，然后再试一次。\n- `IllegalThreadStateException`：你电脑的一颗螺丝上到了错误的螺纹孔里，请联系你的硬盘供应商。\n- `IndexOutOfBoundsException`：你把食指放在了无法接收的地方，重新放置，再试一次。\n- `InstantiationException`：不是每件事都会立即发生，请更耐心一点。\n- `InterruptedException`：告诉你的同事、室友等，当你工作的时候，请勿打扰。\n- `NegativeArraySizeException`：你创建了一个负数长度的数组。这会丢失信息，长期发展将会毁灭宇宙。不过放宽心，Java 发现了你正在做的事，不要再这么干了。\n- `NoSuchFieldException`：你正试图去一个不存在的区域游览。如果你试图去参观一个事实上不存在，其实已经是最高机密的飞机场时，也会得到这个异常。我可以给你示例，然后不得不杀了你。\n- `NoSuchMethodException`：不要使用那个方法！拜托了，就像我们一直做的那样去解决事情吧。\n- `NullPointerException`：你没有狗。请你先找一只狗，比如一只布烈塔尼獵犬，然后再试一次。\n- `NumberFormatException`：你正在使用过时的测量单位，比如英寸或者品脱。请转换成国际基本单位。有一个已知的 bug 会导致 Java 抛出这个异常，那就是你太矮了或者太高了。\n- `RuntimeException`：你不能跑得足够快，可能因为你太胖了。关掉你的电脑，出门锻炼吧。\n- `SecurityException`：你已被认为是国家安全的一个威胁。请你呆在原地别动，然后等着警察来并带你走。\n- `StringIndexOutOfBoundsException`：你的内裤和这个地方格格不入。换掉它们，再试一次。另外如果你根本不穿任何内裤，也会得到这个异常。\n- `UnsupportedOperationException`：因为一些原因，你正试图做一个在道德上不被 Java 支持的手术。包括不必要的截肢，例如割包皮。请停止滥用你的身体，不要移除你的孩子，该死的！\n\n### java.util\n\n- `ConcurrentModificationException`：有人修改了你的 Java 代码。你应该更改密码。\n- `EmptyStackException`：为了让 Java 工作，你必须在桌子上放一叠 Java 书籍。当然，如果书很厚的话，一本就够了。\n- `MissingResourceException`：你太穷了，不配使用 Java。换一个更便宜的语言吧（比如 Whitespace、Shakesperre、Cow、Spaghetti 或者 C#）。\n- `NoSuchElementException`：这里只存在四种元素（地球、水、空气、火）。《第五元素》只是部电影而已。\n- `TooManyListenersException`：你被太多秘密机构窃听了，SecurityException 马上就到。\n\n### java.awt\n\n- `AWTException`：你正在使用AWT，也就是说你的图形界面会很丑。这个异常只是一个警告可以被忽略。\n- `FontFormatException`：你的布局很丑陋，或者你选择了一个糟糕的字体，或者太多的字体。请咨询一名专业的设计师。\n- `HeadlessException`：Java 认为身为一名程序员，你实在是太蠢了。\n- `IllegalComponentStateException`：你的一个硬件（例如硬盘、CPU、内存）坏掉了。请联系你的硬件供应商。\n\n### java.awt.color\n\n- `CMMException`：你的 CMM 坏掉了，真是见鬼了。我经常烧毁自己的房子，然后去一个新的城市重新开始。\n- `ProfileDataException`：你的个人档案包含可疑信息。如果你不是一名共产主义者、恐怖分子或者无神论者，请联系 CIA 修正错误。\n\n### java.awt.datatransfer\n\n- `MimeTypeParseException`：你的哑剧（Mime）糟透了，没人能够理解你到底想表达什么。尝试一些更简单的事情吧，比如迎风散步，或者被困在一个看不见的盒子里。\n- `UnsupportedFlavorException`：你正试图使用一种 Java 不知道的香料。大部分人似乎只知道使用香草和樱桃。\n\n### java.beans\n\n- `IntrospectionException`：你太内向了，你应该变得外向一些。 别再当一个呆子，出门去见见人吧！\n- `PropertyVetoException`：你的一部分财产被冻结了。这条信息应该已经告诉你谁干的和原因。如果没看见，你可能也不该询问。\n\n### java.io\n\n- `CharConversionException`：你一直试图焚烧一些不燃物。也可能是因为你试着把自己变成一条鱼，但这不可能发生。\n- `EOFException`：你得到这条异常是因为你不知道EOF是什么意思。但是，我并不打算告诉你，因为你是一个不学无术的人。\n- `FileNotFoundException`：一名木匠应该总是知道他的工具放在哪里。\n- `InterruptedIOException`：你不顾之前的 IOException，一直在使用 IO，然后你的活动就被中断了。\n- `InvalidClassException`：查看 ClassNotFoundException。\n- `InvalidObjectException`：反对无效，就像他们在法庭上说的一样。\n- `IOException`：IO 代表输入、输出，并且不得不做收发数据的事。IO 是一个安全问题，不应使用。\n- `NotActiveException`：这个异常意味着两件事。要么是未激活，需要激活；要么是已激活，需要停止。到开始工作为止，激活与未激活都是随机的。\n- `NotSerializableException`：你正试图把一部电影改成电视剧。\n- `ObjectStreamException`：你提出了一连串的反对（Object）意见。提出新的意见前，请限制自己一下，等待法官作出判决。查看 InvalidObjectException。\n- `OptionalDataException`：你似乎认为一些可选数据是必须的。不要让事情变得复杂。\n- `StreamCorruptedException`：你的数据流被损坏了，这意味着它已经被截包，并在黑市上贩卖。\n- `SyncFailedException`：你试图与其他人同步你的失败，然后被证明比他人更加失败。去找一些跟你同等水平的人吧。\n- `UnsupportedEncodingException`：如果你想在网上发送自己的代码，必须与美国国家安全局核对你的加密密匙。如果不这么做，将把你视为恐怖分子，并以适当方式处理。如果你得到这个异常，能跑多快跑多快。\n- `UTFDataFormatException`：UTF 代表通用传输格式，是一种无论你使用哪种格式都会用到的数据传输方式。你试图通过 UTF 传输错误格式的数据。\n- `WriteAbortedException`：你需要在程序中的某处写上“aborted”。这通常没什么意义，但你就得这样做。\n\n### java.net\n\n- `BindException`：Java编程和束缚不能混为一谈。\n- `ConnectException`：你正试图与一个不能连接的事物建立连接。试着连接其他事物吧。也许可以通过一个特殊的连接对象实现你想要的连接。\n- `MalformedURLException`：你正在制作一个形状错误的壶（例如一个“L”状），或者你有拼写错误的单词“urn”（例如“url”）。\n- `NoRouteToHostException`：没有通往主机的“道路”，请联系公路管理员。\n- `PortUnreachableException`：港口必须正确地放置在水边。如果在内陆，它们将会无法接触。\n- `ProtocolException`：这是一个严重违反规定的结果（例如在你主机上的“puk韓g”）。解决方法很简单：不要那样做！\n- `SocketException`：你把电脑连接到了错误的电源插座。大部分情况下你不得不寻找其它插座，但一些电脑背部有一个开关，可以设置电源插座类型。\n- `SocketTimeoutException`：你的电脑连接了一个带计时器的电源插座，并且时间已经走完。只有烙铁和相似的东西才会使用这种插座。\n- `UnknownHostException`：你的父母没有教过你不要和陌生人说话么？\n- `UnknownServiceException`：你正试图进入接近一个未知服务。众所周知，未知服务或许是特工组织。\n- `URISyntaxException`：“You are I”是一个语法错误的句子。将其改为“You are me”，别管那到底啥意思。\n\n### java.rmi\n\n- `AccessException`：你正在使用“Microsoft Access”。请不要这样做。\n- `AlreadyBoundException`：不管在 java.net.BindException 的描述中是什么状况，RMI 都提供捆绑服务。然而，你不能绑一个已经被捆绑的人。\n- `ConnectException`：你正试图与一个不能连接的事物建立连接。试着连接其他事物吧。也许可以通过一个特殊的连接对象实现你想要的连接。\n- `ConnectIOException`：你正试图通过 IO 与另一个不能被连接的事物建立连接。尝试连接其他事物吧。或许你可以通过一个特殊的连接对象实现想要的连接。\n- `MarshalException`：你的“marshal”出问题了。你应做的事取决于我们正在讨论的是哪种“marshal”。他可以是陆军元帅、警察、消防队员或者只不过是一名普通的司仪。注意这个异常与马绍尔群岛共和国没有任何关系，也称为 RMI。\n- `NoSuchObjectException`：你正试图使用一个不存在的对象。以爱因斯坦之名，创造它或者不要使用它！\n- `NotBoundException`：如果你正在使用奴隶，请确认至少有一个人被绑住了。\n- `RemoteException`：这是一条远程抛出的特殊异常。如果其他人的应用变得不稳定，以致于不能产生一条异常，相反地，你可能会得到这条异常。请找到源头并提醒那位程序员这个错误。\n- `RMISecurityException`：马绍尔群岛共和国变得不稳定了。如果你住在这儿，你最好离开，直到安全得到保障为止都别回来。如果你住在其他地方，可以无视这个异常。\n- `ServerException`：第二发球（或者双发失误同样适用）。\n- `ServerRuntimeException`：只要是网球比赛都很长。当你花太长时间发球时，就会得到这条异常。\n- `StubNotFoundException`：当你去看电影的时候，你应该一直保留自己的票根。如果不这么做，并且离开了电影院，你就不能重新进去，不得不去买张新票。所以保留你的票根！\n- `UnexpectedException`：这个异常对你来说应该会成为一个大惊喜。如果发生了，所有事都变成它应该的样子。\n- `UnknownHostException`：你父母没有教过你不要和陌生人说话吗？\n- `UnmarshalException`：.你没有完成一名法律工作人员的职责（例如你曾经的法官工作）。注意这个正确的术语是“曾经”（used to）。你已经被解雇（fire）了（如果你是一名消防队员（firefighter），这可真是讽刺啊）。\n\n### java.security\n\n- `AccessControlException`：你失去了对 Microsoft Access 的控制。如果你无法重获控制或者通过其他方式停止程序，你应该尽快切断电脑电源。\n- `DigestException`：你应该注意自己的食物，消化不良也能变成严重的问题。\n- `GeneralSecurityException`：在某些地方做一些事情并不安全。如果你有足够的权力，你应该随机入侵一个国家（最好在中东地区）。如果你没有那种权力，至少应该有一把枪。\n- `InvalidAlgorithmParameterException`：你向一位残疾人用他不能理解的方式解释你的算法。简单一点！\n- `InvalidKeyException`：这个异常有两种不同的原因：1、你正在使用错误的钥匙。我的建议是在你的钥匙上画不同颜色的小点来帮助你记住哪一把对应哪一个锁。2、 你不能锁住残疾人却不给他们钥匙，如果他们足够聪明发现如何使用钥匙，他们就有自由移动的权- 利。\n- `InvalidParameterException`：你使用了蔑视的术语去描述一名残疾人。\n- `KeyException`：不要尝试不用钥匙就能开锁。\n- `KeyManagementException`：你遗失了自己的钥匙。很可能忘在办公室（如果你正试图进入你家）或者忘在家里（如果你正试图进入办公室）。\n- `KeyStoreException`：延续之前 KeyManagementException 的解释就是你的钱包有个洞。\n- `NoSuchAlgorithmException`：你试图用以前未知的方法解决问题。停止创新吧，用老算法重写一遍。你也可以为自己的想法申请专利，然后等待未来 Java 发布新版本的时候纳入其中。\n- `NoSuchProviderException`：如果你是一名单亲妈妈，你没法成为家庭主妇。首先，你得为家庭找到一名供养者。\n- `PrivilegedActionException`：你试图采取一个行动，但是没有得到权限。比如，只有名人才可以做到地从谋杀中逃脱，只有天主教神父和耶和华的高级见证人才能做地猥亵儿童，只有在私人企业担任管理职位的人才能被允许地偷钱。\n- `ProviderException`：你是一名妇女并试图供养一个家庭。显而易见，你的丈夫不能成为一名“家庭主妇”，所以你得让他供养个家庭。想象一下，Java固执且不肯改变，事情就是这样工作的，解决它。\n- `SignatureException`：要么你是伪造的其他人的签名，要么是无法接受你的签名。一个签名不能太丑陋、太易读或太大。\n- `UnrecoverableKeyException`：该死。你把你的钥匙扔进了下水沟。我唯一能安慰你的就是其他人也无法恢复钥匙，所以倒不是必须换掉你的锁。\n\n### java.text\n\n- `ParseException`：你做的没有任何意义，冷静下来，再试一次。\n\n---\n\n参考文档：\n\n- [java提高篇之异常（上）](http://www.importnew.com/20629.html)\n- [java提高篇之异常（下）](http://www.importnew.com/20645.html)\n- [深入理解java异常处理机制](http://www.importnew.com/14688.html)\n- [Java 中 9 个处理 Exception 的最佳实践](http://www.importnew.com/26775.html)\n- [Java常见异常及解释](http://www.importnew.com/16725.html)","tags":["Java"],"categories":["后端"]},{"title":"Java集合框架知识整理","url":"/2018/1024672.html","content":"\nJava集合框架主要由`Collection`和`Map`两个根接口及其子接口、实现类组成。\n\n## 集合类关系梳理\n\n- `Collection`接口继承了`Iterable`接口，依赖了`Predicate`、`Spliterator`、`Stream`接口（这些均为`Java8`新增），`Iterable`接口依赖了`Iterator`接口。\n  - `List`接口继承自`Collection`接口,依赖了`UnaryOperator`接口（`Java8`新增）、`ListIterator`、`Comparator`接口\n  - `Queue`接口继承了`Collection`接口\n    - `Deque`接口继承了`Queue`接口\n    - `BlockingQueue`接口继承了`Queue`接口\n      - `BlockingDeque`接口继承了`BlockingQueue`、`Deque`接口\n      - `TransferQueue`接口继承了`BlockingQueue`接口\n  - `AbstractCollection`抽象类实现了`Collection`接口，\n    - `AbstractList`抽象类继承了`AbstractCollection`抽象类，实现了`List`接口，依赖了`List`、`RandomAccess`、`Cloneable`、`Serializable`接口\n      - `ArrayList`类继承了`AbstractList`抽象类，实现了`List`、`RandomAccess`、`Cloneable`、`Serializable`接口\n      - `AbstractSequentialList`抽象类继承了`AbstractList`抽象类\n        - `LinkedList`类继承了`AbstractSequentialList`抽象类，实现了`List`、`Deque`、`Cloneable`、`Serializable`接口\n      - `CopyOnWriteArrayList`实现了`List`、`RandomAccess`、`Cloneable`、`Serializable`接口\n      - `Vector`类继承了`AbstractList`抽象类，实现了`List`、`RandomAccess`、`Cloneable`、`Serializable`接口\n        - `Stack`类继承了`Vector`类\n    - `AbstractQueue`抽象类继承了`AbstractCollection`接口，实现了`Queue`接口\n      - `SynchronousQueue`类继承了`AbstractQueue`接口，实现了`BlockingQueue`、`Serializable`接口，依赖了`Collection`、`Spliterator`接口\n      - `ArrayBlockingQueue`类继承了`AbstractQueue`接口，实现了`BlockingQueue`、`Serializable`接口\n      - `LinkedBlockingQueue`类继承了`AbstractQueue`接口，实现了`BlockingQueue`、`Serializable`接口\n      - `PriorityBlockingQueue`类继承了`AbstractQueue`接口，实现了`BlockingQueue`、`Serializable`接口，聚合了`Comparator`接口，依赖了`Collection`、`Comparator`、`Comparable`接口\n      - `DelayQueue`类继承了`AbstractQueue`接口，实现了`BlockingQueue`接口\n      - `LinkedBlockingDeque`类继承了`AbstractQueue`接口，实现了`BlockingDeque`、`Serializable`接口\n      - `PriorityQueue`类继承了`AbstractQueue`接口\n      - `LinkedTransferQueue`类继承了`AbstractQueue`接口，实现了`TransferQueue`、`Serializable`接口（Java7新增）\n    - `ConcurrentLinkedDeque`类继承了`AbstractCollection`抽象类，实现了`Deque`、`Cloneable`、`Serializable`接口\n    - `ArrayDeque`类继承了`AbstractCollection`抽象类，实现了`Deque`、`Serializable`接口\n  - `Set`接口继承自`Collection`接口\n    - `AbstractSet`抽象类继承了`AbstractCollection`抽象类，实现了`Set`接口\n      - `HashSet`类继承了`AbstractSet`抽象类，实现了`Set`、`Cloneable`、`Serializable`接口，聚合了`HashMap`\n        - `LinkedHashSet`类继承了`HashSet`类，实现了`Set`、`Cloneable`、`Serializable`接口\n      - `TreeSet`类继承了`AbstractSet`抽象类，实现了`NavigableSet`、`Cloneable`、`Serializable`接口，聚合了`NavigableMap`，依赖了`Comparator`、`SortedSet`接口\n      - `EnumSet`抽象类继承了`AbstractSet`抽象类，实现了`Cloneable`、`Serializable`接口，依赖了`Comparator`、`SortedSet`接口\n        - `RegularEnumSet`类继承了`EnumSet`抽象类\n        - `JumboEnumSet`类继承了`EnumSet`抽象类\n      - `ConcurrentSkipListSet`类继承了`AbstractSet`抽象类，实现了`NavigableSet`、`Cloneable`、`Serializable`接口\n      - `CopyOnWriteArraySet`类继承了`AbstractSet`抽象类，实现了`Serializable`接口，聚合了`CopyOnWriteArrayList`类，依赖了`Predicate`、`Consumer`接口\n    - `SortedSet`接口继承自`Set`接口，依赖了`Comparator`接口\n      - `NavigableSet`接口继承自`SortedSet`接口(Java6新增)\n- `Map`接口依赖了`Set`、`Collection`、`BiConsumer`、`Function`、`BiFunction`接口，`Map.Entry`是Map中的内部接口\n  - `AbstractMap`抽象类实现了`Map`接口，聚合了`Collection`、`Set`接口\n    - `HashMap`类继承了`AbstractMap`抽象类，实现了`Map`、`Cloneable`、`Serializable`接口，依赖了`Collection`、`Set`接口\n      - `LinkedHashMap`继承了`HashMap`类，实现了`Map`接口，依赖了`Collection`、`Set`、`Consumer`、`BiConsumer`接口\n    - `TreeMap`类继承了`AbstractMap`抽象类，实现了`NavigableMap`、`Cloneable`、`Serializable`接口，依赖了`Comparator`、`SortedMap`、`Collection`、`Set`、`BiConsumer`、`BiFunction`接口\n    - `EnumMap`类继承了`AbstractMap`抽象类，实现了`Cloneable`、`Serializable`接口，依赖了`AbstractSet`类，`Collection`、`Set`接口\n    - `WeakHashMap`类继承了`AbstractMap`抽象类，实现了`Map`接口，依赖了`Collection`、`Set`、`Consumer`、`BiConsumer`、`BiFunction`接口\n    - `IdentityHashMap`类继承了`AbstractMap`抽象类，实现了`Map`、`Serializable`、`Cloneable`接口，依赖了`Collection`、`Set`、`Consumer`、`BiConsumer`、`BiFunction`接口\n    - `ConcurrentHashMap`类继承了`AbstractMap`抽象类，实现了`ConcurrentMap`、`Serializable`接口，依赖了`Comparable`、`ParameterizedType`、`Collection`、`Set`、`Spliterator`、`Consumer`、`BiConsumer`、`Function`、`BiFunction`、`ToDoubleFunction`、`DoubleBinaryOperator`等接口\n    - `ConcurrentSkipListMap`类继承了`AbstractMap`抽象类，实现了`ConcurrentNavigableMap`、`Cloneable`、`Serializable`接口，聚合了`Comparator`接口，依赖了`Collection`、`Set`、`Consumer`、`BiConsumer`、`BiFunction`、`NavigableSet`接口\n  - `SortedMap`接口继承自`Map`接口，依赖了`Set`、`Collection`、`Comparator`接口\n    - `NavigableMap`接口继承了`SortedMap`接口，依赖了`NavigableSet`接口\n    - `ConcurrentNavigableMap`接口继承了`ConcurrentMap`、`NavigableMap`接口，聚合了`NavigableSet`接口\n  - `ConcurrentMap`接口继承了`Map`接口，依赖了`BiConsumer`、`BiFunction`接口\n  - `Hashtable`类继承了`Dictionary`抽象类，实现了`Map`、`Cloneable`、`Serializable`接口，聚合了`Collection`、`Set`接口，依赖了`Enumeration`、`BiConsumer`、`BiFunction`接口\n    - `Properties`类继承了`Hashtable`类\n- `Collections`是`Collection`的辅助工具类，依赖了上述大多数接口和类\n- `Arrays`是数组的辅助工具类，依赖了上述一些接口和类\n\n## 集合UML关系图\n\nJava Collection UML类关系图如下：\n\n![Java Collection UML类关系图](http://static.blinkfox.com/Java_Collection_UML.png)\n\nJava Map UML类关系图如下：\n\n![Java Map UML类关系图](http://static.blinkfox.com/Java_Map_UML.png)\n\n## 各集合接口、类的介绍\n\n- `Collection`：`Collection`是最基本集合接口，它定义了一组允许重复的对象。`Collection`接口派生了三个子接口`List`、`Set`和`Queue`。`Collection`所有实现类的遍历都可以使用`Iterator`接口或者是`foreach`来循环。\n  - `List`：`List`代表有序、可重复的集合。\n    - `ArrayList`：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程不安全，效率高。`ArrayList`创建时的大小为`0`；当加入第一个元素时，进行第一次扩容时，默认容量大小为`10`，每次扩容都以当前数组大小的1.5倍去扩容。\n    - `Vector`：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程安全，效率低。`Vector`创建时的默认大小为`10`；`Vector`每次扩容都以当前数组大小的`2`倍去扩容。当指定了`capacityIncrement`之后，每次扩容仅在原先基础上增加`capacityIncrement`个单位空间。`ArrayList`和`Vector`的`add`、`get`、`size`方法的复杂度都为`O(1)`，`remove`方法的复杂度为`O(n)`。\n      - `Stack`：`Vector`的一个子类，是标准的**先进后出**(FILO, First In Last Out)的栈。底层通过数组实现的，线程安全。\n    - `LinkedList`：底层使用双向循环链表的数据结构来实现，排列有序可重复，查询速度慢、增删数据快，线程不安全。\n    - `CopyOnWriteArrayList`：底层使用`Copy-On-Write`的优化策略实现，适用于**读多写少**的场景，同`ArrayList`功能相似，线程安全。`CopyOnWriteArrayList`在某些情况下比`Collections.synchronizedList(List list)`有更好的性能。缺点是：内存占用大和数据一致性问题，只能保证最终一致性。\n  - `Set`：`Set`代表无序、不可重复的集合。\n    - `HastSet`：底层使用`Hash`表来实现，内部使用了`HashMap`，排列无序不可重复，存取速度快，线程不安全。\n      - `LinkedHashSet`：底层采用`Hash`表存储，并用双向链表记录插入顺序，排列有序不可重复，存取速度较`HashSet`略慢，比`TreeSet`快，线程不安全。\n    - `TreeSet`：底层使用红黑树来实现，内部使用了`NavigableMap`，按自然顺序或者自定义顺序存放、不可重复，线程不安全。\n    - `CopyOnWriteArraySet`：底层使用`Copy-On-Write`的优化策略实现，适用于**读多写少**的场景，内部使用了`CopyOnWriteArrayList`，同`HastSet`功能相似，线程安全。\n    - `ConcurrentSkipListSet`：底层使用**跳跃列表**来实现，适用于**高并发**的场景，内部使用了`ConcurrentNavigableMap`，同`TreeSet`功能相似，线程安全。\n    - `EnumSet`：是抽象类，只能用来存储Enum常量或其子类，不能存储其它类型，`EnumSet`有两种实现方式，`RegularEnumSet`和`JumboEnumSet`，但是这两种实现方式是包**私有**的，不能在包外访问，因此必须使用工厂方法来创建并返回`EnumSet`实例，不能通过构造函数来创建。`EnumSet`中提供了多种创建`EnumSet`实例的静态工厂方法，例如`of`方法（进行了函数重载），`copyOf`方法，`noneOf`方法等。存储效率快，线程不安全。存储枚举常量时使用`EnumSet`而不要用`HashSet`。\n  - `Queue`：`Queue`是Java 5之后增加的集合体系，表示**队列**集合的相关实现，大多遵循**先进先出**(FIFO, First-In-First-Out)的模式。\n    - `PriorityQueue`：即优先队列，底层基于**优先堆的一个无界队列**来实现，无界但可选容量界限。这个优先队列中的元素可以默认自然排序或者通过提供的`Comparator`（比较器）在队列实例化的时排序，而不是先进先出。不允许空值、不支持`non-comparable`（不可比较）的对象，每次从队列中取出的是具有最高优先权的元素，线程不安全。\n    - `ArrayBlockingQueue`：底层基于**定长数组**的阻塞队列实现，即是线程安全的有界阻塞队列。`ArrayBlockingQueue`内部通过**互斥锁**保护竞争资源，实现了多线程对竞争资源的互斥访问。队列中的锁是没有分离的，所以在添加的同时就不能读取，读取的同时就不能添加，所以锁方面性能不如`LinkedBlockingQueue`。\n    - `LinkedBlockingQueue`：即链接队列，底层基于**单向链表**的阻塞队列实现，无界但可选容量界限，线程安全。队列中的锁是分离的，即添加用的是`putLock`，获取是`takeLock`，所以在添加获取方面理论上性能会高于`ArrayBlockingQueue`。所以`LinkedBlockingQueue`更适合实现生产者-消费者队列。\n    - `PriorityBlockingQueue`：即优先阻塞队列，底层基于**优先堆的一个无界队列**来实现，无界但可选容量界限的阻塞队列，线程安全，功能同`PriorityQueue`、`LinkedBlockQueue`相似。其所含对象的排序不是先进先出，而是依据对象的自然排序顺序或者是构造函数的`Comparator`决定的顺序。\n    - `SynchronousQueue`：即同步队列，是一种线程安全无缓冲的无界阻塞队列。其操作必须是放和取交替完成的，即每个`put`必须等待一个`take`，反之亦然。\n    - `DelayQueue`：即延迟队列，是一种有序无界阻塞队列，只有在延迟期满时才能从中提取元素，线程安全。\n    - `ArrayDeque`：底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用`Stack`，而是推荐使用更高效的`ArrayDeque`来实现栈的功能，非线程安全。\n    - `LinkedBlockingDeque`：底层采用了**双向链表**实现的**双端阻塞并发**队列，无限扩展且可选容量。该阻塞队列同时支持`FIFO`和`FILO`两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。\n    - `ConcurrentLinkedDeque`：底层采用了**双向链表**实现的**双端非阻塞并发**队列，无限扩展且可选容量。该队列同时支持`FIFO`和`FILO`两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。\n    - `LinkedTransferQueue`：底层采用了**单向链表**实现的**无界传输阻塞**队列，先进先出，无限扩展且可选容量线程安全。\n- `Map`：`Map`代表具有映射关系的集合。\n  - `HashMap`：底层是用**链表数组**，`Java8`后又加了**红黑树**来实现，键无序不可重复可为null、值可重复可为null，存取速度快，线程不安全。\n    - `LinkedHashMap`：底层是用**链表数组**存储，并用双向链表记录插入顺序，键有序不可重复可为null、值可重复可为null，存取速度快较`HashMap`略慢，比`TreeMap`快，线程不安全。\n  - `HashTable`：底层是用**链表数组**，键无序不可重复可为null、值可重复可为null，存取速度较`HashMap`慢，线程安全。\n    - `Properties`：是`HashTable`的子类，是<String,String>的映射，比`HashTable`多了`load`、`store`两个方法，线程安全。\n  - `TreeMap`：底层使用红黑树来实现，内部使用了`Comparator`，按自然顺序或自定义顺序存放键，键不可重复不可为null、值可重复可为null，存取速度较`HashMap`慢，线程不安全。\n  - `EnumMap`：底层使用数组来实现，是专门为枚举类型量身定做的Map，性能更好。只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以`EnumMap`使用数组来存放与枚举类型对应的值，线程不安全。\n  - `WeakHashMap`：同`HashMap`基本相似。区别在于，`HashMap`的`key`保留对象的强引用，这意味着只要该`HashMap`对象不被销毁，该`HashMap`对象所有key所引用的对象不会被垃圾回收，`HashMap`也不会自动删除这些`key`所对应的`key-value`对象；但`WeakHashMap`的`key`只保留对实际对象的弱引用，这意味着当垃圾回收了该`key`所对应的实际对象后，`WeakHashMap`会自动删除该`key`对应的`key-value`对象。\n  - `IdentityHashMap`：同`HashMap`基本相似。区别在于，在处理两个`key`相等时，对于普通`HashMap`而言，只要`key1`和`key2`通过`equals`比较返回`true`时就认为key相同；在`IdentityHashMap`中，当且仅当两个`key`严格相等时(`key1 = key2`)时才认为两个`key`相同。\n  - `ConcurrentHashMap`：底层使用**锁分段**技术来实现线程安全，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。`ConcurrentHashMap`是由`Segment`数组结构和`HashEntry`数组结构组成。`Segment`是一种可重入锁`ReentrantLock`，在`ConcurrentHashMap`里扮演锁的角色，`HashEntry`则用于存储键值对数据。一个`ConcurrentHashMap`里包含一个`Segment`数组，`Segment`的结构和`HashMap`类似，是一种数组和链表结构， 一个`Segment`里包含一个`HashEntry`数组，每个`HashEntry`是一个链表结构的元素， 每个`Segment`守护者一个`HashEntry`数组里的元素,当对`HashEntry`数组的数据进行修改时，必须首先获得它对应的`Segment`锁。\n  - `ConcurrentSkipListMap`：底层使用**跳跃列表**来实现，适用于**高并发**的场景，内部使用了`ConcurrentNavigableMap`，同`TreeMap`功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补`ConcurrentHashMap`不支持排序的问题。\n\nJava集合框架功能介绍思维导图如下：\n\n![Java集合框架功能介绍思维导图](http://static.blinkfox.com/Java_collections_mind.png)\n\n### 一些概念解释\n\n- **跳表**：是一种采用了用空间换时间思想的数据结构。它会随机地将一些节点提升到更高的层次，以创建一种逐层的数据结构，以提高操作的速度。\n- **阻塞队列和非阻塞的区别**：如果队列里面已经放满了，如果是阻塞队列那么线程会一直阻塞，而非阻塞对垒则会抛出异常。\n\n### 一些数据结构的优缺点\n\n- **Hash表**：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。\n- **红黑树**：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。\n- **SkipList**：插入、查找为O(logn)，但常数项比红黑树要大；底层结构为链表，可无锁实现；数据天然有序。\n\n## 一些接口的主要方法梳理\n\n### Collection接口中的抽象方法\n\n- `int size()`，返回集合的大小\n- `boolean isEmpty()`，返回集合是否为空的布尔值\n- `boolean contains(Object o)`，返回集合是否包含元素`o`的布尔值\n- `Iterator<E> iterator()`，返回该集合中元素的迭代器，继承自`Iterable`接口\n- `Object[] toArray()`，返回一个包含此集合中所有元素的数组\n- `<T> T[] toArray(T[] a)`，`toArray()`方法的泛型版本，返回一个包含此集合中所有元素的数组，返回类型由传入数组参数的类型决定\n- `boolean add(E e)`，返回向集合中插入元素`e`是否成功的布尔值\n- `boolean remove(Object o)`，返回从集合中删除元素`o`是否成功的布尔值\n- `boolean containsAll(Collection<?> c)`，返回本集合中是否完全包含集合`c`的布尔值，即判断集合`c`是否是本集合子集\n- `boolean addAll(Collection<? extends E> c)`，将集合`c`中的所有元素添加到本集合中并返回\n- `boolean removeAll(Collection<?> c)`，移除本集合中所有包含集合`c`的所有元素\n- `default boolean removeIf(Predicate<? super E> filter)`，Java8新增的接口默认方法。将会批量删除符合filter条件的所有元素，该方法需要一个Predicate对象作为作为参数，Predicate也是函数式接口，因此可使用Lambda表达式作为参数。\n- `boolean retainAll(Collection<?> c)`，返回本集合和集合`c`中相同的元素并存到本集合中,集合`c`保持不变，返回值表示的是本集合是否发生过改变。即该方法是用来求两个集合的交集，交集的结果存到本集合中，如果本集合没发生变化则返回`true`\n- `void clear()`，清空本集合中的所有元素\n- `boolean equals(Object o)`，返回本集合是否和对象`o`相等的布尔值\n- `int hashCode()`，返回此集合的`Hash`码值\n- `default Spliterator<E> spliterator()`，在集合中创建`Spliterator`对象\n  - `Spliterator`是Java 8引入的新接口，顾名思义，`Spliterator`可以理解`Iterator`的`Split`版本（但用途要丰富很多）。使用`Iterator`的时候，我们可以顺序地遍历容器中的元素，使用`Spliterator`的时候，我们可以将元素分割成多份，分别交于不于的线程去遍历，以提高效率。使用`Spliterator`每次可以处理某个元素集合中的一个元素 — 不是从`Spliterator`中获取元素，而是使用`tryAdvance()`或`forEachRemaining()`方法对元素应用操作。但`Spliterator`还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二。这些新增加的能力让流并行处理代码可以很方便地将工作分布到多个可用线程上完成。\n- `default Stream<E> stream()`，返回一个顺序的`Stream`对象。Java8引入了Stream以实现对集合更方便地进行函数式编程。\n- `default Stream<E> parallelStream()`，返回一个可能并行的`Stream`对象。Java8新增的方法。流可以是顺序的也可以是并行的。顺序流的操作是在单线程上执行的，而并行流的操作是在多线程上并发执行的。\n\n### List接口中的额外抽象方法\n\n- `boolean addAll(int index, Collection<? extends E> c)`，将指定集合`c`中的所有元素插入到指定索引位置处\n- `default void replaceAll(UnaryOperator<E> operator)`，Java8新增的使用`Lambda`的方式，通过应用`UnaryOperator`获得的结果来替换列表中的每个元素\n- `default void sort(Comparator<? super E> c)`，在比较器的基础上将本列表排序\n- `E get(int index)`，获取本集合中指定索引位置处的元素\n- `E set(int index, E element)`，设置或替换本集合中指定索引位置处的元素\n- `void add(int index, E element)`，在本集合中的指定索引位置处插入指定的元素\n- `E remove(int index)`，移除本集合中指定索引位置处的元素\n- `int indexOf(Object o)`，返回指定元素第一次出现的索引位置\n- `int lastIndexOf(Object o)`，返回指定元素最后出现的索引位置\n- `ListIterator<E> listIterator()`，返回本集合中的`ListIterator`迭代器\n- `ListIterator<E> listIterator(int index)`，返回本集合中从指定索引位置开始的`ListIterator`迭代器\n- `List<E> subList(int fromIndex, int toIndex)`，返回指定开始和结束索引位置的子集合\n\n### Set接口中的额外抽象方法\n\n无\n\n### Map接口中的抽象方法\n\n- `boolean containsKey`，判断本Map集合中是否包含指定的key键\n- `boolean containsValue`，判断本Map集合中是否包含指定的value值\n- `V get(Object key)`，根据key获取本Map集合中的value值\n- `V get(Object key)`，向本Map集合中存放key键和value值,返回value值\n- `V remove(Object key)`，根据key删除本Map集合中的key和value值，并返回删除的value值\n- `void putAll(Map<? extends K, ? extends V> m)`，将指定的Map集合添加到本的Map集合当中\n- `Set<K> keySet()`，获取本Map集合中的所有key值，并以Set接口的结果作为返回\n- `Collection<V> values()`，获取本Map集合中的所有value值，并以Collection接口的结果作为返回\n- `Set<Map.Entry<K, V>> entrySet()`，获取本Map集合中的所有key和value值，并以`Set<Map.Entry<K, V>>`的结果作为返回\n- `default V getOrDefault(Object key, V defaultValue)`，根据key获取本Map集合中的value值，如果没找到对应的值或者value值是null,则返回`defaultValue`的值\n- `default void forEach(BiConsumer<? super K, ? super V> action)`，Java8新增的使用`Lambda`的方式遍历操作Map中的元素的默认接口方法\n- `default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)`，Java8新增的使用`Lambda`的方式遍历替换Map中的元素的默认接口方法\n- `default V putIfAbsent(K key, V value)`，Java8新增的不用写是否为null值的检测语句向Map中保存key和value的元素的默认接口方法，即如果通过key获取到的value是空的，则在调用`put(key, value)`方法并返回value值\n- `default boolean remove(Object key, Object value)`，Java8新增的默认接口方法，删除给定key所对应的元素，如果value不存在、为null或者与参数中的value不等，则不能删除。即删除操作需要满足给定的值需要和map中的值相等的条件\n- `default boolean replace(K key, V oldValue, V newValue)`，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不存在、为null或者与参数中的oldValue不等，则不能替换。即替换操作需要满足给定的值需要和map中的值相等的条件\n- `default V replace(K key, V value)`，Java8新增的默认接口方法，替换给定key所对应的元素，如果value不为null，则value值与参数中的value值做替换。\n- `default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)`，Java8新增的默认接口方法，根据key获取到的value如果不为null，则直接返回value值，否则将`Lambda`表达式中的结果值存放到Map中\n- `default V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`，Java8新增的默认接口方法，根据key获取到的value和新计算的值如果不为null，则直接新计算的值，否则移除该key，且返回null\n- `default V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`，Java8新增的默认接口方法，将`Lambda`表达式中的结果值存放到Map中，如果计算的新值为null则返回null，且移除以前有的key和value值\n- `default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)`，Java8新增的默认接口方法，将新计算的值覆盖Map中原key对应的value值\n\n### SortedSet接口中的额外抽象方法\n\n- `Comparator<? super E> comparator()`，返回本SortedSet集合中的`Comparator`比较器\n- `SortedSet<E> subSet(E fromElement, E toElement)`，获取开始元素和结束元素之间的子SortedSet集合\n- `SortedSet<E> headSet(E toElement)`，获取开始元素和`toElement`元素之间的子SortedSet集合\n- `SortedSet<E> tailSet(E fromElement)`，获取`fromElement`元素和结束元素之间的子SortedSet集合\n- `E first()`，获取本SortedSet集合中的第一个元素\n- `E last()`，获取本SortedSet集合中的最后一个元素\n\n### SortedMap接口中的额外抽象方法\n\n- `Comparator<? super K> comparator()`，返回本SortedMap集合中的`Comparator`比较器\n- `SortedMap<K,V> subMap(K fromKey, K toKey)`，获取开始key和结束key之间的子SortedMap集合\n- `SortedMap<K,V> headMap(K toKey)`，获取开始key和`toKey`元素之间的子SortedMap集合\n- `SortedMap<K,V> tailMap(K fromKey)`，获取`fromKey`元素和结束key之间的子SortedMap集合\n- `K firstKey()`，获取本SortedMap集合中的第一个key\n- `K lastKey()`，获取本SortedMap集合中的最后一个key\n- `Set<K> keySet()`，获取本SortedMap集合中所有key的Set集合\n- `Collection<V> values()`，获取本SortedMap集合中所有value的Collection集合\n- `Set<Map.Entry<K, V>> entrySet()`，获取本SortedMap集合中所有key和value的Map集合\n","tags":["Java","UML"],"categories":["后端"]},{"title":"UML各类关系介绍","url":"/2018/102247618.html","content":"\n## 继承关系（generalization）\n\n**继承**关系用一条带**空心箭头的直线**表示。如下图所示（A继承自B）：\n\n![A继承自B](http://static.blinkfox.com/uml_demo_1.png)\n\n**继承**指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。**继承关系为`is-a`的关系**，是类与类或者接口与接口之间最常见的关系之一，在Java中此类关系通过关键字`extends`来表示。\n\n> **注意**：表现在代码中，继承关系表现为**一个类继承另一个类或者一个接口继承另一个接口**。\n\n## 实现关系（realization）\n\n**实现**关系是用一条带**空心箭头的虚线**表示。如下图所示（A实现B）：：\n\n![A实现B](http://static.blinkfox.com/uml_demo_2.png)\n\n**实现**指的是一个`class`类实现`interface`接口（可以是多个）的功能。实现是类与接口之间最常见的关系之一，在Java中此类关系通过关键字`implements`来表示。\n\n> **注意**：表现在代码中，实现关系表现为**普通类实现某个接口**。\n\n## 关联关系（association）\n\n**关联**关系是用一条**可能会有方向的直线**表示的。关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如上图，表示A关联B，但B不关联A；如下图所示：\n\n![A关联B](http://static.blinkfox.com/uml_demo_3.png)\n\n**关联**关系体现的是两个类、或者类与接口之间语义级别的一种强依赖的结构关系，是一种长期的静态稳定的关系，通常与运行状态无关，一般由常识等因素决定的。\n\n例如：乘车人和车票之间就是一种关联关系。\n\n> **注意**：表现在代码中，**被关联类以类属性的形式出现在关联类中，也可能是关联类引用了一个类型为被关联类的全局变量**。\n\n## 聚合关系（aggregation）\n\n**聚合**关系用一条带**空心菱形箭头的直线**表示，如下图所示A聚合到B，或者说B由A组成。\n\n![A聚合到B](http://static.blinkfox.com/uml_demo_4.png)\n\n**聚合**关系用于表示实体对象之间的关系，表示整体由部分构成的意思。**聚合是关联关系的一种特例，它体现的是整体与部分、拥有的关系，即`has-a`的关系**，此时整体与部分之间是**可分离**的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。例如一个部门由多个员工组成。\n\n> **注意**：表现在代码中，和关联关系是一致的，只能从语义级别来区分。聚合与组合不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在。\n\n## 组合关系（composition）\n\n**组合**关系用一条带**实心菱形箭头的直线**表示，如下图表示A组成B，或者B由A组成。\n\n![A组合到B](http://static.blinkfox.com/uml_demo_5.png)\n\n**组合**关系同样表示整体由部分组成的意思。与聚合关系一样，**组合也是关联关系的一种特例，它体现的是一种整体与部分不可分割的关系，即`contains-a`的关系，这种关系比聚合更强，也称为强聚合**。例如公司由多个部门组成组合，但此时整体与部分是**不可分离**的，整体的生命周期结束也就意味着部分的生命周期结束。\n\n> **注意**：表现在代码中，和关联关系是一致的，只能从语义级别来区分。组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也就不存在了。例如，公司不存在了，部门也将不存在了。\n\n## 依赖关系（dependency）\n\n**依赖**关系是用一套**带箭头的虚线**表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系。\n\n![A依赖于B](http://static.blinkfox.com/uml_demo_6.png)\n\n**依赖**关系是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A，与关联关系不同的是，它是一种**临时性**的关系，通常在运行期间产生，并且随着运行时的变化依赖关系也可能发生变化。\n\n显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。\n\n> **注意**：表现在代码中，依赖关系体现为**类的构造方法及类方法的传入参数**。\n\n## UML类关系图示例\n\n请看以下这个UML类关系图：\n\n![UML示例](http://static.blinkfox.com/uml_demo_0.png)\n\n- 开车的类图结构表示的是一个接口\n- 有一个自行车的抽象类，实现了开车的接口，它们之间的关系为实现关系，使用带空心三角箭头的虚线表示\n- 自行车与摩拜单车之间是继承关系，使用带空心三角箭头的实线表示\n- 学生上学需要用到摩拜单车，与摩拜单车是一种依赖关系，使用带箭头的虚线表示\n- 学生与身份证之间为关联关系，使用一根实线表示，如果两个类之间互相通过属性引用，则是双向关联关系\n- 学生与班级、学生与学校之间是聚合关系，使用带空心菱形箭头的实线表示\n- 学校与班级是组合关系，使用带实心菱形箭头的实线表示","tags":["Java","面向对象编程","UML"],"categories":["软件设计"]},{"title":"面向对象编程的理解","url":"/2018/102136438.html","content":"\n## 面向过程和面向对象\n\n### 面向过程思想概述\n\n面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。\n\n### 面向对象思想概述\n\n当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。面向对象是基于面向过程的编程思想。\n\n## 面向对象特征\n\n- 抽象\n- 封装\n- 继承\n- 多态\n\n### 抽象\n\n把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：\n\n- 数据抽象：表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)\n- 过程抽象：表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)\n\n### 封装\n\n封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。隐藏之后，外部程序就不能接触和改变那些细节，所以不用担心自己的类会受到非法修改，可确保它们不会对其他程序造成影响。\n\n#### 封装的原则\n\n- 将不需要对外提供的内容都隐藏起来\n- 把属性都隐藏，提供公共方法对其访问\n\n### 继承\n\n一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。\n\n#### 继承概念的实现方式\n\n- 类继承：类继承是指直接使用基类的属性和方法而无需额外编码。\n- 接口继承：接口继承是指仅使用属性和方法的名称、但是子类必须提供实现。\n\n### 多态\n\n多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。\n\n#### 实现多态的方式\n\n- 重载\n- 重写\n- 实现接口\n\n## 面向对象总结\n\n封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了**代码重用**。而多态则是为了实现另一个目的：**接口重用**！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。\n\n### 面向对象开发\n\n就是不断的创建对象，使用对象，指挥对象做事情。\n\n### 面向对象设计\n\n更好的管理和维护对象之间的关系。\n\n### 面向对象优点\n\n- 更符合我们思想习惯的思想\n- 将复杂的事情简单化\n- 将我们从执行者变成了指挥者\n","tags":["Java","面向对象编程"],"categories":["编程之道"]},{"title":"Java面向对象设计之建造者模式","url":"/2018/102060028.html","content":"\n## 一、模式动机\n\n无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。\n\n在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。\n\n复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。\n\n## 二、模式定义\n\n> 造者模式(`Builder Pattern`)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于**对象创建型模式**。建造者模式又可以称为**生成器模式**。\n\n建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。\n\n## 三、模式结构\n\n### 1. 角色组成\n\n建造者模式包含如下角色：\n\n- `Builder`：抽象建造者\n- `ConcreteBuilder`：具体建造者\n- `Director`：导演者\n- `Product`：产品角色\n\n### 2. 结构图\n\n![建造者模式结构图][1]\n\n## 四、示例代码\n\n首先，是产品类：\n\n```java\n/**\n * 产品类.\n *\n * Created by blinkfox on 2016/10/8.\n */\npublic class Product {\n\n    private String part1;\n\n    private String part2;\n\n    /* getter 和 setter方法. */\n\n    public String getPart1() {\n        return part1;\n    }\n\n    public void setPart1(String part1) {\n        this.part1 = part1;\n    }\n\n    public String getPart2() {\n        return part2;\n    }\n\n    public void setPart2(String part2) {\n        this.part2 = part2;\n    }\n\n}\n```\n\n其实，是抽象的建造者`Builder`接口和具体的建造者`ConcreteBuilder`类：\n\n```java\n/**\n * 抽象的建造者.\n *\n * Created by blinkfox on 2016/10/8.\n */\npublic interface Builder {\n\n    /**\n     * 产品建造部分1.\n     */\n    void buildPart1();\n\n    /**\n     * 产品建造部分2.\n     */\n    void buildPart2();\n\n    /**\n     * 得到建造的产品.\n     *\n     * @return 产品\n     */\n    Product getResult();\n\n}\n```\n\n```java\n/**\n * 具体的建造者实现类.\n *\n * Created by blinkfox on 2016/10/8.\n */\npublic class ConcreteBuilder implements Builder {\n\n    /** 产品. */\n    private Product product = new Product();\n\n    /**\n     * 产品建造部分1.\n     */\n    @Override\n    public void buildPart1() {\n        product.setPart1(\"编号：95757\");\n    }\n\n    /**\n     * 产品建造部分2.\n     */\n    @Override\n    public void buildPart2() {\n        product.setPart2(\"名称：小机器人\");\n    }\n\n    /**\n     * 得到建造的产品.\n     *\n     * @return 产品\n     */\n    @Override\n    public Product getResult() {\n        return product;\n    }\n\n}\n```\n\n最后，导演者`Director`类：\n\n```java\n/**\n * 导演者类.\n *\n * Created by blinkfox on 2016/10/8.\n */\npublic class Director {\n\n    /** 当前需要的建造者对象. */\n    private Builder builder;\n\n    /**\n     * 构造方法.\n     *\n     * @param builder\n     */\n    public Director(Builder builder) {\n        this.builder = builder;\n    }\n\n    /**\n     * 产品构造方法，负责调用各个零件建造方法.\n     */\n    public void construct() {\n        builder.buildPart1();\n        builder.buildPart2();\n    }\n\n}\n```\n\n以下是建造者模式的客户端场景类：\n\n```java\n/**\n * 建造者模式的客户端场景类.\n *\n * Created by blinkfox on 2016/10/8.\n */\npublic class BuilderClient {\n\n    /**\n     * 主入口方法.\n     *\n     * @param args 数组参数\n     */\n    public static void main(String[] args) {\n        Builder builder = new ConcreteBuilder();\n        Director director = new Director(builder);\n        director.construct();\n        Product product = builder.getResult();\n        System.out.println(product.getPart1());\n        System.out.println(product.getPart2());\n    }\n\n}\n```\n\n## 五、模式分析\n\n抽象建造者类中定义了产品的创建方法和返回方法;\n\n建造者模式的结构中还引入了一个导演者类`Director`，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象\n\n在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。\n\n### 1. 优点\n\n建造者模式的优点：\n\n- 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\n- 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。\n- 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\n- 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。\n\n### 2. 缺点\n\n建造者模式的缺点：\n\n- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。\n\n### 3. 适用环境\n\n在以下情况下可以使用建造者模式：\n\n- 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。\n- 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。\n- 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。\n- 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。\n\n### 4. 建造者模式与抽象工厂模式的比较\n\n- 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。\n- 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。\n- 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。\n\n## 六、模式总结\n\n- 建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。\n- 建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其`construct()`建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造\n- 在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。\n- 建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。\n- 建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。\n\n[1]: http://static.blinkfox.com/Builder.jpg","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java面向对象设计之外观模式","url":"/2018/101818310.html","content":"\n## 一、模式定义\n\n> **外观模式**(`Facade Pattern`)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为**门面模式**，它是一种对象结构型模式。\n\n## 二、模式结构\n\n### 1. 角色组成\n\n外观模式包含如下角色：\n\n- `Facade`: 外观角色\n- `SubSystem`: 子系统角色\n\n### 2. 结构图\n\n![命令模式结构图][1]\n\n## 三、示例代码\n\n首先，是各个子系统角色类，分别如下：\n\n```java\n/**\n * 子系统类A.\n *\n * Created by blinkfox on 16/8/25.\n */\npublic class ClassA {\n\n    public void doSomethingA() {\n        System.out.println(\"----业务方法A...\");\n    }\n\n}\n```\n\n```java\n/**\n * 子系统类B.\n *\n * Created by blinkfox on 16/8/25.\n */\npublic class ClassB {\n\n    public void doSomethingB() {\n        System.out.println(\"----业务方法B...\");\n    }\n\n}\n```\n\n```java\n/**\n * 子系统类C.\n *\n * Created by blinkfox on 16/8/25.\n */\npublic class ClassC {\n\n    public void doSomethingC() {\n        System.out.println(\"----业务方法C...\");\n    }\n\n}\n```\n\n以下是外观模式的外观类：\n\n```java\n/**\n * 外观门面类.\n *\n * Created by blinkfox on 16/8/25.\n */\npublic class Facade {\n\n    private ClassA a = new ClassA();\n    private ClassB b = new ClassB();\n    private ClassC c = new ClassC();\n\n    // 以下是提供给外部访问的方法.\n\n    public void methodA() {\n        this.a.doSomethingA();\n    }\n\n    public void methodB() {\n        this.b.doSomethingB();\n    }\n\n    public void methodC() {\n        this.c.doSomethingC();\n    }\n\n}\n```\n\n## 四、模式分析\n\n根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“**迪米特法则**”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。\n\n- 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。\n- 外观模式的目的在于降低系统的复杂程度。\n- 外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。\n\n### 1. 优点\n\n外观模式的优点k：\n\n- 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。\n- 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。\n- 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。\n- 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。\n\n### 2. 缺点\n\n外观模式的缺点：\n\n- 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。\n- 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“**开闭原则**”。\n\n### 3. 适用环境\n\n在以下情况下可以使用外观模式：\n\n- 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。\n- 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。\n- 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。\n\n## 五、模式总结\n\n- 在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。\n- 外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。\n- 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。\n- 外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。\n- 外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。\n\n[1]: http://static.blinkfox.com/Facade.jpg","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java面向对象设计之中介者模式","url":"/2018/101718124.html","content":"\n## 一、模式动机\n\n在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：\n\n- 系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。\n- 对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。\n- 系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。\n- 在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。\n- 对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。\n\n## 二、模式定义\n\n> **中介者模式(`Mediator Pattern`)**：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为**调停者模式**，它是一种对象行为型模式。\n\n## 三、模式结构\n\n### 1. 角色组成\n\n中介者模式包含如下角色：\n\n- `Mediator`: 抽象中介者\n- `ConcreteMediator`: 具体中介者\n- `Colleague`: 抽象同事类\n- `ConcreteColleague`: 具体同事类\n\n### 2. 结构图\n\n![命令模式结构图][1]\n\n[1]: http://static.blinkfox.com/Mediator.jpg\n\n## 四、示例代码\n\n首先，是抽象的`Mediator`类和具体的`ConcreteMediator`类：\n\n```java\n/**\n * 通用抽象中介者类.\n *\n * Created by blinkfox on 16/8/21.\n */\npublic abstract class Mediator {\n\n    /** 定义同事类1. */\n    protected ConcreteColleague1 colleague1;\n\n    /** 定义同事类2. */\n    protected ConcreteColleague2 colleague2;\n\n    /* getter 和 setter 方法 */\n    public ConcreteColleague1 getColleague1() {\n        return colleague1;\n    }\n\n    public void setColleague1(ConcreteColleague1 colleague1) {\n        this.colleague1 = colleague1;\n    }\n\n    public ConcreteColleague2 getColleague2() {\n        return colleague2;\n    }\n\n    public void setColleague2(ConcreteColleague2 colleague2) {\n        this.colleague2 = colleague2;\n    }\n\n    /**\n     * 中介者模式的抽象业务逻辑1.\n     */\n    public abstract void doSomething1();\n\n    /**\n     * 中介者模式的抽象业务逻辑2.\n     */\n    public abstract void doSomething2();\n\n}\n```\n\n```java\n/**\n * 具体的通用中介者类.\n *\n * Created by blinkfox on 16/8/21.\n */\npublic class ConcreteMediator extends Mediator {\n\n    /**\n     * 中介者模式的具体业务逻辑1.\n     */\n    @Override\n    public void doSomething1() {\n        super.colleague1.selfMethod1();\n        super.colleague2.selfMethod2();\n    }\n\n    /**\n     * 中介者模式的具体业务逻辑2.\n     */\n    @Override\n    public void doSomething2() {\n        super.colleague1.selfMethod1();\n        super.colleague2.selfMethod2();\n    }\n\n}\n```\n\n其实，是抽象的`Colleague`类和具体的`ConcreteColleague`类：\n\n```java\n/**\n * 抽象的同事类.\n *\n * Created by blinkfox on 16/8/21.\n */\npublic abstract class Colleague {\n\n    /** 中介者. */\n    protected Mediator mediator;\n\n    public Colleague(Mediator mediator) {\n        this.mediator = mediator;\n    }\n\n}\n```\n\n```java\n/**\n * 具体的同事类1.\n *\n * Created by blinkfox on 16/8/21.\n */\npublic class ConcreteColleague1 extends Colleague {\n\n    public ConcreteColleague1(Mediator mediator) {\n        super(mediator);\n    }\n\n    /**\n     * 自有方法.\n     */\n    public void selfMethod1() {\n        System.out.println(\"------ConcreteColleague1-处理自己的业务逻辑1--------\");\n    }\n\n    /**\n     * 依赖方法.\n     */\n    public void depMethod1() {\n        System.out.println(\"------ConcreteColleague1-委托给中介者的业务逻辑1--------\");\n        super.mediator.doSomething1();\n    }\n\n}\n```\n\n```java\n/**\n * 具体的同事类2.\n *\n * Created by blinkfox on 16/8/21.\n */\npublic class ConcreteColleague2 extends Colleague {\n\n    public ConcreteColleague2(Mediator mediator) {\n        super(mediator);\n    }\n\n    /**\n     * 自有方法2.\n     */\n    public void selfMethod2() {\n        System.out.println(\"------ConcreteColleague2-处理自己的业务逻辑2--------\");\n    }\n\n    /**\n     * 依赖方法2.\n     */\n    public void depMethod2() {\n        System.out.println(\"------ConcreteColleague2-委托给中介者的业务逻辑2--------\");\n        super.mediator.doSomething2();\n    }\n\n}\n```\n\n以下是中介者模式的客户端场景类：\n\n```java\n/**\n * 中介者模式的场景类\n * Created by blinkfox on 16/8/21.\n */\npublic class MediatorClient {\n\n    public static void main(String[] args) {\n        Mediator mediator = new ConcreteMediator();\n\n        ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator);\n        ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator);\n        mediator.setColleague1(colleague1);\n        mediator.setColleague2(colleague2);\n\n        colleague1.depMethod1();\n        colleague2.depMethod2();\n        mediator.doSomething1();\n        mediator.doSomething2();\n    }\n\n}\n```\n\n## 五、模式分析\n\n中介者模式可以使对象之间的关系数量急剧减少。\n\n中介者承担两方面的职责：\n\n- **中转作用（结构性）**：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。\n- **协调作用（行为性）**：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。\n\n### 1. 优点\n\n中介者模式的优点：\n\n- 简化了对象之间的交互。\n- 将各同事解耦。\n- 减少子类生成。\n- 可以简化各同事类的设计和实现。\n\n### 2. 缺点\n\n中介者模式的缺点：\n\n- 在具体中介者类中包含了同事之间的交互细节，**可能会导致具体中介者类非常复杂，使得系统难以维护**。\n\n### 3. 适用环境\n\n在以下情况下可以使用中介者模式：\n\n- 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。\n- 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。\n- 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。\n- 交互的公共行为，如果需要改变行为则可以增加新的中介者类。\n\n## 六、模式总结\n\n- 中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。\n- 中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。\n- 通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。\n- 中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。\n- 中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java面向对象设计之命令模式","url":"/2018/101640715.html","content":"\n## 一、模式动机\n\n在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。\n\n命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。\n\n## 二、模式定义\n\n> **命令模式(`Command Pattern`)**：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(`Action`)模式或事务(`Transaction`)模式。\n\n## 三、模式结构\n\n### 1. 角色组成\n\n命令模式包含如下角色：\n\n- `Command`: 抽象命令类\n- `ConcreteCommand`: 具体命令类\n- `Invoker`: 调用者\n- `Receiver`: 接收者\n- `Client`: 客户类\n\n### 2. 结构图\n\n![命令模式结构图][1]\n\n[1]: http://static.blinkfox.com/Command.jpg\n\n## 四、示例代码\n\n首先，是抽象的`Receiver`类和具体的`Receiver`类：\n\n```java\n/**\n * 通用的抽象 Receiver 接收者.\n *\n * Created by blinkfox on 16/8/17.\n */\npublic abstract class Receiver {\n\n    /**\n     * 定义每个接收者都必须完成的业务.\n     */\n    public abstract void doSomething();\n\n}\n```\n\n```java\n/**\n * 具体的 Receiver 类1.\n *\n * Created by blinkfox on 16/8/17.\n */\npublic class ConcreteReceiver1 extends Receiver {\n\n    @Override\n    public void doSomething() {\n        System.out.println(\"ConcreteReceiver1 处理的业务逻辑...\");\n    }\n\n}\n```\n\n```java\n/**\n * 具体的 Receiver 类2.\n *\n * Created by blinkfox on 16/8/17.\n */\npublic class ConcreteReceiver2 extends Receiver {\n\n    @Override\n    public void doSomething() {\n        System.out.println(\"ConcreteReceiver2 处理的业务逻辑...\");\n    }\n\n}\n```\n\n其实，是抽象的`Command`类和具体的`Command`类：\n\n```java\n/**\n * 抽象的 Command 类.\n *\n * Created by blinkfox on 16/8/17.\n */\npublic abstract class Command {\n\n    /**\n     * 命令的抽象执行命令的方法.\n     */\n    public abstract void execute();\n\n}\n```\n\n```java\n/**\n * 具体的 Command 命令类1.\n *\n * Created by blinkfox on 16/8/17.\n */\npublic class ConcreteCommand1 extends Command {\n\n    /** 对哪个receiver类进行处理. */\n    private Receiver receiver;\n\n    public ConcreteCommand1(Receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    /**\n     * 必须实现的一个命令.\n     */\n    @Override\n    public void execute() {\n        this.receiver.doSomething();\n    }\n\n}\n```\n\n```java\n/**\n * 具体的 Command 命令类2.\n *\n * Created by blinkfox on 16/8/17.\n */\npublic class ConcreteCommand2 extends Command {\n\n    /** 对哪个receiver类进行处理. */\n    private Receiver receiver;\n\n    public ConcreteCommand2(Receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    /**\n     * 必须实现的命令.\n     */\n    @Override\n    public void execute() {\n        this.receiver.doSomething();\n    }\n\n}\n```\n\n最后，调用者`Invoker`类：\n\n```java\n/**\n * 调用者 Invoker 类.\n *\n * Created by blinkfox on 16/8/17.\n */\npublic class Invoker {\n\n    private Command command;\n\n    public void setCommand(Command command) {\n        this.command = command;\n    }\n\n    /**\n     * 执行命令.\n     */\n    public void action() {\n        this.command.execute();\n    }\n}\n```\n\n以下是命令模式的客户端场景类：\n\n```java\n/**\n * 命令模式的场景类.\n *\n * Created by blinkfox on 16/8/17.\n */\npublic class CommandClient {\n\n    public static void main(String[] args) {\n        Invoker invoker = new Invoker();\n        Receiver receiver = new ConcreteReceiver1();\n        Command command = new ConcreteCommand1(receiver);\n\n        // 把命令交给调用者执行\n        invoker.setCommand(command);\n        invoker.action();\n    }\n\n}\n```\n\n## 五、模式分析\n\n**命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开**。\n\n- 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。\n- 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n- 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。\n- 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。\n\n### 1. 优点\n\n命令模式的优点：\n\n- 降低系统的耦合度。\n- 新的命令可以很容易地加入到系统中。\n- 可以比较容易地设计一个命令队列和宏命令（组合命令）。\n- 可以方便地实现对请求的`Undo`和`Redo`。\n\n### 2. 缺点\n\n命令模式的缺点：\n\n- 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。\n\n### 3. 适用环境\n\n在以下情况下可以使用命令模式：\n\n- 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。\n- 系统需要在不同的时间指定请求、将请求排队和执行请求。\n- 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n- 系统需要将一组操作组合在一起，即支持宏命令\n\n## 六、模式总结\n\n- 在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。\n- 命令模式包含四个角色：抽象命令类中声明了用于执行请求的`execute()`等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。\n- 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。\n- 命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。\n- 命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"代码整洁之道内容概要","url":"/2018/101560116.html","content":"\n读了代码整洁之道，觉得这本书写的很好，所以就将里面自己觉得很经典的内容记录下来，作为自己以后写代码的标准和准则。同时也为那些曾经困惑过的人一点参考吧！\n\n## 一、在正式开始之前，我们先思考几个几个问题：\n\n### 1.需求与代码哪个重要？\n\n答：并不是所有的产品都能提出合理的需求，当你面对一个提出不合理需求的产品的时候，你需要坚持自己的原则，不能妥协。\n\n### 2.易读和易懂是一回事吗？\n\n答：易读的代码和易懂的代码是有区别的，不是易读的代码就是易懂的代码。\n\n### 3.什么是测试驱动代码？\n\n答：测试驱动代码，你写的代码要可以执行单元测试。如果你发现你的代码很难写单元测试，那么你就要思考你的代码是不是已经不整洁了，或者说已经乱成一团了。\n\n### 4.什么是简单的代码？\n\n答：\n1.能通过所有测试\n2.没有重复代码\n3.体现系统中全部设计理念\n4.包含尽量少的实体，包括，类，函数，方法等\n\n如果某段代码在程序设计中反复出现，就证明想法在代码中没有很好的体现出来。总之，不要重复代码，只做一件事，表达力，小规模抽象。\n\n## 二、第二章 有意义的命名\n\n### 1.名副其实\n\n变量，函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用。如果名称需要注释来补充，那么就不算名副其实。\n\n### 2.避免误导\n\n必须避免留下掩藏代码本意的错误线索。\n\n### 3.做有意义的区分\n\n只要体现出有意义的区分，使用a和the这样的前缀就没有错。废话就是冗余。\n\n### 4.使用读得出来的名称\n\n不要用傻乎乎的自造词，而不是恰当的英语词。\n\n### 5.使用可搜索的名称\n\n使用便于搜索的名字。\n\n### 6.避免使用编码\n\n把类型或者作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外，还要再搞懂另一种编码”语言”。\n\n### 7.避免思维映射\n\n不应当让读者在脑中把你的名称翻译为他们熟知的名称，尤其是在经常出现在选择是使用问题领域术语还是解决方案领域术语的时候。\n\n### 8.类名或对象名最好使用名词或者名词短语\n\n### 9.方法名最好使用动词或者动词短语\n\n### 10.别扮可爱\n\n命名一定要通俗易懂。\n\n### 11.每一个概念对应一个词\n\n给每个抽象概念选择一个词，并一以贯之\n\n### 12.别用双关语词\n\n避免将同一个词用于不同目的，遵循一词一义的原则\n\n### 13.使用解决方案领域名\n\n### 14.使用源自所涉领域名\n\n### 15.添加有意义的语境\n\n在一个bean中定义变量名的时候，变量名一定是基于实际使用场景。\n\n### 16.不要添加没用的语境\n\n## 三、第三章 函数\n\n### 1.短小\n\n函数第一规则是要短小。第二条规则是还要更短小。\n\n### 2.只做一件事\n\n- 函数应该做一件事。做好这件事。只做一件事。如果可以从你的函数中还能拆分出一个函数，该函数不仅只是单纯地重新诠释其实现，那么你设计的函数就不是一个好的函数。\n- 函数中的区段，如果函数被切分了多个区段，这就证明该函数做的事情太多了。\n\n### 3.每个函数一个抽象层级\n\n### 4.switch语句\n\n确保每个switch都埋藏在较低的抽象层级，而且永远不重复。\n\n### 5.使用描述性的名称\n\n命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如：includeSetupPages。\n\n### 6.函数参数\n\n- 最理想的函数参数的数量是零个，其次是一，再次是二，应尽量避免三。有足够的理由才能用上三个以上的参数。\n- 如果函数看来需要两个，三个或者三个以上参数，就说明其中一些参数应该封装为类了。\n- 函数和函数的参数命名一般是动名词比较好。\n\n### 7.无副作用\n\n### 8.分割指令与查询\n\n函数要么做什么事，要么回答什么事，但二者不可兼得\n\n### 9.使用异常替代返回错误码\n\n- 返回错误码的时候，就是在要求调用者立刻处理错误。\n- 如果使用异常替代返回错误码，错误处理代码就能从住路径代码中分离出来，得到简化。\n- 抽离try/catch代码块\n\n### 10.别重复自己\n\n### 11.结构化编程\n\n## 四、第四章 注释\n\n### 1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。\n\n### 2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？\n\n- 法律信息\n- 提供信息的注释\n- 提供意图的解释\n- 阐释\n- 警告\n- TODO注释\n- TODO是一种程序要认为应该要做的，但是由于某种原因没有做的\n- 放大,放大某些看似不合理的地方\n\n## 五、第六章 对象和数据结构\n\n### 1.得墨忒定律\n\n模块不应该了解他所操作对象的内部情形。对象隐藏数据曝露操作，这就意味着对象不应该通过存取器曝露其内部结构。\n\n## 六、第七章 错误处理\n\n### 1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。\n### 2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。\n\n## 七、第八章 边界\n\n### 1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。\n\n## 八、第九章 单元测试\n\n### 1.TDD三定律\n\n- 在编写不能通过的单元测试前，不可编写生产代码。\n- 只可编写刚好无法通过的单元测试，不能编译也算不通过\n- 只可编写刚好足以通过当前失败测试的生产代码\n\n### 2.整洁测试三要素\n\n- 可读性\n- 可读性\n- 可读性\n\n### 3.整洁测试的五条原则：\n\n- 快速，测试应该够快\n- 独立，测试应该相互独立\n- 可重复，测试应当可在任何环境中重复通过。\n- 自足验证，测试应该有布尔值输出，无论测试是成功还是失败，不应该人工通过log来确认测试是否成功或者失败。\n- 及时，测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。\n\n## 九、第十章 类\n\n### 1.单一权责原则，类或者模块应有且只有一条加以修改的理由。\n### 2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。\n\n## 十、第十一章 系统\n\n### 1.将系统的构造与使用分开\n\n软件系统应将起始过程和启始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在相互缠结的依赖关系。（延迟初始化可以加快程序运行速度）\n\n#### 1.1分解main\n\n将程序的构造放到main，并使其与运行时逻辑分开，main只管构造并将构造后的数据对象发送给各个应用，或者被各个应用使用。但是，不参与运行时的任何逻辑控制。\n\n#### 1.2工厂模式\n\n使用该模式可以将系统构造和系统运行时逻辑分开。\n\n#### 1.3依赖注入（需要强化理解）\n\n#### 1.4扩容\n\n“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统，实现新用户的故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发，重构以及他们打造出的整洁的代码。\n\n#### 1.5测试驱动系统架构\n\n最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯编程语言对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具结合起来。这种架构就能测试驱动，就像代码一样。(需要关注面向切片编程(POJO))\n\n#### 1.6优化决策\n\n模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或是一个软件项目，无人能做所有的决策。最好是授权给最有资格的人。拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的，时机刚好的决策。决策的复杂性降低了。\n\n## 十一、第十二章 迭进\n\n### 1. 通过迭进设计达到代码整洁的目的：\n\n通过这几个原则可以让你的设计变简单（DIP，SRP）\n\n- 运行所有测试\n- 不可重复，\n- 表达了程序员的意图\n- 尽可能减少类和方法的数量\n- 以上规则按其重要程度排序\n\n### 2. 简单设计规则1:运行所有测试\n\n编写的测试越多就越能持续走向编写较易测试的代码，紧耦合的代码很难编写测试。遵循有关编写测试并持续运行测试的简单，明确的规则，系统就会更贴近OO低耦合度，高内聚度的目标。编写测试引致更好的设计。\n\n### 3. 简单设计规则2-4：重构\n\n在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是简单设计原则后三条规则的地方:消除重复，保证表达力，尽可能减少类和方法的数量。\n\n### 4. 不可重复\n\n### 5. 表达力\n\n### 6. 尽可能少的类和方法\n\n## 十二、第十三章 并发编程\n\n### 1. 为什么要并发\n\n并发是一种解耦策略。它帮我们把做什么和何时做分解开。\n\n### 2. 并发的防御原则\n\n### 13.1 单一权责原则（SRP）\n\n并发代码应该从其他代码中分离出来，因为，并发代码相比于其他的代码是很复杂的存在。但是，并发实现细节常常直接嵌入到其他生产代码中。那么下面几个问题需要考虑，\n\n- 并发相关代码由自己的开发，修改和调优生命周期\n- 开发相关代码由自己要对付的挑战，和非并发相关代码不同，而且往往更为困难\n- 即便没有周边应用程序增加负担，写得不好的并发代码可能的出错方式数量已经足具挑战性。\n\n> 建议：分离并发相关代码与其他代码。\n\n### 13.2 限制数据作用域\n\n两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是采用`synchronized`关键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越多，就越可能出错。\n\n> 建议：谨记数据封装，严格限制对可能被共享的数据的访问。\n\n### 13.3 使用数据副本\n\n避免共享数据的好方法之一就是一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外一种情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。\n\n### 13.4　线程尽可能地独立\n\n让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。\n\n建议：尝试将数据分解到可被独立线程操作的独立子集。\n\n### 13.5 了解执行模型\n\n#### 13.5.1 生产者－－－消费者模型\n\n一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。\n\n#### 13.5.2 读者－－－作者模型\n\n当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的消息，这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。\n\n挑战之处在于平衡读者线程和作者线程的需求，实现正确的操作，提供合理的吞吐量，避免线程饥饿。\n\n#### 13.5.3哲学家问题（故事内容不在这里描述）\n\n从哲学家问题可以反映出编写并发经常遇到的问题，死锁，活锁，吞吐量和效率降低等问题。那么学习这些基础问题的解决算法可以帮助你解决大多数的并发问题，因为大多的并发问题都是上述问题的变种。\n\n### 13.6 警惕同步方法之间的依赖\n\n同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java语言有synchronized概念，可以用来保护单个方法。然而，如果在同一共享类中由多个同步方法，系统就可能写得不太正确了。\n\n> 建议：避免使用一个共享对象的多个方法。如果有时必须使用一个共享对象的多个方法。这种情况发生时，有３中写对代码的手段：\n\n- 基于客户端的锁定－－客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。\n- 基于服务端的锁定－－在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新的方法。\n- 适配服务端－－创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务端代码。\n\n### 13.7保持同步区域微小\n\n应该尽可能少地设计临界区，如果有请尽可能减小同步区域。\n\n### 13.8　编写线程需要注意的几点：\n\n#### (1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。\n\n#### (2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。\n\n#### (3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码\n\n- 1.单线程与多线程在执行时不同的情况\n- 2.线程代码与实物或测试替身互动\n- 3.用运行速度,缓慢和有变动的测试替身执行\n- 4.将测试配置为能运行一定数量的迭代\n\n> 建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。\n\n#### (4). 编写可调整的线程代码\n\n在系统运行时允许线程发生变动。允许线程依据吞吐量和使用率自我调整。\n\n#### (5). 运行多余处理器数量的线程\n\n任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。\n\n#### (6). 在不同平台上运行\n\n#### (7). 调整代码并强迫错误发生\n\n## 十三、第14章 逐步改进\n\n代码并不是一次就能写的很干净的，需要我们不断的迭代和优化。\n\n## 十四、第17章 味道与启发\n\n### 1. 注释\n\n#### (1). 不恰当的注释信息\n\n让注释传达本该更好地在源代码控制系统，问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。注释只应该描述有关代码和设计的技术性信息。\n\n#### (2). 废弃的注释\n\n过时，无关或不正确的注释就是废弃的注释。\n\n#### (3). 冗余注释\n\n如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。注释应该谈及代码自身没有提到的东西。\n\n#### (4). 注释要写就要写最好的注释，别画蛇添足\n\n#### (5). 注释掉的代码，看到注释掉的代码就删。\n\n### 2. 环境\n\n#### (1). 需要多步才能实现的构建\n\n构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四出寻找额外的小jar,xml文件和其他系统所需的杂物。你应该能够用单个命令签出系统，并单个指令构建它。\n\n#### (2). 需要多步才能做到测试\n\n你应该能够用单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速，轻易和直接了当地做到。\n\n### 3. 函数\n\n- 函数的参数应该少。\n- 输出参数违反直觉。如果非要修改，那就修改函数所在对象好了。\n- 标示参数，布尔值参数宣告函数做了不止一件事，应该消灭掉，即函数只做一件事。\n- 永不被调用的方法应该丢弃。\n\n### 4. 一般性问题\n\n(1). 如果代码需要有多种语言，那么应该尽力减少源文件中额外语言的数量和范围。\n\n(2). 明显的行为未被实现，如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。\n\n(3). 不正确的边界行为，追索每种边界条件，编写测试。\n\n(4). 忽视安全\n\n(5). 重复，尽可能找到并消除重复。\n\n(6). 在错误的抽象层级上的代码，创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。\n\n(7). 基类不可多度依赖于派生类，基类应该对派生类一无所知。\n\n(8). 信息过多，设计良好的模块有着非常小的接口，让你事半功倍。设计良好的接口并不提供许多需要依靠的函数，所以耦合度比较低。\n\n优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。\n\n(9). 死代码一定要删除。\n\n(10). 垂直分隔，变量和函数应该在靠近被使用的地方定义。私有函数应该刚好在其首次被使用的位置下面定义。\n\n(11). 前后不一致，从一而终即一旦选中，就小心持续遵循。如果在特定函数中用了response的变量来持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名。这样会让你的代码更易阅读。\n\n(12). 混淆视听，没用的变量或者函数直接删掉，以免造成不必要的干扰。\n\n(13). 人为耦合，不互相依赖的东西不该耦合。一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量，常量或函数不恰当地放在临时方便的位置。\n\n(14). 特性依恋，类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。\n\n(15). 选择算子参数，尽量不要把boolean作为函数参数\n\n(16). 晦涩意图，代码要尽可能具有表达力。\n\n(17). 位置错误的权责，我们可以采用最小惊异原则来帮助我们即代码应该放在读者自然而然期待它所在的地方。\n\n(18). 不恰当的静态方法，对于没有机会打算让它有多态行为的函数可以作为动态函数，否则可选用静态函数。\n\n(19). 使用解释性变量，命名要有意义。\n\n(20). 函数名称应该表达其行为\n\n(21). 理解算法\n\n(22). 把逻辑依赖改为物理依赖：\n\n- 1.逻辑依赖：原始数据和业务逻辑之间的依赖关系。例如：定义的常量和业务逻辑存在着依赖关系或者说被捆绑在了一起，即当业务逻辑发生变化或者存在其他可能性的时候且定义的常量无法满足导致常量需要修改。\n- 2.物理依赖：函数方法和业务逻辑之间的依赖关系。例如：为了解决逻辑依赖的问题，我们可以通过构造一个方法将数据和业务隔离。\n\n(23). 用多态替代`if/else` 或 `switch/case`\n\n(24). 遵循标准约定\n\n(25). 用命名常量替代魔术数，魔术数不仅仅指的是数字，也泛指任何不能自我描述的符号。\n\n(26). 准确，在可以用List的时候，非要把变量声明为ArrayList就过分拘束了。在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。代码中的含糊和不准确性要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。\n\n(27). 结构甚于约定，坚守结构甚于约定的设计决策。\n\n(28). 封装条件，如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。\n\n例如：\n\n```java\nif(shouldBeDeleted(timer))\n```\n要好于\n\n```java\nif(timer.hasExpired() && !timer.isRecurrent())\n```\n\n(29). 避免否定性条件，尽可能将条件表示为肯定形式。\n\n(30). 函数只该做一件事\n\n(31). 掩蔽时序耦合，排列函数参数，好让它们被调用的次序显而易见。\n\n(32). 别随意，构建代码需要理由，而且理由应于代码结构相契合。\n\n(33). 封装边界条件，把处理边界条件的代码集中到一处，不要散落于代码中。\n\n(34). 函数应该只在一个抽象层级上，函数中的语句应该在同意抽象级上，该层级应该是函数名所示操作的下一层。\n\n(35). 在较高层级放置可配置数据，如果你有个已知并在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。\n\n(36). 避免传递浏览，编写害羞代码。\n\n(37). 不要继承常量\n\n### 17.5 测试\n\n1. 使用覆盖率工具，覆盖率工具能汇报你测试策略中的缺口。使用测试覆盖率工具能更容易地找到不足的模块，类和函数。\n2. 别略过小测试\n3. 被忽略的测试就是对不确定事物的疑问。\n4. 测试边界条件\n5. 全面测试相近的缺陷，缺陷趋向于扎堆。\n6. 测试失败的模式有启发性。\n7. 测试覆盖率的模式有启发性，查看被或未被以通过的测试执行的代码，往往能发现失败的测试为何失败的线索。\n8. 测试应该快速。\n\n来自：[代码整洁之道内容概要][1]\n\n\n  [1]: http://www.uml.org.cn/codeNorms/201701162.asp","tags":["整洁代码","重构","测试"],"categories":["编程之道"]},{"title":"Java面向对象设计之观察者模式","url":"/2018/101432841.html","content":"\n## 一、模式动机\n\n建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。\n\n## 二、模式定义\n\n> 观察者模式(`Observer Pattern`)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（`Publish`/`Subscribe`）模式、模型-视图（`Model`/`View`）模式、源-监听器（`Source`/`Listener`）模式或从属者（`Dependents`）模式。\n\n观察者模式是一种**对象行为型模式**。\n\n## 三、模式结构\n\n### 1. 角色组成：\n\n观察者模式包含如下角色：\n\n- `Subject`: 目标（抽象的被观察着）\n- `ConcreteSubject`: 具体目标（具体的被观察者）\n- `Observer`: 观察者\n- `ConcreteObserver`: 具体观察者\n\n### 2. 结构图：\n\n![观察者模式结构图][1]\n\n### 3. 时序图：\n\n![观察者模式时序图][2]\n\n## 四、示例代码\n\n首先，是观察者接口：\n\n```java\n/**\n * 观察者接口\n * Created by blinkfox on 16/7/14.\n */\npublic interface Observer {\n\n    // 更新的方法\n    public void update();\n\n}\n```\n\n接下来，是具体的观察者类：\n\n```java\n/**\n * 具体的观察者.\n *\n * Created by blinkfox on 16/7/15.\n */\npublic class ConcreteObserver implements Observer {\n\n    /**\n     * 实现更新方法.\n     */\n    @Override\n    public void update() {\n        System.out.println(\"接收到信息,并进行处理...\");\n    }\n\n}\n```\n\n然后，是被观察者的抽象类：\n\n```java\n/**\n * 被观察者的抽象类.\n *\n * Created by blinkfox on 16/7/14.\n */\npublic abstract class Subject {\n\n    /** 定义一个观察者的集合. */\n    private List<Observer> observers = new ArrayList<Observer>();\n\n    /**\n     * 增加一个观察者.\n     *\n     * @param o\n     */\n    public void addObserver(Observer o) {\n        this.observers.add(o);\n    }\n\n    /**\n     * 删除一个观察者.\n     *\n     * @param o\n     */\n    public void delObserver(Observer o) {\n        this.observers.remove(o);\n    }\n\n    /**\n     * 通知所有观察者.\n     */\n    public void notifyObservers() {\n        for (Observer o: observers) {\n            o.update();\n        }\n    }\n\n}\n```\n\n具体的被观察者：\n\n```java\n/**\n * 具体的被观察者.\n *\n * Created by blinkfox on 16/7/15.\n */\npublic class ConcreteSubject extends Subject {\n\n    /**\n     * 具体的业务.\n     */\n    public void doSomething() {\n        super.notifyObservers();\n    }\n\n}\n```\n\n最后，是用于测试观察者模式的客户端场景类：\n\n```java\n/**\n * 观察者模式客户端场景类.\n *\n * Created by blinkfox on 16/7/15.\n */\npublic class ObserverClient {\n\n    public static void main(String[] args) {\n        // 创建一个被观察者和观察者.\n        ConcreteSubject sub = new ConcreteSubject();\n        Observer obs = new ConcreteObserver();\n        // 观察者观察被观察者.\n        sub.addObserver(obs);\n        // 观察者开始活动了.\n        sub.doSomething();\n    }\n\n}\n```\n\n## 五、模式分析\n\n- 观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。\n- 这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。\n- 作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为**发布-订阅**(`publish-subscribe`)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。\n\n### 1. 优点\n\n观察者模式的优点：\n\n- 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。\n- 观察者模式在观察目标和观察者之间建立一个抽象的耦合。\n- 观察者模式支持广播通信。\n- 观察者模式符合“开闭原则”的要求。\n\n### 2. 缺点\n\n观察者模式的缺点：\n\n- 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\n- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。\n- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n\n### 3.适用环境\n\n在以下情况下可以使用观察者模式：\n\n- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n- 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n- 一个对象必须通知其他对象，而并不知道这些对象是谁。\n- 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。\n\n> 观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。\n\n## 六、总结\n\n- 观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。\n- 观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。\n- 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。\n- 观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。\n- 观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。\n- 在JDK的`java.util`包中，提供了`Observable`类以及`Observer`接口，它们构成了Java语言对观察者模式的支持。\n\n[1]: http://static.blinkfox.com/Obeserver.jpg\n[2]: http://static.blinkfox.com/seq_Obeserver.jpg","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"常用Bash命令整理之其他常用命令","url":"/2018/101342868.html","content":"\n## 1. hostname - 查看主机名\n\n`hostname`命令用于查看系统的主机名，或是修改系统的主机名。\n\n`hostname`的常用命令如下：\n\n```bash\n# 显示系统的当前主机名\nhostname\n\n# 修改你系统的主机名\nhostname blinkfox-system\n\n# 使用 -F 选项，从指定的文件中读取主机名\nhostname -F /root/hostname.txt\n```\n\n## 2. uptime - 查看系统运行时间\n\n`uptime`命令用于打印系统的运行时间等信息。使用如下：\n\n```bash\nuptime\n```\n\n## 3. w、who - 列出登录的用户\n\n`w`命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下：\n\n```bash\nw\n\n# 打印如下\n22:42  up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75\nUSER     TTY      FROM              LOGIN@  IDLE WHAT\nblinkfox console  -                日19   6days -\nblinkfox s000     -                五23       - w\n```\n\n`who`命令有与`w`命令类似的用途，但它的功能比`w`命令更强大一些。语法格式如下：\n\n```bash\nwho [OPTION]... [FILE | ARG1 ARG2]\n```\n\n`who`常用命令如下：\n\n```bash\n# 显示当前登录的所有用户信息\nwho\n\n# 显示系统的启动时间\nwho -b\n\n# 显示系统登录进程\nwho -l\n\n# 显示与当前标准输入关联的用户信息\nwho -m\n\n# 显示系统的运行级别\nwho -r\n\n# 显示所有登录用户的用户名和登录用户数\nwho -q\n```\n\n## 4. uname - 查看系统信息\n\n`uname`命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：\n\n```bash\nuname [OPTION]...\n```\n\n常用使用方式如下：\n\n```bash\n# 只打印内核的名称\nuname\n\n# 使用 -n 选项，只打印系统的主机名\nuname -n\n\n# 使用 -r 选项，打印内核版本信息\nuname -r\n\n# 使用 -m 选项，打印系统的硬件名称\nuname -m\n\n# 使用 -p 选项，打印系统的处理器类型信息\nuname -p\n\n# 使用 -i 选项，打印系统的硬件平台信息\nuname -i\n\n# 使用 -a 选项，打印上述所有示例中的信息\nuname -a\n```\n\n## 5. date - 显示和设置系统日期和时间\n\n`date`命令用于以多种格式显示日期和时间，或设置系统的日期和时间。`date`命令的语法如下所示：\n\n```bash\ndate [OPTION]... [+FORMAT]\ndate [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n```\n\n常用使用命令如下：\n\n```bash\n# 以默认格式显示系统的当前日期时间\ndate\n\n# 格式化当前日期\ndate +\"%Y-%m-%d\"\n\n# 格式化输出昨天的日期\ndate -d \"1 day ago\" +\"%Y-%m-%d\"\n\n# 2秒后格式化输出\ndate -d \"2 second\" +\"%Y-%m-%d %H:%M.%S\"\n\n# 普通格式化转出\ndate -d \"2009-12-12\" +\"%Y/%m/%d %H:%M.%S\"\n\n# apache格式转换\ndate -d \"Dec 5, 2009 12:00:37 AM\" +\"%Y-%m-%d %H:%M.%S\"\n\n# 日期加减操作\ndate +%Y%m%d #显示前天年月日\ndate -d \"+1 day\" +%Y%m%d #显示前一天的日期\ndate -d \"-1 day\" +%Y%m%d #显示后一天的日期\ndate -d \"-1 month\" +%Y%m%d #显示上一月的日期\ndate -d \"+1 month\" +%Y%m%d #显示下一月的日期\ndate -d \"-1 year\" +%Y%m%d #显示前一年的日期\ndate -d \"+1 year\" +%Y%m%d #显示下一年的日期\n\n# 设定时间\ndate -s # 设置当前时间，只有root权限才能设置，其他只能查看\ndate -s 20160816 # 设置成20160816，这样会把具体时间设置成空00:00:00\ndate -s 01:01:01 # 设置具体时间，不会对日期做更改\ndate -s \"01:01:01 2012-05-23\" # 这样可以设置全部时间 \ndate -s \"01:01:01 20120523\" # 这样可以设置全部时间\ndate -s \"2012-05-23 01:01:01\" # 这样可以设置全部时间 \ndate -s \"20120523 01:01:01\" # 这样可以设置全部时间\n```\n\n## 6. id - 显示用户属性\n\n`id`命令用于打印输出用户`uid`、`gid`、用户名和组名等用户身份信息。`id`命令的语法如下所示：\n\n```bash\nid [OPTION]... [USERNAME]\n```\n\n常见使用命令如下：\n\n```bash\n# 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息\nid\n\n# 使用 -u 选项，输出用户的 uid\nid -u\n\n#-u 选项和 -n 选项结合使用，输出账户的用户名\nid -un\n\n# 使用 -g 选项，输出帐号当前起作用的gid\nid -g\n\n# -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名\nid -gn\n\n# 使用 -G 选项，输出帐号所属的所有群组id\nid -G root\n\n# -G 与 -n 选项结合使用，输出账号所属的所有群组的名称\nid -Gn root\n```","tags":["Linux"],"categories":["软件工具"]},{"title":"常用Bash命令整理之文本处理","url":"/2018/101120587.html","content":"\n## 1. sort - 文本排序\n\n`sort`命令用于将文本文件的行排序。默认情况下，`sort`命令是按照字符串的字母顺序排序。\n\nsort 的常用命令如下：\n\n```bash\n# 将文本内容按字母顺序排序\nsort example.txt\n\n# 使用 -u 选项，移除所有重复行后排序\nsort -u example.txt\n\n# 使用 -n 选项，将令数字按数值的大小排序\nsort -n example.txt\n\n# 使用 -r 选项，以倒序方式排序\nsort -n -r example.txt\n\n# 同时将 file1、file2 的内容排序\nsort file1 file2\n```\n\n## 2.uniq - 文本去重\n\n`uniq`命令用于移除或发现文件中重复的条目。\n\n```bash\n# 它将移除文件中重复的行并显示单一行\nuniq example.txt\n\n# 可以统计重复行出现的次数\nuniq -c example.txt\n\n# 使用 -d 选项，只显示文件中有重复的行并只显示一次\nuniq -d example.txt\n\n# 使用 -D 选项，显示文件中所有重复的行\nuniq -D example.txt\n\n# 使用 -u 选项，只显示文件中不重复的行\nuniq -u example.txt\n\n# 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复\nuniq -w 3 example.txt\n\n# 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复\nuniq -s 3 example.txt\n\n# 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复\nuniq -f 1 example.txt\n```\n\n## 3.tr - 替换或删除字符\n\n`tr`命令主要用于删除文件中控制字符或进行字符转换。使用`tr`时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。`tr`刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。\n\n`tr`命令的语法如下所示：\n\n```bash\ntr [OPTION]... SET1 [SET2]\n```\n\n常用命令示例：\n\n```bash\n# 若要将大括号转换为小括号\ntr '{}' '()' < textfile > newfile\n\n# 若要将大括号转换成方括号\ntr '{}' '\\[]' < textfile > newfile\n\n# 若要将小写字符转换成大写，请输入：\ntr 'a-z' 'A-Z' < textfile > newfile\n\n# 若要创建一个文件中的单词列表\ntr -cs '[:lower:][:upper:]' '[\\n*]' < textfile > newfile\n\n# 若要从某个文件中删除所有空字符\ntr -d '\\0' < textfile > newfile\n\n# 若要用单独的换行替换每一序列的一个或多个换行，请输入：\ntr -s '\\n' < textfile > newfile\n\n# 要以单个“#”字符替换 <space> 字符类中的每个字符序列\ntr -s '[:space:]' '[#*]'\n```\n\n## 4.grep - 查找字符串\n\n`grep`命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，`grep`命令只显示匹配的行。\n\n`grep`命令的语法如下所示：\n\n```bash\ngrep [OPTION]... PATTERN [FILE]...\ngrep [OPTION]... [-e PATTERN | -f FILE] [FILE]...\n```\n\n```bash\n# `grep`命令查找文件/etc/passwd 中帐号 blinkfox 的信息\ngrep blinkfox /etc/passwd\n\n# 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写\ngrep -i blinkfox /etc/passwd\n\n# 使用 -r 选项，可以递归搜索指定目录下的所有文件\ngrep -r blinkfox /etc/\n\n# 使用 -w 选项，只匹配包含指定单词的行\ngrep -w blinkfox /etc/\n\n# 使用 -c 选项，报告文件或文本中模式被匹配的次数\ngrep -c blinkfox /etc/passwd\n\n# 使用 -n 选项，显示每一个匹配的行的行号\ngrep -n blinkfox /etc/passwd\n\n# 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行\ngrep -v blinkfox /etc/passwd\n\n# 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出\ngrep --color blinkfox /etc/passwd\n```\n\n## 5.diff - 比较两个文件\n\n`diff`命令用于比较两个文件，并找出它们之间的不同。`diff`命令的语法如下所示：\n\n```bash\ndiff [OPTION]... from-file to-file\n```\n\n常用使用方式如下：\n\n```bash\n# 比较两个文件\ndiff nsswitch.conf nsswitch.conf.org\n\n# 使用 -w 选项，比较时忽略空格\ndiff -w nsswitch.conf nsswitch.conf.org\n\n# 使用 -y 选项，以并排的格式输出两个文件的比较结果\ndiff -y nsswitch.conf nsswitch.conf.org\n\n使用 -c 选项，以上下对比的格式输出两个文件的比较结果\ndiff -c nsswitch.conf nsswitch.conf.org\n```","tags":["Linux"],"categories":["软件工具"]},{"title":"常用Bash命令整理之操作文件和目录","url":"/2018/101039242.html","content":"\n## 1. touch - 创建文件\n\n`touch`命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。`touch`命令又如下选项：\n\n```bash\n-a: 只改变访问时间 \n-c: 不创建任何文件\n-m: 只改变修改时间\n-r: 使用指定文件的时间替代当前时间\n-t: 使用 [[CC]YY]MMDDhhmm[.ss] 替代当前时间\n```\n\ntouch 命令的常见用法如下：\n\n```bash\n# 创建一个名为 effyl 的新空文件\ntouch effyl\n\n# 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件\ntouch effyl myeffyl lueffyl\n\n# 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个\ntouch -a effyl\n\n# 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳\ntouch -c effyl\n\n# 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变\ntouch -m effyl\n\n# 使用 -c 和 -t 选项，来明确设置文件的时间\ntouch -c -t YYMMDDHHMM filename\n\n# 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项\ntouch -r myeffyl effyl\n```\n\n## 2.mkdir - 创建目录\n\n`mkdir`命令用于创建一个新目录。最基本的`mkdir`命令的使用方法如下所示：\n\n```bash\n# 在当前目录下创建一个给定的目录名\nmkdir <dirname>\n\n# 在 backup 中的相对路径创建一个名为 old 的目录\nmkdir backup/old\n\n# 在 backup 中的绝对路径中创建一个名为 old 的目录\nmkdir /home/blinkfox/backup/old\n\n# 使用 -p 选项，会自动创建所有还不存在的父目录\nmkdir -p backup/old\n\n# 使用 -m 选项，可以设置将要创建目录的权限\n# 如：创建一个任何人都有读写访问权限的目录\nmkdir -p -m 777 backup/old\n```\n\n## 3.cp - 复制文件或目录\n\n`cp`命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。\n\n使用 cp 命令复制文件和目录的语法有以下几种：\n\n```bash\n# 复制源文件到目标文件\ncp [OPTION] SOURCE DEST\n\n# 复制一个或多个源文件到一个目录\ncp [OPTION] SOURCE... DIRECTORY\n\n# 同上\ncp [OPTION] -t DIRECTORY SOURCE... \n```\n\n常用使用示例如下：\n\n```bash\n# 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txt\ncp file.txt newfile.txt\n\n# 复制当前目录下的 file.txt 文件到 /tmp 目录下\ncp file.txt /tmp\n\n# 复制当前目录下的所有文件到 /tmp 目录下\ncp * /tmp\n\n# 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息\ncp -p filename /path/to/new/location/myfile\n\n# 使用 -R 或 -r 选项，恶意递归地复制一个目录\n# 即将一个目录及其下的所有文件和子目录都复制到另一个目录\ncp -R * /home/blinkfox/backup\n```\n\n## 4.ln - 链接文件或目录\n\n`ln`命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：\n\n```bash\n# 在目录 lib 下创建一个软链接 library.so，链接到 /home/blinkfox/src/library.so\nln -s /home/blinkfox/src/library.so /home/blinkfox/lib\n\n# 创建目录的软链接\nln -s /home/blinkfox/src source\n```\n\n## 5. mv - 移动文件或目录\n\n`mv`命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，`mv`命令还可用于修改文件或目录的名字。\n\nmv 命令的基本语法如下所示：\n\n```bash\nmv SOURCE... DIRECTORY\n```\n\n常用命令如下：\n\n```bash\n# 将当前目录下的文件 source.txt 移到目录 /tmp 下\nmv source.txt /tmp\n\n# 将目录 dir1、dir2 移到目录 dir_dist 下\nmv dir1 dir2 dir_dist\n\n# 将当前目录下的 old.txt 文件更名为 new.txt\nmv old.txt new.txt\n\n# 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息\nmv -i old.txt new.txt\n\n# 将当前目录下的所有文件移动到目录 /tmp 下\nmv * /tmp/\n\n# 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录\nmv -u dir1/* dir2/\n```\n\n## 6.rm - 删除文件或目录\n\n`rm`命令用于删除指定的文件和目录。其语法如下所示：\n\n```bash\nrm [OPTIONS]... FILE...\n```\n\n`rm`的常用命令如下：\n\n```bash\n# 删除当前目录下的文件 file1.txt、file2.txt、file3.txt\nrm file1.txt file2.txt file3.txt\n\n# 删除当前目录下的所有文件\nrm *\n\n# 删除你当前帐号主目录下的 temp 目录中的所有文件\nrm ~/temp/*\n\n# 使用 -i 选项，可以在删除每个文件或目录前提示用户确认\nrm -i *\n\n# 删除当前目录下所有以\".doc\"结尾的文件\nrm *.doc\n\n# 删除当前目录下所有文件名中包含\"movie\"字符串的文件\nrm *movie*\n\n# 删除当前目录下所有以\"a\"开头的文件\nrm a*\n\n# 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件\nrm ???\n\n# 删除当前目录下文件扩展名有两个字符的所有文件\nrm *.??\n\n# 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件\nrm *[abc]*\n\n# 删除当前目录下文件名中包含 0~9 的所有文件\nrm *[0-9]*\n\n# 删除当前目录下文件扩展名是字母 c 或 h 的所有文件\nrm *.[ch]\n\n# 删除 /tmp 目录下的所有文件及其子目录\nrm -rf /tmp/*\n```\n\n> -f 删除前不提示用户确认，并忽略不存在的文件\n\n> -r 递归地删除目录及其下的内容","tags":["Linux"],"categories":["软件工具"]},{"title":"常用Bash命令整理之查看文件和目录","url":"/2018/10094804.html","content":"\n## 1. ls - 列出文件名和目录\n\n`ls`命令是`Linux`中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入`ls`命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。\n\n以下便是`ls`命令及其选项的作用说明：\n\n```bash\n# 仅列出当前目录下所有文件和目录\nls\n\n# 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等\nls -l\n\n# 将文件大小显示符合人类阅读习惯的格式\nls -lh\n\n# 将使用不同的特殊字符归类不同的文件类型\nls -F\n\n# 以长列表格式列出某个目录的信息\nls -ld /var/log\n\n# 将递归地列出子目录的内容\nls -R /etc/sysconfig/\n\n# 以长列表格式按文件或目录的修改时间倒序地列出文件和目录\nls -ltr\n\n# 以长列表格式按文件大小顺序列出文件和目录\nls -ls\n\n# 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）\nls -a\n\n# 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）\nls -A\n\n输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组\nls -n\n```\n\n## 2. cat - 连接显示文件内容\n\n`cat` 命令也是Linux系统中最常用的命令之一。`cat`命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。\n\n`cat`命令的语法如下所示：\n\n```bash\ncat [OPTION] [FILE]...\n```\n\n`cat`常用命令如下：\n\n```bash\n# 使用 cat 命令查看文件 /etc/group 的内容\ncat /etc/group\n\n# 显示多个文件的内容\ncat /etc/redhat-release /etc/issue\n\n# -n 选项，可以显示文件内容的行号\ncat -n /etc/fstab\n\n# -b 选项和 -n 选项类似，但只标识非空白行的行号\ncat -b /etc/fstab\n\n# -e 选项，将在每一行的结尾显示“$”字符\ncat -e /etc/fstab\n```\n\n> 当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。\n\n## 3.less、more - 分屏显示文件\n\n`more`命令在你使用小的xterm窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more命令是一个用于一次翻阅一整屏文件的过滤器。\n\n```bash\n# 查看一个文件，自动清空屏幕并显示文件开头部分\nmore /etc/inittab\n\n# 指定一次显示num行\nmore -num /etc/inittab\n```\n\n与`more`命令相比，我个人更喜欢`less`命令来查看文件。`less`命令与`more`命令类似，但`less`命令向前和向后翻页都支持，而且`less`命令不需要在查看前加载整个文件，即`less`命令查看文件更快速。\n\n`less`常用命令参数如下：\n\n```bash\n-b  <缓冲区大小> 设置缓冲区的大小\n-e  当文件显示结束后，自动离开\n-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件\n-g  只标志最后搜索的关键词\n-i  忽略搜索时的大小写\n-m  显示类似more命令的百分比\n-N  显示每行的行号\n-o  <文件名> 将less 输出的内容在指定文件中保存起来\n-Q  不使用警告音\n-s  显示连续空行为一行\n-S  行过长时间将超出部分舍弃\n-x  <数字> 将“tab”键显示为规定的数字空格\n/字符串：向下搜索“字符串”的功能\n?字符串：向上搜索“字符串”的功能\nn： 重复前一个搜索（与 / 或 ? 有关）\nN： 反向重复前一个搜索（与 / 或 ? 有关）\nb  向后翻一页\nd  向后翻半页\nh  显示帮助界面\nQ  退出less 命令\nu  向前滚动半页\ny  向前滚动一行\n空格键 滚动一行\n回车键 滚动一页\n[pagedown]： 向下翻动一页\n[pageup]：   向上翻动一页\n```\n\n## 4.head - 显示文件头部\n\n`head`命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前10行内容。\n\n使用`-n`选项可以指定打印文件的前N行：\n\n```bash\n# 指定打印文件的前5行\nhead -n 5 /etc/inittab\n（或）head -5 /etc/inittab\n\n# 打印文件的前N个字节的数据\nhead -c 10 /etc/inittab\n```\n\n## 5.tail - 显示文件尾部\n\n`tail`命令和`head`命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后10行内容。\n\n使用`-n`选项可以指定打印文件的最后N行：\n\n```bash\n# 指定打印文件的后10行\ntail -n 10 /etc/inittab\ntail -10 /etc/inittab\n\n# 即时打印文件中新写入的行\ntail -f /var/log/messages\n\n# --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件\ntail -f /tmp/debug.log --retry\n```\n\n## 6.file - 查看文件类型\n\n`file`命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。\n\n```bash\n# 查看文件类型\nfile /etc/inittab\n\n# 可以MIME类型的格式显示文件类型的信息\nfile -i  /etc/inittab\n\n# 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示\nfile -N *\n```\n\n## 7.wc - 查看文件统计信息\n\n`wc`命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示：\n\n```bash\nwc filename\nX Y Z /etc/inittab\n```\n\n其中X表示行数，Y表示单词数，Z表示字节数，filename表示文件名。\n\n```bash\n# -l选项，可以只统计文件的行数信息\nwc -l /etc/inittab\n\n# -w选项，可以只统计文件的单词数信息\nwc -w /etc/inittab\n\n# -c选项，可以只统计文件的字节数信息\nwc -c /etc/inittab\n\n# -L选项，可以只统计文件中最长的行的长度\nwc -L /etc/inittab\n```\n\n## 8.find - 查找文件或目录\n\n`find`命令用于根据你指定的参数搜索和定位文件和目录的列表。`find`命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。\n\n`find`命令常用使用和说明如下：\n\n```bash\n# 查找指定目录下的某个文件\nfind /etc/ -name inittab\n\n# 在当前目录下查找名称为 inittab 的文件\nfind . -name inittab\n\n# 在当前目录下，文件不区分大小写是example的所有文件\nfind . -iname example\n\n# 找出当前目录下所有以 sh 结尾的文件\nfind . -type f -name \"*.sh\"\n\n# 找出当前目录下，文件权限是 777 的所有文件\nfind . -type f -perm 777\n\n# 找出当前目录下，文件权限不是 777 的所有文件\nfind . -type f ! -perm 777\n\n# 找出当前目录下所有只读文件\nfind . -type f ! -perm /a+w\n\n# 找出你帐号主目录下的所有可执行文件\nfind ~ -type f -perm /a+w\n\n# 找出 /tmp 目录下的.log文件并将其删除：\nfind /tmp/ -type f -name \"*.log\" -exec rm -f {} \\;\n\n# 找出当前目录下的所有空文件\nfind . -type f -empty\n\n# 找出当前目录下的所有空目录\nfind . -type d -empty\n\n# 找出 /tmp 目录下的所有隐藏文件\nfind /tmp/ -type f -name \".*\"\n\n# 找出 /tmp 目录下，所有者是 root 的文件和目录\nfind /tmp/ -user root\n\n# 找出 /tmp 目录下，用户组是 developer 的文件和目录\nfind /tmp/ -group root\n\n# 找出你账号的主目录下，3 天前修改的文件\nfind ~ -type f -mtime 3\n\n# 找出你账号的主目录下，30 天以前修改的所有文件\nfind ~ -type f -mtime +30\n\n# 找出你账号的主目录下，3 天以内修改的所有文件\nfind ~ -type f -mtime -3\n\n# 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件\nfind ~ -type f -mtime +30 -mtime -60\n\n# 找出 /etc 目录下，一小时以内变更过的文件\nfind /etc -type f -cmin -60\n\n# 找出 /etc 目录下，一小时以内访问过的文件\nfind /etc -type f -amin -60\n\n# 找出你账号主目录下，大小是50MB的所有文件\nfind ~ -type f -size 50MB\n\n# 找出你账号主目录下，大于50MB小于100MB的所有文件\nfind ~ -type f -size +50MB -size -100MB\n\n# 找出你账号主目录下，大于100MB的文件并将其删除\nfind ~ -type f -size +100MB -exec rm -rf {} \\;\n```","tags":["Linux"],"categories":["软件工具"]},{"title":"Google Java编程风格指南","url":"/2018/10056920.html","content":"\n## 1 前言\n\n这份文档是`Google Java`编程风格规范的完整定义。当且仅当一个`Java`源文件符合此文档中的规则，我们才认为它符合`Google`的`Java`编程风格。\n\n与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。\n\n### 1.1 术语说明\n\n本文档中除非特殊说明，否则：\n\n- 术语`class`可表示一个普通类、枚举类、接口或者注解。\n- 术语`comment`只用来指代实现的注释(`implementation comments`)，我们不使用文档注释(`documentation comments`)一词，而是用`Javadoc`。\n\n其他术语说明，将在文档中需要说明的地方单独说明。\n\n### 1.2 指南说明\n\n本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。\n\n## 2 源文件基础\n\n### 2.1 文件名\n\n源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为`.java`。\n\n### 2.2 文件编码：UTF-8\n\n源文件编码格式使用`UTF-8`。\n\n### 2.3 特殊字符\n\n#### 2.3.1 空格字符\n\n除了换行符外，`ASCII`水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着：\n\n- 所有其他空白字符将被转义。\n- `Tab`字符不被用作缩进控制。\n\n#### 2.3.2 特殊转义字符串\n\n任何需要转义字符串表示的字符（例如：`\\b`, `\\t`, `\\n`, `\\f`, `\\r`, `\\'`, `\\\\`等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 `\\012`）或`Unicode`码（例如：`\\u000a`）表示。\n\n#### 2.3.3 非ASCII字符\n\n对于其余非`ASCII`字符，直接使用`Unicode`字符（例如 `∞`），或者使用对应的`Unicode`码（例如：`\\u221e`）转义，都是允许的。**唯一需要考虑的是，何种方式更能使代码容易阅读和理解**。\n\n> **注意**：在使用`Unicode`码转义，或者甚至是有时直接使用`Unicode`字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。\n\n例子：\n\n| 示例  | 结论  |\n| ------------ | ------------ |\n| String unitAbbrev = \"μs\";\t | 赞：即使没有注释也非常清晰。  |\n| String unitAbbrev = \"\\u03bcs\"; // \"μs\"  | 允许，但没有理由要这样做。  |\n| String unitAbbrev = \"\\u03bcs\"; // Greek letter mu, \"s\"  | 允许，但这样做显得笨拙还容易出错。  |\n| String unitAbbrev = \"\\u03bcs\";  | 很糟：读者根本看不出这是什么。  |\n| return '\\ufeff' + content; // byte order mark  | 很好：对于非打印字符，使用转义，并在必要时写上注释。  |\n\n> **注意**：永远不要由于害怕某些程序可能无法正确处理非`ASCII`字符而让你的代码可读性变差。当程序无法正确处理非`ASCII`字符时，它自然无法正确运行，你就会去`fix`这些问题的了。(言下之意就是大胆去用非`ASCII`字符，如果真的有需要的话)\n\n## 3 源文件结构\n\n源文件按照先后顺序，由以下几部分组成：\n\n- 许可证(`License`)或版权信息(`copyright`)（如果需要）\n- `package`语句\n- `import`语句\n- `class`类声明（每个源码文件只能有唯一一个顶级`class`）。\n\n> **注意**：以上每个部分之间应该只有**一个空行**作为间隔。\n\n### 3.1 许可证或版权信息\n\n如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。\n\n### 3.2 package语句\n\n`package`语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里)\n\n### 3.3 import语句\n\n#### 3.3.1 import不使用通配符\n\n`import`语句中不应该使用通配符，不管是否是静态导入。\n\n#### 3.3.2 import不换行\n\n`import`语句不换行，列限制(4.4节)并不适用于`import`语句。(每个`import`语句独立成行)\n\n#### 3.3.3 顺序和间距\n\n`import`语句可分为以下几组，按照顺序，每组由**一个空行**分隔：\n\n- 所有的静态导入(static import)归为一组\n- `com.google`包的`import`归为一组\n- 使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：`android`, `com`, `junit`, `org`, `sun`\n- `java`包归为一组\n- `javax`包归为一组\n\n> **注意**：同一组内的`import`语句之间不应用空行隔开，同一组中的`import`语句按字典序排列。\n\n### 3.4 类声明\n\n#### 3.4.1 只声明唯一一个顶级class\n\n每个源文件中只能有一个顶级class。\n\n#### 3.4.2 类成员顺序\n\n类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。\n\n最重要的一点，**每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑**。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。\n\n##### 3.4.2.1 重载：永不分离\n\n当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。\n\n## 4 格式\n\n> **术语说明**：块状结构(`block-­like construct`)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。\n\n### 4.1 大括号\n\n#### 4.1.1 使用大括号(即使是可选的)\n\n大括号一般用在`if`, `else`, `for`, `do`, `while`等语句，即使只有一条语句(或是空)，也应该把大括号写上。\n\n#### 4.1.2 非空语句块采用`K&R`风格\n\n对于非空语句块，大括号遵循`Kernighan`和`Ritchie`风格 ([Egyptian brackets](https://blog.codinghorror.com/new-programming-jargon/)):\n\n- 左大括号前不换行\n- 左大括号后换行\n- 右大括号前换行\n- 如果右大括号结束是一个`语句块`或者`方法体`、`构造函数体`或者`有命名的类体`，则需要换行。当右括号后面接`else`或者`逗号`时，不应该换行。\n\n示例：\n\n```java\nreturn () -> {\n    while (condition()) {\n        method();\n    }\n};\n\nreturn new MyClass() {\n    @Override public void method() {\n        if (condition()) {\n            try {\n                something();\n            } catch (ProblemException e) {\n                recover();\n            }\n        } else if (otherCondition()) {\n            somethingElse();\n        } else {\n            lastThing();\n        }\n    }\n};\n```\n\n一些例外的情况，将在`4.8.1`节讲`枚举类型`的时候讲到。\n\n#### 4.1.3 空语句块：使代码更简洁\n\n一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：`if/else` 或者`try/catch/finally`）.\n\n示例：\n\n```java\n// 这是可接受的\nvoid doNothing() {}\n\n// 这同样是可接受的\nvoid doNothingElse() {\n}\n```\n\n```java\n// 这是不可接受的：多块语句中没有简洁的空语句块\ntry {\n    doSomething();\n} catch (Exception e) {}\n```\n\n### 4.2块缩进：2个空格\n\n每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。\n\n> **注意**：根据实际的编程经验，`2`个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码`臃肿`不够美观。所以，我这里建议使用`4`个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。\n\n### 4.3 一行一个语句\n\n每条语句结束都需要换行。\n\n### 4.4 列长度限制：100\n\nJava代码的列长度限制为`100个`字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。\n\n例外：\n\n- 不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)\n- `package`和`import`语句(见3.2节和3.3节)\n- 注释中那些可能被剪切并粘贴到shell中的命令行\n\n> **注意**：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，`100`个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用`120`个字符的宽度更为合适。\n\n### 4.5 换行\n\n**术语说明**：一般情况下，一行长代码为了避免超出列限制(`100`个字符)而被分为多行，我们称之为断行(`line­-wrapping`)。\n\n我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。\n\n> **注意**: 提取`方法`或`局部变量`可以解决问题，而不不需要进行断行。\n\n#### 4.5.1 在何处断行\n\n断行的主要原则是：**选择在更高级的语法逻辑处断行**。其他一些原则如下：\n\n- 当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。\n- 如果要在非赋值运算符处断行，那么在该符号前断开(比如`+`操作符，它将位于下一行)。以下的`类运算符`也可作为参考：\n  - 点操作符`.`\n  - 类型界限中的`&`、`||`等（例如：`<T extends Foo & Bar>`)\n- 当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：`=`，它与前面的内容留在同一行)。\n  - 这条规则也适用于`foreach`语句中的冒号。\n- 方法名或构造函数名与左括号留在同一行。\n- 逗号(`,`)与其前面的内容留在同一行。也就是在逗号之后断行。\n- `Lambda`表达式在箭头符号(`->`)后断行。\n\n示例：\n\n```java\nMyLambda<String, Long, Object> lambda =\n    (String label, Long value, Object obj) -> {\n        ...\n    };\n\nPredicate<String> predicate = str ->\n    longExpressionInvolving(str);\n```\n\n> **注意**：换行的主要目标是使代码更清晰易读。\n\n#### 4.5.2 断行的缩进：至少+4个空格\n\n自动换行时，第一行后的每一行至少比第一行多缩进`4`个空格(注意：制表符不用于缩进。见2.3.1节)。\n\n当存在连续自动换行时，缩进可能会多缩进不只`4`个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。\n\n第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。\n\n### 4.6 空白\n\n#### 4.6.1 垂直空白\n\n以下情况需要使用单行空行：\n\n- 类成员之间需要单个空行隔开：例如：`字段`，`构造函数`，`方法`，`嵌套类`，`静态初始化块`，`实例初始化块`。但也有以下两种例外情况：\n  - 两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。\n  - 枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。\n- 在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。\n- 类的第一个成员之前或最后一个成员之后，使用空行(可选)。\n- 本文档所介绍的其他章节的空行要求(比如3.3节：`import`语句)。\n\n#### 4.6.2 水平空白\n\n除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现：\n\n- 所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：`if`, `for` `catch`等)\n- 所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：`else`、`catch`）\n- 在左大括号之前都需要空格隔开。只有两种例外：\n  - `@SomeAnnotation({a, b})`\n  - `String[][] x = {{\"foo\"}};`\n- 所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：`a + b`、`b = a < 0 ? 0 : a`)\n- 逗号(`,`)、冒号(`:`)、分号(`;`)和右小括号(`)`)、Lambda箭头符号(`->`)之后，需要空格隔开。\n- `//`双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：`a = 0; // 赋值为0`）\n- 变量声明时，变量类型和变量名之间需要用空格隔开。（例如：`List<String> list`）\n- 初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：`new int[] {5, 6}`和`new int[] { 5, 6 }`）\n\n> **注意**：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。\n\n#### 4.6.3 水平对齐：不做要求\n\n> **术语说明**：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。\n\n这种对齐是被允许的，但是不会做强制要求。\n\n以下是没有水平对齐和水平对齐的例子：\n\n```java\nprivate int x;   // 这种挺好\nprivate Color color;   // 同上\n\nprivate int   x;      // 允许，但是未来会继续编辑\nprivate Color color;  // 可能会使它对不齐\n```\n\n> **注意**：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为**爆炸半径**。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码`review`的速度，引起更多`merge`代码冲突的情况。\n\n### 4.7 分组小括号：推荐使用\n\n除非作者和`reviewer`都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。\n\n### 4.8 特殊结构\n\n#### 4.8.1 枚举类型\n\n枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例：\n\n```java\nprivate enum Answer {\n    YES {\n        @Override public String toString() {\n            return \"yes\";\n        }\n    },\n\n    NO,\n    MAYBE\n}\n```\n\n没有方法和Javadoc的枚举类可写成数组初始化的格式：\n\n```java\nprivate enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }\n```\n\n由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。\n\n#### 4.8.2 变量声明\n\n##### 4.8.2.1 每次声明一个变量\n\n不要使用组合声明。例如：`int a, b;`是不允许的。\n\n##### 4.8.2.2 需要时才声明，尽快进行初始化\n\n不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。\n\n#### 4.8.3 数组\n\n##### 4.8.3.1 数组初始化：可写成块状结构\n\n数组初始化可以写成块状结构，例如以下格式的写法都是允许的：\n\n```java\nnew int[] {           new int[] {\n  0, 1, 2, 3            0,\n}                       1,\n                        2,\nnew int[] {             3,\n  0, 1,               }\n  2, 3\n}                     new int[]\n                          {0, 1, 2, 3}\n```\n\n##### 4.8.3.2 非C风格的数组声明\n\n中括号是类型的一部分：`String[] args`， 而非`String args[]`。\n\n#### 4.8.4 switch语句\n\n**术语说明**：`switch`块的大括号内是一个或多个语句组。每个语句组包含一个或多个`switch`标签(`case FOO: `或`default:`)，后面跟着一条或多条语句。\n\n##### 4.8.4.1 缩进\n\n和其他语句块一样，`switch`大括号之后缩进两个字符。每个`switch`标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。\n\n##### 4.8.4.2 继续向下执行的注释\n\n在一个`switch`块内，每个语句组要么通过`break`、`continue`、`return`或`抛出异常`来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用`// fall through`)。这个特殊的注释并不需要在最后一个语句组(一般是`default`)中出现。例如：\n\n```java\nswitch (input) {\n    case 1:\n    case 2:\n        prepareOneOrTwo();\n        // fall through\n    case 3:\n        handleOneTwoOrThree();\n        break;\n    default:\n        handleLargeNumber(input);\n}\n```\n\n> **注意**：在`case 1`之后不需要该注释，仅在语句组的末尾。\n\n##### 4.8.4.3 default标签需要显式声明\n\n每个`switch`语句中，都需要显式声明`default`标签。即使没有任何代码也需要显示声明。\n\n> **注意**：枚举类型的`switch`语句可以省略`default`语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。\n\n#### 4.8.5 注解\n\n注解应用到类、方法或者构造方法时，应紧接`Javadoc`之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如：\n\n```java\n@Override\n@Nullable\npublic String getNameIfPresent() { ... }\n```\n\n**例外**：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如：\n\n```java\n@Override public int hashCode() { ... }\n```\n\n注解应用到成员变量时，也是紧接`Javadoc`之后。不同的是，多个注解可以放在同一行。例如：\n\n```java\n@Partial @Mock DataLoader loader;\n```\n\n对于参数或者局部变量使用注解的情况，没有特定的规范。\n\n#### 4.8.6 注释\n\n##### 4.8.6.1 块注释风格\n\n注释的缩进与它所注释的代码缩进相同。可以采用`/* */`进行注释，也可以用`//`进行注释。当使用`/* */`进行多行注释时，每一行都应该以`*`开始，并且`*`应该上下对齐。\n\n例如：\n\n```java\n/*\n * This is\n * okay.\n */\n\n// And so\n// is this.\n\n/* Or you can\n * even do this. */\n```\n\n> **注意**：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用`/* */`，`//`一般不会自动对齐。\n\n#### 4.8.7 修饰符\n\n类和成员变量的修饰符，按`Java Lauguage Specification`中介绍的先后顺序排序。具体是：\n\n```java\npublic protected private abstract default static final transient volatile synchronized native strictfp\n```\n\n#### 4.8.8 数字字面量\n\n长整型的数字字面量使用大写的`L`作为后缀，不得使用小写（以免与数字1混淆）。例如：使用`3000000000L`，而不是`3000000000l`。\n\n## 5 命名约定\n\n### 5.1 对所有标识符都通用的规则\n\n标识符只能使用`ASCII`字母和数字，因此每个有效的标识符名称都能匹配正则表达式`\\w+`。\n\n在Google其它编程语言风格中使用的特殊前缀或后缀，如`name_`, `mName`, `s_name`和`kName`，在Java编程风格中都不再使用。\n\n### 5.2 标识符类型的规则\n\n#### 5.2.1 包名\n\n包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用`com.example.deepspace`，而不是`com.example.deepSpace`或者`com.example.deep_space`。\n\n#### 5.2.2 类名\n\n类名都以`UpperCamelCase`风格编写。\n\n类名通常是名词或名词短语。例如：`Character`或者`ImmutableList`。接口名称也可以是名词或名词短语（例如：`List`），但有时可能是形容词或形容词短语（例如：`Readable`）。现在还没有特定的规则或行之有效的约定来命名注解类型。\n\n测试类的命名以它要测试的类的名称开始，以`Test`结束。例如：`HashTest`或`HashIntegrationTest`。\n\n#### 5.2.3 方法名\n\n方法名都以`lowerCamelCase`风格编写。\n\n方法名通常是动词或动词短语。例如：`sendMessage`或者`stop`。\n\n下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：`test<MethodUnderTest>_<state>`，例如：`testPop_emptyStack`。 并不存在唯一正确的方式来命名测试方法。\n\n#### 5.2.4 常量名\n\n常量名命名模式为`CONSTANT_CASE`，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？\n\n每个常量都是一个静态`final`字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如：\n\n```java\n// 常量\nstatic final int NUMBER = 5;\nstatic final ImmutableList<String> NAMES = ImmutableList.of(\"Ed\", \"Ann\");\nstatic final ImmutableMap<String, Integer> AGES = ImmutableMap.of(\"Ed\", 35, \"Ann\", 32);\nstatic final Joiner COMMA_JOINER = Joiner.on(','); // 因为Joiner是不可变的\nstatic final SomeMutableType[] EMPTY_ARRAY = {};\nenum SomeEnum { ENUM_CONSTANT }\n\n// 非常量\nstatic String nonFinal = \"non-final\";\nfinal String nonStatic = \"non-static\";\nstatic final Set<String> mutableCollection = new HashSet<String>();\nstatic final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);\nstatic final ImmutableMap<String, SomeMutableType> mutableValues =\n    ImmutableMap.of(\"Ed\", mutableInstance, \"Ann\", mutableInstance2);\nstatic final Logger logger = Logger.getLogger(MyClass.getName());\nstatic final String[] nonEmptyArray = {\"these\", \"can\", \"change\"};\n```\n\n这些常量的名字通常是名词或名词短语。\n\n#### 5.2.5 非常量字段名\n\n非常量字段名以`lowerCamelCase`风格编写。\n\n这些名字通常是名词或名词短语。例如：`computedValues`或者`index`。\n\n#### 5.2.6 参数名\n\n参数名以`lowerCamelCase`风格编写。\n\n参数应该避免用单个字符命名。\n\n#### 5.2.7 局部变量名\n\n局部变量名以`lowerCamelCase`风格编写。\n\n即使局部变量是`final`和`不可改变`的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。\n\n#### 5.2.8 类型变量名\n\n类型变量可用以下两种风格之一进行命名：\n\n- 单个的大写字母，后面可以视具体情况跟一个数字(如：`E`, `T`, `X`, `T2`)。\n- 以类命名方式(5.2.2节)，后面加个大写的T(如：`RequestT`, `FooBarT`)。\n\n### 5.3 驼峰式命名法(CamelCase)\n\n**驼峰式命名法**分大驼峰式命名法(`UpperCamelCase`)和小驼峰式命名法(`lowerCamelCase`)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：`IPv6`或`iOS`)。Google指定了以下的转换方案。\n\n名字从散文形式(prose form)开始:\n\n- 把短语转换为纯`ASCII`码，并且移除任何单引号。例如：`Müller’s algorithm`将变成`Muellers algorithm`。\n- 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。\n  - **推荐**：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如`AdWords`将分割成`ad words`)。 \n  - 需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。\n- 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：\n  - 每个单词的第一个字母都大写，来得到大驼峰式命名。\n  - 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。\n- 最后将所有的单词连接起来得到一个标识符。\n\n示例：\n\n| 散文形式  | 正确  | 不正确  |\n| ------------ | ------------ | ------------ |\n| \"XML HTTP request\"  | XmlHttpRequest  | XMLHTTPRequest  |\n| \"new customer ID\"  | newCustomerId  | newCustomerID  |\n| \"inner stopwatch\"  | innerStopwatch  | innerStopWatch  |\n| \"supports IPv6 on iOS?\"  | supportsIpv6OnIos  | supportsIPv6OnIOS  |\n| \"YouTube importer\"  | YouTubeImporter YoutubeImporter^  | 无   |\n\n加`^`号处表示可以，但不推荐。\n\n> **注意**：在英语中，某些带有连字符的单词形式不唯一。例如：`nonempty`和`non-empty`都是正确的，因此方法名`checkNonempty`和`checkNonEmpty`也都是正确的。\n\n## 6 编程实践\n\n### 6.1 `@Override`：总是使用\n\n只要是合法的方法，就把`@Override`注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。\n\n**例外**：当父方法为`@Deprecated`时，可以省略`@Override`。\n\n### 6.2 捕获的异常：不能忽视\n\n除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个`AssertionError`重新抛出。)\n\n如果它确实是不需要在`catch`块中做任何响应，需要做注释加以说明(如下面的例子)。\n\n```java\ntry {\n    int i = Integer.parseInt(response);\n    return handleNumericResponse(i);\n} catch (NumberFormatException ok) {\n    // 它不是一个数字，不过没关系，继续\n}\nreturn handleTextResponse(response);\n```\n\n例外：在测试中，如果一个捕获的异常被命名为`expected`，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。\n\n```java\ntry {\n    emptyStack.pop();\n    fail();\n} catch (NoSuchElementException expected) {\n}\n```\n\n6.3 静态成员：使用类来调用\n\n使用类名调用静态的类成员，而不是具体某个对象或表达式。\n\n```java\nFoo aFoo = ...;\nFoo.aStaticMethod(); // 好\naFoo.aStaticMethod(); // 糟\nsomethingThatYieldsAFoo().aStaticMethod(); // 很糟\n```\n\n6.4 `Finalizers`: 禁用\n\n极少会去重载`Object.finalize`。\n\n> **注意**：不要使用`finalize`。如果你非要使用它，请先仔细阅读和理解`Effective Java第7条款`：“Avoid Finalizers”，然后不要使用它。\n\n## 7 Javadoc\n\n### 7.1 格式\n\n#### 7.1.1 一般形式\n\n`Javadoc`块的基本格式如下所示：\n\n```java\n/**\n * Multiple lines of Javadoc text are written here,\n * wrapped normally...\n */\npublic int method(String p1) { ... }\n```\n\n或者是以下单行形式：\n\n```java\n/** An especially short bit of Javadoc. */\n```\n\n基本格式总是可以接受的。当整个`Javadoc`块能容纳于一行时(且没有标记`@XXX`)，就可以使用单行形式。\n\n#### 7.1.2 段落\n\n空行(只包含最左侧星号的行)会出现在段落之间和`Javadoc`标记(`@XXX`)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签`<p>`，并且它和第一个单词间没有空格。\n\n#### 7.1.3 Javadoc标记\n\n标准的`Javadoc`标记按以下顺序出现：`@param`, `@return`, `@throws`, `@deprecated`, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进`4`个空格(**注**：如果你的缩进统一采用采用`4`个空格，那么这里就应该是`8`个空格)。\n\n#### 7.2 摘要片段\n\n每个类或成员的`Javadoc`以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。\n\n这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以`A {@code Foo} is a...`或者`This method returns...`开头, 它也不会是一个完整的祈使句，如`Save the record.`。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。\n\n> **注意**：一个常见的错误是把简单的Javadoc写成`/** @return the customer ID */`，这是不正确的。它应该写成`/** Returns the customer ID. */`。\n\n### 7.3 在哪里使用Javadoc\n\n至少在每个`public`类及它的每个`public`和`protected`成员处使用`Javadoc`，以下是一些例外：\n\n#### 7.3.1 例外：不言自明的方法\n\n对于简单明显的方法如`getFoo`，`Javadoc`是可选的(可以不写)。这种情况下除了写`Returns the foo`，确实也没有什么值得写了。\n\n单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。\n\n> **注意**：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名`getCanonicalName`，就不应该忽视文档说明，因为读者很可能不知道词语`canonical name`指的是什么。\n\n#### 7.3.2 例外：重载\n\n如果一个方法重载了超类中的方法，那么`Javadoc`并非必需的。\n\n#### 7.3.3 可选的Javadoc\n\n对于包外不可见的类和方法，如有需要，也是要使用`Javadoc`的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成`Javadoc`，这样更统一更友好。\n\n原文地址: [Google Java Style Guide](http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html)","tags":["Java","Google"],"categories":["编程之道"]},{"title":"Git知识点整理","url":"/2018/092433617.html","content":"\n## 1. Git基本概念。\n\n- `repository`\n- `config`\n- `init`\n- `clone`\n- `fetch`\n- `pull`\n- `commit`\n- `push`\n- `branch`\n- `head`\n- `tag`\n- `merge`\n- `conflict`\n- `diff`\n- `log`\n- `show`\n- `status`\n\n## 2. Git工作空间和文件状态\n\n### (1).工作空间\n\n![Git工作空间][1]\n\n左侧为工作区，右侧为版本库。\n\n- 工作区（`Working Directory`） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。\n- 版本库（`Repository`）工作区有一个隐藏目录`.git`，是Git的版本库。\n\n在版本库中标记为`index`的区域为暂存区，标记为`master`的是Git为我们自动创建的第一个分支，代表的是目录树。此时`HEAD`实际是指向`master`分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用`master`来替换。图中的objects标识的区域为git的对象库，实际位于`.git/objects`目录下。\n\n- 当对工作区修改（或新增）的文件执行`git add`命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。\n- 当执行提交操作`git commit`时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。\n- 当执行`git reset HEAD`命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。\n- 当执行`git rm --cached`命令时，会直接从暂存区删除文件，工作区则不做出改变。\n- 当执行`git checkout .`或`git checkout --` 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。\n- 当执行`git checkout HEAD .`或`git checkout HEAD`命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。\n\n### (1).文件状态\n\nGit 有三种状态，你的文件可能处于其中之一：**已提交(`committed`)**、**已修改(`modified`)**和**已暂存(`staged`)**。\n\n## 3. Git配置系统级、全局、当前仓库用户名、邮箱的命令\n\n系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填)\n\n```bash\ngit config --global user.name \"Jerry Mouse\"\ngit config --global user.email \"jerry@yiibai.com\"\n```\n\n列出Git设置\n\n```bash\n\ngit config --list\ngit config -l\n```\n\n## 4. Git fetch和pull的区别\n\n- `git fetch`：相当于是从远程获取最新版本到本地，不会自动merge.\n- `git pull`：相当于是从远程获取最新版本并merge到本地.\n\n### (1). git fetch示例：\n\n```bash\nGit fetch origin master\ngit log -p master..origin/master\ngit merge origin/master\n```\n\n以上命令的含义：\n\n- 首先从远程的`origin`的`master`主分支下载最新的版本到`origin/master`分支上\n- 然后比较本地的`master`分支和`origin/master`分支的差别\n- 最后进行合并\n- 上述过程其实可以用以下更清晰的方式来进行：\n\n### (1). git pull示例：\n\n```bash\ngit pull origin master\n```\n\n上述命令其实相当于`git fetch`和`git merge`。在实际使用中，`git fetch`更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。\n\n## 5. Git reset和revert的却别\n\n- `git revert`是用一次新的commit来回滚之前的commit，`git reset`是直接删除指定的commit。 \n- 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为`git revert`是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是`git reset`是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。\n- `git reset`是把HEAD向后移动了一下，而`git revert`是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。\n- git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。\n\n另外，说一下`git revert`， `git reset –hard`和 `–soft`的区别\n\n- `git reset –mixed id`: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。\n- `git reset –soft id`: 实际上，是`git reset –mixed id`后，又做了一次`git add`。\n- `git reset –herd id`: 是将git的HEAD变了，文件也变了。\n\n## 6. Git merge和reabse的相同点和不同点\n\n`merge`是合并的意思，`rebase`是复位基底的意思，相同点都是用来合并分支的。\n\n![merge和rebase][2]\n\n不同点:\n\n- `merge`操作会生成一个新的节点，之前的提交分开显示。而`rebase`操作不会生成新的节点，是将两个分支融合成一个线性的提交。\n- 解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而`rebase`操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行`git rebase –continue`继续操作，或者`git rebase –skip`忽略冲突。\n- `git pull`和`git pull --rebase`区别：`git pull`做了两个操作分别是\"获取\"和\"合并\"。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。\n\n**总结**：选择 merge 还是 rebase？\n\n- merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容\n- merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面\n- rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面\n- rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面\n- merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定\n- merge 和 rebase 还有很多强大的选项，可以使用 git help <command> 查看\n\n## 7. Git stash是什么？它的相关使用方式命令\n\n- git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。\n- git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。\n- git stash pop --index stash@{0}: 恢复编号为0的进度的工作区和暂存区。\n- git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来\n- git stash drop[<stash>] 删除某一个进度，默认删除最新进度\n- git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。\n- git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了\n\n```bash\n# 恢复工作进度\ngit stash pop [--index] [<stash>]\n--index 参数：不仅恢复工作区，还恢复暂存区\n<stash> 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度\n\n# 这是git stash保存进度的完整命令形式\ngit stash [save message] [-k|--no-keep-index] [--patch]\n-k和--no-keep-index指定保存进度后，是否重置暂存区\n--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似\n\n使用save可以对进度添加备注\n# git stash save \"这是保存的进度\"\n```\n\n## 8. Git只从暂存区删除，从工作空间删除的命令分别是什么?\n\n```bash\ngit rm --cached\n\ngit rm\ngit commit\n```\n\n## 9. Git标签的使用\n\n```bash\n# 列出现有的标签\ngit tag\n\n# 打标签\ngit tag -a v1.01 -m \"Relase version 1.01\"\n\n# 查看相应标签的版本信息\ngit show v1.4\n```\n\n- -a 选项,创建一个含附注类型的标签\n- -m 选项,指定了对应的标签说明\n\n## 9. Git分支的使用\n\n```bash\n# 查看本地分支\ngit branch\n\n# 查看远程分支\ngit branch -r\n\n# 创建本地分支(注意新分支创建后不会自动切换为当前分支)\ngit branch [name]\n\n# 切换分支\ngit checkout [name]\n\n# 创建新分支并立即切换到新分支\ngit checkout -b [name]\n\n# 强制删除一个分支\ngit branch -D [name]\n\n# 合并分支(将名称为[name]的分支与当前分支合并)\ngit merge [name]\n\n# 查看各个分支最后提交信息\ngit br -v\n\n# 查看已经被合并到当前分支的分支\ngit br --merged\n\n# 查看尚未被合并到当前分支的分支\ngit br --no-merged\n```\n\n## 10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。\n\nmerge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个`git checkout upstream`的过程，将`HEAD`从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。\n\n## 11. Git远程操作相关\n\n### (1). clone\n\n> git clone <版本库的网址>\n> git clone <版本库的网址> <本地目录名>\n\n```bash\n# 克隆jQuery的版本库\n git clone https://github.com/jquery/jquery.git\n \n git clone -o jQuery https://github.com/jquery/jquery.git\n```\n\n### (2). remote\n\n```bash\n# 列出所有远程主机\ngit remote\n\n# 使用-v选项，可以参看远程主机的网址\ngit remote -v\n \n# 可以查看该主机的详细信息\ngit remote show <主机名>\n \n# 添加远程主机\ngit remote add <主机名> <网址>\n\n# 删除远程主机\ngit remote rm <主机名>\n\n# 修改远程主机名称\ngit remote rename <原主机名> <新主机名>\n```\n\n### (3). fetch\n\n```bash\n# 取回所有分支(branch)的更新到本地\ngit fetch <远程主机名>\n\n# 取回某的特定分支的更新\ngit fetch <远程主机名> <分支名>\n\n# 取回origin主机的master分支的更新\ngit fetch origin master\n\n# 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支\ngit merge origin/master\ngit rebase origin/master\n```\n\n### (4). pull\n\n> git pull <远程主机名> <远程分支名>:<本地分支名>\n\n```bash\n# 取回origin主机的next分支，与本地的master分支合并\ngit pull origin next:master\n\n# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\ngit pull origin next\n\n# 上面的命令实质上等同于先做git fetch，再做git merge。\ngit fetch origin\ngit merge origin/next\n\n# 合并需要采用rebase模式\ngit pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n```\n\n### (5). push\n\n> git push <远程主机名> <本地分支名>:<远程分支名>\n\n**注意**:分支推送顺序的写法是\"<来源地>:<目的地>\"，所以git pull是\"<远程分支>:<本地分支>\"，而git push是\"<本地分支>:<远程分支>\"。\n\n- 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。\n- 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n\n```bash\n# 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建\ngit push origin master\n\n# 省略了本地分支，以下等同，删除origin主机的master分支\ngit push origin :master\ngit push origin --delete master\n\n# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略\ngit push origin\n\n# 如果当前分支只有一个追踪分支，那么主机名都可以省略。\ngit push\n\n# 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push\ngit push -u origin master\n\n# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机\ngit push --all origin\n\n# 强制推送\ngit push --force origin\n\n# git push不会推送标签(tag)，除非使用–tags选项\ngit push origin --tags\n```\n\n## 12. Git Flow使用简介\n\n就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程：\n\n- Git flow\n- Github flow\n- Gitlab flow\n\n三种工作流程，有一个共同点：都采用\"功能驱动式开发\"（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是[Git flow][3]。\n\n它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。\n\n### (1). Git Flow流程图\n\n![Git Flow流程图][4]\n\n### (2). Git Flow常用的分支\n\n- `Production`分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。\n- `Develop`分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。\n- `Feature`分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。\n- `Release`分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。\n- `Hotfix`分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。\n\n### (3). Git Flow代码示例\n\n#### a. 创建develop分支\n\n```bash\ngit branch develop\ngit push -u origin develop\n```\n\n#### b. 开始新Feature开发\n\n```bash\ngit checkout -b some-feature develop\n# Optionally, push branch to origin:\ngit push -u origin some-feature\n\n# 做一些改动\ngit status\ngit add some-file\ngit commit\n```\n\n#### c. 完成Feature\n\n```bash\ngit pull origin develop\ngit checkout develop\ngit merge --no-ff some-feature\ngit push origin develop\n\ngit branch -d some-feature\n\n# If you pushed branch to origin:\ngit push origin --delete some-feature\n```\n\n#### d. 开始Relase\n\n```bash\ngit checkout -b release-0.1.0 develop\n\n# Optional: Bump version number, commit\n# Prepare release, commit\n```\n\n#### e. 完成Release\n\n```bash\ngit checkout master\ngit merge --no-ff release-0.1.0\ngit push\n\ngit checkout develop\ngit merge --no-ff release-0.1.0\ngit push\n\ngit branch -d release-0.1.0\n\n# If you pushed branch to origin:\ngit push origin --delete release-0.1.0   \n\ngit tag -a v0.1.0 master\ngit push --tags\n```\n\n#### f. 开始Hotfix\n\n```bash\ngit checkout -b hotfix-0.1.1 master\n```\n\n#### g. 完成Hotfix\n\n```bash\ngit checkout master\ngit merge --no-ff hotfix-0.1.1\ngit push\n\ngit checkout develop\ngit merge --no-ff hotfix-0.1.1\ngit push\n\ngit branch -d hotfix-0.1.1\n\ngit tag -a v0.1.1 master\ngit push --tags\n```\n\n  [1]: http://blog.chinaunix.net/attachment/201402/19/10415985_139279770639pM.jpg\n  [2]: http://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png\n  [3]: http://nvie.com/posts/a-successful-git-branching-model/\n  [4]: http://static.blinkfox.com/ghost/imagegit_flow.png","tags":["Git"],"categories":["软件工具"]},{"title":"Java面向对象设计之状态模式","url":"/2018/092123773.html","content":"\n## 一、模式动机\n\n在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(`stateful`)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。\n\n## 二、模式定义\n\n> **状态模式(`State Pattern`)**：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(`Objects for States`)，状态模式是一种对象行为型模式。\n\n## 三、模式结构\n\n### 1. 角色组成：\n\n状态模式包含如下角色：\n\n- `Context`: 环境类\n- `State`: 抽象状态角色\n- `ConcreteState`: 具体状态角色类\n\n### 2. 结构图：\n\n![状态模式结构图][1]\n\n### 3. 时序图：\n\n![状态模式时序图][2]\n\n## 四、示例代码\n\n首先，是抽象的状态角色接口：\n\n```java\n/**\n * 抽象状态角色\n * Created by blinkfox on 16/7/12.\n */\npublic interface IState {\n\n    /**\n     * 抽象方法1\n     */\n    void handle1();\n\n    /**\n     * 抽象方法2\n     */\n    void handle2();\n\n}\n```\n\n接下来，是多个具体的状态角色类，分别如下：\n\n\n```java\n/**\n * 具体状态角色类1\n * Created by blinkfox on 16/7/12.\n */\npublic class ConcreteState1 implements IState {\n\n    /**\n     * 具体状态角色类1中的方法1\n     */\n    @Override\n    public void handle1() {\n        System.out.println(\"执行了具体状态角色类1中的方法1...\");\n    }\n\n    /**\n     * 具体状态角色类1中的方法2\n     */\n    @Override\n    public void handle2() {\n        System.out.println(\"执行了具体状态角色类1中的方法2...\");\n    }\n\n}\n```\n\n\n```java\n/**\n * 具体状态角色类2\n * Created by blinkfox on 16/7/12.\n */\npublic class ConcreteState2 implements IState {\n\n    /**\n     * 具体状态角色类2中的方法1\n     */\n    @Override\n    public void handle1() {\n        System.out.println(\"执行了具体状态角色类2中的方法1...\");\n    }\n\n    /**\n     * 具体状态角色类2中的方法2\n     */\n    @Override\n    public void handle2() {\n        System.out.println(\"执行了具体状态角色类2中的方法2...\");\n    }\n    \n}\n```\n\n然后，是环境类：\n\n\n```java\n/**\n * 环境角色类\n * Created by blinkfox on 16/7/12.\n */\npublic class Context {\n\n    // 当前状态\n    private IState state;\n\n    /**\n     * 构造方法\n     * @param state\n     */\n    public Context(IState state) {\n        this.state = state;\n    }\n\n    /**\n     * 方法1\n     */\n    public void handle1() {\n        this.state.handle1();\n    }\n\n    /**\n     * 方法2\n     */\n    public void handle2() {\n        this.state.handle2();\n    }\n\n}\n```\n\n最后，是用于测试状态模式的客户端场景类：\n\n\n```java\n/**\n * 状态模式的客户端场景累\n * Created by blinkfox on 16/7/12.\n */\npublic class StateClient {\n\n    public static void main(String[] args) {\n        Context context = new Context(new ConcreteState1());\n        context.handle1();\n        context.handle2();\n    }\n\n}\n```\n\n## 五、模式分析\n\n- 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。\n- 状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。\n\n在状态模式结构中需要理解环境类与抽象状态类的作用：\n\n- 环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。\n- 抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。\n\n### 1. 优点\n\n状态模式的优点：\n\n- 封装了转换规则。\n- 枚举可能的状态，在枚举状态之前需要确定状态种类。\n- 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。\n- 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。\n- 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。\n\n### 2. 缺点\n\n状态模式的缺点：\n\n- 状态模式的使用必然会增加系统类和对象的个数。\n- 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。\n- 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。\n\n### 3.适用环境\n\n在以下情况下可以使用状态模式：\n\n- 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。\n- 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。\n\n> 状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。\n\n## 六、总结\n\n- 状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。\n- 状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。\n- 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。\n- 状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。\n- 状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。\n\n[1]: http://static.blinkfox.com/State.jpg\n[2]: http://static.blinkfox.com/seq_State.jpg\n\n","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java面向对象设计之代理模式","url":"/2018/092032073.html","content":"\n## 一、模式动机\n\n在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。\n\n通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。\n\n## 二、模式定义\n\n> **代理模式(`Proxy Pattern`)**：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做`Proxy`或`Surrogate`，它是一种对象结构型模式。\n\n## 三、模式结构\n\n### 1. 角色组成\n\n代理模式包含如下角色：\n\n- `Subject`: 抽象主题角色\n- `RealSubject`: 真实主题角色\n- `Proxy`: 代理主题角色\n\n### 2. 结构图\n\n![代理模式结构图][1]\n\n## 四、示例代码\n\n首先，是抽象的主题接口和真实主题类：\n\n```java\npackage com.blinkfox.patterns.proxy;\n\n/**\n * 抽象主题类\n * Created by blinkfox on 2017/1/1.\n */\npublic interface ISubject {\n\n    /**\n     * 定义一个方法\n     */\n    public void request();\n\n}\n```\n\n```java\npackage com.blinkfox.patterns.proxy;\n\n/**\n * 真实主题类\n * Created by blinkfox on 2017/1/1.\n */\npublic class RealSubject implements ISubject {\n\n    /**\n     * 实现方法\n     */\n    @Override\n    public void request() {\n        System.out.println(\"真实主题类请求方法...\");\n    }\n\n}\n```\n\n然后，是代理类：\n\n```java\npackage com.blinkfox.patterns.proxy;\n\n/**\n * 代理类\n * Created by blinkfox on 2017/1/1.\n */\npublic class Proxy implements ISubject {\n\n    private ISubject subject;\n\n    public Proxy(ISubject subject) {\n        this.subject = subject;\n    }\n\n    @Override\n    public void request() {\n        this.before();\n        this.subject.request();\n        this.after();\n    }\n\n    /**\n     * 预处理\n     */\n    private void before() {\n        System.out.println(\"执行前(before)的处理...\");\n    }\n\n    /**\n     * 善后处理\n     */\n    private void after() {\n        System.out.println(\"执行后(after)的处理...\");\n    }\n\n}\n```\n\n最后，是客户端场景测试类：\n\n```java\npackage com.blinkfox.patterns.proxy;\n\n/**\n * 代理模式客户端场景类\n * Created by blinkfox on 2017/1/1.\n */\npublic class ProxyClient {\n\n    public static void main(String[] args) {\n        ISubject subject = new RealSubject();\n        Proxy proxy = new Proxy(subject);\n        proxy.request();\n    }\n\n}\n```\n\n## 五、模式分析\n\n### 1. 优点\n\n代理模式的优点：\n\n- 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。\n- 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。\n- 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。\n- 保护代理可以控制对真实对象的使用权限。\n\n### 2. 缺点\n\n代理模式的缺点：\n\n- 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。\n- 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n\n### 3. 适用环境\n\n根据代理模式的使用目的，常见的代理模式有以下几种类型：\n\n- **远程(Remote)代理**：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。\n- **虚拟(Virtual)代理**：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。\n- **Copy-on-Write代理**：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。\n- **保护(Protect or Access)代理**：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。\n- **缓冲(Cache)代理**：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。\n- **防火墙(Firewall)代理**：保护目标不让恶意用户接近。\n- **同步化(Synchronization)代理**：使几个用户能够同时使用一个对象而没有冲突。\n- **智能引用(Smart Reference)代理**：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。\n\n## 模式总结\n\n- 在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。\n- 代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。\n- 代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。\n- 如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。\n- 保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。\n\n  [1]: http://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Spring基础介绍","url":"/2018/091736407.html","content":"\n## 一、Spring 概述\n\n### （一）Spring 的简史\n\n[Spring][1] 的历史网上有很多的介绍，下面是 Spring 发展历程的一个简介。\n\n#### 1. 第一阶段：xml 配置\n\n在 Spring 1.x 时代，使用 Spring 开发满眼都是 xml 配置的 Bean，随着项目的扩大，我们需要把 xml 配置文件放到不同的配置文件里，那时候需要频繁地在开发的类和配置文件之间切换。\n\n#### 2. 第二阶段：注解配置\n\n在 Spring 2.x 时代，随着 JDK 1.5 带来的注解支持，Spring 提供了声明 Bean 的注解（如：@Component、@Service），大大减少了配置量。这时 Spring 圈子里存在着一种争论：注解配置和 xml 配置究竟哪个更好？我们最终的选择是应用的基本配置（如：数据库配置）用 xml，业务配置用注解。\n\n#### 3. 第三阶段：Java 配置\n\n从 Spring 3.x 到现在，Spring 提供了 Java 配置的能力，使用 Java 配置可以让你更理解你配置的 Bean。我们目前刚好处于这个时代，Spring 4.x 和 Spring Boot 都推荐使用 Java 配置。\n\n### （二）Spring 概述\n\nSpring 框架是一个轻量级的企业级开发的一站式解决方案。所谓解决方案就是可以基于 Spring 解决 JavaEE 开发的所有问题。Spring 框架主要提供了`IoC`容器、AOP、数据访问、Web 开发、消息、测试等相关技术的支持。\n\nSpring 使用简单的 POJO（`Plain Old Java Object`，即无任何限制的普通Java对象）来进行企业级开发。每一个被 Spring 管理的 Java 对象都被称之为 Bean；而 Spring 提供了一个 IoC 容器用来初始化对象，解决对象间的依赖管理和对象的使用。\n\n#### 1. Spring 的模块\n\nSpring 是模块化的，这意味着你可以只使用你需要的Spring的模块。如下图所示：\n\n![Spring 模块][2]\n\n图中的每个最小单元，Spring 都至少有一个对应的 jar 包。\n\n##### （1）核心容器（Core Contariner）\n\n- Spring-Core：核心工具类，Spring 其他模块大量使用 Spring-Core\n- Spring-Beans：Spring 定义 Bean 的支持\n- Spring-Context：运行时 Spring 容器\n- Spring-Context-Support：容器对第三方包的集成支持\n- Spring-Expression：使用表达式语言在运行时查询和操作对象\n\n##### （2）AOP\n\n- Spring-AOP：基于代理的 AOP 支持\n- Spring-Aspects：基于 AspectJ 的 AOP 支持\n\n##### （3）消息（Messaging）\n\n- Spring-Messaging：对消息架构和协议的支持\n\n##### （4）Web\n\n- Spring-Web：提供基础的 Web 集成的功能，在 Web 项目中提供 Spring 的容器\n- Spring-Webmvc：提供基于 Servlet 的 Spring MVC\n- Spring-WebSocket：提供 WebSocket 功能\n- Spring-Webmvc-Portlet：提供 Portlet 环境功能\n\n##### （5）数据访问/集成（Data Access/Integration）\n\n- Spring-JDBC：提供以 JDBC 访问数据库的支持\n- Spring-TX：提供编程式和声明式的事务支持\n- Spring-ORM：提供对对象/关系映射技术的支持\n- Spring-OXM：提供对对象/xml 映射技术的支持\n- Spring-JMS：提供对 JMS 的支持\n\n#### 1. Spring 的生态\n\nSpring 发展到现在已经不仅仅是 Spring 框架本身的内容，Spring 目前提供了大量的基于 Spring 的项目，可以用来更深入地降低我们的开发难度，提高开发效率。\n目前 Spring 的生态里主要有以下项目，我们可以根据自己项目的需要来选择使用相应的项目。\n\n- Spring Boot：使用默认开发配置来实现快速开发\n- Spring XD：用来简化大数据应用开发\n- Spring Cloud：为分布式系统开发提供工具集\n- Spring Data：对主流关系型和 NoSQL 数据库的支持\n- Spring Integration：通过消息机制对企业集成模式（EIP）的支持\n- Spring Batch：简化及优化大量数据的批处理操作\n- Spring Security：通过认证和授权保护应用\n- Spring HATEOAS：基于 HATEOAS 原则简化 REST 服务开发\n- Spring Social：与社交网络 API（如：Facebook、新浪微博等）的集成\n- Spring AMQP：对基于 AMQP 的消息的支持\n- Spring Mobile：提供对手机设备检测的功能，给不同的设备返回不同的页面的功能\n- Spring for Android：主要提供在 Android 上消费 RESTful API 的功能\n- Spring Web Flow：基于 SpringMVC 提供基于向导流程式的 Web 应用开发\n- Spring Web Services：提供了基于协议有限的 SOAP/Web 服务\n- Spring LDAP：简化使用 LDAP 开发\n- Spring Session：提供一个 API 及实现来管理用户会话信息\n\n## 二、Spring 项目快速搭建\n\n这里我们使用目前 Java 主流的项目构建工具[Maven][3]来搭建项目。\n\n### （一）Maven 介绍\n\nApache Maven 是一个基于项目对象模型（Project Object Model，POM）的软件项目管理工具。Maven 可用来管理项目的依赖、编译、打包、文档等信息。使用 Maven 来管理项目时，项目依赖的 jar 包将不再包含在项目内，而是集中放置在用户目录下的 .m2 文件夹下。关于 Maven 的详细安装介绍可参考[这里][4]。\n\n### （二）创建项目\n\n在创建项目之前，须确保你的计算机上已经安装好有 Java 和 Maven 环境。然后，打开终端通过以下简单的命令就可以在你的当前目录下创建一个 Jave web 的项目结构：\n\n```bash\nmvn archetype:generate -DgroupId=com.blinkfox -DartifactId=springdemo -DpackageName=com.blinkfox.springdemo -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false\n```\n\n其中`-DgroupId=com.blinkfox`是组织名，`-DartifactId=springdemo`是该组织下的项目名称，`-DarchetypeArtifactId=maven-archetype-webapp`代表创建一个简单的 webapp 项目。\n\n创建项目的时候，Maven会自动下载一些需要用到的 jar 包和 Maven 插件。如果顺利创建成功的话，就会在你的当前目录下看到名为 springdemo 的项目，其中包含`src`的文件夹和`pom.xml`文件。且在你的终端会看到如下输出：\n\n![Maven创建项目成功][5]\n\n### （三）添加 Spring 依赖\n\n接下来需要通过修改 pom.xml 来添加 Spring 的依赖，添加编译插件，且将编译级别设置为1.7，pom.xml文件的修改如下：\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.blinkfox</groupId>\n    <artifactId>springdemo</artifactId>\n    <packaging>war</packaging>\n    <version>1.0-SNAPSHOT</version>\n    <name>springdemo Maven Webapp</name>\n    <url>http://maven.apache.org</url>\n\n    <properties>\n        <java.version>1.7</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>4.3.3.RELEASE</version>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>springdemo</finalName>\n        <!-- 指定maven的默认操作为 -->\n        <defaultGoal>compile</defaultGoal>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.1</version>\n                <configuration>\n                    <source>${java.version}</source>\n                    <target>${java.version}</target>\n                    <encoding>UTF-8</encoding>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 三、Spring 基础配置\n\nSpring 框架本身有四大原则：\n\n- 使用 POJO 进行轻量级和最小侵入式开发\n- 通过依赖注入和面向接口编程来实现松耦合\n- 通过 AOP 和默认习惯进行声明式编程\n- 使用 AOP 和模板(template)减少模式化代码\n\nSpring 的所有功能设计和实现都是基于此四大原则。\n\n### （一）依赖注入\n\n#### 1. 重点说明\n\n我们经常说的控制反转（Inversion of Control，IoC）和依赖注入（dependency injection，DI）在 Spring 环境下是等同的概念，控制反转是通过依赖注入实现的。所谓依赖注入指的是容器负责创建对象和维护对象间的依赖关系，而不是通过对象本身负责自己的创建和解决自己的依赖。\n\n依赖注入的主要目的是为了解耦，体现了一种“组合”的理念。如果你希望你的类具备某项功能的时候，是继承自一个具有此功能的父类好呢？还是组合另外一个具有这个功能的类好呢？答案是不言而喻的，继承一个父类，之类将与父类耦合，组合另外一个类则使耦合度大大降低。\n\nSpring IoC 容器（ApplicationContext）负责创建 Bean，并通过容器将功能类 Bean 注入到你需要的 Bean 中。Spring 提供使用 xml、注解、Java 配置、groovy 配置实现 Bean 的创建和注入。\n\n无论是 xml 配置、注解配置还是 Java 配置，都被称为配置元数据，所谓元数据即描述数据的数据。元数据本身不具备任何可执行的能力，只能通过外界代码来对这些元数据行解析后进行一些有意义操作。Spring 容器解析这些配置元数据进行 Bean 初始化、配置和管理依赖。\n\n声明 Bean 的注解：\n\n- `@Component`: 组件，没有明确角色\n- `@Controller`: 在展现层（MVC -> Spring MVC）使用\n- `@Service`: 在业务逻辑层（service层）使用\n- `@Repository`: 在数据访问层（dao层）使用\n\n注入 Bean 的注解，一般情况下通用：\n\n- `@Autowired`: Spring 提供的注解\n- `@Inject`: JSR-330 提供的注解\n- `@Resource`: JSR-250 提供的注解\n\n`@Autowired`、`@Inject`、`@Resource`可注解在 set 方法上或者属性上，推荐注解在属性上，优点是代码更少、层次更清晰。\n\n#### 2. 代码示例\n\n（1）编写功能类的 Bean。\n\n```java\npackage com.blinkfox.service.impl;\n\nimport org.springframework.stereotype.Service;\n\n/**\n * Created by blinkfox on 2016/10/27.\n */\n@Service\npublic class FunctionService {\n\n    public String sayHello(String word) {\n        return \"Hello \" + word + \"!\";\n    }\n\n}\n```\n\n> **代码解释**：\n> 1. 使用 @Service 注解声明当前 FunctionService 类是 Spring 管理的一个 Bean。其中，使用 @Component、@Service、@Repository、@Controller 是等效的，可根据需要选用。\n\n（2）使用功能类的 Bean。\n\n```java\npackage com.blinkfox.service.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n/**\n * Created by blinkfox on 2016/10/27.\n */\n@Service\npublic class UseFunctionService {\n\n    @Autowired\n    private FunctionService functionService;\n\n\n    public String sayHello(String word) {\n        return functionService.sayHello(word);\n    }\n\n}\n```\n\n> **代码解释**：\n> 1. 使用 @Service 注解声明当前 UseFunctionService 类是 Spring 管理的一个 Bean。\n> 2. 使用 @Autowired 将 FunctionService 的实体 Bean 注入到 UseFunctionService 中，让 UseFunctionService 具备 FunctionService 的功能，此处使用 JSR-330 的 @Inject 注解或者 JSR-250 的 @Resource 注解是等效的。\n\n（3）配置类。\n\n```java\npackage com.blinkfox.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Created by blinkfox on 2016/10/27.\n */\n@Configuration\n@ComponentScan(\"com.blinkfox.service.impl\")\npublic class DiConfig {\n}\n```\n\n> **代码解释**：\n> 1. 使用 @Configuration 注解声明当前类是一个配置类。\n> 2. 使用 @ComponentScan 将 自动扫描包名下所有使用的 @Component、@Service、@Repository、@Controller 类，并注册为 Bean。\n\n（4）运行。\n\n```java\npackage com.blinkfox.maintest;\n\nimport com.blinkfox.config.DiConfig;\nimport com.blinkfox.service.impl.UseFunctionService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\n/**\n * Created by blinkfox on 2016/10/27.\n */\npublic class FunctionMain {\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(DiConfig.class);\n        UseFunctionService useFunctionService = context.getBean(UseFunctionService.class);\n        System.out.println(useFunctionService.sayHello(\"Spring\"));\n        context.close();\n    }\n\n}\n```\n\n> **代码解释**：\n> 1. 使用 AnnotationConfigApplicationContext 作为 Spring 容器，接收使用一个配置类作为参数。\n> 2. 获得声明配置的 UseFunctionService 的 Bean。\n\n### （二）Java 配置\n\n#### 1. 重点说明\n\nJava 配置是 Spring4.x 推荐的配置方式，可以完全替代 xml 配置；Java 配置也是 Spring Boot 推荐的配置方式。\n\nJava 配置是通过 @Configuration 和 @Bean 来实现的。\n\n- @Configuration 声明当前类是一个配置类，相当于一个Spring配置的 xml 文件。\n- @Bean 注解在方法上，声明当前方法的返回值是一个 Bean。\n\n何时使用 Java 配置或者注解配置呢？我们主要的原则是：全局配置使用 Java 配置（如数据库相关配置、MVC相关配置），业务 Bean 的配置使用注解配置（@Service、@Component、@Repository、@Controller）。\n\n#### 2. Java配置代码示例\n\n（1）编写功能类的 Bean\n\n```java\npackage com.blinkfox.service.impl;\n\n/**\n * Created by blinkfox on 2016/10/27.\n */\n// 1\npublic class JavaConfigService {\n\n    public String sayHello(String word) {\n        return \"Hello \" + word + \"!\";\n    }\n\n}\n```\n\n> **代码解释**：\n> 1. 此处没有使用 @Service 声明 Bean。\n\n（2）使用功能类的 Bean\n\n```java\npackage com.blinkfox.service.impl;\n\n/**\n * Created by blinkfox on 2016/10/27.\n */\n// 1\npublic class UseJavaConfigService {\n    // 2\n    private JavaConfigService javaConfigService;\n\n    public void setJavaConfigService(JavaConfigService javaConfigService) {\n        this.javaConfigService = javaConfigService;\n    }\n\n    public String sayHello(String word) {\n        return javaConfigService.sayHello(word);\n    }\n\n}\n```\n\n> **代码解释**：\n> 1. 此处没有使用 @Service 声明 Bean。\n> 2. 此处没有使用 @Autowired 注解注入 Bean。\n\n（3）Java 配置类\n\n```java\npackage com.blinkfox.config;\n\nimport com.blinkfox.service.impl.JavaConfigService;\nimport com.blinkfox.service.impl.UseJavaConfigService;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Created by blinkfox on 2016/10/27.\n */\n@Configuration // 1\npublic class JavaConfig {\n\n    @Bean  // 2\n    public JavaConfigService javaConfigService() {\n        return new JavaConfigService();\n    }\n\n    @Bean\n    public UseJavaConfigService useJavaConfigService() {\n        UseJavaConfigService useJavaConfigService = new UseJavaConfigService();\n        useJavaConfigService.setJavaConfigService(javaConfigService()); // 3\n        return useJavaConfigService;\n    }\n\n}\n```\n\n> **代码解释**：\n> 1. 使用 @Configuration 注解表明当前类是一个配置类，这意味着这个类型里可能有0个或者多个 @Bean 注解，此处没有使用包扫描，是因为所有的 Bean 都在此类中定义了。\n> 2. 使用 @Bean 注解声明当前方法 JavaConfigService 的返回值是一个 Bean，Bean的名称是方法名。\n> 3. 注入 FunctionService 的 Bean 时候直接调用 javaConfigService()。\n\n（4）运行\n\n```java\npackage com.blinkfox.maintest;\n\nimport com.blinkfox.config.JavaConfig;\nimport com.blinkfox.service.impl.UseJavaConfigService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\n/**\n * Created by blinkfox on 2016/10/27.\n */\npublic class JavaConfigMain {\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(JavaConfig.class);\n        UseJavaConfigService useJavaConfigService = context.getBean(UseJavaConfigService.class);\n        System.out.println(useJavaConfigService.sayHello(\"Spring Java Config\"));\n        context.close();\n    }\n\n}\n```\n\n### （三）AOP\n\n#### 1. 重点说明\n\nAOP：面向切面编程，是面向对象编程（OOP）的补充。\n\nSpring 的 AOP 的存在目的是为了解耦。AOP 可以让一组类共享相同的行为。在 OOP 中只能通过继承和实现接口来共享相同的行为，从而使代码的耦合度增强，且类继承只能为单继承，阻碍更多行为添加到一组类上，AOP 弥补了 OOP 的不足。\n\nSpring 支持 AspectJ 的注解式切面编程。\n\n- 使用 @AspectJ 声明是一个切面。\n- 使用 @After、@Before、Around 定义通知（advice）类型，可直接将拦截规则（切点）作为参数。\n- 其中 @After、@Before、Around 参数的拦截规则为切点（PointCut），为了使切点复用，可使用 @PointCut 专门定义拦截规则，然后在 @After、@Before、Around 的参数中调用。\n- 其中符合条件的每一个拦截处为连接点（JoinPoint）。\n\nSpring本身在事务处理（@Transcational）和数据缓存（@Cacheable）等都使用注解拦截。下面示例将演示基于注解和方法规则的拦截方式，演示一种模拟记录操作的日志系统的实现。\n\n#### 2. 注解拦截代码示例\n\n（1）添加 Spring aop 支持及 AspectJ 依赖。\n\n```java\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-aop</artifactId>\n\t<version>4.3.3.RELEASE</version>\n</dependency>\n<dependency>\n\t<groupId>org.aspectj</groupId>\n\t<artifactId>aspectjrt</artifactId>\n\t<version>1.8.9</version>\n</dependency>\n<dependency>\n\t<groupId>org.aspectj</groupId>\n\t<artifactId>aspectjweaver</artifactId>\n\t<version>1.8.9</version>\n</dependency>\n```\n（2）编写拦截规则的注解。\n\n```java\npackage com.blinkfox.annotation;\n\nimport java.lang.annotation.*;\n\n/**\n * Created by blinkfox on 2016/10/29.\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface LogAction {\n\n    String name() default \"这是默认的操作名称\";\n\n}\n```\n\n> **代码解释**：\n> 注解本身是没有功能的，就和 xml 一样。注解和 xml 都是一种元数据，元数据即解释数据的数据，这就是所谓的配置。注解的功能来自用这个注解的地方。\n\n（3）编写使用注解的被拦截类。\n\n```java\npackage com.blinkfox.service.impl;\n\nimport com.blinkfox.annotation.LogAction;\nimport org.springframework.stereotype.Service;\n\n/**\n * Created by blinkfox on 2016/10/29.\n */\n@Service\npublic class DemoAnnotationService {\n\n    @LogAction(name = \"注解式拦截的 add 操作\")\n    public void add() {\n\n    }\n\n}\n```\n\n（4）编写使用方法规则被拦截规类。\n\n```java\npackage com.blinkfox.service.impl;\n\nimport org.springframework.stereotype.Service;\n\n/**\n * Created by blinkfox on 2016/10/29.\n */\n@Service\npublic class DemoMethodService {\n\n    public void add() {\n\n    }\n\n}\n```\n\n（5）编写切面。\n\n```java\npackage com.blinkfox.aop;\n\nimport com.blinkfox.annotation.LogAction;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n * Created by blinkfox on 2016/10/29.\n */\n@Aspect // 1\n@Component // 2\npublic class LogAspect {\n\n    @Pointcut(\"@annotation(com.blinkfox.annotation.LogAction)\") // 3\n    public void annotationPointCut() {\n\n    }\n\n    @After(\"annotationPointCut()\") // 4\n    public void after(JoinPoint joinPoint) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        LogAction logAction = method.getAnnotation(LogAction.class);\n        System.out.println(\"---注解式拦截:\" + logAction.name()); // 5\n    }\n\n    @After(\"execution(* com.blinkfox.service.impl.DemoMethodService.*(..))\") // 6\n    public void before(JoinPoint joinPoint) {\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        System.out.println(\"---方法规则式拦截:\" + method.getName());\n    }\n\n}\n```\n\n> **代码解释**：\n> 1. 通过 @Aspect 注解声明一个切面。\n> 2. 通过 @Component 让此切面成为 Spring 容器管理的Bean。\n> 3. 通过 @PointCut 注解声明切点。\n> 4. 通过 @After 注解声明一个通知类型，并使用 @PointCut定义的切点。\n> 5. 通过可获得注解上的属性，然后做日志记录相关的操作，下面相同。\n> 6. 通过 @Before 注解声明一个通知类型，此通知直接使用拦截规则作为参数。\n\n（6）配置类。\n\n```java\npackage com.blinkfox.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\n\n/**\n * Created by blinkfox on 2016/10/29.\n */\n@Configuration\n@ComponentScan(\"com.blinkfox\")\n@EnableAspectJAutoProxy\npublic class AopConfig {\n\n}\n```\n\n> **代码解释**：\n> 1. 使用 @EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ的支持。\n\n（6）运行。\n\n```java\npackage com.blinkfox.maintest;\n\nimport com.blinkfox.config.AopConfig;\nimport com.blinkfox.service.impl.DemoAnnotationService;\nimport com.blinkfox.service.impl.DemoMethodService;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\n/**\n * Created by blinkfox on 2016/10/29.\n */\npublic class AopMain {\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(AopConfig.class);\n        DemoAnnotationService demoAnnotationService = context.getBean(DemoAnnotationService.class);\n        DemoMethodService demoMethodService = context.getBean(DemoMethodService.class);\n        demoAnnotationService.add();\n        demoMethodService.add();\n        context.close();\n    }\n\n}\n```\n\n  [1]: https://spring.io/\n  [2]: http://static.blinkfox.com/spring_moudle.png\n  [3]: http://maven.apache.org/\n  [4]: http://blinkfox.com/linux-debianxia-mavende-an-zhuang-he-shi-yong/\n  [5]: http://static.blinkfox.com/maven_build_project.png","tags":["Java","Spring"],"categories":["后端"]},{"title":"Java面向对象设计之工厂方法模式","url":"/2018/091449719.html","content":"\n## 一、模式定义\n\n工厂方法模式(`Factory Method Pattern`)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n## 二、模式结构\n\n### 1. 角色组成\n\n工厂方法模式包含如下角色：\n\n- `Product`：抽象产品\n- `ConcreteProduct`：具体产品\n- `Factory`：抽象工厂\n- `ConcreteFactory`：具体工厂\n\n### 2. 结构图\n\n![工厂方法模式结构图][1]\n\n### 3. 时序图\n\n![工厂方法模式时序图][2]\n\n## 三、示例代码\n\n首先，是抽象的产品类和具体的产品类：\n\n```java\n/**\n * 抽象产品类\n * Created by blinkfox on 16-6-29.\n */\npublic abstract class Product {\n\n    /**\n     * 产品类的公共方法\n     */\n    public void method1() {\n        System.out.println(\"这是产品类的公共方法\");\n    }\n\n    /**\n     * 抽象方法\n     */\n    public abstract void method2();\n\n}\n```\n\n```java\n/**\n * 具体产品类1\n * Created by blinkfox on 16-6-29.\n */\npublic class ConcreteProduct1 extends Product {\n\n    @Override\n    public void method2() {\n        System.out.println(\"ConcreteProduct1的method2方法\");\n    }\n\n}\n```\n\n```java\n/**\n * 具体产品类2\n * Created by blinkfox on 16-6-29.\n */\npublic class ConcreteProduct2 extends Product {\n\n    @Override\n    public void method2() {\n        System.out.println(\"ConcreteProduct2的method2方法\");\n    }\n\n}\n```\n\n然后，是抽象的工厂类和具体的工厂类：\n\n```java\n/**\n * 抽象的工厂类\n * Created by blinkfox on 16-6-29.\n */\npublic abstract class Factory {\n\n    /**\n     * 运用了Java中的泛型和反射技术,生成某种具体的产品\n     * 其输入类型可以自行设置\n     * @param c\n     * @param <T>\n     * @return\n     */\n    public abstract <T extends Product> T createProduct(Class<T> c);\n\n}\n```\n\n```java\n/**\n * 具体生产产品的工厂类\n * Created by blinkfox on 16-6-29.\n */\npublic class ConcreteFactory extends Factory {\n\n    /**\n     * 运用了Java中的泛型和反射技术,生成某种具体的产品\n     * 其输入类型可以自行设置\n     * @param c\n     * @param <T>\n     * @return\n     */\n    @Override\n    public <T extends Product> T createProduct(Class<T> c) {\n        Product product = null;\n        try {\n            product = (Product) Class.forName(c.getName()).newInstance();\n        } catch (Exception e) {\n            System.out.println(\"生产产品出错\");\n            e.printStackTrace();\n        }\n        return (T) product;\n    }\n\n}\n```\n\n最后，是客户端场景类：\n\n```java\n/**\n * 工厂方法模式客户端场景类\n * Created by blinkfox on 16-6-29.\n */\npublic class Client {\n\n    public static void main(String[] args) {\n        Factory factory = new ConcreteFactory();\n        Product product1 = factory.createProduct(ConcreteProduct1.class);\n        product1.method1();\n        product1.method2();\n\n        Product product2 = factory.createProduct(ConcreteProduct2.class);\n        product2.method1();\n        product2.method2();\n    }\n\n}\n```\n\n## 四、模式分析\n\n在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。\n\n### 1. 优点\n\n工厂方法模式的优点：\n\n- 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。\n- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。\n- 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。\n\n### 2. 缺点\n\n工厂方法模式的缺点：\n\n- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。\n- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。\n\n### 3. 适用环境\n\n在以下情况下可以使用工厂方法模式：\n\n- 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。\n- 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。\n- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。\n\n## 五、模式扩展\n\n工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍4种常用扩展。\n\n### 1. 简单工厂模式\n\n我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下：\n\n```java\n/**\n * 简单工厂模式中的工厂类\n * Created by blinkfox on 16-6-29.\n */\npublic class SimpleFactory {\n\n    /**\n     * 运用了Java中的泛型和反射技术,生成某种具体的产品\n     * 其输入类型可以自行设置\n     * @param c\n     * @param <T>\n     * @return\n     */\n    public static  <T extends Product> T createProduct(Class<T> c) {\n        Product product = null;\n        try {\n            product = (Product) Class.forName(c.getName()).newInstance();\n        } catch (Exception e) {\n            System.out.println(\"生产产品出错\");\n            e.printStackTrace();\n        }\n        return (T) product;\n    }\n\n}\n```\n\n```java\n/**\n * 简单工厂模式客户端场景类\n * Created by blinkfox on 16-6-29.\n */\npublic class SimpleClient {\n\n    public static void main(String[] args) {\n        Product product1 = SimpleFactory.createProduct(ConcreteProduct1.class);\n        product1.method1();\n        product1.method2();\n\n        Product product2 = SimpleFactory.createProduct(ConcreteProduct2.class);\n        product2.method1();\n        product2.method2();\n    }\n\n}\n```\n\n运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。\n\n### 2. 多工厂类工厂方法模式\n\n当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下：\n\n多工厂模式的抽象工厂类：\n\n```java\n/**\n * 生成多个产品的抽象工厂类\n * Created by blinkfox on 16-7-2.\n */\npublic abstract class MultiFactory {\n\n    /**\n     * 生成某种产品的方法\n     * @return\n     */\n    public abstract Product createProduct();\n\n}\n```\n\n第一种产品的创建工厂实现：\n\n```java\n/**\n * 生成产品1的具体工厂类1\n * Created by blinkfox on 16-7-2.\n */\npublic class ConcreteFactory1 extends MultiFactory {\n\n    /**\n     * 生成产品1的方法\n     * @return\n     */\n    @Override\n    public Product createProduct() {\n        return new ConcreteProduct1();\n    }\n\n}\n```\n\n第二种产品的创建工厂实现：\n\n```java\n/**\n * 生成产品2的具体工厂类2\n * Created by blinkfox on 16-7-2.\n */\npublic class ConcreteFactory2 extends MultiFactory {\n\n    /**\n     * 生成产品2的方法\n     * @return\n     */\n    @Override\n    public Product createProduct() {\n        return new ConcreteProduct2();\n    }\n\n}\n```\n\n多工厂模式的客户端场景类\n\n```java\n/**\n * 多工厂方法模式客户端场景类\n * Created by blinkfox on 16-7-2.\n */\npublic class MultiClient {\n\n    public static void main(String[] args) {\n        Product concreteProduct1 = (new ConcreteFactory1()).createProduct();\n        concreteProduct1.method1();\n        concreteProduct1.method2();\n\n        Product concreteProduct2 = (new ConcreteFactory2()).createProduct();\n        concreteProduct1.method1();\n        concreteProduct1.method2();\n    }\n\n}\n```\n\n### 3. 工厂方法的单例模式\n\n单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。\n\n下面是单例类，其中定义了一个private的无参构造函数，目的是不允许通过new的方式创建对象，代码如下：\n\n```java\n/**\n * 工厂方法模式中的单例类\n * Created by blinkfox on 16-7-4.\n */\npublic class Singleton {\n\n    /**\n     * 私有化构造方法，不允许new产生一个对象\n     */\n    private Singleton() {}\n\n    /**\n     * 工厂方法模式中的单例模式业务方法\n     */\n    public void doSomething() {\n        System.out.println(\"工厂方法模式中的单例模式方法。。。\");\n    }\n\n}\n```\n\n以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下：\n\n```java\n/**\n * 生成单例的工厂类\n * Created by blinkfox on 16-7-4.\n */\npublic class SingletonFactory {\n\n    private static Singleton singleton;\n\n    static {\n        try {\n            Class c = Class.forName(Singleton.class.getName());\n            // 获得无参构造\n            Constructor constructor = c.getDeclaredConstructor();\n            // 设置无参构造是可访问的\n            constructor.setAccessible(true);\n            // 产生一个实例对象\n            singleton = (Singleton) constructor.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"生成单例的工厂类方法中生成单例出错\");zuihou\n        }\n    }\n\n    public static Singleton getSingleton() {\n        return singleton;\n    }\n}\n```\n\n最后是工厂方法单例模式的客户端场景类：\n\n```java\n/**\n * 工厂方法单例模式客户端场景类\n * Created by blinkfox on 16-7-4.\n */\npublic class SingleClient {\n\n    public static void main(String[] args) {\n        Singleton singleton = SingletonFactory.getSingleton();\n        singleton.doSomething();\n    }\n\n}\n```\n\n### 4. 工厂方法的延迟初始化\n\n何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下：\n\n```java\n/**\n * 延迟加载的工厂类\n * Created by blinkfox on 16-7-4.\n */\npublic class LazyFactory {\n\n    private static final Map<String, Product> lazyMap = new HashMap<String, Product>();\n\n    public static synchronized Product createProduct(String type) {\n        Product product = null;\n\n        // 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中\n        if (lazyMap.containsKey(type)) {\n            return lazyMap.get(type);\n        }\n\n        // 根据类型创建具体的产品对象\n        if (\"product1\".equals(type)) {\n            product = new ConcreteProduct1();\n        } else {\n            product = new ConcreteProduct2();\n        }\n        // 同时把对象放到缓存容器中\n        lazyMap.put(\"type\", product);\n\n        return product;\n    }\n\n}\n```\n\n上面即为延迟加载的工厂类。代码比较简单，通过定义一个`map`容器来容纳所有产生的对象，如果在`map`容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到`map`容器中，以便下次调用。\n\n延迟加载的工厂模式客户端场景类代码如下：\n\n```java\n/**\n * 延迟加载的工厂模式客户端场景类\n * Created by blinkfox on 16-7-4.\n */\npublic class LazyClient {\n\n    public static void main(String[] args) {\n        Product product1 = LazyFactory.createProduct(\"product1\");\n\n        Product product11 = LazyFactory.createProduct(\"product1\");\n    }\n\n}\n```\n\n## 六、总结\n\n- 工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n- 工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。\n- 工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。\n- 工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。\n- 工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。\n\n  [1]: http://static.blinkfox.com/FactoryMethod.jpg\n  [2]: http://static.blinkfox.com/seq_FactoryMethod.jpg","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java面向对象设计之装饰模式","url":"/2018/091461471.html","content":"\n## 一、模式动机\n\n一般有两种方式可以实现给一个类或对象增加行为：\n\n- **继承机制**，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。\n- **关联机制**，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)\n\n**装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任**，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。**装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展**。这就是装饰模式的模式动机。\n\n## 二、模式定义\n\n> **装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)**，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。\n\n策略模式是一种**对象结构型**模式。\n\n## 三、 模式结构\n\n装饰模式包含如下角色：\n\n- `Component`: 抽象构件\n- `ConcreteComponent`: 具体构件\n- `Decorator`: 抽象装饰类\n- `ConcreteDecorator`: 具体装饰类\n\n### 结构图\n\n![装饰模式结构图][1]\n\n### 时序图\n\n![装饰模式时序图][2]\n\n## 四、示例代码\n\n首先定义一个抽象构件接口：\n\n```java\n/**\n * 抽象构件\n * Created by blinkfox on 16-6-26.\n */\npublic interface Component {\n\n    // 接口方法\n    void operate();\n\n}\n```\n\n然后是具体构件实现类：\n\n```java\n/**\n * 具体构件\n * Created by blinkfox on 16-6-26.\n */\npublic class ConcreteComponent implements Component {\n\n    /**\n     * 具体实现方法\n     */\n    @Override\n    public void operate() {\n        System.out.println(\"do Something...\");\n    }\n\n}\n```\n\n接着是装饰角色：\n\n```java\n/**\n * 装饰角色\n * 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。\n * Created by blinkfox on 16-6-26.\n */\npublic class Decorator implements Component {\n\n    private Component component;\n\n    /**\n     * 通过构造函数传递被修饰者\n     * @param component\n     */\n    public Decorator(Component component) {\n        this.component = component;\n    }\n\n    /**\n     * 委托给被修饰者执行\n     */\n    @Override\n    public void operate() {\n        this.component.operate();\n    }\n\n}\n```\n\n下面是具体的装饰类：\n\n```java\n/**\n * 具体的装饰类1\n * Created by blinkfox on 16-6-26.\n */\npublic class ConcreteDecorator1 extends Decorator {\n\n    /**\n     * 通过构造函数传递被修饰者\n     * @param component\n     */\n    public ConcreteDecorator1(Component component) {\n        super(component);\n    }\n\n    /**\n     * 定义自己的修饰方法1\n     */\n    private void method1() {\n        System.out.println(\"method1修饰...\");\n    }\n\n    /**\n     * 重写父类的operate方法\n     */\n    public void operate() {\n        this.method1();\n        super.operate();\n    }\n\n}\n```\n\n```java\n/**\n * 具体的装饰类2\n * Created by blinkfox on 16-6-26.\n */\npublic class ConcreteDecorator2 extends Decorator {\n\n    /**\n     * 通过构造函数传递被修饰者\n     * @param component\n     */\n    public ConcreteDecorator2(Component component) {\n        super(component);\n    }\n\n    /**\n     * 定义自己的修饰方法2\n     */\n    private void method2() {\n        System.out.println(\"method2修饰...\");\n    }\n\n    /**\n     * 重写父类的operate方法\n     */\n    public void operate() {\n        this.method2();\n        super.operate();\n    }\n\n}\n```\n\n最后是客户端的场景类：\n\n```java\n/**\n * 装饰模式的客户端场景类\n * Created by blinkfox on 16-6-26.\n */\npublic class Client {\n\n    public static void main(String[] args) {\n        Component component = new ConcreteComponent();\n\n        // 第一修饰\n        component = new ConcreteDecorator1(component);\n\n        // 第二修饰\n        component = new ConcreteDecorator2(component);\n\n        // 修饰后运行\n        component.operate();\n    }\n\n}\n```\n\n## 五、模式分析\n\n### 总体分析\n\n- **与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展**。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，*关联关系的缺点是比继承关系要创建更多的对象*。\n- **使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任**。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n\n### 优点\n\n装饰模式的优点：\n\n- 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。\n- 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。\n- 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。\n- 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。\n\n### 缺点\n\n装饰模式的缺点：\n\n- 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。\n- 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。\n\n### 适用环境\n\n在以下情况下可以使用装饰模式：\n\n- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n- 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。\n- 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。\n\n### 模式扩展\n\n装饰模式的简化-需要注意的问题:\n\n- 一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。\n- 尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。\n- 如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。\n\n## 六、总结\n\n- 装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。\n- 装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。\n- 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。\n- 装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。\n- 装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。\n- 装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。\n\n  [1]: http://static.blinkfox.com/Decorator.jpg\n  [2]: http://static.blinkfox.com/seq_Decorator.jpg","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"Java面向对象设计之策略模式","url":"/2018/09149157.html","content":"\n## 一、模式动机\n\n完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。\n\n在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(`Hard Coding`)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。\n\n除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。\n\n为了解决这些问题，可以**定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类**。\n\n## 二、模式定义\n\n> **策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)**。\n\n策略模式是一种对象行为型模式。\n\n## 三、 模式结构\n\n策略模式包含如下角色：\n\n- Context: 环境类\n- Strategy: 抽象策略类\n- ConcreteStrategy: 具体策略类\n\n### 结构图\n\n![策略模式结构图][1]\n\n### 时序图\n\n![策略模式时序图][2]\n\n## 四、示例代码\n\n首先定义一个策略接口：\n\n```java\npublic interface IStrategy {\n\n    /**\n     * 策略模式的运算法则\n     */\n    public void doSomething();\n\n}\n```\n\n然后是具体的策略实现类：\n\n```java\npublic class ConcreteStrategy1 implements IStrategy {\n\n    @Override\n    public void doSomething() {\n        System.out.println(\"具体策略的策略方法1\");\n    }\n\n}\n```\n\n```java\npublic class ConcreteStrategy2 implements IStrategy {\n\n    @Override\n    public void doSomething() {\n        System.out.println(\"具体策略的策略方法2\");\n    }\n\n}\n```\n\n接着是封装角色的类：\n\n```java\npublic class Context {\n\n    // 抽象策略\n    private IStrategy strategy;\n\n    /**\n     * 构造函数设置具体策略\n     * @param strategy\n     */\n    public Context(IStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    /**\n     * 封装后的策略方法\n     */\n    public void doAnything() {\n        this.strategy.doSomething();\n    }\n\n}\n```\n\n最后是客户端的调用策略类：\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        // 声明一个具体的策略\n        IStrategy strategy = new ConcreteStrategy1();\n\n        // 声明上下文对象\n        Context context = new Context(strategy);\n\n        // 执行封装后的方法\n        context.doAnything();\n    }\n\n}\n```\n\n## 五、模式分析\n\n### 总体分析\n\n- 策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“**准备一组算法，并将每一个算法封装起来，使得它们可以互换**”。\n- 在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。\n- 策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。\n\n### 优点\n\n策略模式的优点：\n\n- 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。\n- 策略模式提供了管理相关的算法族的办法。\n- 策略模式提供了可以替换继承关系的办法。\n- 使用策略模式可以避免使用多重条件转移语句。\n\n### 缺点\n\n策略模式的缺点：\n\n- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。\n- 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。\n\n### 适用环境\n\n在以下情况下可以使用策略模式：\n\n- 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n- 一个系统需要动态地在几种算法中选择一种。\n- 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n- 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。\n\n### 模式扩展\n\n策略模式与状态模式：\n\n- 可以通过环境类状态的个数来决定是使用策略模式还是状态模式。\n- 策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。\n- 使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。\n- 如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。\n\n## 六、总结\n\n- 在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。\n- 策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。\n- 策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。\n- 策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。\n- 策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。\n\n  [1]: http://static.blinkfox.com/Strategy1.jpg\n  [2]: http://static.blinkfox.com/strategy2.jpg","tags":["Java","设计模式"],"categories":["软件设计"]},{"title":"微服务-SOA-API的关系","url":"/2017/102949881.html","content":"\n## 一、简单定义\n**微服务架构**是一种构造应用程序的替代性方法。应用程序被分解为更小、完全独立的组件，这使得它们拥有更高的敏捷性、可伸缩性和可用性。  \n**SOA**将应用程序的功能公开为更容易访问的服务接口，使得在下一代应用程序中使用它们的数据和逻辑变得更容易。  \n\nSOA 似乎拥有 企业范围，应用程序在该范围内彼此通信。SOA 通过应用程序之间的标准化接口来公开服务。微服务架构似乎拥有 应用程序范围，仅关注一个应用程序内的结构和组件。\n\n## 微服务：一种替代性架构\n在考虑对比微服务和 SOA 之前，需要理解微服务架构的含义。从基本角度讲，微服务是构建 应用程序的替代性架构。它们提供了更好的方法来解耦应用程序边界 内的组件。事实上，如果将微服务称为 “微型组件”，它们的实际性质会更加明确。  \n尽管应用程序在内部被分解为不同的微服务组件，但从外部来看，应用程序仍是相同的。基于微服务的应用程序公开的 API 的数量和粒度不应与将 API 构建为孤立应用程序有任何不同。微服务中的第一个词 “微型” 表示内部组件的粒度，而不是公开的接口的粒度。\n\n> 从单个庞大的应用程序到微服务\n![](https://www.ibm.com/developerworks/cn/websphere/library/techarticles/1601_clark-trs/images/figure5.jpg)\n\n### 微服务的优势\n完全独立的微服务组件有助于实现完全自主的所有权，带来以下优势：\n\n- 敏捷性和生产力。开发微服务的团队可以完全理解代码库。他们可以在快得多的周期中与其他组件独立地构建、部署和测试代码库。因为微服务组件只是网络上的另一个组件，所以您可以采用最适合所需功能的语言或框架来编写它，并采用最合适的持久性机制。\n这种方法可显著减少要编写的代码量，使维护得到显著简化。它可以确保团队能够根据需要采用新技术或现有技术的新版本，而不是等待应用程序域的剩余部分跟上节奏。对于微服务粒度的定义，微服务组件应足够简单，以便在必要时在其下一次迭代中重写。\n\n- 可伸缩性：微服务开发团队可以在运行时与其他组件独立地扩展微服务组件，实现资源的高效使用和对工作负载变化的快速反应。从理论上讲，一个组件的工作负载可以转移到对任务最合适的基础架构上。它还可以与剩余组件独立地重新放置，以便充分利用网络位置。精心编写的微服务提供了非凡的按需可伸缩性，这一领域的早期创新者和采用者已证明这一点。这些微服务也得到了最佳布置，以便充分利用弹性功能，以富有成本效益的方式访问大量资源的原生云环境。\n- 恢复能力：独立的运行时可以立即提供与其他组件中的故障独立的恢复能力。借助小心地解耦的设计，比如避免同步依赖关系和使用断路器模式，可以编写每个微服务组件来满足自己的可用性需求，而不是在整个应用程序域中引入这些需求。容器等技术和轻量型运行时使微服务组件能够快速且独立地失败，而不是让所有不相关的功能区域都失效。同样地，它们是以一种高度无状态的方式编写的，以便可以立即重新分布工作负载并几乎同时地调出新运行时。  \n\n这些优势的示例是组织转而使用微服务的一些最常见的原因。\n\n## 总结\nSOA 的概念存在于现代架构中，但已通过多种方式发生了演变。集成工具、模式和标准也已发生演变，所以功能和数据更容易公开。服务公开已演变为 API，简化了公开、使用、管理，在某些情况下，还可以从业务功能中牟利。新应用程序架构（包括微服务架构）使得开发人员能够更密切地关注业务逻辑，不断将基础架构细节推送到他们所在的环境。这些开发方式的组合有助于以更敏捷的风格构建解决方案，有助于应用程序获得全新的弹性可伸缩性和容错水平。\n\n## 参考文章\n- [微服务、SOA 和 API：是敌是友？](https://www.ibm.com/developerworks/cn/websphere/library/techarticles/1601_clark-trs/1601_clark.html)\n","tags":["微服务","SOA"],"categories":["软件设计"]},{"title":"微服务系列文章","url":"/2017/102933111.html","content":"\n## 一、微服务架构的优势与不足\n本章介绍了微服务架构模式，讨论了使用微服务的优缺点，以及为什么微服务虽然复杂度高却是复杂应用程序的理想选择。\n\n### 单体架构的地狱\n成功的应用最终会随着时间变得巨大。在每个 sprint 阶段，开发团队都会新加许多行代码。几年后，原本小而简单的应用会变得臃肿。举个极端的例子，我最近与一位开发者交流，他正在开发一款小工具，来分析他们应用（包括几百万行代码）中的几千个 JARs 的依赖。我相信每年都会有大量开发者不遗余力地对付这种麻烦。\n\n一旦你的应用变得庞大、复杂，你的开发团队将饱受折磨，苦苦挣扎于敏捷开发和交付。一大原因就是应用已经格外复杂，庞大到任何一个开发者都无法完全理解。最后，修复 bug 和实施新功能也就极其困难且耗时颇多。更可怕的是，这是一个向下的螺旋发展。代码库越难理解，正确的修改就越难。最后你会深陷庞大的、无法估量的泥淖之中。\n\n而这种应用的尺寸也会拖慢开发进度。应用越大，启动时间越长。譬如在最近的调查中，不少开发者指出启动时间长达 12 分钟。我也听说有的应用启动时间居然得 40 分钟。如果开发者不得不频繁重启应用服务器，那大量时间就被浪费，生产效率也饱受其害。\n\n庞大且复杂的单体应用的另一大问题就是难以进行持续部署。现在， SaaS 应用的发展水平足以在单日内多次将修改推送到生产环境。然而要让复杂的单个应用达到此水平却极为棘手。想更新应用的单个部分，必须重新部署整个应用，漫长的启动时间更是雪上加霜。另外，由于不能完全预见修改的影响，你不得不提前进行大量人工测试。结果就是，持续部署变得不可能。\n\n如果单体应用的不同模块在资源需求方面有冲突的话，那应用的扩展也很难。比如，模块之一需要执行 CPU-intensive 图像处理逻辑，最好部署到 AWS 的 EC2 Compute Optimized instances；而另一模块需要内存数据库，最好适配 EC2 Memory-optimized instances。由于这两个模块需要共同部署，你不得不在在硬件选择方面做妥协。\n\n单体应用的另一问题就是可靠性。由于所有模块都运行在同一进程中，任何模块中的一个 bug，比如内存泄漏都可能弄垮整个进程；此外，由于应用中的所有实例都是唯一，这个 bug 将影响整个应用的可用性。\n\n最后，单体应用会让采用新框架和语言极其困难。举例来说，你有两百万行使用 XYZ 框架的代码，如果要使用 ABC 框架重写代码，无论时间还是成本都将非常高昂，即便新框架更好。这也就成为使用新技术的阻碍。\n\n总结：这个一开始曾经成功关键业务应用，最终却变成一个臃肿的、无法理解的庞然大物。它使用老旧、陈腐、低效的技术，几乎吸引不到出色的开发者。这个应用非常难于扩展，也不稳定可靠。最终，敏捷开发和交付几乎成为不可能。\n\n### 微服务——直击痛点\n诸如亚马逊、eBay、Netflix 等公司已经通过采用微服务架构范式解决了上文（第一部分）提到的问题。不同于构建单一、庞大的应用，微服务架构将应用拆分为一套小且互相关联的服务。\n\n一个微服务一般完成某个特定的功能，比如订单管理、客户管理等。每个微服务都是一个微型应用，有着自己六边形架构，包括商业逻辑和各种接口。有的微服务通过暴露 API 被别的微服务或者应用客户端所用；有的微服务则通过网页 UI 实现。在运行时，每个实例通常是一个云虚拟机或者 Docker 容器。\n\n微服务架构范式对应用和数据库的关系影响巨大。每个服务都有自身的数据库计划，而不与其它服务共享同一个数据库。一方面，这个方法类似企业级数据模型。同时，它也导致部分数据的重复。然而，要想从微服务中获益，为每个服务提供单个的数据库计划就非常必要，这能保证松散耦合。\n\n每个服务都有其自己的数据库。此外，单个服务可以使用符合自己需要的特定类型的数据库，即多语言一致性架构。例如，为了发现附近乘客，驾驶员管理服务必须使用高效支持地理位置请求的数据库。\n\n表面上看，微服务架构范式与 SOA 非常类似，这两种架构都包括一套服务。然而，微服务架构范式被看作不包含某些功能的 SOA 。这些功能包括网络服务说明（ WS-* ）和 Enterprise Service Bus (ESB) 的商品化和请求包。基于微服务的应用更青睐 REST 这样简单的、轻量级的协议，而不是 WS-* 。他们也极力避免在微服务中使用 ESBs 及类似功能。微服务架构范式也拒绝 SOA 的其它部分，比如 canonical schema 的概念。\n\n### 微服务架构的好处\n微服务架构模式有很多好处。首先，通过分解巨大单体应用为多个服务方法解决了复杂性问题。在功能不变的情况下，应用被分解为多个可管理的分支或服务。每个服务都有一个用 RPC- 或者消息驱动 API 定义清楚的边界。微服务架构模式给采用单体式编码方式很难实现的功能提供了模块化的解决方案，由此，单个服务很容易开发、理解和维护。\n\n第二，这种架构使得每个服务都可以有专门开发团队来开发。开发者可以自由选择开发技术，提供 API 服务。当然，许多公司试图避免混乱，只提供某些技术选择。然后，这种自由意味着开发者不需要被迫使用某项目开始时采用的过时技术，他们可以选择现在的技术。甚至于，因为服务都是相对简单，即使用现在技术重写以前代码也不是很困难的事情。\n\n第三，微服务架构模式使得每个微服务独立部署，开发者不再需要协调其它服务部署对本服务的影响。这种改变可以加快部署速度，譬如 UI 团队可以采用 AB 测试并快速部署变化。微服务架构模式使得持续化部署成为可能。\n\n最后，微服务架构模式使得每个服务独立扩展。你可以根据每个服务的规模来部署满足需求的实利。甚至于，你可以使用更适合于服务资源需求的硬件。比如，你可以在 EC2 Compute Optimized instances 上部署 CPU 敏感的服务，而在 EC2 memory-optimized instances 上部署内存数据库。\n\n### 微服务架构的不足\n像任何其它科技一样，微服务架构也有不足。其中一个跟他的名字类似，“微服务”强调了服务大小，实际上，有一些开发者鼓吹建立稍微大一些的，10-100 LOC服务组。尽管小服务更乐于被采用，但是不要忘了微服务只是结果，而不是最终目的。微服务的目的是有效的拆分应用，实现敏捷开发和部署。\n\n另外一个不足之处在于，微服务应用是分布式系统，由此会带来固有的复杂性。开发者需要在 RPC 或者消息传递之间选择并完成进程间通讯机制。此外，他们必须写代码来处理消息传递中速度过慢或者不可用等局部失效问题。当然这并不是什么难事，但相对于单体式应用中通过语言层级的方法或者进程调用，微服务下这种技术显得更复杂一些。\n\n另外一个关于微服务的挑战来自于分区的数据库架构。同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库。使用分布式事务并不一定是好的选择，不仅仅是因为 CAP 理论，还因为当前高扩展性的 NoSQL 数据库和消息传递中间件并不支持这一需求。最终你不得不使用一个最终一致性的方法，从而对开发者提出了更高的要求和挑战。\n\n测试一个基于微服务架构的应用也是很复杂的任务。比如，对于采用流行的 Spring Boot 架构的单体式 web 应用，测试它的 REST API，是很容易的事情。反过来，同样的服务测试需要启动与它有关的所有服务（至少需要这些服务的 stubs）。再重申一次，不能低估了采用微服务架构带来的复杂性。\n\n另外一个挑战在于，微服务架构模式应用的改变将会波及多个服务。比如，假设你在完成一个案例，需要修改服务A、B、C，而 A 依赖 B，B 依赖 C。在单体应用中，你只需要改变相关模块，整合变化，部署就好了。对比之下，微服务架构模式就需要考虑相关改变对不同服务的影响。比如，你需要更新服务 C，然后是 B，最后才是 A。幸运的是，许多改变一般只影响一个服务，而需要协调多服务的改变很少。\n\n部署一个微服务应用也很复杂，一个单体应用只需要在复杂均衡器后面部署各自的服务器就好了。每个应用实例是需要配置诸如数据库和消息中间件等基础服务。相比之下，一个微服务应用一般由大批服务构成。根据 Adrian Cockcroft 的分享，Hailo 由 160 个不同服务构成，而 NetFlix 则超过 600 个服务。每个服务都有多个实例，这就形成大量需要配置、部署、扩展和监控的部分。除此之外，你还需要完成一个服务发现机制（后续文章中发表），以用来发现与它通讯服务的地址（包括服务器地址和端口）。传统的解决问题办法并不能解决这么复杂的问题。最终，成功部署一个微服务应用需要开发者有足够的控制部署方法，并高度自动化。\n\n自动化的方法之一是使用譬如 Cloud Foundry 这样的 PaaS 服务。PaaS 能让开发者轻松部署和管理微服务，让他们无需为获取并配置 IT 资源劳神。同时，配置 PaaS 的系统和网络专家可以采用最佳实践和策略来简化这些问题。另外一个自动部署微服务应用的方法是开发自己的基础 PaaS 系统。通常的起步方式是 Mesos 或 Kubernetes 这样的集群管理方案，配合 Docker 使用。作为一种基于软件的应用交付方法，NGINX 能够方便地在微服务层面提供缓冲、权限控制、API 统计、以及监控。我们会在后续的文章中分析它如何解决这些问题。\n\n### 总结\n构建复杂的应用的确非常困难。单体式的架构更适合轻量级的简单应用。如果你用它来开发复杂应用，那真的会很糟糕。微服务架构模式可以用来构建复杂应用，当然，这种架构模型也有自己的缺点和挑战。\n\n## 二、使用 API 网关构建微服务\n在决定以一组微服务来构建自己的应用时，你需要确定应用客户端如何与微服务交互。\n\n在单体式程序中，通常只有一组冗余的或者负载均衡的服务提供点。在微服务架构中，每一个微服务暴露一组细粒度的服务提供点。在本篇文章中，我们来看它如何影响客户端到服务端通信，并提出一种使用 API 网关的方法。\n\n### 简要概述\n让我们想象一下，你要为一个购物应用程序开发一个原生移动客户端。你很可能需要实现一个产品详情页面，展示任何指定商品的信息。即使只是个智能手机应用，产品详情页面也显示了大量的信息。该页面不仅包含基本的产品信息（如名称、描述、价格），而且还显示了大量其他模块/组件提供的信息。\n\n使用单体应用程序架构时，移动客户端通过向应用程序发起一次 REST 调用（GET api.company.com/productdetails/）来获取这些数据。负载均衡器将请求路由给 N 个相同的应用程序实例中的其中之一。然后，应用程序会查询各种数据库表，并将响应返回给客户端。\n\n相反，若是采用微服务架构，显示在产品页上的数据会分布在不同的微服务上。我们需要决定移动客户端如何访问这些服务。让我们看看有哪些方法。\n\n### 客户端与微服务直接通信\n从理论上讲，客户端可以直接向每个微服务发送请求。每个微服务都有一个公开的端点(https ://.api.company.name）。该 URL 映射到微服务的负载均衡器，由后者负责在可用实例之间分发请求。为了获取产品详情，移动客户端将逐一向上文列出的 N 个服务发送请求。\n\n遗憾的是，这种方法存在挑战和局限。问题之一是客户端需求和每个微服务暴露的细粒度 API 不匹配。在这个例子中，客户端需要发送 7 个独立请求。在更复杂的应用程序中，可能要发送更多的请求；按照 Amazon 的说法，他们在显示他们的产品页面时就调用了数百个服务。然而，客户端通过 LAN 发送许多请求，这在公网上可能会很低效，在移动网络上就根本不可行。这种方法还使得客户端代码非常复杂。\n\n客户端直接调用微服务的另一个问题是，部分服务使用的协议对 web 并不友好。一个服务可能使用 Thrift 二进制 RPC，而另一个服务可能使用 AMQP 消息传递协议。不管哪种协议对于浏览器或防火墙都不够友好，最好是内部使用。在防火墙之外，应用程序应该使用诸如 HTTP 和 WebSocket 之类的协议。\n\n这种方法的另一个缺点是，它会使得微服务难以重构。随着时间推移，我们可能想要更改系统拆分成服务的方式。例如，我们可能合并两个服务，或者将一个服务拆分成两个或更多服务。然而，如果客户端与微服务直接通信，那么执行这类重构就非常困难了。\n\n由于上述三种问题的原因，客户端直接与服务器端通信的方式很少在实际中使用。\n\n### 使用 API 网关构建微服务\n通常来说，使用 API 网关是更好的解决方式。API 网关是一个服务器，也可以说是进入系统的唯一节点。这与面向对象设计模式中的 Facade 模式很像。API 网关封装内部系统的架构，并且提供 API 给各个客户端。它还可能还具备授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等功能。下图展示了一个适应当前架构的 API 网关。\n![](https://user-images.githubusercontent.com/3287183/27023336-b223546e-4f84-11e7-81c4-b882594e8949.png) \n\nAPI 网关负责服务请求路由、组合及协议转换。客户端的所有请求都首先经过 API 网关，然后由它将请求路由到合适的微服务。API 网关经常会通过调用多个微服务并合并结果来处理一个请求。它可以在 web 协议（如 HTTP 与 WebSocket）与内部使用的非 web 友好协议之间转换。\n\nAPI 网关还能为每个客户端提供一个定制的 API。通常，它会向移动客户端暴露一个粗粒度的 API。以产品详情的场景为例，API 网关可以提供一个端点（/productdetails?productid=xxx），使移动客户端可以通过一个请求获取所有的产品详情。API 网关通过调用各个服务（产品信息、推荐、评论等等）并合并结果来处理请求。\n\nNetflix API 网关是一个很好的 API 网关实例。Netflix 流媒体服务提供给成百上千种类型的设备使用，包括电视、机顶盒、智能手机、游戏系统、平板电脑等等。\n\n最初，Netflix 试图为他们的流媒体服务提供一个通用的 API。然而他们发现，由于各种各样的设备都有自己独特的需求，这种方式并不能很好地工作。如今，他们使用一个 API 网关，通过运行与针对特定设备的适配器代码，来为每种设备提供定制的 API。通常，一个适配器通过调用平均 6 到 7 个后端服务来处理每个请求。Netflix API 网关每天处理数十亿请求。\n\n### API 网关的优点和缺点\n如你所料，使用 API 网关有优点也有不足。使用 API 网关的最大优点是，它封装了应用程序的内部结构。客户端只需要同网关交互，而不必调用特定的服务。API 网关为每一类客户端提供了特定的 API，这减少了客户端与应用程序间的交互次数，还简化了客户端代码。\n\nAPI 网关也有一些不足。它增加了一个我们必须开发、部署和维护的高可用组件。还有一个风险是，API 网关变成了开发瓶颈。为了暴露每个微服务的端点，开发人员必须更新 API 网关。API网关的更新过程要尽可能地简单，这很重要；否则，为了更新网关，开发人员将不得不排队等待。不过，虽然有这些不足，但对于大多数现实世界的应用程序而言，使用 API 网关是合理的。\n\n#### 实现 API 网关\n到目前为止，我们已经探讨了使用 API 网关的动力及其优缺点。下面让我们看一下需要考虑的各种设计问题。\n\n### 性能和可扩展性\n只有少数公司拥有 Netflix 这样的规模，需要每天处理每天需要处理数十亿请求。不管怎样，对于大多数应用程序而言，API 网关的性能和可扩展性都非常重要。因此，将 API 网关构建在一个支持异步、I/O 非阻塞的平台上是合理的。有多种不同的技术可以实现一个可扩展的 API 网关。在 JVM 上，可以使用一种基于 NIO 的框架，比如 Netty、Vertx、Spring Reactor 或 JBoss Undertow 中的一种。一个非常流行的非 JVM 选项是 Node.js，它是一个基于 Chrome JavaScript 引擎构建的平台。\n\n另一个方法是使用 NGINX Plus。NGINX Plus 提供了一个成熟的、可扩展的、高性能 web 服务器和一个易于部署的、可配置可编程的反向代理。NGINX Plus 可以管理身份验证、访问控制、负载均衡请求、缓存响应，并提供应用程序可感知的健康检查和监控。\n\n### 使用响应式编程模型\nAPI 网关通过简单地将请求路由给合适的后端服务来处理部分请求，而通过调用多个后端服务并合并结果来处理其它请求。对于部分请求，比如产品详情相关的多个请求，它们对后端服务的请求是独立于其它请求的。为了最小化响应时间，API 网关应该并发执行独立请求。\n\n然而，有时候，请求之间存在依赖。在将请求路由到后端服务之前，API 网关可能首先需要调用身份验证服务验证请求的合法性。类似地，为了获取客户心愿单中的产品信息，API 网关必须首先获取包含这些信息的客户资料，然后再获取每个产品的信息。关于 API 组合，另一个有趣的例子是 Netflix Video Grid。\n\n使用传统的异步回调方法编写 API 组合代码会让你迅速坠入回调地狱。代码会变得混乱、难以理解且容易出错。一个更好的方法是使用响应式方法，以一种声明式样式编写 API 网关代码。响应式抽象概念的例子有 Scala 中的 Future、Java 8 中的 CompletableFuture 和 JavaScript 中的P romise，还有最初微软为 .NET 平台开发的 Reactive Extensions（RX）。Netflix 创建了 RxJava for JVM，专门用于他们的 API 网关。此外，还有 RxJS for JavaScript，它既可以在浏览器中运行，也可以在 Node.js 中运行。使用响应式方法能让你编写简单但高效的 API 网关代码。\n\n### 服务调用\n基于微服务的应用程序是一个分布式系统，必须使用一种进程间通信机制。有两种类型的进程间通信机制可供选择。一种是使用异步的、基于消息传递的机制。有些实现使用诸如 JMS 或 AMQP 那样的消息代理，而其它的实现（如 Zeromq）则没有代理，服务间直接通信。\n\n另一种进程间通信类型是诸如 HTTP 或 Thrift 那样的同步机制。通常，一个系统会同时使用异步和同步两种类型。它甚至还可能使用同一类型的多种实现。总之，API 网关需要支持多种通信机制。\n\n### 服务发现\nAPI 网关需要知道它与之通信的每个微服务的位置（IP 地址和端口）。在传统的应用程序中，或许可以硬连线这个位置，但在现代的、基于云的微服务应用程序中，这并不是一个容易解决的问题。基础设施服务（如消息代理）通常会有一个静态位置，可以通过 OS 环境变量指定。但是，确定一个应用程序服务的位置没有这么简单。应用程序服务的位置是动态分配的，而且，单个服务的一组实例也会随着自动扩展或升级而动态变化。\n\n总之，像系统中的其它服务客户端一样，API 网关需要使用系统的服务发现机制，可以是服务器端发现，也可以是客户端发现。下一篇文章将更详细地描述服务发现。现在，需要注意的是，如果系统使用客户端发现，那么 API 网关必须能够查询服务注册中心，这是一个包含所有微服务实例及其位置的数据库。\n\n### 处理局部失败\n在实现 API 网关时，还需要处理局部失败的问题。该问题出现在所有的分布式系统中。当一个服务调用另一个服务，而后者响应慢或不可用的时候，就会出现这个问题。API 网关不能因为无限期地等待下游服务而阻塞。不过，如何处理失败取决于特定的场景以及哪个服务失败。例如，在产品详情场景下，如果推荐服务无响应，那么 API 网关应该向客户端返回产品详情的其它内容，因为它们对用户依然有用。推荐内容可以为空，也可以用一个固定的 TOP 10 列表取代。不过，如果产品信息服务无响应，那么 API 网关应该向客户端返回一个错误信息。\n\n如果缓存数据可用，那么 API 网关还可以返回缓存数据。例如，鉴于产品价格不会频繁变动，如果价格服务不可用，API 网关可以返回缓存的价格数据。数据可以由 API 网关自己缓存，也可以存储在像 Redis 或 Memcached 之类的外部缓存中。通过返回默认数据或者缓存数据，API 网关可以确保系统故障不影响用户体验。\n\n在编写代码调用远程服务方面，Netflix Hystrix 是一个格外有用的库。Hystrix 会暂停超出特定阈限的调用。它实现了一个“断路器（circuit breaker）”模式，可以防止客户端对无响应的服务进行不必要的等待。如果服务的错误率超出了设定的阈值，那么 Hystrix 会启动断路器，所有请求会立即失败并持续一定时间。Hystrix 允许用户定义一个请求失败后的后援操作，比如从缓存读取数据，或者返回一个默认值。如果你正在使用 JVM，那么你应该考虑使用 Hystrix；如果你正在使用一个非 JVM 环境，那么可以使用一个功能相同的库。\n\n### 总结\n对于大多数基于微服务的应用程序而言，实现 API 网关，将其作为系统的唯一入口很有必要。API 网关负责服务请求路由、组合及协议转换。它为每个应用程序客户端提供一个定制的 API。API 网关还可以通过返回缓存数据或默认数据屏蔽后端服务失败。\n\n## 三、微服务架构中的进程间通信\n在单体应用中，各模块之间的调用是通过编程语言级别的方法或者函数来实现的。而基于微服务的分布式应用是运行在多台机器上的；一般来说，每个服务实例都是一个进程。服务之间的交互必须通过进程间通信（IPC）来实现。\n\n### 交付模式\n当为某个服务选择 IPC 时，首先需要考虑服务之间的交互问题。客户端和服务器之间有很多的交互模式，我们可以从两个维度进行归类。第一个维度是一对一还是一对多：\n\n• 一对一：每个客户端请求有一个服务实例来响应。\n\n• 一对多：每个客户端请求有多个服务实例来响应。\n\n第二个维度是这些交互式是同步还是异步：\n\n• 同步模式：客户端请求需要服务端即时响应，甚至可能由于等待而阻塞。\n\n• 异步模式：客户端请求不会阻塞进程，服务端的响应可以是非即时的。\n\n每个服务都是以上这些模式的组合。对某些服务，一个 IPC 机制就足够了；而对另外一些服务则需要多种 IPC 机制组合。\n\n### 定义 API\nAPI 是服务端和客户端之间的契约。无论选择了何种 IPC 机制，重点是使用某种交互定义语言（IDL）来准确定义服务的 API。对于如何使用 API 优先的方式来定义服务，已经有了一些很好的讨论。你在开发服务之前，要定义服务接口并与客户端开发者共同讨论，后续只需要迭代 API 定义。这样的设计能够大幅提升服务的可用度。\n\nAPI 定义实质上依赖于选定的 IPC 机制。如果使用消息机制，API 则由消息频道（channel）和消息类型构成；如果选择使用 HTTP 机制，API 则由 URL 和请求、响应格式构成。\n\n### 不断进化的 API\n服务的 API 会随着时间而不断变化。在单体应用中，经常会直接修改 API 并更新所有的调用者。但是在基于微服务的应用中，即使所有的 API 的使用者都在同一应用中，这种做法也困难重重，通常不能强制让所有客户端都与服务保持同步更新。此外，你可能会增量部署服务的新版本，这时旧版本会与新版本同时运行。了解这些问题的处理策略至关重要。\n对 API 变化的处理方式与变化的大小有关。有的变化很小，并且可以兼容之前的版本；比如给请求或响应增加属性。在设计客户端和服务时，很有必要遵循健壮性原则。服务更新版本后，使用旧版 API 的客户端应该继续使用。服务为缺失的请求属性提供默认值，客户端则忽略任何额外的响应。使用 IPC 机制和消息格式能够让你轻松改进 API。\n\n然而有时候，API 需要进行大规模改动，并且不兼容旧版本。鉴于不能强制让所有客户端立即升级，支持旧版 API 的服务还要再运行一段时间。如果你使用的是诸如 REST 这样的基于 HTTP 机制的 IPC，一种方法就是将版本号嵌入到 URL 中，每个服务实例可以同时处理多个版本。另一种方法是部署不同实例，每个实例处理一个版本的请求。\n\n### 处理局部失败\n在上一篇关于 API 网关的文章中，我们了解到，分布式系统普遍存在局部失败的问题。由于客户端和服务端是独立的进程，服务端可能无法及时响应客户端请求。服务端可能会因为故障或者维护而暂时不可用。服务端也可能会由于过载，导致对请求的响应极其缓慢。\n\n以上篇文章中提及的产品页为例，假设推荐服务无法响应，客户端可能会由于无限期等待响应而阻塞。这不仅会导致很差的用户体验，并且在很多应用中还会占用之前的资源，比如线程；最终，如下图所示，运行时耗尽线程资源，无法响应。\n\n为了预防这种问题，设计服务时候必须要考虑部分失败的问题。\n\n### IPC 技术\n现在有很多不同的 IPC 技术。服务间通信可以使用同步的请求/响应模式，比如基于 HTTP 的 REST 或者 Thrift。另外，也可以选择异步的、基于消息的通信模式，比如 AMQP 或者 STOMP。此外，还可以选择 JSON 或者 XML 这种可读的、基于文本的消息格式。当然，也还有效率更高的二进制格式，比如 Avro 和 Protocol Buffer。\n\n### 总结\n微服务必须使用进程间通信机制来交互。在设计服务的通信模式时，你需要考虑几个问题：服务如何交互，每个服务如何标识 API，如何升级 API，以及如何处理局部失败。微服务架构异步消息机制和同步请求/响应机制这两类 IPC 机制可用。\n\n## 四、服务发现的可行方案以及实践案例\n为什么要使用服务发现?   \n假设我们写的代码会调用 REST API 或者 Thrift API 的服务。为了完成一次请求，代码需要知道服务实例的网络位置（IP 地址和端口）。运行在物理硬件上的传统应用中，服务实例的网络位置是相对固定的；代码能从一个偶尔更新的配置文件中读取网络位置。\n\n对于基于云端的、现代化的微服务应用而言，这却是一大难题，服务实例的网络位置都是动态分配的。由于扩展、失败和升级，服务实例会经常动态改变，因此，客户端代码需要使用更加复杂的服务发现机制。\n\n服务发现有两大模式：客户端发现模式和服务端发现模式。我们先来了解客客户端发现模式。\n\n### 客户端发现模式\n\n\n## 参考文章\n- [微服务架构概念解析](http://blog.daocloud.io/microservices-1/)\n- [使用 API 网关构建微服务](http://blog.daocloud.io/microservices-2/)\n- [微服务架构中的进程间通信](http://blog.daocloud.io/microservices-3/)\n- [服务发现的可行方案以及实践案例](http://blog.daocloud.io/microservices-4/)\n","tags":["微服务","架构设计"],"categories":["软件设计"]},{"title":"微服务定义-Martin Fowler","url":"/2017/102933933.html","content":"\n*转发自[YYGCui](http://blog.cuicc.com/blog/2015/07/22/microservices)，翻译的Martin Fowler[microservices](http://martinfowler.com/articles/microservices.html)。*\n\n在过去几年中，“微服务架构”这一术语如雨后春笋般涌现出来，它描述了一种将软件应用程序设计为一组可独立部署的服务的特定方式。虽然这种架构风格没有明确的定义，但在组织、业务能力上有一些共同的特征：自动化部署，端点智能化，语言和数据的去中心化控制。\n\n“微服务” - 软件架构拥挤大街上的有一个新术语。虽然我们自然的倾向是轻蔑的一瞥将它一带而过，然而我们发现这一术语描述了一种越来越吸引人的软件系统风格。我们已看到，在过去的几年中有许多项目使用了这种风格，并且到目前为止结果都还不错，以致于这已变成了我们同事在构建企业级应用程序时默认使用的架构风格。然而，遗憾的是并没有太多的信息来概述什么是微服务风格以及怎样用这种风格。\n\n简单来说，微服务架构风格[1]是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。s\n\n与单体风格作对比有助于开始解释微服务风格：单体应用程序被构建为单一单元。企业级应用程序通常由三部分组成：客户端侧用户接口(由运行于开发机上的浏览器里的HTML页面和Javascript组成)，数据库(由插入到通用关系型数据库管理系统中的许多数据表格组成)，服务端应用程序。服务端应用程序处理HTTP请求，执行领域逻辑，从数据库中检索、更新数据，选择、填充将要发送到浏览器的HTTP视图。服务端应用程序是一个单一的逻辑可执行单体[2]。系统的任何改变都将牵涉到重新构建和部署服务端的一个新版本。\n\n这样的单体服务器是构建这样一个系统最自然的方式。处理请求的所有逻辑都运行在一个单一进程中，允许你使用编程语言的基本特性将应用程序划分类、函数和命名空间。你认真的在开发机上运行测试应用程序，并使用部署管道来保证变更已被正确地测试并部署到生产环境中。该单体的水平扩展可以通过在负载均衡器后面运行多个实例来实现。\n\n单体应用程序可以是成功的，但人们日益对他们感到挫败，尤其是随着更多的应用程序被部署在云上。变更周期被捆绑在一起 —— 即使只变更应用程序的一部分，也需要重新构建并部署整个单体。长此以往，通常将很难保持一个良好的模块架构，这使得很难变更只发生在需要变更的模块内。程序扩展要求进行整个应用程序的扩展而不是需要更多资源的应用程序部分的扩展。\n\n![图1: 单体和微服务](http://blog.cuicc.com/images/sketch.png)\n\n这些挫败导向了微服务架构风格：构建应用程序为服务套件。除了服务是可独立部署、可独立扩展的之外，每个服务都提供一个固定的模块边界。甚至允许不同的服务用不同的的语言开发，由不同的团队管理。\n\n我们不会声称微服务风格是新颖的、创新的，其本质至少可以回溯到Unix的设计哲学。但我们的确认为没有足够的人仔细考虑微服务架构，并且如果使用它很多软件实现将会更好。\n\n## 微服务架构的特征\n\n我们无法给出微服务架构风格的一个正式定义，但我们可以尝试去描述我们看到的符合该架构的一些共性。就概述共性的任何定义来说，并非所有的微服务架构风格都有这些共性，但我们期望大多数微服务架构风格展现出大多数特性。虽然本文作者一直是这个相当松散的社区的活跃用户，我们的目的是试图描述我们工作中和我们知道的一些团队的相似努力中的所见所闻。特别是我们不会制定一些可遵守的定义。\n\n### 通过服务组件化\n\n只要我们一直从事软件行业，一个愿望就是通过把组件插在一起构建系统，如同我们看到的现实世界中事物的构造方式一样。在最近的二十年中，我们看到作为大多数语言平台一部分的公共库的大量汇编工作取得了很大的进展。\n\n当谈到组件时，我们遭遇困难的定义：组件是什么。我们的定义是：组件是一个可独立替换和独立升级的软件单元。\n\n微服务架构将使用库，但组件化软件的主要方式是分解成服务。我们把库定义为链接到程序并使用内存函数调用来调用的组件，而服务是一种进程外的组件，它通过web服务请求或rpc(远程过程调用)机制通信(这和很多面向对象程序中的服务对象的概念是不同的[3]。)\n\n使用服务作为组件而不是使用库的一个主要原因是服务是可独立部署的。如果你有一个应用程序[4]是由单一进程里的多个库组成，任何一个组件的更改都导致必须重新部署整个应用程序。但如果应用程序可分解成多个服务，那么单个服务的变更只需要重新部署该服务即可。当然这也不是绝对的，一些变更将会改变服务接口导致一些协作，但一个好的微服务架构的目的是通过内聚服务边界和按合约演进机制来最小化这些协作。\n\n使用服务作为组件的另一个结果是一个更加明确的组件接口。大多数语言没有一个好的机制来定义一个明确的[发布接口](http://martinfowler.com/bliki/PublishedInterface.html)。通常只有文档和规则来预防客户端打破组件的封装，这导致组件间过于紧耦合。服务通过明确的远程调用机制可以很容易的避免这些。\n\n像这样使用服务确实有一些缺点，远程调用比进程内调用更昂贵，因此远程API被设计成粗粒度，这往往更不便于使用。如果你需要更改组件间的责任分配，当你跨进程边界时，这样的行为动作更难达成。\n\n直观的估计，我们观察到服务与运行时进程一一映射，但这仅仅是直观的估计而已。一个服务可能由多进程组成，这些进程总是被一起开发和部署，比如只被这个服务使用的应用进程和数据库。\n\n### 围绕业务能力组织\n\n当想要把大型应用程序拆分成部件时，通常管理层聚焦在技术层面，导致UI团队、服务侧逻辑团队、数据库团队的划分。当团队按这些技术线路划分时，即使是简单的更改也会导致跨团队的时间和预算审批。一个聪明的团队将围绕这些优化，两害取其轻 - 只把业务逻辑强制放在它们会访问的应用程序中。换句话说，逻辑无处不在。这是Conway法则[5]在起作用的一个例子。\n\n> 任何设计系统(广泛定义的)的组织将产生一种设计，他的结构就是该组织的通信结构。\n> -- Melvyn Conway, 1967\n\n![图2: Conway法则在起作用](http://blog.cuicc.com/images/conways-law.png)\n\n\n微服务采用不同的分割方法，划分成围绕业务能力组织的服务。这些服务采取该业务领域软件的宽栈实现，包括用户接口、持久化存储和任何外部协作。因此，团队都是跨职能的，包括开发需要的全方位技能：用户体验、数据库、项目管理。\n\n![图3: 团队边界增强的服务边界](http://blog.cuicc.com/images/PreferFunctionalStaffOrganization.png)\n\n[www.comparethemarket.com](www.comparethemarket.com)是按这种方式组织的一个公司。跨职能团队负责创建和运营产品，产品被划分成若干个体服务，这些服务通过消息总线通信。\n\n大型单体应用程序也总是可以围绕业务能力来模块化，虽然这不是常见的情况。当然，我们将敦促创建单体应用程序的大型团队将团队本身按业务线拆分。我们看到这种情况的主要问题是他们趋向于围绕太多的上下文进行组织。如果单体横跨了多个模块边界，对团队个体成员来说，很难把它们装进他们的短期记忆里。另外，我们看到模块化的路线需要大量的规则来强制实施。服务组件所要求的更加明确的分离，使得它更容易保持团队边界清晰。\n\n>### 侧边栏：微服务有多大？\n>\n>虽然，“微服务”已成为这种架构风格的代称，这个名字确实会导致不幸的聚焦于服务的大小，并为“微”由什么组成争论不休。在与微服务实践者的对话中，我们发现有各种大小的服务。最大的服务报道遵循亚马逊两匹萨团队(也就是，整个团队吃两个披萨就吃饱了)的理念，这意味着团队不超过12个人。在更小的规模大小上，我们看到这样的安排，6人团队将支持6个服务。\n>\n>这导致这样一个问题，在服务每12个人和服务每1个人的大小范围内，是否有足够大的不同使他们不能被集中在同一微服务标签下。目前，我们认为最好把它们组合在一起。但随着深入探索这种风格，我们一定有可能改变我们的看法。\n\n### 是产品不是项目\n\n我们看到大多数应用程序开发工作使用一个项目模式：目标是交付将要完成的一些软件。完成后的软件被交接给维护组织，然后它的构建团队就解散了。\n\n微服务支持者倾向于避免这种模式，而是认为一个团队应该负责产品的整个生命周期。对此一个共同的启示是亚马逊的理念 [\"you build, you run it\"](https://queue.acm.org/detail.cfm?id=1142065) ，开发团队负责软件的整个产品周期。这使开发者经常接触他们的软件在生产环境如何工作，并增加与他们的用户联系，因为他们必须承担至少部分的支持工作。\n\n产品思想与业务能力紧紧联系在一起。要持续关注软件如何帮助用户提升业务能力，而不是把软件看成是将要完成的一组功能。\n\n没有理由说为什么同样的方法不能用在单体应用程序上，但服务的粒度更小，使得它更容易在服务开发者和用户之间建立个人关系。\n\n### 智能端点和哑管道\n\n当在不同进程间创建通信结构时，我们已经看到了很多的产品和方法，把显著的智慧强压进通信机制本身。一个很好的例子就是企业服务总线(ESB)，在ESB产品中通常为消息路由、编排(choreography)、转化和应用业务规则引入先进的设施。\n\n微服务社区主张另一种方法：智能端点和哑管道。基于微服务构建的应用程序的目标是尽可能的解耦和尽可能的内聚 - 他们拥有自己的领域逻辑，他们的行为更像经典UNIX理念中的过滤器 - 接收请求，应用适当的逻辑并产生响应。使用简单的REST风格的协议来编排他们，而不是使用像WS-Choreography或者BPEL或者通过中心工具编制(orchestration)等复杂的协议。\n\n最常用的两种协议是使用资源API的HTTP请求-响应和轻量级消息传送[6]。对第一种协议最好的表述是\n\n{% blockquote -- http://www.amazon.com/gp/product/0596805829?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596805829 Ian Robinson %}\n本身就是web，而不是隐藏在web的后面。\n{% endblockquote %}\n\n微服务团队使用的规则和协议，正是构建万维网的规则和协议(在更大程度上，是UNIX的)。从开发者和运营人员的角度讲，通常使用的资源可以很容易的缓存。\n\n第二种常用方法是在轻量级消息总线上传递消息。选择的基础设施是典型的哑的(哑在这里只充当消息路由器) - 像RabbitMQ或ZeroMQ这样简单的实现仅仅提供一个可靠的异步交换结构 - 在服务里，智能仍旧存活于端点中，生产和消费消息。\n\n单体应用中，组件都在同一进程内执行，它们之间通过方法调用或函数调用通信。把单体变成微服务最大的问题在于通信模式的改变。一种幼稚的转换是从内存方法调用转变成RPC，这导致频繁通信且性能不好。相反，你需要用粗粒度通信代替细粒度通信。\n\n### 分权治理\n\n集中治理的一个后果是单一技术平台的标准化发展趋势。经验表明，这种方法正在收缩 - 不是每个问题都是钉子，也不是每个解决方案都是锤子。我们更喜欢使用正确的工具来完成工作，而单体应用程序在一定程度上可以利用语言的优势，这是不常见的。\n\n把单体的组件分裂成服务，在构建这些服务时可以有自己的选择。你想使用Node.js开发一个简单的报告页面？去吧。用C++实现一个特别粗糙的近乎实时的组件？好极了。你想换用一个更适合组件读操作数据的不同风格的数据库？我们有技术来重建它。\n\n当然，仅仅因为你可以做些什么，而不意味着你应该这样做 - 但用这种方式划分系统意味着你可以选择。\n\n团队在构建微服务时也更喜欢用不同的方法来达标。他们更喜欢生产有用的工具这种想法，而不是写在纸上的标准，这样其他开发者可以用这些工具解决他们所面临的相似的问题。有时，这些工具通常在实施中收获并与更广泛的群体共享，但不完全使用一个内部开源模型。现在git和github已经成为事实上的版本控制系统的选择，在内部开放源代码的实践也正变得越来越常见。\n\n>### 侧边栏：微服务和SOA\n>\n>当我们谈论微服务时，一个常见问题是它是否仅仅是十年前我们看到的面向服务的架构(SOA)。这一点是有可取之处的，因为微服务风格和SOA赞同的某些主张十分相似。然而，问题是SOA意味着[很多不同的东西](http://martinfowler.com/bliki/ServiceOrientedAmbiguity.html)，而大多数时候，我们遇到的所谓的SOA和这里我们描述的风格明显不同，这种不同通常由于SOA专注于用于集成单体应用的ESB。\n>\n>特别是，我们已经看到许多拙劣的面向服务的实现——从倾向于将复杂性隐藏在 ESB [7]中，到花费数百万美元却毫无价值的失败的多年倡议，到积极抑制变化的集中治理模式，有时很难看到过去的这些问题。\n>\n>当然，微服务社区用到的许多技术从开发者在大型组织机构整合服务的经验中成长。[Tolerant Reader](http://martinfowler.com/bliki/TolerantReader.html)模式就是这样的一个例子。使用简单协议是衍生自这些经验的另一个方法，使用网络的努力已做出远离中央标准的反应，坦率地说，中心标准已达到[令人叹为观止](http://wiki.apache.org/ws/WebServiceSpecifications)的复杂性。(任何时候，你需要一个本体来管理你的本体论，你知道你深陷困境。)\n>\n>SOA的这种常见表现使得一些微服务倡导者完全拒绝SOA标签，尽管其他人认为微服务是SOA的一种形式[8]，也许服务导向做得对。无论哪种方式，事实上，SOA意味着如此不同的事情，这意味着有一个术语来更清晰地定义这种架构风格是有价值的。\n\nNetflix是遵守这一理念的很好的例子。尤其是，以库的形式分享有用的且经过市场检验的代码，这激励其他开发者用类似的方式解决相似的问题，同时还为采用不同方法敞开了大门。共享库倾向于聚焦在数据存储、进程间通信和我们接下来要深入讨论的基础设施自动化的共性问题。\n\n对为服务社区来说，开销特别缺乏吸引力。这并不是说社区不重视服务合约。恰恰相反，因为他们有更多的合约。只是他们正在寻找不同的方式来管理这些合约。像[Tolerant Reader](http://martinfowler.com/bliki/TolerantReader.html)和消费者驱动的契约([Consumer-Driven Contracts](http://martinfowler.com/articles/consumerDrivenContracts.html))这样的模式通常被用于微服务。\n这些援助服务合约在独立进化。执行消费者驱动的合约作为构建的一部分，增加了信心并对服务是否在运作提供了更快的反馈。事实上，我们知道澳大利亚的一个团队用消费者驱动的合约这种模式来驱动新业务的构建。他们使用简单的工具定义服务的合约。这已变成自动构建的一部分，即使新服务的代码还没写。服务仅在满足合约的时候才被创建出来 - 这是在构建新软件时避免\"YAGNI\"[9]困境的一个优雅的方法。围绕这些成长起来的技术和工具，通过减少服务间的临时耦合，限制了中心合约管理的需要。\n\n>### 侧边栏：许多语言，许多选项\n>\n>JVM作为平台的成长就是在一个共同平台内混合语言的最新例子。几十年来，破壳到高级语言利用高层次抽象的优势已成为一种普遍的做法。如同下拉到机器硬件，用低层次语言写性能敏感的代码一样。然而，很多单体不需要这个级别的性能优化和常见的更高层次的抽象，也不是DSL的。相反，单体通常是单一语言的并趋向于限制使用的技术的数量[10]。\n\n也许去中心化治理的最高境界就是亚马逊广为流传的build it/run it理念。团队要对他们构建的软件的各方面负责，包括7*24小时的运营。这一级别的责任下放绝对是不规范的，但我们看到越来越多的公司让开发团队负起更多责任。Netflix是采用这一理念的另一家公司[11]。每天凌晨3点被传呼机叫醒无疑是一个强有力的激励，使你在写代码时关注质量。这是关于尽可能远离传统的集中治理模式的一些想法。\n\n### 去中心化数据管理\n\n数据管理的去中心化有许多不同的呈现方式。在最抽象的层面上，这意味着使系统间存在差异的世界概念模型。在整合一个大型企业时，客户的销售视图将不同于支持视图，这是一个常见的问题。客户的销售视图中的一些事情可能不会出现在支持视图中。它们确实可能有不同的属性和(更坏的)共同属性，这些共同属性在语义上有微妙的不同。\n\n这个问题常见于应用程序之间，但也可能发生在应用程序内部，尤其当应用程序被划分成分离的组件时。一个有用的思维方式是有界上下文([Bounded Context](http://martinfowler.com/bliki/BoundedContext.html))内的领域驱动设计(Domain-Driven Design, DDD)理念。DDD把一个复杂域划分成多个有界的上下文，并且映射出它们之间的关系。这个过程对单体架构和微服务架构都是有用的，但在服务和上下文边界间有天然的相关性，边界有助于澄清和加强分离，就像业务能力部分描述的那样。\n\n>### 侧边栏：久经考验的标准和执行标准\n>\n>这有一点分裂，微服务团队倾向于避开企业架构组规定的那种严格的执行标准，但又很乐意使用甚至传教开放标准，比如HTTP、ATOM和其他威格士。\n>\n>关键的区别是如何定制标准和如何执行。由诸如IETF等组织管理的标准仅当在世界范围内有几个有用的实现时才变成标准，这往往会从成功的开源项目成长起来。\n>\n>这些标准是远离企业世界的标准。往往被一个几乎没有近期编程经验的或受供应商过度影响的组织开发的。\n\n和概念模型的去中心化决策一样，微服务也去中心化数据存储决策。虽然单体应用程序更喜欢单一的逻辑数据库做持久化存储，但企业往往倾向于一系列应用程序共用一个单一的数据库 - 这些决定是供应商授权许可的商业模式驱动的。微服务更倾向于让每个服务管理自己的数据库，或者同一数据库技术的不同实例，或完全不同的数据库系统 - 这就是所谓的混合持久化([Polyglot Persistence](http://martinfowler.com/bliki/PolyglotPersistence.html))。你可以在单体应用程序中使用混合持久化，但它更常出现在为服务里。\n\n![](http://blog.cuicc.com/images/decentralised-data.png)\n\n对跨微服务的数据来说，去中心化责任对管理升级有影响。处理更新的常用方法是在更新多个资源时使用事务来保证一致性。这个方法通常用在单体中。\n\n像这样使用事务有助于一致性，但会产生显著地临时耦合，这在横跨多个服务时是有问题的。分布式事务是出了名的难以实现，因此微服务架构强调[服务间的无事务协作](http://www.eaipatterns.com/ramblings/18_starbucks.html)，对一致性可能只是最后一致性和通过补偿操作处理问题有明确的认知。\n\n对很多开发团队来说，选择用这样的方式管理不一致性是一个新的挑战，但这通常与业务实践相匹配。通常业务处理一定程度的不一致，以快速响应需求，同时有某些类型的逆转过程来处理错误。这种权衡是值得的，只要修复错误的代价小于更大一致性下损失业务的代价。\n\n### 基础设施自动化\n\n在过去的几年中，基础设施自动化已经发生了巨大的变化，特别是云和AWS的演化已经降低了构建、部署和运维微服务的操作复杂度。\n\n许多用微服务构建的产品或系统是由在[持续部署](http://martinfowler.com/bliki/ContinuousDelivery.html)和它的前身[持续集成](http://martinfowler.com/articles/continuousIntegration.html)有丰富经验的团队构建的。团队用这种方式构建软件，广泛使用了基础设施自动化。如下面的构建管线图所示：\n\n![图5: 基础构建管道](http://blog.cuicc.com/images/basic-pipeline.png)\n\n因为这不是一篇关于持续交付的文章，我们这里将之光住几个关键特性。我们希望有尽可能多的信心，我们的软件正在工作，所以我们运行大量的**自动化测试**。推广工作软件的流水线意味着我们可以**自动化部署**到每个新环境。\n\n一个单体应用程序可以十分愉快地通过这些环境被构建、测试和推送。事实证明，一旦你为单体投入了自动化生产之路，那么部署更多的应用程序似乎也不会更可怕。请记住，持续部署的目标之一是使部署枯燥，所以无论是一个或三个应用程序，只要它的部署仍然枯燥就没关系[12]。\n\n>### 侧边栏：使它容易做正确的事情\n>\n>我们发现，作为持续交付和持续部署的一个后果，增加自动化的一个副作用是创造有用的工具，以帮助开发人员和运营人员。用于创造人工制品、管理代码库、起立(standing up)简单服务或添加标准监控和日志记录的工具现在都是很常见的。web上最好的例子可能是[Netflix的开源工具集](http://netflix.github.io/)，但也有其他我们广泛使用的工具，如[Dropwizard](http://dropwizard.codahale.com/)。\n\n我们看到团队使用大量的基础设施自动化的另一个领域是在生产环境中管理微服务时。与我们上面的断言(只要部署是枯燥的)相比，单体和微服务没有太大的差别，各运营场景可以明显不同。\n\n![图6: 模块部署常常不同](http://blog.cuicc.com/images/micro-deployment.png)\n\n### 为失败而设计\n\n使用服务作为组件的一个结果是，应用程序需要被设计成能够容忍服务失效。任何服务调用都可能因为供应者不可用而失败，客户端必须尽可能优雅的应对这种失败。与单体应用设计相比这是一个劣势，因为它引入额外的复杂性来处理它。结果是，微服务团队不断反思服务失效如何影响用户体验。Netflix的[Simian Army](https://github.com/Netflix/SimianArmy)在工作日诱导服务甚至是数据中心故障来测试应用程序的弹性和监测。\n\n在生产环境中的这种自动化测试足够给大多数运营团队那种不寒而栗，通常在结束一周的工作之前。这不是说单体风格不能够进行完善的监测设置，只是在我们的经验中比较少见。\n\n>### 侧边栏：断路器和产品就绪代码\n>\n>[断路器(Circuit Breaker)](http://martinfowler.com/bliki/CircuitBreaker.html)与其他模式如Bulkhead和Timeout出现在[《Release it!》](http://www.amazon.com/gp/product/B00A32NXZO?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B00A32NXZO)中。这些模式是被一起实现的，在构建通信应用程序时，它们是至关重要的。[这篇Netflix博文](http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html)很好的解释了使用这些模式的应用程序。\n\n既然服务随时都可能失败，那么能够快速检测故障，如果可能的话，能自动恢复服务是很重要的。微服务应用程序投入大量比重来进行应用程序的实时监测，既检查构形要素(每秒多少次数据请求)，又检查业务相关指标(例如每分钟收到多少订单)。语义监测可以提供一套早期预警系统，触发开发团队跟进和调查。\n\n这对微服务架构特别重要，因为微服务偏好编排和事件协作，这会带来突发行为。虽然很多专家称赞偶然涌现的价值，事实的真相是，突发行为有时可能是一件坏事请。监测对于快速发现不良突发行为是至关重要的，所以它可以被修复。\n\n单体可以被构建成和微服务一样透明 - 事实上，它们应该是透明的。不同的是，你绝对需要知道在不同进程中运行的服务是否断开。对同一进程中的库来说，这种透明性是不大可能有用的。\n\n>### 侧边栏：同步调用被认为是有害的\n>\n>任何时候，在服务间有大量的同步调用，你将遇到停机的乘法效应。简单地说，就是你的系统的停机时间编程各个组件停机时间的乘积。你面临一个选择，让你的调用变成异步或者管理停机时间。在www.guardian.co.uk，他们已在新平台实现了一个简单的规则 - 每个用户请求一个同步调用，而在Netflix，他们的平台API重设计成在API交换结构(fabric)建立异步性。\n\n微服务团队希望看到为每个单独的服务设置的完善的监控和日志记录，比如控制面板上显示启动/关闭状态和各种各样的运营和业务相关指标。断路器状态、当前吞吐量和时延的详细信息是我们经常遇到的其他例子。\n\n### 进化式设计\n\n微服务从业者，通常有进化式设计背景并且把服务分解看做是进一步的工具，使应用程序开发者能够控制他们应用程序中的变更而不减缓变更。变更控制并不一定意味着变更的减少 - 用正确的态度和工具，你可以频繁、快速且控制良好的改变软件。\n\n当你试图把软件系统组件化时，你就面临着如何划分成块的决策 - 我们决定分割我们的应用的原则是什么？组件的关键特性是独立的更换和升级的理念[13] - 这意味着我们要找到这样的点，我们可以想象重写组件而不影响其合作者。事实上很多微服务群组通过明确地预期许多服务将被废弃而不是长期演进来进一步找到这些点。\n\n卫报网站是被设计和构建成单体应用程序的一个好例子，但它已向微服务方向演化。网站的核心仍是单体，但他们喜欢通过使用调用单体API构建的微服务添加新功能。这种方法对添加临时性的特性特别方便，比如处理体育赛事的专题页面。网站的这样一部分可以使用快速开发语言迅速的被放在一起，并且一旦赛事结束立即删除。在金融机构中，我们看到类似的方法，为一个市场机会添加新服务，并在几个月甚至几周后丢弃掉。\n\n强调可替代性是模块设计更一般原则的一个特例，它是通过变更模式来驱动模块化的[14]。您希望将同时更改的内容保存在同一个模块中。系统中很少变更的部分应该和正在经历大量扰动的部分放在不同的服务里。如果你发现你自己不断地一起改变两个服务，这是它们应该被合并的一个标志。\n\n把组件放在服务中，为更细粒度的发布计划增加了一个机会。对单体来说，任何变更都需要完整构建和部署整个应用程序。而对微服务来说，你只需要重新部署你修改的服务。这可以简化和加速发布过程。坏处是，你必须担心一个服务的变化会阻断其消费者。传统的集成方法试图使用版本管理解决这个问题，但是微服务世界的偏好是[只把版本管理作为最后的手段](http://martinfowler.com/articles/enterpriseREST.html#versioning)。我们可以避免大量的版本管理，通过把服务设计成对他们的提供者的变化尽可能的宽容。\n\n## 微服务是未来吗？\n\n我们写这篇文章的主要目的是讲解微服务的主要思想和原则。通过花时间做这件事情，我们清楚地认为微服务架构风格是一个重要的思想 - 它值得为企业应用程序认真考虑。我们最近用这种风格构建了一些系统，也知道别人用这种风格并赞成这种风格。\n\n那些我们知道的以某种方式开拓这种架构风格的包括亚马逊，Netflix，[卫报](http://www.theguardian.com/)，[英国政府数字服务部门](https://gds.blog.gov.uk/)，[realestate.com.au](http://martinfowler.com/articles/realestate.com.au)，前锋和[comparethemarket.com](http://www.comparethemarket.com/)。2013年的会议电路中全是正向微服务类别转移的公司 - 包括Travis CI。此外还有大量的组织长期以来一直在做可归为微服务类别的事情，但是还没有使用这个名字。(这通常被称为SOA - 虽然，正如我们说过的，SOA有许多矛盾的形式。[15])\n\n尽管有这些积极的经验，但是，我们并不认为我们确信微服务是软件架构的未来发展方向。虽然到目前为止，与单体应用程序相比，我们的经验是正面的，但我们意识到这样的事实，并没有经过足够的时间使我们做出充分的判断。\n\n通常，你的架构决策的真正后果是在你做出这些决定的几年后才显现的。我们已经看到对模块化有强烈愿望的一个好团队用单体架构构建的项目，已经衰败了多年。很多人相信微服务是不太可能出现这种衰败的，因为服务界限是明确的，并且很难围绕它打补丁。然而，除非我们看到足够多经过足够岁月的系统，我们不能真正评估微服务架构有多么成熟。\n\n人们当然有理由希望微服务是多么不成熟。在组件化中做任何努力，成功取决于软件在多大程度上适用于组件化。很难弄清楚组件边界在哪里。进化式设计承认获取正确边界的困难性和使它们易于重构的重要性。但当你的组件是带有远程通信的服务时，那么重构它比重构带有进程内库的服务难很多。跨服务边界移动代码是很困难的，任何接口变更都需要在参与者之间进行协调，需要添加向后兼容层，并且测试也变得更加复杂。\n\n>### 侧边栏：《构建微服务》\n>\n>我们的同事Sam Newman花费2014年的大部分时间写了[一本书](http://www.amazon.com/gp/product/1491950358?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=1491950358)，捕捉了我们构建微服务的经验。如果你想深入到这个话题中，这应该是你的下一步。\n\n另一个问题是，如果组件不组成的干净利索，那么所有你做的是将复杂度从组件内部转移到组件之间的连接。不仅仅是把复杂性移到周围，它将复杂性移动到一个不太明确、难以控制的地方。在没有服务间的凌乱连接的情况下，当你在看一个小的、简单的组件内部时，你可以很容易的认为事情是更好的。\n\n最后，有团队技能的因素。更熟练的团队倾向于采用新技术。但是对更熟练的团队更有效的一种技术不一定适合于不太熟练的团队。我们已经看到大量的例子，不太熟练的团队构建了凌乱的单体架构，但这需要时间去看当微服务发生这种凌乱时会发生什么。一个差的团队总是创建一个差的系统 - 很难讲在这个例子中微服务会减少这种凌乱还是使它更糟糕。\n\n我们听到的一个合理的说法是，你不应该从微服务架构开始。相反，从单体开始，使它保持模块化，一旦单体成为问题时把它分解成微服务。(虽然这个建议是不理想的，因为一个好的进程内接口通常不是一个好的服务接口。)\n\n所以我们怀着谨慎乐观的态度写了这篇文章。到目前为止，我们已经看到关于微服务风格足以觉得这是一条值得探索的路。我们不能肯定地说，我们将在哪里结束，但软件开发的挑战之一是，你只能基于目前能拿到手的不完善的信息作出决定。\n\n---\n\n[1]: 2011年5月在威尼斯召开的软件架构研讨会上，“微服务”这一术语被讨论用来描述参与者一直在探索的一种常见的架构风格。2012年5月，该研讨会决定使用“微服务”作为最合适的名字。2012年3月在波兰克拉科夫市举办的33届Degree大会上，James介绍了这些想法作为一个案例研究[微服务 - Java，Unix方式](http://2012.33degree.org/talk/show/67)，Fred George也[差不多在同一时间](http://www.slideshare.net/fredgeorge/micro-service-architecure)提出。Netflix的Adrian Cockcroft把这种方法描述为“细粒度的SOA”，在网域级开拓了这一风格，还有在该文中提到的许多人 - Joe Walnes, Dan North, Evan Botcher 和 Graham Tackley。\n[2]: 单体这一术语已被Unix社区使用了一段时间，在[《Unix编程艺术》](http://www.amazon.com/gp/product/B003U2T5BA?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B003U2T5BA)中用它来描述非常大的系统。\n[3]: 很多面向对象的设计人员，包括我们自己，在[领域驱动设计](http://www.amazon.com/gp/product/0321125215?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321125215)意义上使用服务对象术语，该对象不依赖于实体执行一个重要进程。这和我们在本文中如何使用“服务”是不同的概念。不幸的是，服务这个词有两个含义，我们不得不忍受这个多义词。\n[4]: 我们认为[应用程序是一个社会结构](http://martinfowler.com/bliki/ApplicationBoundary.html)，它由代码基、功能组、资金体组合在一起。\n[5]: 原文可在Melvyn Conway的网站上找到，[在这里](http://www.melconway.com/Home/Committees_Paper.html)。\n[6]: 在极端规模下，组织通常移至二进制协议并权衡规模的透明度。例如[protobufs]()。使用二进制协议的系统仍旧展现出智能端点、哑管道。大多数网站，当然绝大多数企业不需要做这种权衡，透明度可以是一个很大的胜利。\n[7]: 我们忍不住提起Jim Webber的说法，ESB全称是[“令人震惊的意大利面条盒”](http://www.infoq.com/presentations/soa-without-esb)\n[8]: Netflix使这种联系清晰起来 - 直到最近作为细粒度SOA提及他们的架构风格。\n[9]: “YAGNI”也就是“You Aren't Going To Need It(你将不需要它)”是一个[XP原则](http://c2.com/cgi/wiki?YouArentGonnaNeedIt)和劝诫，在你知道你需要它们时才添加特性\n[10]: 我们声称单体是单一语言的，这有一点不诚实 - 要在现在web上构建系统，你可能需要知道JavaScript、XHTML、CSS、选择的服务器语言、SQL和ORM方言。很难只用单一语言，但是你知道我的意思。\n[11]: 在2013年11月的Flowcon大会上提交的[这个出色演讲中](http://www.slideshare.net/adrianco/flowcon-added-to-for-cmg-keynote-talk-on-how-speed-wins-and-how-netflix-is-doing-continuous-delivery)，Adrian Cockcroft特别提到“开发者自助服务”和“开发者运行他们自己写的代码”(原文如此)。\n[12]: 我们这里有一点不诚实。显然在更复杂的拓扑结构中部署更多的服务要比部署单一单体更困难。幸运的是，模式减少了这种复杂性 - 在工具上的投资仍是必须的。\n[13]: 事实上，Dan North提到这种风格是可更换的组件架构而不是微服务。因为这似乎是在讨论我们更喜欢的后者的一个特征子集。\n[14]: Kent Beck强调这是他[《实现模式》](http://www.amazon.com/gp/product/0321413091?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321413091)一书中的设计原则之一。\n[15]: SOA几乎是这段历史的根源。我记得当SOA这一术语出现在本世纪初时，有人说“多年来我们一直这样做”。一个理由是，这种风格看其根源是在企业计算早期COBOL程序通过数据文件通信的方式。在另一个方向，有人可能会说微服务和Erlang编程模型相同，但被应用于企业应用程序上下文。","tags":["微服务","架构设计"],"categories":["软件设计"]},{"title":"Java面向对象设计模式","url":"/2017/102923866.html","content":"\n# 一、概述\n\n设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。\n\n拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。\n\n# 二、创建型\n\n## 1. 单例（Singleton）\n\n### Intent\n\n确保一个类只有一个实例，并提供该实例的全局访问点。\n\n### Class Diagram\n\n使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。\n\n私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eca1f422-8381-409b-ad04-98ef39ae38ba.png\"/> </div><br>\n\n### Implementation\n\n#### Ⅰ 懒汉式-线程不安全\n\n以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。\n\n这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 `if (uniqueInstance == null)` ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 `uniqueInstance = new Singleton();` 语句，这将导致实例化多次 uniqueInstance。\n\n```java\npublic class Singleton {\n\n    private static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public static Singleton getUniqueInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n#### Ⅱ 饿汉式-线程安全\n\n线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。\n\n但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。\n\n```java\nprivate static Singleton uniqueInstance = new Singleton();\n```\n\n#### Ⅲ 懒汉式-线程安全\n\n只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。\n\n但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。\n\n```java\npublic static synchronized Singleton getUniqueInstance() {\n    if (uniqueInstance == null) {\n        uniqueInstance = new Singleton();\n    }\n    return uniqueInstance;\n}\n```\n\n#### Ⅳ 双重校验锁-线程安全\n\nuniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。\n\n双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。\n\n```java\npublic class Singleton {\n\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public static Singleton getUniqueInstance() {\n        if (uniqueInstance == null) {\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 `uniqueInstance = new Singleton();` 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。\n\n```java\nif (uniqueInstance == null) {\n    synchronized (Singleton.class) {\n        uniqueInstance = new Singleton();\n    }\n}\n```\n\nuniqueInstance 采用 volatile 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：\n\n1. 为 uniqueInstance 分配内存空间\n2. 初始化 uniqueInstance\n3. 将 uniqueInstance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1>3>2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T<sub>1</sub> 执行了 1 和 3，此时 T<sub>2</sub> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\n\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\n\n#### Ⅴ 静态内部类实现\n\n当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance()` 方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。\n\n这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。\n\n```java\npublic class Singleton {\n\n    private Singleton() {\n    }\n\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    public static Singleton getUniqueInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n#### Ⅵ 枚举实现\n\n```java\npublic enum Singleton {\n\n    INSTANCE;\n\n    private String objName;\n\n\n    public String getObjName() {\n        return objName;\n    }\n\n\n    public void setObjName(String objName) {\n        this.objName = objName;\n    }\n\n\n    public static void main(String[] args) {\n\n        // 单例测试\n        Singleton firstSingleton = Singleton.INSTANCE;\n        firstSingleton.setObjName(\"firstName\");\n        System.out.println(firstSingleton.getObjName());\n        Singleton secondSingleton = Singleton.INSTANCE;\n        secondSingleton.setObjName(\"secondName\");\n        System.out.println(firstSingleton.getObjName());\n        System.out.println(secondSingleton.getObjName());\n\n        // 反射获取实例测试\n        try {\n            Singleton[] enumConstants = Singleton.class.getEnumConstants();\n            for (Singleton enumConstant : enumConstants) {\n                System.out.println(enumConstant.getObjName());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```html\nfirstName\nsecondName\nsecondName\nsecondName\n```\n\n该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。\n\n该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。\n\n### Examples\n\n- Logger Classes\n- Configuration Classes\n- Accesing resources in shared mode\n- Factories implemented as Singletons\n\n### JDK\n\n- [java.lang.Runtime#getRuntime()](http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29)\n- [java.awt.Desktop#getDesktop()](http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--)\n- [java.lang.System#getSecurityManager()](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--)\n\n## 2. 简单工厂（Simple Factory）\n\n### Intent\n\n在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。\n\n### Class Diagram\n\n简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。\n\n这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic interface Product {\n}\n```\n\n```java\npublic class ConcreteProduct implements Product {\n}\n```\n\n```java\npublic class ConcreteProduct1 implements Product {\n}\n```\n\n```java\npublic class ConcreteProduct2 implements Product {\n}\n```\n\n以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        int type = 1;\n        Product product;\n        if (type == 1) {\n            product = new ConcreteProduct1();\n        } else if (type == 2) {\n            product = new ConcreteProduct2();\n        } else {\n            product = new ConcreteProduct();\n        }\n        // do something with the product\n    }\n}\n```\n\n以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。\n\n```java\npublic class SimpleFactory {\n\n    public Product createProduct(int type) {\n        if (type == 1) {\n            return new ConcreteProduct1();\n        } else if (type == 2) {\n            return new ConcreteProduct2();\n        }\n        return new ConcreteProduct();\n    }\n}\n```\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        SimpleFactory simpleFactory = new SimpleFactory();\n        Product product = simpleFactory.createProduct(1);\n        // do something with the product\n    }\n}\n```\n\n## 3. 工厂方法（Factory Method）\n\n### Intent\n\n定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。\n\n### Class Diagram\n\n在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。\n\n下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic abstract class Factory {\n    abstract public Product factoryMethod();\n    public void doSomething() {\n        Product product = factoryMethod();\n        // do something with the product\n    }\n}\n```\n\n```java\npublic class ConcreteFactory extends Factory {\n    public Product factoryMethod() {\n        return new ConcreteProduct();\n    }\n}\n```\n\n```java\npublic class ConcreteFactory1 extends Factory {\n    public Product factoryMethod() {\n        return new ConcreteProduct1();\n    }\n}\n```\n\n```java\npublic class ConcreteFactory2 extends Factory {\n    public Product factoryMethod() {\n        return new ConcreteProduct2();\n    }\n}\n```\n\n### JDK\n\n- [java.util.Calendar](http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--)\n- [java.util.ResourceBundle](http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-)\n- [java.text.NumberFormat](http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--)\n- [java.nio.charset.Charset](http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-)\n- [java.net.URLStreamHandlerFactory](http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-)\n- [java.util.EnumSet](https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-)\n- [javax.xml.bind.JAXBContext](https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--)\n\n## 4. 抽象工厂（Abstract Factory）\n\n### Intent\n\n提供一个接口，用于创建  **相关的对象家族** 。\n\n### Class Diagram\n\n抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。\n\n抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。\n\n至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。\n\n从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic class AbstractProductA {\n}\n```\n\n```java\npublic class AbstractProductB {\n}\n```\n\n```java\npublic class ProductA1 extends AbstractProductA {\n}\n```\n\n```java\npublic class ProductA2 extends AbstractProductA {\n}\n```\n\n```java\npublic class ProductB1 extends AbstractProductB {\n}\n```\n\n```java\npublic class ProductB2 extends AbstractProductB {\n}\n```\n\n```java\npublic abstract class AbstractFactory {\n    abstract AbstractProductA createProductA();\n    abstract AbstractProductB createProductB();\n}\n```\n\n```java\npublic class ConcreteFactory1 extends AbstractFactory {\n    AbstractProductA createProductA() {\n        return new ProductA1();\n    }\n\n    AbstractProductB createProductB() {\n        return new ProductB1();\n    }\n}\n```\n\n```java\npublic class ConcreteFactory2 extends AbstractFactory {\n    AbstractProductA createProductA() {\n        return new ProductA2();\n    }\n\n    AbstractProductB createProductB() {\n        return new ProductB2();\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        AbstractFactory abstractFactory = new ConcreteFactory1();\n        AbstractProductA productA = abstractFactory.createProductA();\n        AbstractProductB productB = abstractFactory.createProductB();\n        // do something with productA and productB\n    }\n}\n```\n\n### JDK\n\n- [javax.xml.parsers.DocumentBuilderFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html)\n- [javax.xml.transform.TransformerFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--)\n- [javax.xml.xpath.XPathFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--)\n\n## 5. 生成器（Builder）\n\n### Intent\n\n封装一个对象的构造过程，并允许按步骤构造。\n\n### Class Diagram\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5e376d-0b3e-490e-a43a-3231914b6668.png\"/> </div><br>\n\n### Implementation\n\n以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。\n\n```java\npublic class AbstractStringBuilder {\n    protected char[] value;\n\n    protected int count;\n\n    public AbstractStringBuilder(int capacity) {\n        count = 0;\n        value = new char[capacity];\n    }\n\n    public AbstractStringBuilder append(char c) {\n        ensureCapacityInternal(count + 1);\n        value[count++] = c;\n        return this;\n    }\n\n    private void ensureCapacityInternal(int minimumCapacity) {\n        // overflow-conscious code\n        if (minimumCapacity - value.length > 0)\n            expandCapacity(minimumCapacity);\n    }\n\n    void expandCapacity(int minimumCapacity) {\n        int newCapacity = value.length * 2 + 2;\n        if (newCapacity - minimumCapacity < 0)\n            newCapacity = minimumCapacity;\n        if (newCapacity < 0) {\n            if (minimumCapacity < 0) // overflow\n                throw new OutOfMemoryError();\n            newCapacity = Integer.MAX_VALUE;\n        }\n        value = Arrays.copyOf(value, newCapacity);\n    }\n}\n```\n\n```java\npublic class StringBuilder extends AbstractStringBuilder {\n    public StringBuilder() {\n        super(16);\n    }\n\n    @Override\n    public String toString() {\n        // Create a copy, don't share the array\n        return new String(value, 0, count);\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        final int count = 26;\n        for (int i = 0; i < count; i++) {\n            sb.append((char) ('a' + i));\n        }\n        System.out.println(sb.toString());\n    }\n}\n```\n\n```html\nabcdefghijklmnopqrstuvwxyz\n```\n\n### JDK\n\n- [java.lang.StringBuilder](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html)\n- [java.nio.ByteBuffer](http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-)\n- [java.lang.StringBuffer](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-)\n- [java.lang.Appendable](http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html)\n- [Apache Camel builders](https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder)\n\n## 6. 原型模式（Prototype）\n\n### Intent\n\n使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。\n\n### Class Diagram\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b8922f8c-95e6-4187-be85-572a509afb71.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic abstract class Prototype {\n    abstract Prototype myClone();\n}\n```\n\n```java\npublic class ConcretePrototype extends Prototype {\n\n    private String filed;\n\n    public ConcretePrototype(String filed) {\n        this.filed = filed;\n    }\n\n    @Override\n    Prototype myClone() {\n        return new ConcretePrototype(filed);\n    }\n\n    @Override\n    public String toString() {\n        return filed;\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        Prototype prototype = new ConcretePrototype(\"abc\");\n        Prototype clone = prototype.myClone();\n        System.out.println(clone.toString());\n    }\n}\n```\n\n```html\nabc\n```\n\n### JDK\n\n- [java.lang.Object#clone()](http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29)\n\n# 三、行为型\n\n## 1. 责任链（Chain Of Responsibility）\n\n### Intent\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。\n\n### Class Diagram\n\n- Handler：定义处理请求的接口，并且实现后继链（successor）\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ca9f23bf-55a4-47b2-9534-a28e35397988.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic abstract class Handler {\n\n    protected Handler successor;\n\n\n    public Handler(Handler successor) {\n        this.successor = successor;\n    }\n\n\n    protected abstract void handleRequest(Request request);\n}\n```\n\n```java\npublic class ConcreteHandler1 extends Handler {\n\n    public ConcreteHandler1(Handler successor) {\n        super(successor);\n    }\n\n\n    @Override\n    protected void handleRequest(Request request) {\n        if (request.getType() == RequestType.TYPE1) {\n            System.out.println(request.getName() + \" is handle by ConcreteHandler1\");\n            return;\n        }\n        if (successor != null) {\n            successor.handleRequest(request);\n        }\n    }\n}\n```\n\n```java\npublic class ConcreteHandler2 extends Handler {\n\n    public ConcreteHandler2(Handler successor) {\n        super(successor);\n    }\n\n\n    @Override\n    protected void handleRequest(Request request) {\n        if (request.getType() == RequestType.TYPE2) {\n            System.out.println(request.getName() + \" is handle by ConcreteHandler2\");\n            return;\n        }\n        if (successor != null) {\n            successor.handleRequest(request);\n        }\n    }\n}\n```\n\n```java\npublic class Request {\n\n    private RequestType type;\n    private String name;\n\n\n    public Request(RequestType type, String name) {\n        this.type = type;\n        this.name = name;\n    }\n\n\n    public RequestType getType() {\n        return type;\n    }\n\n\n    public String getName() {\n        return name;\n    }\n}\n\n```\n\n```java\npublic enum RequestType {\n    TYPE1, TYPE2\n}\n```\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n\n        Handler handler1 = new ConcreteHandler1(null);\n        Handler handler2 = new ConcreteHandler2(handler1);\n\n        Request request1 = new Request(RequestType.TYPE1, \"request1\");\n        handler2.handleRequest(request1);\n\n        Request request2 = new Request(RequestType.TYPE2, \"request2\");\n        handler2.handleRequest(request2);\n    }\n}\n```\n\n```html\nrequest1 is handle by ConcreteHandler1\nrequest2 is handle by ConcreteHandler2\n```\n\n### JDK\n\n- [java.util.logging.Logger#log()](http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29)\n- [Apache Commons Chain](https://commons.apache.org/proper/commons-chain/index.html)\n- [javax.servlet.Filter#doFilter()](http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-)\n\n## 2. 命令（Command）\n\n### Intent\n\n将命令封装成对象中，具有以下作用：\n\n- 使用命令来参数化其它对象\n- 将命令放入队列中进行排队\n- 将命令的操作记录到日志中\n- 支持可撤销的操作\n\n### Class Diagram\n\n- Command：命令\n- Receiver：命令接收者，也就是命令真正的执行者\n- Invoker：通过它来调用命令\n- Client：可以设置命令与命令的接收者\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c44a0342-f405-4f17-b750-e27cf4aadde2.png\"/> </div><br>\n\n### Implementation\n\n设计一个遥控器，可以控制电灯开关。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e6bded8e-41a0-489a-88a6-638e88ab7666.jpg\"/> </div><br>\n\n```java\npublic interface Command {\n    void execute();\n}\n```\n\n```java\npublic class LightOnCommand implements Command {\n    Light light;\n\n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.on();\n    }\n}\n```\n\n```java\npublic class LightOffCommand implements Command {\n    Light light;\n\n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.off();\n    }\n}\n```\n\n```java\npublic class Light {\n\n    public void on() {\n        System.out.println(\"Light is on!\");\n    }\n\n    public void off() {\n        System.out.println(\"Light is off!\");\n    }\n}\n```\n\n```java\n/**\n * 遥控器\n */\npublic class Invoker {\n    private Command[] onCommands;\n    private Command[] offCommands;\n    private final int slotNum = 7;\n\n    public Invoker() {\n        this.onCommands = new Command[slotNum];\n        this.offCommands = new Command[slotNum];\n    }\n\n    public void setOnCommand(Command command, int slot) {\n        onCommands[slot] = command;\n    }\n\n    public void setOffCommand(Command command, int slot) {\n        offCommands[slot] = command;\n    }\n\n    public void onButtonWasPushed(int slot) {\n        onCommands[slot].execute();\n    }\n\n    public void offButtonWasPushed(int slot) {\n        offCommands[slot].execute();\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        Invoker invoker = new Invoker();\n        Light light = new Light();\n        Command lightOnCommand = new LightOnCommand(light);\n        Command lightOffCommand = new LightOffCommand(light);\n        invoker.setOnCommand(lightOnCommand, 0);\n        invoker.setOffCommand(lightOffCommand, 0);\n        invoker.onButtonWasPushed(0);\n        invoker.offButtonWasPushed(0);\n    }\n}\n```\n\n### JDK\n\n- [java.lang.Runnable](http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html)\n- [Netflix Hystrix](https://github.com/Netflix/Hystrix/wiki)\n- [javax.swing.Action](http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html)\n\n## 3. 解释器（Interpreter）\n\n### Intent\n\n为语言创建解释器，通常由语言的语法和语法分析来定义。\n\n### Class Diagram\n\n- TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。\n- Context：上下文，包含解释器之外的一些全局信息。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b125bcd-1b36-43be-9b78-d90b076be549.png\"/> </div><br>\n\n### Implementation\n\n以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。\n\n例如一颗解析树为 D And (A Or (B C))，文本 \"D A\" 满足该解析树定义的规则。\n\n这里的 Context 指的是 String。\n\n```java\npublic abstract class Expression {\n    public abstract boolean interpret(String str);\n}\n```\n\n```java\npublic class TerminalExpression extends Expression {\n\n    private String literal = null;\n\n    public TerminalExpression(String str) {\n        literal = str;\n    }\n\n    public boolean interpret(String str) {\n        StringTokenizer st = new StringTokenizer(str);\n        while (st.hasMoreTokens()) {\n            String test = st.nextToken();\n            if (test.equals(literal)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n```java\npublic class AndExpression extends Expression {\n\n    private Expression expression1 = null;\n    private Expression expression2 = null;\n\n    public AndExpression(Expression expression1, Expression expression2) {\n        this.expression1 = expression1;\n        this.expression2 = expression2;\n    }\n\n    public boolean interpret(String str) {\n        return expression1.interpret(str) && expression2.interpret(str);\n    }\n}\n```\n\n```java\npublic class OrExpression extends Expression {\n    private Expression expression1 = null;\n    private Expression expression2 = null;\n\n    public OrExpression(Expression expression1, Expression expression2) {\n        this.expression1 = expression1;\n        this.expression2 = expression2;\n    }\n\n    public boolean interpret(String str) {\n        return expression1.interpret(str) || expression2.interpret(str);\n    }\n}\n```\n\n```java\npublic class Client {\n\n    /**\n     * 构建解析树\n     */\n    public static Expression buildInterpreterTree() {\n        // Literal\n        Expression terminal1 = new TerminalExpression(\"A\");\n        Expression terminal2 = new TerminalExpression(\"B\");\n        Expression terminal3 = new TerminalExpression(\"C\");\n        Expression terminal4 = new TerminalExpression(\"D\");\n        // B C\n        Expression alternation1 = new OrExpression(terminal2, terminal3);\n        // A Or (B C)\n        Expression alternation2 = new OrExpression(terminal1, alternation1);\n        // D And (A Or (B C))\n        return new AndExpression(terminal4, alternation2);\n    }\n\n    public static void main(String[] args) {\n        Expression define = buildInterpreterTree();\n        String context1 = \"D A\";\n        String context2 = \"A B\";\n        System.out.println(define.interpret(context1));\n        System.out.println(define.interpret(context2));\n    }\n}\n```\n\n```html\ntrue\nfalse\n```\n\n### JDK\n\n- [java.util.Pattern](http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)\n- [java.text.Normalizer](http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html)\n- All subclasses of [java.text.Format](http://docs.oracle.com/javase/8/docs/api/java/text/Format.html)\n- [javax.el.ELResolver](http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html)\n\n## 4. 迭代器（Iterator）\n\n### Intent\n\n提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。\n\n### Class Diagram\n\n- Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；\n- Iterator 主要定义了 hasNext() 和 next() 方法。\n- Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/89292ae1-5f13-44dc-b508-3f035e80bf89.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic interface Aggregate {\n    Iterator createIterator();\n}\n```\n\n```java\npublic class ConcreteAggregate implements Aggregate {\n\n    private Integer[] items;\n\n    public ConcreteAggregate() {\n        items = new Integer[10];\n        for (int i = 0; i < items.length; i++) {\n            items[i] = i;\n        }\n    }\n\n    @Override\n    public Iterator createIterator() {\n        return new ConcreteIterator<Integer>(items);\n    }\n}\n```\n\n```java\npublic interface Iterator<Item> {\n\n    Item next();\n\n    boolean hasNext();\n}\n```\n\n```java\npublic class ConcreteIterator<Item> implements Iterator {\n\n    private Item[] items;\n    private int position = 0;\n\n    public ConcreteIterator(Item[] items) {\n        this.items = items;\n    }\n\n    @Override\n    public Object next() {\n        return items[position++];\n    }\n\n    @Override\n    public boolean hasNext() {\n        return position < items.length;\n    }\n}\n```\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        Aggregate aggregate = new ConcreteAggregate();\n        Iterator<Integer> iterator = aggregate.createIterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}\n```\n\n### JDK\n\n- [java.util.Iterator](http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html)\n- [java.util.Enumeration](http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html)\n\n## 5. 中介者（Mediator）\n\n### Intent\n\n集中相关对象之间复杂的沟通和控制方式。\n\n### Class Diagram\n\n- Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。\n- Colleague：同事，相关对象\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/30d6e95c-2e3c-4d32-bf4f-68128a70bc05.png\"/> </div><br>\n\n### Implementation\n\nAlarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/82cfda3b-b53b-4c89-9fdb-26dd2db0cd02.jpg\"/> </div><br>\n\n使用中介者模式可以将复杂的依赖结构变成星形结构：\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5359cbf5-5a79-4874-9b17-f23c53c2cb80.jpg\"/> </div><br>\n\n```java\npublic abstract class Colleague {\n    public abstract void onEvent(Mediator mediator);\n}\n```\n\n```java\npublic class Alarm extends Colleague {\n\n    @Override\n    public void onEvent(Mediator mediator) {\n        mediator.doEvent(\"alarm\");\n    }\n\n    public void doAlarm() {\n        System.out.println(\"doAlarm()\");\n    }\n}\n```\n\n```java\npublic class CoffeePot extends Colleague {\n    @Override\n    public void onEvent(Mediator mediator) {\n        mediator.doEvent(\"coffeePot\");\n    }\n\n    public void doCoffeePot() {\n        System.out.println(\"doCoffeePot()\");\n    }\n}\n```\n\n```java\npublic class Calender extends Colleague {\n    @Override\n    public void onEvent(Mediator mediator) {\n        mediator.doEvent(\"calender\");\n    }\n\n    public void doCalender() {\n        System.out.println(\"doCalender()\");\n    }\n}\n```\n\n```java\npublic class Sprinkler extends Colleague {\n    @Override\n    public void onEvent(Mediator mediator) {\n        mediator.doEvent(\"sprinkler\");\n    }\n\n    public void doSprinkler() {\n        System.out.println(\"doSprinkler()\");\n    }\n}\n```\n\n```java\npublic abstract class Mediator {\n    public abstract void doEvent(String eventType);\n}\n```\n\n```java\npublic class ConcreteMediator extends Mediator {\n    private Alarm alarm;\n    private CoffeePot coffeePot;\n    private Calender calender;\n    private Sprinkler sprinkler;\n\n    public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) {\n        this.alarm = alarm;\n        this.coffeePot = coffeePot;\n        this.calender = calender;\n        this.sprinkler = sprinkler;\n    }\n\n    @Override\n    public void doEvent(String eventType) {\n        switch (eventType) {\n            case \"alarm\":\n                doAlarmEvent();\n                break;\n            case \"coffeePot\":\n                doCoffeePotEvent();\n                break;\n            case \"calender\":\n                doCalenderEvent();\n                break;\n            default:\n                doSprinklerEvent();\n        }\n    }\n\n    public void doAlarmEvent() {\n        alarm.doAlarm();\n        coffeePot.doCoffeePot();\n        calender.doCalender();\n        sprinkler.doSprinkler();\n    }\n\n    public void doCoffeePotEvent() {\n        // ...\n    }\n\n    public void doCalenderEvent() {\n        // ...\n    }\n\n    public void doSprinklerEvent() {\n        // ...\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        Alarm alarm = new Alarm();\n        CoffeePot coffeePot = new CoffeePot();\n        Calender calender = new Calender();\n        Sprinkler sprinkler = new Sprinkler();\n        Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler);\n        // 闹钟事件到达，调用中介者就可以操作相关对象\n        alarm.onEvent(mediator);\n    }\n}\n```\n\n```java\ndoAlarm()\ndoCoffeePot()\ndoCalender()\ndoSprinkler()\n```\n\n### JDK\n\n- All scheduleXXX() methods of [java.util.Timer](http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html)\n- [java.util.concurrent.Executor#execute()](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-)\n- submit() and invokeXXX() methods of [java.util.concurrent.ExecutorService](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html)\n- scheduleXXX() methods of [java.util.concurrent.ScheduledExecutorService](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html)\n- [java.lang.reflect.Method#invoke()](http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-)\n\n## 6. 备忘录（Memento）\n\n### Intent\n\n在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。\n\n### Class Diagram\n\n- Originator：原始对象\n- Caretaker：负责保存好备忘录\n- Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50678f34-694f-45a4-91c6-34d985c83fee.png\"/> </div><br>\n\n### Implementation\n\n以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。\n\n实现参考：[Memento Pattern - Calculator Example - Java Sourcecode](https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html)\n\n```java\n/**\n * Originator Interface\n */\npublic interface Calculator {\n\n    // Create Memento\n    PreviousCalculationToCareTaker backupLastCalculation();\n\n    // setMemento\n    void restorePreviousCalculation(PreviousCalculationToCareTaker memento);\n\n    int getCalculationResult();\n\n    void setFirstNumber(int firstNumber);\n\n    void setSecondNumber(int secondNumber);\n}\n```\n\n```java\n/**\n * Originator Implementation\n */\npublic class CalculatorImp implements Calculator {\n\n    private int firstNumber;\n    private int secondNumber;\n\n    @Override\n    public PreviousCalculationToCareTaker backupLastCalculation() {\n        // create a memento object used for restoring two numbers\n        return new PreviousCalculationImp(firstNumber, secondNumber);\n    }\n\n    @Override\n    public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) {\n        this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();\n        this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();\n    }\n\n    @Override\n    public int getCalculationResult() {\n        // result is adding two numbers\n        return firstNumber + secondNumber;\n    }\n\n    @Override\n    public void setFirstNumber(int firstNumber) {\n        this.firstNumber = firstNumber;\n    }\n\n    @Override\n    public void setSecondNumber(int secondNumber) {\n        this.secondNumber = secondNumber;\n    }\n}\n```\n\n```java\n/**\n * Memento Interface to Originator\n *\n * This interface allows the originator to restore its state\n */\npublic interface PreviousCalculationToOriginator {\n    int getFirstNumber();\n    int getSecondNumber();\n}\n```\n\n```java\n/**\n *  Memento interface to CalculatorOperator (Caretaker)\n */\npublic interface PreviousCalculationToCareTaker {\n    // no operations permitted for the caretaker\n}\n```\n\n```java\n/**\n * Memento Object Implementation\n * <p>\n * Note that this object implements both interfaces to Originator and CareTaker\n */\npublic class PreviousCalculationImp implements PreviousCalculationToCareTaker,\n        PreviousCalculationToOriginator {\n\n    private int firstNumber;\n    private int secondNumber;\n\n    public PreviousCalculationImp(int firstNumber, int secondNumber) {\n        this.firstNumber = firstNumber;\n        this.secondNumber = secondNumber;\n    }\n\n    @Override\n    public int getFirstNumber() {\n        return firstNumber;\n    }\n\n    @Override\n    public int getSecondNumber() {\n        return secondNumber;\n    }\n}\n```\n\n```java\n/**\n * CareTaker object\n */\npublic class Client {\n\n    public static void main(String[] args) {\n        // program starts\n        Calculator calculator = new CalculatorImp();\n\n        // assume user enters two numbers\n        calculator.setFirstNumber(10);\n        calculator.setSecondNumber(100);\n\n        // find result\n        System.out.println(calculator.getCalculationResult());\n\n        // Store result of this calculation in case of error\n        PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();\n\n        // user enters a number\n        calculator.setFirstNumber(17);\n\n        // user enters a wrong second number and calculates result\n        calculator.setSecondNumber(-290);\n\n        // calculate result\n        System.out.println(calculator.getCalculationResult());\n\n        // user hits CTRL + Z to undo last operation and see last result\n        calculator.restorePreviousCalculation(memento);\n\n        // result restored\n        System.out.println(calculator.getCalculationResult());\n    }\n}\n```\n\n```html\n110\n-273\n110\n```\n\n### JDK\n\n- java.io.Serializable\n\n## 7. 观察者（Observer）\n\n### Intent\n\n定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。\n\n主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3c6a30-c735-4edb-8115-337288a4f0f2.jpg\" width=\"600\"/> </div><br>\n\n### Class Diagram\n\n主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。\n\n观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a8c8f894-a712-447c-9906-5caef6a016e3.png\"/> </div><br>\n\n### Implementation\n\n天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1df9732-86ce-4d69-9f06-fba1db7b3b5a.jpg\"/> </div><br>\n\n```java\npublic interface Subject {\n    void registerObserver(Observer o);\n\n    void removeObserver(Observer o);\n\n    void notifyObserver();\n}\n```\n\n```java\npublic class WeatherData implements Subject {\n    private List<Observer> observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData() {\n        observers = new ArrayList<>();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        notifyObserver();\n    }\n\n    @Override\n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n\n    @Override\n    public void removeObserver(Observer o) {\n        int i = observers.indexOf(o);\n        if (i >= 0) {\n            observers.remove(i);\n        }\n    }\n\n    @Override\n    public void notifyObserver() {\n        for (Observer o : observers) {\n            o.update(temperature, humidity, pressure);\n        }\n    }\n}\n```\n\n```java\npublic interface Observer {\n    void update(float temp, float humidity, float pressure);\n}\n```\n\n```java\npublic class StatisticsDisplay implements Observer {\n\n    public StatisticsDisplay(Subject weatherData) {\n        weatherData.reisterObserver(this);\n    }\n\n    @Override\n    public void update(float temp, float humidity, float pressure) {\n        System.out.println(\"StatisticsDisplay.update: \" + temp + \" \" + humidity + \" \" + pressure);\n    }\n}\n```\n\n```java\npublic class CurrentConditionsDisplay implements Observer {\n\n    public CurrentConditionsDisplay(Subject weatherData) {\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void update(float temp, float humidity, float pressure) {\n        System.out.println(\"CurrentConditionsDisplay.update: \" + temp + \" \" + humidity + \" \" + pressure);\n    }\n}\n```\n\n```java\npublic class WeatherStation {\n    public static void main(String[] args) {\n        WeatherData weatherData = new WeatherData();\n        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);\n        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n\n        weatherData.setMeasurements(0, 0, 0);\n        weatherData.setMeasurements(1, 1, 1);\n    }\n}\n```\n\n```html\nCurrentConditionsDisplay.update: 0.0 0.0 0.0\nStatisticsDisplay.update: 0.0 0.0 0.0\nCurrentConditionsDisplay.update: 1.0 1.0 1.0\nStatisticsDisplay.update: 1.0 1.0 1.0\n```\n\n### JDK\n\n- [java.util.Observer](http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html)\n- [java.util.EventListener](http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html)\n- [javax.servlet.http.HttpSessionBindingListener](http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html)\n- [RxJava](https://github.com/ReactiveX/RxJava)\n\n## 8. 状态（State）\n\n### Intent\n\n允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。\n\n### Class Diagram\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79df886f-fdc3-4020-a07f-c991bb58e0d8.png\"/> </div><br>\n\n### Implementation\n\n糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/396be981-3f2c-4fd9-8101-dbf9c841504b.jpg\" width=\"600\"/> </div><br>\n\n```java\npublic interface State {\n    /**\n     * 投入 25 分钱\n     */\n    void insertQuarter();\n\n    /**\n     * 退回 25 分钱\n     */\n    void ejectQuarter();\n\n    /**\n     * 转动曲柄\n     */\n    void turnCrank();\n\n    /**\n     * 发放糖果\n     */\n    void dispense();\n}\n```\n\n```java\npublic class HasQuarterState implements State {\n\n    private GumballMachine gumballMachine;\n\n    public HasQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n\n    @Override\n    public void insertQuarter() {\n        System.out.println(\"You can't insert another quarter\");\n    }\n\n    @Override\n    public void ejectQuarter() {\n        System.out.println(\"Quarter returned\");\n        gumballMachine.setState(gumballMachine.getNoQuarterState());\n    }\n\n    @Override\n    public void turnCrank() {\n        System.out.println(\"You turned...\");\n        gumballMachine.setState(gumballMachine.getSoldState());\n    }\n\n    @Override\n    public void dispense() {\n        System.out.println(\"No gumball dispensed\");\n    }\n}\n```\n\n```java\npublic class NoQuarterState implements State {\n\n    GumballMachine gumballMachine;\n\n    public NoQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n\n    @Override\n    public void insertQuarter() {\n        System.out.println(\"You insert a quarter\");\n        gumballMachine.setState(gumballMachine.getHasQuarterState());\n    }\n\n    @Override\n    public void ejectQuarter() {\n        System.out.println(\"You haven't insert a quarter\");\n    }\n\n    @Override\n    public void turnCrank() {\n        System.out.println(\"You turned, but there's no quarter\");\n    }\n\n    @Override\n    public void dispense() {\n        System.out.println(\"You need to pay first\");\n    }\n}\n```\n\n```java\npublic class SoldOutState implements State {\n\n    GumballMachine gumballMachine;\n\n    public SoldOutState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n\n    @Override\n    public void insertQuarter() {\n        System.out.println(\"You can't insert a quarter, the machine is sold out\");\n    }\n\n    @Override\n    public void ejectQuarter() {\n        System.out.println(\"You can't eject, you haven't inserted a quarter yet\");\n    }\n\n    @Override\n    public void turnCrank() {\n        System.out.println(\"You turned, but there are no gumballs\");\n    }\n\n    @Override\n    public void dispense() {\n        System.out.println(\"No gumball dispensed\");\n    }\n}\n```\n\n```java\npublic class SoldState implements State {\n\n    GumballMachine gumballMachine;\n\n    public SoldState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n\n    @Override\n    public void insertQuarter() {\n        System.out.println(\"Please wait, we're already giving you a gumball\");\n    }\n\n    @Override\n    public void ejectQuarter() {\n        System.out.println(\"Sorry, you already turned the crank\");\n    }\n\n    @Override\n    public void turnCrank() {\n        System.out.println(\"Turning twice doesn't get you another gumball!\");\n    }\n\n    @Override\n    public void dispense() {\n        gumballMachine.releaseBall();\n        if (gumballMachine.getCount() > 0) {\n            gumballMachine.setState(gumballMachine.getNoQuarterState());\n        } else {\n            System.out.println(\"Oops, out of gumballs\");\n            gumballMachine.setState(gumballMachine.getSoldOutState());\n        }\n    }\n}\n```\n\n```java\npublic class GumballMachine {\n\n    private State soldOutState;\n    private State noQuarterState;\n    private State hasQuarterState;\n    private State soldState;\n\n    private State state;\n    private int count = 0;\n\n    public GumballMachine(int numberGumballs) {\n        count = numberGumballs;\n        soldOutState = new SoldOutState(this);\n        noQuarterState = new NoQuarterState(this);\n        hasQuarterState = new HasQuarterState(this);\n        soldState = new SoldState(this);\n\n        if (numberGumballs > 0) {\n            state = noQuarterState;\n        } else {\n            state = soldOutState;\n        }\n    }\n\n    public void insertQuarter() {\n        state.insertQuarter();\n    }\n\n    public void ejectQuarter() {\n        state.ejectQuarter();\n    }\n\n    public void turnCrank() {\n        state.turnCrank();\n        state.dispense();\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void releaseBall() {\n        System.out.println(\"A gumball comes rolling out the slot...\");\n        if (count != 0) {\n            count -= 1;\n        }\n    }\n\n    public State getSoldOutState() {\n        return soldOutState;\n    }\n\n    public State getNoQuarterState() {\n        return noQuarterState;\n    }\n\n    public State getHasQuarterState() {\n        return hasQuarterState;\n    }\n\n    public State getSoldState() {\n        return soldState;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n```\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        GumballMachine gumballMachine = new GumballMachine(5);\n\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n\n        gumballMachine.insertQuarter();\n        gumballMachine.ejectQuarter();\n        gumballMachine.turnCrank();\n\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.ejectQuarter();\n\n        gumballMachine.insertQuarter();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n    }\n}\n```\n\n```html\nYou insert a quarter\nYou turned...\nA gumball comes rolling out the slot...\nYou insert a quarter\nQuarter returned\nYou turned, but there's no quarter\nYou need to pay first\nYou insert a quarter\nYou turned...\nA gumball comes rolling out the slot...\nYou insert a quarter\nYou turned...\nA gumball comes rolling out the slot...\nYou haven't insert a quarter\nYou insert a quarter\nYou can't insert another quarter\nYou turned...\nA gumball comes rolling out the slot...\nYou insert a quarter\nYou turned...\nA gumball comes rolling out the slot...\nOops, out of gumballs\nYou can't insert a quarter, the machine is sold out\nYou turned, but there are no gumballs\nNo gumball dispensed\n```\n\n## 9. 策略（Strategy）\n\n### Intent\n\n定义一系列算法，封装每个算法，并使它们可以互换。\n\n策略模式可以让算法独立于使用它的客户端。\n\n### Class Diagram\n\n- Strategy 接口定义了一个算法族，它们都实现了  behavior() 方法。\n- Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png\"/> </div><br>\n\n### 与状态模式的比较\n\n状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。\n\n状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。\n\n### Implementation\n\n设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。\n\n```java\npublic interface QuackBehavior {\n    void quack();\n}\n```\n\n```java\npublic class Quack implements QuackBehavior {\n    @Override\n    public void quack() {\n        System.out.println(\"quack!\");\n    }\n}\n```\n\n```java\npublic class Squeak implements QuackBehavior{\n    @Override\n    public void quack() {\n        System.out.println(\"squeak!\");\n    }\n}\n```\n\n```java\npublic class Duck {\n\n    private QuackBehavior quackBehavior;\n\n    public void performQuack() {\n        if (quackBehavior != null) {\n            quackBehavior.quack();\n        }\n    }\n\n    public void setQuackBehavior(QuackBehavior quackBehavior) {\n        this.quackBehavior = quackBehavior;\n    }\n}\n```\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        Duck duck = new Duck();\n        duck.setQuackBehavior(new Squeak());\n        duck.performQuack();\n        duck.setQuackBehavior(new Quack());\n        duck.performQuack();\n    }\n}\n```\n\n```html\nsqueak!\nquack!\n```\n\n### JDK\n\n- java.util.Comparator#compare()\n- javax.servlet.http.HttpServlet\n- javax.servlet.Filter#doFilter()\n\n## 10. 模板方法（Template Method）\n\n### Intent\n\n定义算法框架，并将一些步骤的实现延迟到子类。\n\n通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。\n\n### Class Diagram\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac6a794b-68c0-486c-902f-8d988eee5766.png\"/> </div><br>\n\n### Implementation\n\n冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11236498-1417-46ce-a1b0-e10054256955.png\"/> </div><br>\n\n```java\npublic abstract class CaffeineBeverage {\n\n    final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        addCondiments();\n    }\n\n    abstract void brew();\n\n    abstract void addCondiments();\n\n    void boilWater() {\n        System.out.println(\"boilWater\");\n    }\n\n    void pourInCup() {\n        System.out.println(\"pourInCup\");\n    }\n}\n```\n\n```java\npublic class Coffee extends CaffeineBeverage {\n    @Override\n    void brew() {\n        System.out.println(\"Coffee.brew\");\n    }\n\n    @Override\n    void addCondiments() {\n        System.out.println(\"Coffee.addCondiments\");\n    }\n}\n```\n\n```java\npublic class Tea extends CaffeineBeverage {\n    @Override\n    void brew() {\n        System.out.println(\"Tea.brew\");\n    }\n\n    @Override\n    void addCondiments() {\n        System.out.println(\"Tea.addCondiments\");\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        CaffeineBeverage caffeineBeverage = new Coffee();\n        caffeineBeverage.prepareRecipe();\n        System.out.println(\"-----------\");\n        caffeineBeverage = new Tea();\n        caffeineBeverage.prepareRecipe();\n    }\n}\n```\n\n```html\nboilWater\nCoffee.brew\npourInCup\nCoffee.addCondiments\n-----------\nboilWater\nTea.brew\npourInCup\nTea.addCondiments\n```\n\n### JDK\n\n- java.util.Collections#sort()\n- java.io.InputStream#skip()\n- java.io.InputStream#read()\n- java.util.AbstractList#indexOf()\n\n## 11. 访问者（Visitor）\n\n### Intent\n\n为一个对象结构（比如组合结构）增加新能力。\n\n### Class Diagram\n\n- Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作\n- ConcreteVisitor：具体访问者，存储遍历过程中的累计结果\n- ObjectStructure：对象结构，可以是组合结构，或者是一个集合。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/79c6f036-bde6-4393-85a3-ef36a0327bd2.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic interface Element {\n    void accept(Visitor visitor);\n}\n```\n\n```java\nclass CustomerGroup {\n\n    private List<Customer> customers = new ArrayList<>();\n\n    void accept(Visitor visitor) {\n        for (Customer customer : customers) {\n            customer.accept(visitor);\n        }\n    }\n\n    void addCustomer(Customer customer) {\n        customers.add(customer);\n    }\n}\n```\n\n```java\npublic class Customer implements Element {\n\n    private String name;\n    private List<Order> orders = new ArrayList<>();\n\n    Customer(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    void addOrder(Order order) {\n        orders.add(order);\n    }\n\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n        for (Order order : orders) {\n            order.accept(visitor);\n        }\n    }\n}\n```\n\n```java\npublic class Order implements Element {\n\n    private String name;\n    private List<Item> items = new ArrayList();\n\n    Order(String name) {\n        this.name = name;\n    }\n\n    Order(String name, String itemName) {\n        this.name = name;\n        this.addItem(new Item(itemName));\n    }\n\n    String getName() {\n        return name;\n    }\n\n    void addItem(Item item) {\n        items.add(item);\n    }\n\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n\n        for (Item item : items) {\n            item.accept(visitor);\n        }\n    }\n}\n```\n\n```java\npublic class Item implements Element {\n\n    private String name;\n\n    Item(String name) {\n        this.name = name;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    public void accept(Visitor visitor) {\n        visitor.visit(this);\n    }\n}\n```\n\n```java\npublic interface Visitor {\n    void visit(Customer customer);\n\n    void visit(Order order);\n\n    void visit(Item item);\n}\n```\n\n```java\npublic class GeneralReport implements Visitor {\n\n    private int customersNo;\n    private int ordersNo;\n    private int itemsNo;\n\n    public void visit(Customer customer) {\n        System.out.println(customer.getName());\n        customersNo++;\n    }\n\n    public void visit(Order order) {\n        System.out.println(order.getName());\n        ordersNo++;\n    }\n\n    public void visit(Item item) {\n        System.out.println(item.getName());\n        itemsNo++;\n    }\n\n    public void displayResults() {\n        System.out.println(\"Number of customers: \" + customersNo);\n        System.out.println(\"Number of orders:    \" + ordersNo);\n        System.out.println(\"Number of items:     \" + itemsNo);\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        Customer customer1 = new Customer(\"customer1\");\n        customer1.addOrder(new Order(\"order1\", \"item1\"));\n        customer1.addOrder(new Order(\"order2\", \"item1\"));\n        customer1.addOrder(new Order(\"order3\", \"item1\"));\n\n        Order order = new Order(\"order_a\");\n        order.addItem(new Item(\"item_a1\"));\n        order.addItem(new Item(\"item_a2\"));\n        order.addItem(new Item(\"item_a3\"));\n        Customer customer2 = new Customer(\"customer2\");\n        customer2.addOrder(order);\n\n        CustomerGroup customers = new CustomerGroup();\n        customers.addCustomer(customer1);\n        customers.addCustomer(customer2);\n\n        GeneralReport visitor = new GeneralReport();\n        customers.accept(visitor);\n        visitor.displayResults();\n    }\n}\n```\n\n```html\ncustomer1\norder1\nitem1\norder2\nitem1\norder3\nitem1\ncustomer2\norder_a\nitem_a1\nitem_a2\nitem_a3\nNumber of customers: 2\nNumber of orders:    4\nNumber of items:     6\n```\n\n### JDK\n\n- javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor\n- javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor\n\n## 12. 空对象（Null）\n\n### Intent\n\n使用什么都不做的空对象来代替 NULL。\n\n一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。\n\n### Class Diagram\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22870bbe-898f-4c17-a31a-d7c5ee5d1c10.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic abstract class AbstractOperation {\n    abstract void request();\n}\n```\n\n```java\npublic class RealOperation extends AbstractOperation {\n    @Override\n    void request() {\n        System.out.println(\"do something\");\n    }\n}\n```\n\n```java\npublic class NullOperation extends AbstractOperation{\n    @Override\n    void request() {\n        // do nothing\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        AbstractOperation abstractOperation = func(-1);\n        abstractOperation.request();\n    }\n\n    public static AbstractOperation func(int para) {\n        if (para < 0) {\n            return new NullOperation();\n        }\n        return new RealOperation();\n    }\n}\n```\n\n# 四、结构型\n\n## 1. 适配器（Adapter）\n\n### Intent\n\n把一个类接口转换成另一个用户需要的接口。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png\"/> </div><br>\n\n### Class Diagram\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ff5152fc-4ff3-44c4-95d6-1061002c364a.png\"/> </div><br>\n\n### Implementation\n\n鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。\n\n要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！\n\n```java\npublic interface Duck {\n    void quack();\n}\n```\n\n```java\npublic interface Turkey {\n    void gobble();\n}\n```\n\n```java\npublic class WildTurkey implements Turkey {\n    @Override\n    public void gobble() {\n        System.out.println(\"gobble!\");\n    }\n}\n```\n\n```java\npublic class TurkeyAdapter implements Duck {\n    Turkey turkey;\n\n    public TurkeyAdapter(Turkey turkey) {\n        this.turkey = turkey;\n    }\n\n    @Override\n    public void quack() {\n        turkey.gobble();\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        Turkey turkey = new WildTurkey();\n        Duck duck = new TurkeyAdapter(turkey);\n        duck.quack();\n    }\n}\n```\n\n### JDK\n\n- [java.util.Arrays#asList()](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29)\n- [java.util.Collections#list()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-)\n- [java.util.Collections#enumeration()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-)\n- [javax.xml.bind.annotation.adapters.XMLAdapter](http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-)\n\n## 2. 桥接（Bridge）\n\n### Intent\n\n将抽象与实现分离开来，使它们可以独立变化。\n\n### Class Diagram\n\n- Abstraction：定义抽象类的接口\n- Implementor：定义实现类接口\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png\"/> </div><br>\n\n### Implementation\n\nRemoteControl 表示遥控器，指代 Abstraction。\n\nTV 表示电视，指代 Implementor。\n\n桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。\n\n```java\npublic abstract class TV {\n    public abstract void on();\n\n    public abstract void off();\n\n    public abstract void tuneChannel();\n}\n```\n\n```java\npublic class Sony extends TV {\n    @Override\n    public void on() {\n        System.out.println(\"Sony.on()\");\n    }\n\n    @Override\n    public void off() {\n        System.out.println(\"Sony.off()\");\n    }\n\n    @Override\n    public void tuneChannel() {\n        System.out.println(\"Sony.tuneChannel()\");\n    }\n}\n```\n\n```java\npublic class RCA extends TV {\n    @Override\n    public void on() {\n        System.out.println(\"RCA.on()\");\n    }\n\n    @Override\n    public void off() {\n        System.out.println(\"RCA.off()\");\n    }\n\n    @Override\n    public void tuneChannel() {\n        System.out.println(\"RCA.tuneChannel()\");\n    }\n}\n```\n\n```java\npublic abstract class RemoteControl {\n    protected TV tv;\n\n    public RemoteControl(TV tv) {\n        this.tv = tv;\n    }\n\n    public abstract void on();\n\n    public abstract void off();\n\n    public abstract void tuneChannel();\n}\n```\n\n```java\npublic class ConcreteRemoteControl1 extends RemoteControl {\n    public ConcreteRemoteControl1(TV tv) {\n        super(tv);\n    }\n\n    @Override\n    public void on() {\n        System.out.println(\"ConcreteRemoteControl1.on()\");\n        tv.on();\n    }\n\n    @Override\n    public void off() {\n        System.out.println(\"ConcreteRemoteControl1.off()\");\n        tv.off();\n    }\n\n    @Override\n    public void tuneChannel() {\n        System.out.println(\"ConcreteRemoteControl1.tuneChannel()\");\n        tv.tuneChannel();\n    }\n}\n```\n\n```java\npublic class ConcreteRemoteControl2 extends RemoteControl {\n    public ConcreteRemoteControl2(TV tv) {\n        super(tv);\n    }\n\n    @Override\n    public void on() {\n        System.out.println(\"ConcreteRemoteControl2.on()\");\n        tv.on();\n    }\n\n    @Override\n    public void off() {\n        System.out.println(\"ConcreteRemoteControl2.off()\");\n        tv.off();\n    }\n\n    @Override\n    public void tuneChannel() {\n        System.out.println(\"ConcreteRemoteControl2.tuneChannel()\");\n        tv.tuneChannel();\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA());\n        remoteControl1.on();\n        remoteControl1.off();\n        remoteControl1.tuneChannel();\n        RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony());\n         remoteControl2.on();\n         remoteControl2.off();\n         remoteControl2.tuneChannel();\n    }\n}\n```\n\n### JDK\n\n- AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)\n- JDBC\n\n## 3. 组合（Composite）\n\n### Intent\n\n将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。\n\n### Class Diagram\n\n组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。\n\n组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic abstract class Component {\n    protected String name;\n\n    public Component(String name) {\n        this.name = name;\n    }\n\n    public void print() {\n        print(0);\n    }\n\n    abstract void print(int level);\n\n    abstract public void add(Component component);\n\n    abstract public void remove(Component component);\n}\n```\n\n```java\npublic class Composite extends Component {\n\n    private List<Component> child;\n\n    public Composite(String name) {\n        super(name);\n        child = new ArrayList<>();\n    }\n\n    @Override\n    void print(int level) {\n        for (int i = 0; i < level; i++) {\n            System.out.print(\"--\");\n        }\n        System.out.println(\"Composite:\" + name);\n        for (Component component : child) {\n            component.print(level + 1);\n        }\n    }\n\n    @Override\n    public void add(Component component) {\n        child.add(component);\n    }\n\n    @Override\n    public void remove(Component component) {\n        child.remove(component);\n    }\n}\n```\n\n```java\npublic class Leaf extends Component {\n    public Leaf(String name) {\n        super(name);\n    }\n\n    @Override\n    void print(int level) {\n        for (int i = 0; i < level; i++) {\n            System.out.print(\"--\");\n        }\n        System.out.println(\"left:\" + name);\n    }\n\n    @Override\n    public void add(Component component) {\n        throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点\n    }\n\n    @Override\n    public void remove(Component component) {\n        throw new UnsupportedOperationException();\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        Composite root = new Composite(\"root\");\n        Component node1 = new Leaf(\"1\");\n        Component node2 = new Composite(\"2\");\n        Component node3 = new Leaf(\"3\");\n        root.add(node1);\n        root.add(node2);\n        root.add(node3);\n        Component node21 = new Leaf(\"21\");\n        Component node22 = new Composite(\"22\");\n        node2.add(node21);\n        node2.add(node22);\n        Component node221 = new Leaf(\"221\");\n        node22.add(node221);\n        root.print();\n    }\n}\n```\n\n```html\nComposite:root\n--left:1\n--Composite:2\n----left:21\n----Composite:22\n------left:221\n--left:3\n```\n\n### JDK\n\n- javax.swing.JComponent#add(Component)\n- java.awt.Container#add(Component)\n- java.util.Map#putAll(Map)\n- java.util.List#addAll(Collection)\n- java.util.Set#addAll(Collection)\n\n## 4. 装饰（Decorator）\n\n### Intent\n\n为对象动态添加功能。\n\n### Class Diagram\n\n装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png\"/> </div><br>\n\n### Implementation\n\n设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。\n\n下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg\" width=\"600\"/> </div><br>\n\n```java\npublic interface Beverage {\n    double cost();\n}\n```\n\n```java\npublic class DarkRoast implements Beverage {\n    @Override\n    public double cost() {\n        return 1;\n    }\n}\n```\n\n```java\npublic class HouseBlend implements Beverage {\n    @Override\n    public double cost() {\n        return 1;\n    }\n}\n```\n\n```java\npublic abstract class CondimentDecorator implements Beverage {\n    protected Beverage beverage;\n}\n```\n\n```java\npublic class Milk extends CondimentDecorator {\n\n    public Milk(Beverage beverage) {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public double cost() {\n        return 1 + beverage.cost();\n    }\n}\n```\n\n```java\npublic class Mocha extends CondimentDecorator {\n\n    public Mocha(Beverage beverage) {\n        this.beverage = beverage;\n    }\n\n    @Override\n    public double cost() {\n        return 1 + beverage.cost();\n    }\n}\n```\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        Beverage beverage = new HouseBlend();\n        beverage = new Mocha(beverage);\n        beverage = new Milk(beverage);\n        System.out.println(beverage.cost());\n    }\n}\n```\n\n```html\n3.0\n```\n\n### 设计原则\n\n类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。\n\n不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。\n\n### JDK\n\n- java.io.BufferedInputStream(InputStream)\n- java.io.DataInputStream(InputStream)\n- java.io.BufferedOutputStream(OutputStream)\n- java.util.zip.ZipOutputStream(OutputStream)\n- java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()\n\n## 5. 外观（Facade）\n\n### Intent\n\n提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。\n\n### Class Diagram\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9978fa6-9f49-4a0f-8540-02d269ac448f.png\"/> </div><br>\n\n### Implementation\n\n观看电影需要操作很多电器，使用外观模式实现一键看电影功能。\n\n```java\npublic class SubSystem {\n    public void turnOnTV() {\n        System.out.println(\"turnOnTV()\");\n    }\n\n    public void setCD(String cd) {\n        System.out.println(\"setCD( \" + cd + \" )\");\n    }\n\n    public void startWatching(){\n        System.out.println(\"startWatching()\");\n    }\n}\n```\n\n```java\npublic class Facade {\n    private SubSystem subSystem = new SubSystem();\n\n    public void watchMovie() {\n        subSystem.turnOnTV();\n        subSystem.setCD(\"a movie\");\n        subSystem.startWatching();\n    }\n}\n```\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        Facade facade = new Facade();\n        facade.watchMovie();\n    }\n}\n```\n\n### 设计原则\n\n最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。\n\n## 6. 享元（Flyweight）\n\n### Intent\n\n利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。\n\n### Class Diagram\n\n- Flyweight：享元对象\n- IntrinsicState：内部状态，享元对象共享内部状态\n- ExtrinsicState：外部状态，每个享元对象的外部状态不同\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5c22d5-9c0e-49e1-b5b0-6cc7032724d4.png\"/> </div><br>\n\n### Implementation\n\n```java\npublic interface Flyweight {\n    void doOperation(String extrinsicState);\n}\n```\n\n```java\npublic class ConcreteFlyweight implements Flyweight {\n\n    private String intrinsicState;\n\n    public ConcreteFlyweight(String intrinsicState) {\n        this.intrinsicState = intrinsicState;\n    }\n\n    @Override\n    public void doOperation(String extrinsicState) {\n        System.out.println(\"Object address: \" + System.identityHashCode(this));\n        System.out.println(\"IntrinsicState: \" + intrinsicState);\n        System.out.println(\"ExtrinsicState: \" + extrinsicState);\n    }\n}\n```\n\n```java\npublic class FlyweightFactory {\n\n    private HashMap<String, Flyweight> flyweights = new HashMap<>();\n\n    Flyweight getFlyweight(String intrinsicState) {\n        if (!flyweights.containsKey(intrinsicState)) {\n            Flyweight flyweight = new ConcreteFlyweight(intrinsicState);\n            flyweights.put(intrinsicState, flyweight);\n        }\n        return flyweights.get(intrinsicState);\n    }\n}\n```\n\n```java\npublic class Client {\n\n    public static void main(String[] args) {\n        FlyweightFactory factory = new FlyweightFactory();\n        Flyweight flyweight1 = factory.getFlyweight(\"aa\");\n        Flyweight flyweight2 = factory.getFlyweight(\"aa\");\n        flyweight1.doOperation(\"x\");\n        flyweight2.doOperation(\"y\");\n    }\n}\n```\n\n```html\nObject address: 1163157884\nIntrinsicState: aa\nExtrinsicState: x\nObject address: 1163157884\nIntrinsicState: aa\nExtrinsicState: y\n```\n\n### JDK\n\nJava 利用缓存来加速大量小对象的访问时间。\n\n- java.lang.Integer#valueOf(int)\n- java.lang.Boolean#valueOf(boolean)\n- java.lang.Byte#valueOf(byte)\n- java.lang.Character#valueOf(char)\n\n## 7. 代理（Proxy）\n\n### Intent\n\n控制对其它对象的访问。\n\n### Class Diagram\n\n代理有以下四类：\n\n- 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。\n- 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。\n- 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。\n- 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。\n\n<div align=\"center\"> <img src=\"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png\"/> </div><br>\n\n### Implementation\n\n以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。\n\n```java\npublic interface Image {\n    void showImage();\n}\n```\n\n```java\npublic class HighResolutionImage implements Image {\n\n    private URL imageURL;\n    private long startTime;\n    private int height;\n    private int width;\n\n    public int getHeight() {\n        return height;\n    }\n\n    public int getWidth() {\n        return width;\n    }\n\n    public HighResolutionImage(URL imageURL) {\n        this.imageURL = imageURL;\n        this.startTime = System.currentTimeMillis();\n        this.width = 600;\n        this.height = 600;\n    }\n\n    public boolean isLoad() {\n        // 模拟图片加载，延迟 3s 加载完成\n        long endTime = System.currentTimeMillis();\n        return endTime - startTime > 3000;\n    }\n\n    @Override\n    public void showImage() {\n        System.out.println(\"Real Image: \" + imageURL);\n    }\n}\n```\n\n```java\npublic class ImageProxy implements Image {\n\n    private HighResolutionImage highResolutionImage;\n\n    public ImageProxy(HighResolutionImage highResolutionImage) {\n        this.highResolutionImage = highResolutionImage;\n    }\n\n    @Override\n    public void showImage() {\n        while (!highResolutionImage.isLoad()) {\n            try {\n                System.out.println(\"Temp Image: \" + highResolutionImage.getWidth() + \" \" + highResolutionImage.getHeight());\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        highResolutionImage.showImage();\n    }\n}\n```\n\n```java\npublic class ImageViewer {\n\n    public static void main(String[] args) throws Exception {\n        String image = \"http://image.jpg\";\n        URL url = new URL(image);\n        HighResolutionImage highResolutionImage = new HighResolutionImage(url);\n        ImageProxy imageProxy = new ImageProxy(highResolutionImage);\n        imageProxy.showImage();\n    }\n}\n```\n\n### JDK\n\n- java.lang.reflect.Proxy\n- RMI\n\n# 参考资料\n\n- 弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.\n- Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.\n- Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.\n- [Design Patterns](http://www.oodesign.com/)\n- [Design patterns implemented in Java](http://java-design-patterns.com/)\n- [The breakdown of design patterns in JDK](http://www.programering.com/a/MTNxAzMwATY.html)\n\n","tags":["Java","设计模式"],"categories":["软件设计"]}]