<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="keywords" content="Docker必知必会（翻译自官方文档），Docker概述、架构、数据持久化、使用nexus3搭建私有仓库，Docker常用命令，Docker Compose使用介绍，Dockerfile最佳实践">
    <meta name="description" content="Docker必知必会。本文包括Docker概述、架构、数据持久化、使用nexus3搭建私有仓库，Docker常用命令，Docker Compose使用介绍，Dockerfile最佳实践等内容。">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Docker必知必会（翻译自官方文档） | 悟尘纪</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="悟尘纪" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags/" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives/" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>时间轴</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/docs/" class="waves-effect waves-light">

      
      <i class="fas fa-atlas" style="zoom: 0.6;"></i>
      
      <span>书籍列表</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/docs/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3.html">
          
          <i class="fab fa-docker" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Docker必知必会</span>
        </a>
      </li>
      
      <li>
        <a href="/docs/Fabric%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%9E%E6%88%98/0%E3%80%81%E6%91%98%E8%A6%81.html">
          
          <i class="fas fa-chess-board" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Fabric从入门到企业级实践</span>
        </a>
      </li>
      
      <li>
        <a href="/docs/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html">
          
          <i class="fas fa-plane-departure" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Java面向对象设计模式</span>
        </a>
      </li>
      
      <li>
        <a href="/docs/NodeJS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/Node.js%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html">
          
          <i class="fab fa-node-js" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>NodeJS从入门到实战</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about/" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends/" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">悟尘纪</div>
        <div class="logo-desc">
            
            人生就是一场修行，上善若水，厚德载物。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			时间轴
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-atlas"></i>
			
			书籍列表
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="/docs/Docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3.html " style="margin-left:75px";>
				  
				   <i class="fa fab fa-docker" style="position: absolute;left:50px" ></i>
			      
		          <span>Docker必知必会</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/docs/Fabric%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%9E%E6%88%98/0%E3%80%81%E6%91%98%E8%A6%81.html " style="margin-left:75px";>
				  
				   <i class="fa fas fa-chess-board" style="position: absolute;left:50px" ></i>
			      
		          <span>Fabric从入门到企业级实践</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/docs/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html " style="margin-left:75px";>
				  
				   <i class="fa fas fa-plane-departure" style="position: absolute;left:50px" ></i>
			      
		          <span>Java面向对象设计模式</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/docs/NodeJS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/Node.js%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html " style="margin-left:75px";>
				  
				   <i class="fa fab fa-node-js" style="position: absolute;left:50px" ></i>
			      
		          <span>NodeJS从入门到实战</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('本文尚未公开，需输入密码才能访问。')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Docker必知必会（翻译自官方文档）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Docker/">
                                <span class="chip bg-color">Docker</span>
                            </a>
                        
                            <a href="/tags/DevOps/">
                                <span class="chip bg-color">DevOps</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%B7%A5%E5%85%B7/" class="post-category">
                                工具
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-03-25
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    36 分
                </div>
                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、Docker-概述"><a href="#一、Docker-概述" class="headerlink" title="一、Docker 概述"></a>一、Docker 概述</h2><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的快速交付，测试和部署代码的方法，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
<p>容器化越来越受欢迎，是因为容器：</p>
<ul>
<li><strong>灵活</strong>：即使最复杂的应用程序也可以容器化。</li>
<li><strong>轻量级</strong>：容器利用并共享主机内核，在系统资源方面比虚拟机更加有效。</li>
<li><strong>可移植性</strong>：您可以在本地构建，部署到云并在任何地方运行。</li>
<li><strong>松散耦合</strong>：容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们。</li>
<li><strong>可扩展</strong>：您可以在数据中心内增加并自动分发容器副本。</li>
<li><strong>安全</strong>：容器将积极的约束和隔离应用于流程，而无需用户方面的任何配置。</li>
</ul>
<h3 id="Docker-平台"><a href="#Docker-平台" class="headerlink" title="Docker 平台"></a>Docker 平台</h3><p>Docker 提供了在松散隔离的环境（称为容器）中打包和运行应用程序的功能。隔离和安全性使您可以在给定主机上同时运行多个容器。容器是轻量级的，因为它们不需要管理程序的额外负担，而是直接在主机的内核中运行。这意味着与使用虚拟机相比，您可以在给定的硬件组合上运行更多的容器。您甚至可以在实际上是虚拟机的主机中运行 Docker 容器！</p>
<p>Docker 提供了工具和平台来管理容器的生命周期：</p>
<ul>
<li>使用容器开发应用程序及其支持组件。</li>
<li>容器成为分发和测试应用程序的单元。</li>
<li>准备就绪后，可以将应用程序作为容器或协调服务部署到生产环境中。无论您的生产环境是本地数据中心，云提供商还是两者的混合，其工作原理都相同。</li>
</ul>
<h3 id="我可以将-Docker-用于什么"><a href="#我可以将-Docker-用于什么" class="headerlink" title="我可以将 Docker 用于什么"></a>我可以将 Docker 用于什么</h3><p><strong>1、快速，一致地交付您的应用程序</strong></p>
<p>Docker 通过允许开发人员使用提供您的应用程序和服务的本地容器在标准化环境中工作，从而简化了开发生命周期。容器非常适合持续集成和持续交付（CI / CD）工作流程。</p>
<p><strong>2、响应式部署和扩展</strong></p>
<p>Docker 基于容器的平台允许高度可移植的工作负载。Docker 容器可以在开发人员的本地笔记本电脑上，数据中心中的物理或虚拟机上，云提供商上或混合环境中运行。</p>
<p>Docker 的可移植性和轻量级的特性还使您可以轻松地动态管理工作负载，并根据业务需求指示实时扩展或关闭应用程序和服务。</p>
<p><strong>3、在同一硬件上运行更多工作负载</strong></p>
<p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行且经济高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合高密度环境和中小型部署，而您需要用更少的资源做更多的事情。</p>
<h2 id="二、Docker-架构"><a href="#二、Docker-架构" class="headerlink" title="二、Docker 架构"></a>二、Docker 架构</h2><p>Docker 使用客户端-服务器架构。Docker <em>客户端</em> 与 Docker <em>守护进程</em> 进行对话，该<em>守护进程</em> 完成了构建、运行和分发 Docker 容器的繁重工作。Docker 客户端和守护程序可以在同一系统上运行，或者您可以将 Docker 客户端连接到远程 Docker 守护程序。Docker 客户端和守护程序在 UNIX 套接字或网络接口上使用 REST API 进行通信。</p>
<p><img src="https://pic.lixl.cn/2020/image-20200325194141346.png" alt="Docker架构图"></p>
<h3 id="Docker-守护进程"><a href="#Docker-守护进程" class="headerlink" title="Docker 守护进程"></a>Docker 守护进程</h3><p>Docker 守护程序（<code>dockerd</code>）侦听 Docker API 请求并管理 Docker 对象，例如 images（镜像），containers（容器），networks（网络）和 volume（卷）。守护程序还可以与其他守护程序通信以管理 Docker 服务。</p>
<h3 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h3><p>Docker 客户端（<code>docker</code>）是许多 Docker 用户与 Docker 交互的主要方式。当您使用诸如<code>docker run</code> 之类的命令时，客户端会将这些命令发送到 <code>dockerd</code>，以执行这些命令。该<code>docker</code>命令使用 Docker API。Docker 客户端可以与多个守护程序通信。</p>
<h3 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h3><p>Docker 仓库存储 Docker 镜像。Docker Hub 是任何人都可以使用的公共仓库，并且 Docker 配置为默认在 Docker Hub 上查找映像。您甚至可以运行自己的私人仓库。如果使用 Docker 数据中心（DDC），则其中包括 Docker 可信仓库（DTR）。</p>
<p>使用<code>docker pull</code>或<code>docker run</code>命令时，所需的镜像将从配置的仓库中提取。使用该<code>docker push</code>命令时，会将映像推送到配置的仓库。</p>
<h3 id="Docker-对象"><a href="#Docker-对象" class="headerlink" title="Docker 对象"></a>Docker 对象</h3><p>使用 Docker 时，您正在创建和使用镜像，容器，网络，卷，插件和其他对象。本节是其中一些对象的简要概述。</p>
<h4 id="Images（镜像）"><a href="#Images（镜像）" class="headerlink" title="Images（镜像）"></a>Images（镜像）</h4><p>镜像是一个只读模板（不包含任何动态数据，其内容在构建之后也不会被改变 ），其中包含创建 Docker 容器的说明。通常，一个镜像基于另一个镜像，并带有一些额外的定制。 例如，你可以建立一个基于 ubuntu 镜像的镜像，安装 ubuntu Apache HTTP Server 和你的应用程序，以及运行你的应用程序所需的配置细节。</p>
<p>您可以创建自己的镜像，也可以仅使用其他人创建并在仓库中发布的镜像。要构建自己的镜像，您可以 使用简单的语法创建一个 <code>Dockerfile</code>，以定义创建镜像并运行它所需的步骤。<code>Dockerfile</code> 中的每条指令都会在镜像中创建一个层。更改 <code>Dockerfile</code> 并重建镜像时，仅重建那些已更改的层。与其他虚拟化技术相比，这是使镜像如此轻巧，小型和快速的部分原因。</p>
<h4 id="Containers-（容器）"><a href="#Containers-（容器）" class="headerlink" title="Containers （容器）"></a>Containers （容器）</h4><p>容器是镜像的可运行实例。您可以使用 Docker API 或 CLI 创建，启动，停止，移动或删除容器。您可以将容器连接到一个或多个网络，将存储附加到该网络，甚至根据其当前状态创建新映像。</p>
<p>默认情况下，容器与其他容器及其主机之间的隔离程度相对较高。您可以控制容器的网络，存储或其他基础子系统与其他容器或与主机的隔离程度。</p>
<p>容器由其映像以及在创建或启动时为其提供的任何配置选项定义。删除容器后，未存储在持久性存储中的状态更改将消失。</p>
<blockquote>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 Volume（数据卷）、或者挂载宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
</blockquote>
<h4 id="Service-（服务）"><a href="#Service-（服务）" class="headerlink" title="Service （服务）"></a>Service （服务）</h4><p>服务允许跨多个 Docker 守护进程调度容器，这些守护进程以多个管理者和工作者的群体形式协同工作。集群的每个成员都是一个 Docker 守护进程，并且所有守护进程都使用 Docker API 进行通信。服务允许您定义所需的状态，例如在任何给定时间必须可用的服务副本数。默认情况下，该服务在所有工作节点之间实现负载平衡。对于使用者而言，Docker 服务似乎是一个单独的应用程序。Docker Engine 在 Docker 1.12 及更高版本中支持集群模式。</p>
<h2 id="三、Docker-安装"><a href="#三、Docker-安装" class="headerlink" title="三、Docker 安装"></a>三、Docker 安装</h2><h3 id="1、获取-Docker"><a href="#1、获取-Docker" class="headerlink" title="1、获取 Docker"></a>1、获取 Docker</h3><p>Docker 分为 CE 和 EE 两大版本。Docker CE 分为 <code>stable</code>、 <code>test</code> 和 <code>nightly</code> 三个更新频道。官方网站上有各种环境下的 <a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">安装指南</a>，可以根据自己的情况进行安装。</p>
<h3 id="2、镜像加速"><a href="#2、镜像加速" class="headerlink" title="2、镜像加速"></a>2、镜像加速</h3><p>一般国内在使用过程中拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。各个镜像站测试结果请到 <a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions" target="_blank" rel="noopener">docker-practice/docker-registry-cn-mirror-test</a> 查看。</p>
<p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧参考如下内容编辑 json 文件：</p>
<pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://dockerhub.azk8s.cn"</span><span class="token punctuation">,</span> <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像。执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<pre class="line-numbers language-bash"><code class="language-bash">Registry Mirrors:
 https://dockerhub.azk8s.cn/
 https://hub-mirror.c.163.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="3、小试牛刀"><a href="#3、小试牛刀" class="headerlink" title="3、小试牛刀"></a>3、小试牛刀</h3><p>以下命令运行一个<code>ubuntu</code>容器，以交互方式附加到本地命令行会话，然后运行<code>/bin/bash</code>。</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run -i -t ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当您运行此命令时，会发生以下情况（假设您使用的是默认仓库配置）：</p>
<ol>
<li>如果您在<code>ubuntu</code>本地没有该映像，则 Docker 会将其从已配置的仓库中拉出，就像您已<code>docker pull ubuntu</code>手动运行一样。</li>
<li>Docker 会创建一个新容器，就像您已<code>docker container create</code> 手动运行命令一样。</li>
<li>Docker 将一个读写文件系统分配给容器，作为其最后一层。这允许运行中的容器在其本地文件系统中创建或修改文件和目录。</li>
<li>Docker 创建了一个网络接口以将容器连接到默认网络，因为您未指定任何网络选项。这包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。</li>
<li>Docker 启动容器并执行<code>/bin/bash</code>。因为容器是交互式运行的，并且已附加到您的终端（由于<code>-i</code>和<code>-t</code> 标志），所以您可以在输出记录到终端时使用键盘提供输入。</li>
<li>当您键入<code>exit</code>以终止<code>/bin/bash</code>命令时，容器将停止但不会被删除。您可以重新启动或删除它。</li>
</ol>
<h2 id="四、数据持久化存储与性能调优"><a href="#四、数据持久化存储与性能调优" class="headerlink" title="四、数据持久化存储与性能调优"></a>四、数据持久化存储与性能调优</h2><h3 id="数据持久保存"><a href="#数据持久保存" class="headerlink" title="数据持久保存"></a>数据持久保存</h3><p>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着当该容器不再存在时，数据也将丢失。</p>
<p>为了让数据脱离容器持久保存，Docker 提供了两个选项来将文件持久存储在主机中： <code>volume</code> 和 <code>bind mount</code> 。如果您在 Linux 上运行 Docker，则还可以使用 _tmpfs 挂载_。如果您在 Windows 上运行 Docker，则还可以使用<em>命名管道</em>。</p>
<p><img src="https://pic.lixl.cn/2020/types-of-mounts.png" alt="挂载的类型以及它们在Docker主机上的位置"></p>
<ul>
<li><strong>volume（卷）</strong>存储在主机文件系统的一部分中，该文件系统<em>由 Docker 管理</em>（<code>/var/lib/docker/volumes/</code>在 Linux 上）。非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久保存数据的最佳方法。</li>
<li><strong>bind mount（绑定挂载）</strong>可以存储在主机系统上的<em>任何位置</em>。它们甚至可能是重要的系统文件或目录。Docker 主机或 Docker 容器上的非 Docker 进程可以随时对其进行修改。</li>
<li><strong><code>tmpfs</code>挂载</strong> 仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统中。</li>
</ul>
<p><code>volume</code> 和 <code>bind mount</code> 都可以使用 <code>-v</code> 或 <code>--volume</code> 标志安装到容器中，但是两者的语法略有不同。</p>
<blockquote>
<p>关于挂载类型的更多详细信息：<a href="https://docs.docker.com/storage/#more-details-about-mount-types" target="_blank" rel="noopener">Manage data in Docker</a></p>
</blockquote>
<h3 id="挂载卷性能调优"><a href="#挂载卷性能调优" class="headerlink" title="挂载卷性能调优"></a>挂载卷性能调优</h3><p>在 macOS（和其他非 Linux 平台）上，保证容器内和主机文件一致性的开销很大。然而，在许多情况下，容器与主机之间不需要完美的一致性。区分不同情况可以显着提高性能。</p>
<p>通过在 <code>docker run -v</code>， <code>--volume</code> 的 option 中指定 <code>cached</code> 或 <code>delegated</code>，可以显着提高 Docker Desktop for Mac 上已装载卷访问的性能。您可以根据情况调整所需的一致性级别：</p>
<ul>
<li><code>consistent</code>：默认值，完美的一致性，即主机和容器实时一致。</li>
<li><code>cached</code>：主机具有权威性。容器执行的写操作对主机是立即可见的，但是在主机上执行的写操作可能不会立即反应在容器内。</li>
<li><code>delegated</code>：容器的内容具有权威性。提供最弱保证，由容器执行的写操作可能不会立即反映在主机文件系统上，提供的性能要比其他配置好得多。</li>
</ul>
<p>为每个挂载卷独立设置缓存策略，例如：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run \
    -v /Users/lixl.cn/project:/project:cached \
    -v /host/another-path:/mount/another-point:consistent \
    alpine <span class="token function">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="五、Docker-镜像仓库"><a href="#五、Docker-镜像仓库" class="headerlink" title="五、Docker 镜像仓库"></a>五、Docker 镜像仓库</h2><p>Repository（仓库）是集中存放镜像的地方。一个 Docker Registry 中可以包含多个 Repository（仓库），每个仓库可以包含多个 Tag（标签），每个标签对应一个 Image（镜像）。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry。用户也可以创建本地仓库方便内部使用。</p>
<h3 id="1、官方公共仓库-Docker-Hub"><a href="#1、官方公共仓库-Docker-Hub" class="headerlink" title="1、官方公共仓库 Docker Hub"></a>1、官方公共仓库 Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>lxl823</code> 请替换为你的 Docker 账号用户名。</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker tag nginx lxl823/nginx:1.17.9
docker image <span class="token function">ls</span>
REPOSITORY       TAG            IMAGE ID            CREATED             SIZE
nginx            latest          6678c7c2e56c        6 days ago          127MB
lxl823/nginx     1.17.9          6678c7c2e56c        6 days ago          127MB

docker push lxl823/nginx:1.17.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>登录 <a href="https://hub.docker.com/repositories" target="_blank" rel="noopener">hub.docker.com</a> ，可以看到镜像已经发布到仓库中。</p>
<p><img src="https://pic.lixl.cn/2020/image-20200326185134980.png" alt="Docker hub 镜像仓库"></p>
<h4 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h4><p>Docker Hub可以自动从外部存储库中的源代码构建映像，并将生成的映像自动推送到您的Docker存储库。</p>
<p>设置自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动构建，包括如下的步骤：</p>
<ul>
<li>登录 Docker Hub；</li>
<li>在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站；</li>
<li>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</li>
<li>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</li>
<li>指定 <code>Dockerfile</code> 的位置，并保存。</li>
</ul>
<p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p>
<p>进一步了解：<a href="https://docs.docker.com/docker-hub/builds/" target="_blank" rel="noopener">Set up automated builds</a></p>
<h3 id="2、基于-docker-registry-搭建本地仓库"><a href="#2、基于-docker-registry-搭建本地仓库" class="headerlink" title="2、基于 docker-registry 搭建本地仓库"></a>2、基于 docker-registry 搭建本地仓库</h3><p><a href="https://docs.docker.com/registry/" target="_blank" rel="noopener"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener"><code>docker-registry</code></a> v2.x 版本。</p>
<h4 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h4><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d -p 5000:5000 --restart<span class="token operator">=</span>always --name registry registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p>
<p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后使用 <code>docker push</code> 推送它到仓库。</p>
<h3 id="3、基于-Sonatype-Nexus-3-搭建本地仓库"><a href="#3、基于-Sonatype-Nexus-3-搭建本地仓库" class="headerlink" title="3、基于 Sonatype Nexus 3 搭建本地仓库"></a>3、基于 Sonatype Nexus 3 搭建本地仓库</h3><p>在企业中把内部的一些工具包放入 Nexus 中是比较常见的做法。 Nexus 不仅能够用于创建 Maven 私服，还可以用来创建 yum、pypi、npm、nuget、rubygems 等各种私有仓库。而且，Nexus 从 3.0 版本也开始支持创建 Docker 镜像仓库了！</p>
<h4 id="拉取并启动-nexus-容器"><a href="#拉取并启动-nexus-容器" class="headerlink" title="拉取并启动 nexus 容器"></a>拉取并启动 nexus 容器</h4><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \
    --name nexus \
    -p 8085:8081 \
    -p 8086:8086 \
    -v nexus_data:/nexus-data \
    sonatype/nexus3:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>等待 3-5 分钟，如果 <code>nexus</code> 容器没有异常退出，就可以使用浏览器打开 <code>http://localhost:8085</code> 访问 Nexus 了。</p>
<h4 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h4><p>创建一个私有仓库的方法： <code>Repository -&gt; Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p>
<ul>
<li>Name：仓库的名称</li>
<li>HTTP：仓库单独的访问端口，如 <code>8086</code></li>
<li>Hosted -&gt; Deployment pollcy：请选择 Allow redeploy 否则无法上传 Docker 镜像。</li>
</ul>
<p>还可以创建一个 docker (proxy) 类型的仓库连接到 DockerHub 上。再创建一个 docker (group) 类型的仓库把刚才的 hosted 与 proxy 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将连接到 DockerHub 中下载并缓存到 Nexus 中。</p>
<h4 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h4><p>菜单 <code>Security -&gt; Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p>
<p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p>
<h4 id="Nginx-加密代理"><a href="#Nginx-加密代理" class="headerlink" title="Nginx 加密代理"></a>Nginx 加密代理</h4><p>部署 Nginx 时，我们先需要获得 SSL 证书。目前提供免费证书的云服务商很多，也可以使用 <code>openssl</code> 自行签发证书。我们还还需要 2 个域名，一个用来展示 nexus 前台，另一个用做 docker 仓库。Nginx 配置如下:</p>
<pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span>
<span class="token attr-name">    listen</span> <span class="token attr-value">80;</span>
<span class="token attr-name">    server_name</span> <span class="token attr-value">nexus3.lixl.cn;  # nexus 前台</span>

<span class="token attr-name">    location</span> <span class="token attr-value">/ {</span>
<span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://local.lixl.cn:8085;</span>
<span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Host $host;</span>
<span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Real-IP $remote_addr;</span>
<span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Forwarded-For $proxy_add_x_forwarded_for;</span>
<span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Via "nginx";</span>
    }

<span class="token attr-name">    error_page</span> <span class="token attr-value">  500 502 503 504  /50x.html;</span>
<span class="token attr-name">    location</span> <span class="token punctuation">=</span> <span class="token attr-value">/50x.html {</span>
<span class="token attr-name">        root</span> <span class="token attr-value">  /usr/share/nginx/html;</span>
    }
}

<span class="token attr-name">server</span> <span class="token attr-value">{</span>
<span class="token attr-name">    listen</span> <span class="token attr-value">443 ssl;</span>
<span class="token attr-name">    server_name</span> <span class="token attr-value">nexus.lixl.cn;  # docker 仓库</span>

<span class="token attr-name">    ssl_certificate</span> <span class="token attr-value">/etc/nginx/certs/nexus.lixl.cn.crt;</span>
<span class="token attr-name">    ssl_certificate_key</span> <span class="token attr-value">/etc/nginx/certs/nexus.lixl.cn.key;</span>

<span class="token attr-name">    ssl_session_timeout</span> <span class="token attr-value"> 5m;</span>

<span class="token attr-name">    ssl_ciphers</span> <span class="token attr-value">HIGH:!aNULL:!MD5;</span>
<span class="token attr-name">    ssl_protocols</span> <span class="token attr-value">SSLv3 TLSv1 TLSv1.1 TLSv1.2;</span>
<span class="token attr-name">    ssl_prefer_server_ciphers</span> <span class="token attr-value">  on;</span>

<span class="token attr-name">    location</span> <span class="token attr-value">/ {</span>
<span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://local.lixl.cn:8086;</span>
<span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Host $host;</span>
<span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Real-IP $remote_addr;</span>
<span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Forwarded-For $proxy_add_x_forwarded_for;</span>
<span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Via "nginx";</span>
<span class="token attr-name">        client_max_body_size</span> <span class="token attr-value">1024M;</span>
    }

<span class="token attr-name">    error_page</span> <span class="token attr-value">  500 502 503 504  /50x.html;</span>
<span class="token attr-name">    location</span> <span class="token punctuation">=</span> <span class="token attr-value">/50x.html {</span>
<span class="token attr-name">        root</span> <span class="token attr-value">  /usr/share/nginx/html;</span>
    }
}

<span class="token attr-name">server</span> <span class="token attr-value">{</span>
<span class="token attr-name">    listen</span> <span class="token attr-value">80;</span>
<span class="token attr-name">    server_name</span> <span class="token attr-value">nexus.lixl.cn;  # docker 仓库</span>

<span class="token attr-name">    return</span> <span class="token attr-value">301 https://$server_name$request_uri;</span>
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="登录本地仓库并推送镜像"><a href="#登录本地仓库并推送镜像" class="headerlink" title="登录本地仓库并推送镜像"></a>登录本地仓库并推送镜像</h4><p>使用 <code>docker login</code> 进行测试，用户名密码与 Nexus 账号一致。</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker login https://nexus.lixl.cn
Username: admin
Password:
Login Succeeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 <code>docker push</code> 命令将自己的镜像推送到 Nexus：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker tag nginx nexus.lixl.cn/nginx:20200326
docker image <span class="token function">ls</span>
REPOSITORY             TAG             IMAGE ID            CREATED             SIZE
nginx                  latest          6678c7c2e56c        6 days ago          127MB
nexus.lixl.cn/nginx    20200326        6678c7c2e56c        6 days ago          127MB

docker push nexus.lixl.cn/nginx:20200326<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>推送成功。在本地仓库即可看到新推送的镜像：</p>
<p><img src="https://pic.lixl.cn/2020/image-20200326201622029.png" alt="本地仓库新推送的镜像"></p>
<h2 id="六、Docker-网络配置"><a href="#六、Docker-网络配置" class="headerlink" title="六、Docker 网络配置"></a>六、Docker 网络配置</h2><h2 id="七、Docker-常用命令"><a href="#七、Docker-常用命令" class="headerlink" title="七、Docker 常用命令"></a>七、Docker 常用命令</h2><p>一张图总结 Docker 常用命令及状态变化：</p>
<p><img src="https://pic.lixl.cn/2020/image-20200325192936728.png" alt="Docker常用命令及状态变化图"></p>
<p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p>
<ul>
<li><code>attach</code>：依附到一个正在运行的容器中；</li>
<li><code>build</code>：从一个 Dockerfile 创建一个镜像；</li>
<li><code>commit</code>：从一个容器的修改中创建一个新的镜像；</li>
<li><code>cp</code>：在容器和本地宿主系统之间复制文件中；</li>
<li><code>create</code>：创建一个新容器，但并不运行它；</li>
<li><code>diff</code>：检查一个容器内文件系统的修改，包括修改和增加；</li>
<li><code>events</code>：从服务端获取实时的事件；</li>
<li><code>exec</code>：在运行的容器内执行命令；</li>
<li><code>export</code>：导出容器内容为一个 <code>tar</code> 包；</li>
<li><code>history</code>：显示一个镜像的历史信息；</li>
<li><code>images</code>：列出存在的镜像；</li>
<li><code>import</code>：导入一个文件（典型为 <code>tar</code> 包）路径或目录来创建一个本地镜像；</li>
<li><code>info</code>：显示一些相关的系统信息；</li>
<li><code>inspect</code>：显示一个容器的具体配置信息；</li>
<li><code>kill</code>：关闭一个运行中的容器 (包括进程和所有相关资源)；</li>
<li><code>load</code>：从一个 tar 包中加载一个镜像；</li>
<li><code>login</code>：注册或登录到一个 Docker 的仓库服务器；</li>
<li><code>logout</code>：从 Docker 的仓库服务器登出；</li>
<li><code>logs</code>：获取容器的 log 信息；</li>
<li><code>network</code>：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>
<li><code>node</code>：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</li>
<li><code>pause</code>：暂停一个容器中的所有进程；</li>
<li><code>port</code>：查找一个 nat 到一个私有网口的公共口；</li>
<li><code>ps</code>：列出主机上的容器；</li>
<li><code>pull</code>：从一个 Docker 的仓库服务器下拉一个镜像或仓库；</li>
<li><code>push</code>：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>
<li><code>rename</code>：重命名一个容器；</li>
<li><code>restart</code>：重启一个运行中的容器；</li>
<li><code>rm</code>：删除给定的若干个容器；</li>
<li><code>rmi</code>：删除给定的若干个镜像；</li>
<li><code>run</code>：创建一个新容器，并在其中运行给定命令；</li>
<li><code>save</code>：保存一个镜像为 tar 包文件；</li>
<li><code>search</code>：在 Docker index 中搜索一个镜像；</li>
<li><code>service</code>：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>
<li><code>start</code>：启动一个容器；</li>
<li><code>stats</code>：输出（一个或多个）容器的资源使用统计信息；</li>
<li><code>stop</code>：终止一个运行中的容器；</li>
<li><code>swarm</code>：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>
<li><code>tag</code>：为一个镜像打标签；</li>
<li><code>top</code>：查看一个容器中的正在运行的进程信息；</li>
<li><code>unpause</code>：将一个容器内所有的进程从暂停状态中恢复；</li>
<li><code>update</code>：更新指定的若干容器的配置信息；</li>
<li><code>version</code>：输出 Docker 的版本信息；</li>
<li><code>volume</code>：管理 Docker volume，包括查看、创建、删除等；</li>
<li><code>wait</code>：阻塞直到一个容器终止，然后输出它的退出符。</li>
</ul>
<p>更详细信息，请查看博文：<a href="https://www.lixl.cn/2020/03157569.html">悟尘纪 <em>—</em> Docker常用命令详解</a></p>
<h2 id="八、Docker-Compose"><a href="#八、Docker-Compose" class="headerlink" title="八、Docker Compose"></a>八、Docker Compose</h2><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h2 id="九、Dockerfile-最佳实践"><a href="#九、Dockerfile-最佳实践" class="headerlink" title="九、Dockerfile 最佳实践"></a>九、Dockerfile 最佳实践</h2><h3 id="1、一般性的指南和建议"><a href="#1、一般性的指南和建议" class="headerlink" title="1、一般性的指南和建议"></a>1、一般性的指南和建议</h3><h4 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h4><p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p>
<h4 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 .dockerignore 文件</h4><p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p>
<h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>在 <code>Docker 17.05</code> 以上版本中，你可以使用 <a href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/" target="_blank" rel="noopener">多阶段构建</a> 来减少所构建镜像的大小。</p>
<h4 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h4><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
<h4 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" class="headerlink" title="一个容器只运行一个进程"></a>一个容器只运行一个进程</h4><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web 应用、数据库、缓存。</p>
<p>如果容器互相依赖，你可以使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/network/linking.html" target="_blank" rel="noopener">Docker 自定义网络</a> 来把这些容器连接起来。</p>
<h4 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" class="headerlink" title="镜像层数尽可能少"></a>镜像层数尽可能少</h4><p>你需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
<h4 id="将多行参数排序"><a href="#将多行参数排序" class="headerlink" title="将多行参数排序"></a>将多行参数排序</h4><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p>
<p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
  bzr \
  cvs \
  git \
  mercurial \
  subversion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="使用构建缓存"><a href="#使用构建缓存" class="headerlink" title="使用构建缓存"></a>使用构建缓存</h4><p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p>
<p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：</p>
<ul>
<li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li>
<li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li>
<li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li>
<li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li>
</ul>
<p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p>
<h3 id="2、Dockerfile-指令"><a href="#2、Dockerfile-指令" class="headerlink" title="2、Dockerfile 指令"></a>2、Dockerfile 指令</h3><p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">Alpine</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p>
<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p>
<blockquote>
<p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p>
</blockquote>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># Set one or more individual labels</span>
<span class="token keyword">LABEL</span> com.example.version=<span class="token string">"0.0.1-beta"</span>

<span class="token keyword">LABEL</span> vendor=<span class="token string">"ACME Incorporated"</span>

<span class="token keyword">LABEL</span> com.example.release<span class="token punctuation">-</span>date=<span class="token string">"2015-02-12"</span>

<span class="token keyword">LABEL</span> com.example.version.is<span class="token punctuation">-</span>production=<span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># Set multiple labels at once, using line-continuation characters to break long lines</span>
<span class="token keyword">LABEL</span> vendor=ACME\ Incorporated \
      com.example.is<span class="token punctuation">-</span>beta= \
      com.example.is<span class="token punctuation">-</span>production=<span class="token string">""</span> \
      com.example.version=<span class="token string">"0.0.1-beta"</span> \
      com.example.release<span class="token punctuation">-</span>date=<span class="token string">"2015-02-12"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于标签可以接受的键值对，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">Understanding object labels</a>。关于查询标签信息，参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">Managing labels on objects</a>。</p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p>
<h5 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h5><p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p>
<p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p>
<p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
        package<span class="token punctuation">-</span>bar \
        package<span class="token punctuation">-</span>baz \
        package<span class="token punctuation">-</span>foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>18.04

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>18.04

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p>
<p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
    package<span class="token punctuation">-</span>bar \
    package<span class="token punctuation">-</span>baz \
    package<span class="token punctuation">-</span>foo=1.3.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p>
<p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \
    aufs<span class="token punctuation">-</span>tools \
    automake \
    build<span class="token punctuation">-</span>essential \
    curl \
    dpkg<span class="token punctuation">-</span>sig \
    libcap<span class="token punctuation">-</span>dev \
    libsqlite3<span class="token punctuation">-</span>dev \
    mercurial \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1<span class="token punctuation">-</span>dev \
    s3cmd=1.1.* \
 &amp;&amp; rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p>
<p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p>
<blockquote>
<p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p>
</blockquote>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p>
<p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p>
<p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p>
<p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p>
<p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ENV</span> PG_MAJOR 9.3

<span class="token keyword">ENV</span> PG_VERSION 9.3.4

<span class="token keyword">RUN</span> curl <span class="token punctuation">-</span>SL http<span class="token punctuation">:</span>//example.com/postgres<span class="token punctuation">-</span>$PG_VERSION.tar.xz <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xJC /usr/src/postgress &amp;&amp; …

<span class="token keyword">ENV</span> PATH /usr/local/postgres<span class="token punctuation">-</span>$PG_MAJOR/bin<span class="token punctuation">:</span>$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p>
<h4 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h4><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p>
<p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> requirements.txt /tmp/

<span class="token keyword">RUN</span> pip install <span class="token punctuation">-</span><span class="token punctuation">-</span>requirement /tmp/requirements.txt

<span class="token keyword">COPY</span> . /tmp/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p>
<p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ADD</span> http<span class="token punctuation">:</span>//example.com/big.tar.xz /usr/src/things/

<span class="token keyword">RUN</span> tar <span class="token punctuation">-</span>xJf /usr/src/things/big.tar.xz <span class="token punctuation">-</span>C /usr/src/things

<span class="token keyword">RUN</span> make <span class="token punctuation">-</span>C /usr/src/things all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而是应该使用下面这种方法：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> mkdir <span class="token punctuation">-</span>p /usr/src/things \
    &amp;&amp; curl <span class="token punctuation">-</span>SL http<span class="token punctuation">:</span>//example.com/big.tar.xz \
    <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xJC /usr/src/things \
    &amp;&amp; make <span class="token punctuation">-</span>C /usr/src/things all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面使用的管道操作，所以没有中间文件需要删除。</p>
<p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p>
<p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">"s3cmd"</span><span class="token punctuation">]</span>

<span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">"--help"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在直接运行该镜像创建的容器会显示命令帮助：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run s3cmd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者提供正确的参数来执行某个命令：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run s3cmd <span class="token function">ls</span> s3://mybucket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样镜像名可以当成命令行的参考。</p>
<p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p>
<p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">set</span> -e

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">=</span> <span class="token string">'postgres'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">chown</span> -R postgres <span class="token string">"<span class="token variable">$PGDATA</span>"</span>

    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"$(ls -A "</span><span class="token variable">$PGDATA</span><span class="token string">")"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        gosu postgres initdb
    <span class="token keyword">fi</span>

    <span class="token function">exec</span> gosu postgres <span class="token string">"<span class="token variable">$@</span>"</span>
<span class="token keyword">fi</span>

<span class="token function">exec</span> <span class="token string">"<span class="token variable">$@</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>
</blockquote>
<p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> ./docker<span class="token punctuation">-</span>entrypoint.sh /

<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">"/docker-entrypoint.sh"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p>
<p>你可以很简单地启动 <code>Postgres</code>：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run postgres<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以执行 <code>Postgres</code> 并传递参数：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run postgres postgres --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run --rm -it postgres <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p>
<blockquote>
<p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。</p>
</blockquote>
<p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener">gosu</a>。</p>
<p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p>
<h3 id="3、官方镜像示例"><a href="#3、官方镜像示例" class="headerlink" title="3、官方镜像示例"></a>3、官方镜像示例</h3><p>这些官方镜像的 Dockerfile 都是参考典范：<a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">https://github.com/docker-library/docs</a></p>
<h2 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h2><ul>
<li><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker docs</a></p>
</li>
<li><p><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">Docker —— 从入门到实践</a></p>
</li>
</ul>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://www.lixl.cn" rel="external nofollow noreferrer">悟尘</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                    </span>
                <span class="reprint-info">
                    <a href="https://www.lixl.cn/2020/032539393.html">https://www.lixl.cn/2020/032539393.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-ND 4.0</a>
                    许可协议，转载请注明来源
                    <a href="https://www.lixl.cn" target="_blank">悟尘纪</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        var selection = window.getSelection();
        if (('' + selection).length >= Number.parseInt('50')) {
            let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
            M.toast({html: toastHTML});
        }
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Docker/">
                                    <span class="chip bg-color">Docker</span>
                                </a>
                            
                                <a href="/tags/DevOps/">
                                    <span class="chip bg-color">DevOps</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="wechat,weibo,qq,qzone,douban,twitter,facebook,google,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'd032ec0dfbe5a4b4ec6f',
        clientSecret: 'afe793d53f24ebd7f53d0eb4dd21f3bc706dab06',
        repo: 'site',
        owner: 'lxl80',
        admin: "lxl80",
        id: '2020-03-25T10-06-26',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/032950740.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="mkdocs/draft/index">
                        
                        <span class="card-title">mkdocs/draft/index</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            关于本站（草稿）本站是 悟尘纪 的子站点，用于方便浏览博文中的系列文章。
基于 MkDocs 的 Material 主题搭建，通过左侧的目录树可以方便的浏览系列文章，界面风...
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-03-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            悟尘
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/032252398.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="跨团队、流程和应用的主动变革，支撑企业数字化转型">
                        
                        <span class="card-title">跨团队、流程和应用的主动变革，支撑企业数字化转型</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            快速向客户提供新服务和新功能是公司的关键竞争优势之一，这需要把数字化转型当做企业的一种战略性变革。本文将对如何支撑企业数字化转型进行分析并提出建议。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-03-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/" class="post-category">
                                    技术管理
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B/">
                        <span class="chip bg-color">数字化转型</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('50')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 悟尘纪<br />'
            + '文章作者: 悟尘<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归 [悟尘](http://lixl.cn) 所有，采用 CC BY-NC-ND 4.0 许可协议，转载请注明来源！';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            &copy;
            <span id="year">2019</span>
            <a href="https://www.lixl.cn" target="_blank">悟尘</a>
            &nbsp;|&nbsp;&nbsp;基于&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> 的
            &nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a> 主题构建
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;&nbsp;<i class="far fa-eye"></i>&nbsp;PV:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;&nbsp;<i class="fas fa-users"></i>&nbsp;UV:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;
            </span>
            
            
            
            &nbsp;|&nbsp;&nbsp;<span id="icp">
                <a href="http://www.beian.miit.gov.cn/" target="_blank">冀ICP备20001325号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/lxl80/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:me@lixl.cn" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=369888789" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 369888789" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?7e0bedc93e9b2cc20cfa835875bef2d6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
