


<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="悟尘纪电子书">
      
      
        <link rel="canonical" href="https://www.lixl.cn/NodeJS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/Node.js%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">
      
      
        <meta name="author" content="悟尘">
      
      <link rel="shortcut icon" href="https://www.lixl.cn/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-5.0.2">
    
    
      
        <title>Node.js必知必会（安装配置、应用实例及同步控制）</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.07c9fbf5.min.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ecd4686e.min.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CCascadia+Code&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Cascadia Code",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
      <link rel="stylesheet" href="../../extra/my.css">
    
    
      
    
    
  </head>
  
  
    
    
    <body dir="" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#nodejs" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="">
    <a href="https://www.lixl.cn" title="系列文章" class="md-header-nav__button md-logo" aria-label="系列文章">
      
  <img src="https://www.lixl.cn/medias/logo.png" alt="logo">

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <span class="md-header-nav__topic md-ellipsis">
          
  <img src="https://www.lixl.cn/medias/logo.png" alt="logo">

        </span>
        <span class="md-header-nav__topic md-ellipsis">
        Node.js必知必会（安装配置、应用实例及同步控制）
        </span>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" /></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://www.lixl.cn" title="前往 GitHub 仓库" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"/></svg>
  </div>
  <div class="md-source__repository">
    返回博客站
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://www.lixl.cn" title="系列文章" class="md-nav__button md-logo" aria-label="系列文章">
      
  <img src="https://www.lixl.cn/medias/logo.png" alt="logo">

    </a>
    系列文章
  </label>
  
    <div class="md-nav__source">
      
<a href="https://www.lixl.cn" title="前往 GitHub 仓库" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"/></svg>
  </div>
  <div class="md-source__repository">
    返回博客站
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="关于本站" class="md-nav__link">
      关于本站
    </a>
  </li>

    
      
      
      


  

    
      
      
      


  

    
      
      
      


  

    
      
      
      

  


  
  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" checked>
    
    <label class="md-nav__link" for="nav-5">
      NodeJS从入门到实践
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z" /></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="NodeJS从入门到实践" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
        </span>
        NodeJS从入门到实践
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Electron%E6%9E%84%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8/" title="Electron构建跨平台应用" class="md-nav__link">
      Electron构建跨平台应用
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Node.js必知必会（安装配置、应用实例及同步控制）
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3,9H17V7H3V9M3,13H17V11H3V13M3,17H17V15H3V17M19,17H21V15H19V17M19,7V9H21V7H19M19,13H21V11H19V13Z" /></svg>
        </span>
      </label>
    
    <a href="./" title="Node.js必知必会（安装配置、应用实例及同步控制）" class="md-nav__link md-nav__link--active">
      Node.js必知必会（安装配置、应用实例及同步控制）
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
      </span>
      目录
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#nodejs" class="md-nav__link">
    一、Node.js简介
  </a>
  
    <nav class="md-nav" aria-label="一、Node.js简介">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nodejs_1" class="md-nav__link">
    NodeJS 架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    相关资源
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    二、安装配置
  </a>
  
    <nav class="md-nav" aria-label="二、安装配置">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nvmnodejs" class="md-nav__link">
    安装nvm及Node.js
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#npm" class="md-nav__link">
    npm
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    三、Node特点
  </a>
  
    <nav class="md-nav" aria-label="三、Node特点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#io" class="md-nav__link">
    异步I/O
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    事件与回调函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    单线程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io_1" class="md-nav__link">
    擅长I/O密集型的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    性能不俗
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#nodejs_2" class="md-nav__link">
    四、Node.js常用模块
  </a>
  
    <nav class="md-nav" aria-label="四、Node.js常用模块">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#global" class="md-nav__link">
    Global模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#process" class="md-nav__link">
    Process模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#console" class="md-nav__link">
    Console模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#util" class="md-nav__link">
    Util模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#events" class="md-nav__link">
    Events模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#file-system" class="md-nav__link">
    File System模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http" class="md-nav__link">
    Http模块
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#nodejs_3" class="md-nav__link">
    五、创建Node.js应用
  </a>
  
    <nav class="md-nav" aria-label="五、创建Node.js应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nodehttp" class="md-nav__link">
    使用Node创建http服务器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#webexpress" class="md-nav__link">
    web框架express简单使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#promise-async" class="md-nav__link">
    六、异步编程方案（Promise &amp; Async）
  </a>
  
    <nav class="md-nav" aria-label="六、异步编程方案（Promise &amp; Async）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#promise" class="md-nav__link">
    基于Promise实现同步控制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#async" class="md-nav__link">
    基于Async实现同步控制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eslint" class="md-nav__link">
    七、基于ESLint保障质量
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    八、参考
  </a>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
      </ul>
    </nav>
  </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
      </span>
      目录
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#nodejs" class="md-nav__link">
    一、Node.js简介
  </a>
  
    <nav class="md-nav" aria-label="一、Node.js简介">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nodejs_1" class="md-nav__link">
    NodeJS 架构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    相关资源
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    二、安装配置
  </a>
  
    <nav class="md-nav" aria-label="二、安装配置">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nvmnodejs" class="md-nav__link">
    安装nvm及Node.js
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#npm" class="md-nav__link">
    npm
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#node" class="md-nav__link">
    三、Node特点
  </a>
  
    <nav class="md-nav" aria-label="三、Node特点">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#io" class="md-nav__link">
    异步I/O
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    事件与回调函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    单线程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io_1" class="md-nav__link">
    擅长I/O密集型的应用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    性能不俗
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#nodejs_2" class="md-nav__link">
    四、Node.js常用模块
  </a>
  
    <nav class="md-nav" aria-label="四、Node.js常用模块">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#global" class="md-nav__link">
    Global模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#process" class="md-nav__link">
    Process模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#console" class="md-nav__link">
    Console模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#util" class="md-nav__link">
    Util模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#events" class="md-nav__link">
    Events模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#file-system" class="md-nav__link">
    File System模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http" class="md-nav__link">
    Http模块
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#nodejs_3" class="md-nav__link">
    五、创建Node.js应用
  </a>
  
    <nav class="md-nav" aria-label="五、创建Node.js应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nodehttp" class="md-nav__link">
    使用Node创建http服务器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#webexpress" class="md-nav__link">
    web框架express简单使用
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#promise-async" class="md-nav__link">
    六、异步编程方案（Promise &amp; Async）
  </a>
  
    <nav class="md-nav" aria-label="六、异步编程方案（Promise &amp; Async）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#promise" class="md-nav__link">
    基于Promise实现同步控制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#async" class="md-nav__link">
    基于Async实现同步控制
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#eslint" class="md-nav__link">
    七、基于ESLint保障质量
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    八、参考
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                  <h1>Node.js必知必会（安装配置、应用实例及同步控制）</h1>
                
                <h2 id="nodejs">一、Node.js简介<a class="headerlink" href="#nodejs" title="Permanent link">&para;</a></h2>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。于2009年由Google Brain团队的软件工程师Ryan Dahl发起创建，2015年后正式被<a href="https://foundation.nodejs.org/">NodeJS基金会</a>接管。</p>
<h3 id="nodejs_1">NodeJS 架构<a class="headerlink" href="#nodejs_1" title="Permanent link">&para;</a></h3>
<p><img alt="Node.js架构" src="https://pic.lixl.cn/2019/20200113000457.png/w1280" /></p>
<p>Node使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p>
<p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>
<p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）。在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p>
<h3 id="_1">相关资源<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<ul>
<li>Node.js官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></li>
<li>版本管理工具nvm：<a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></li>
<li>包管理工具npm：<a href="https://www.npmjs.com/">https://www.npmjs.com/</a></li>
<li>npm中文文档：<a href="https://www.npmjs.cn/">https://www.npmjs.cn/</a></li>
<li>国内的 npm 镜像源：<a href="http://cnpmjs.org/">http://cnpmjs.org/</a></li>
<li>中文社区：<a href="https://cnodejs.org/">https://cnodejs.org/</a></li>
</ul>
<h2 id="_2">二、安装配置<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>建议使用nvm来进行node版本管理，它会安装相应版本的npm。</p>
<h3 id="nvmnodejs">安装nvm及Node.js<a class="headerlink" href="#nvmnodejs" title="Permanent link">&para;</a></h3>
<p>nvm全名node.js version management，顾名思义是一个nodejs的版本管理工具。通过它可以安装和切换不同版本的nodejs。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 安装nvm（ 升级nvm重新执行此命令）:</span>
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh <span class="p">|</span> bash
<span class="c1"># 列出所有可以安装的node版本号</span>
nvm ls-remote
<span class="c1"># 安装指定版本号的node</span>
nvm install v12.4.1
<span class="c1"># 设置 nodejs 默认版本</span>
nvm <span class="nb">alias</span> default <span class="m">12</span>.4.1
<span class="c1"># 切换node的版本</span>
nvm use v10.15.3
<span class="c1"># 当前node版本</span>
nvm current
node -v
<span class="c1"># 列出所有已经安装的node版本</span>
nvm ls
<span class="c1"># 卸载已安装的node版本</span>
nvm uninstall v6.9.5
</code></pre></div>

<h3 id="npm">npm<a class="headerlink" href="#npm" title="Permanent link">&para;</a></h3>
<p>npm 是世界上最大的软件注册中心，随同NodeJS一起安装，来自全球各地的开源开发人员使用 npm 来共享和复用软件包。npm 由三个独立的部分组成：</p>
<ul>
<li>网站： <a href="https://npmjs.com">https://npmjs.com</a> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</li>
<li>注册表（registry）：是一个巨大的数据库，保存了每个包（package）的信息。</li>
<li>命令行工具 (CLI)：通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># 查看 npm 版本</span>
npm -v
<span class="c1"># 更新npm版本</span>
npm install npm@latest -g
<span class="c1"># 搜索模块</span>
npm search hexo
<span class="c1"># 安装依赖包</span>
npm install &lt;Module Name&gt;
npm install hexo      <span class="c1"># 本地安装 hexo</span>
npm install hexo -g   <span class="c1"># 全局安装 hexo</span>
<span class="c1"># 查看所有全局安装的模块</span>
npm list -g
<span class="c1"># 查看某个模块</span>
npm list hexo
<span class="c1"># 卸载模块</span>
npm uninstall hexo
<span class="c1"># 卸载后，查看包是否还存在</span>
npm ls
<span class="c1"># 更新某个模块</span>
npm update hexo
<span class="c1"># 创建模块</span>
npm init
</code></pre></div>

<p>每个版本的 Node 都自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 ~/.nvm/versions/node/${version}/lib/node_modules 这样的目录。</p>
<p>运行下面这个命令，可以从特定版本导入之前安装过的 npm 包到我们将要安装的新版本 Node 中：</p>
<div class="highlight"><pre><span></span><code>nvm install v12.16.1 --reinstall-packages-from<span class="o">=</span>v10.15.3
</code></pre></div>

<h2 id="node">三、Node特点<a class="headerlink" href="#node" title="Permanent link">&para;</a></h2>
<h3 id="io">异步I/O<a class="headerlink" href="#io" title="Permanent link">&para;</a></h3>
<p>在Node中，绝大多数的操作都以异步的方式进行调用。在底层构建了很多异步I/O的API，从文件读取到网络请求等，均是如此。这样的意义在于，在Node中，我们可以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。在编程模型上可以极大提升效率。
下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时：</p>
<div class="highlight"><pre><span></span><code><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/path1&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;读取文件1完成&#39;</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;/path2&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;读取文件2完成&#39;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>

<p>而对于同步I/O而言，它们的耗时是两个任务的耗时之和。这里异步带来的优势是显而易见的。</p>
<h3 id="_3">事件与回调函数<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>在JavaScript中，函数被作为第一等公民来对待，可以将函数作为对象传递给方法作为实参进行调用。Node将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。</p>
<p>下面的例子展示的是Ajax异步提交的服务器端处理过程。Node创建一个Web服务器，并侦听8080端口。对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件：</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">quertstring</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;querystring&#39;</span><span class="p">);</span>

<span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span><span class="nx">res</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">postData</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">setEncoding</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">);</span>

  <span class="c1">// 监听请求的data事件</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">chunk</span><span class="p">){</span>
    <span class="nx">postData</span> <span class="o">+=</span> <span class="nx">chunk</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="c1">// 监听请求的end事件</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">postData</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;服务器启动完成，监听端口：8080&#39;</span><span class="p">)</span>
</code></pre></div>

<p>相应地，我们在前端为Ajax请求绑定了success事件，在发出请求后，只需关心请求成功时执行相应的业务逻辑即可，相关代码如下：</p>
<div class="highlight"><pre><span></span><code><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
  <span class="s1">&#39;url&#39;</span><span class="o">:</span> <span class="s1">&#39;/url&#39;</span><span class="p">,</span>
  <span class="s1">&#39;method&#39;</span><span class="o">:</span> <span class="s1">&#39;POST&#39;</span><span class="p">,</span>
  <span class="s1">&#39;data&#39;</span><span class="o">:</span> <span class="p">{},</span>
  <span class="s1">&#39;success&#39;</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// success事件</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>

<p>与其他的Web后端编程语言相比，Node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的。代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍。</p>
<h3 id="_4">单线程<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。
同样，单线程也有它自身的弱点。Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：<code>child_process</code>。子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。</p>
<h3 id="io_1">擅长I/O密集型的应用<a class="headerlink" href="#io_1" title="Permanent link">&para;</a></h3>
<p>通常，说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p>
<h3 id="_5">性能不俗<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU，I/O阻塞造成的性能浪费远比CPU的影响小。</p>
<p><img alt="计算斐波那契数列的耗时排行" src="https://pic.lixl.cn/2019/20200113165953.png/w1280" /></p>
<h2 id="nodejs_2">四、Node.js常用模块<a class="headerlink" href="#nodejs_2" title="Permanent link">&para;</a></h2>
<p>更多模块详细介绍，可查阅官方文档: <a href="https://nodejs.org/api/">https://nodejs.org/api/</a></p>
<h3 id="global">Global模块<a class="headerlink" href="#global" title="Permanent link">&para;</a></h3>
<p>浏览器JavaScript当中window是全局对象，NodeJS中全局对象是global，global最根本的作用是作为全局变量的宿主（即所有的全局变量都是global对象的属性），因此在所有模块中都可以直接使用而无需包含。</p>
<h3 id="process">Process模块<a class="headerlink" href="#process" title="Permanent link">&para;</a></h3>
<p>process是全局变量(即global对象的属性)，用于描述当前NodeJS进程状态。</p>
<h3 id="console">Console模块<a class="headerlink" href="#console" title="Permanent link">&para;</a></h3>
<p>console用于提供控制台标准输出。</p>
<p><code>console.log()</code>：向标准输出流打印字符并以换行符结束(<em>如果只有1个参数，则输出该参数的字符串形式；如果有2个参数，则以类似于C语言<code>printf()</code>的格式化输出</em>)。</p>
<p><code>console.error()</code>：与<code>console.log()</code>的用法相同，只是向标准错误流进行输出。</p>
<p><code>console.trace()</code>：向标准错误流输出当前的调用栈:</p>
<div class="highlight"><pre><span></span><code>$ node app.js
Trace
    at Object.&lt;anonymous&gt; <span class="o">(</span>/workspace/app.js:1:71<span class="o">)</span>
    at Module._compile <span class="o">(</span>module.js:643:30<span class="o">)</span>
    at Object.Module._extensions..js <span class="o">(</span>module.js:654:10<span class="o">)</span>
    at Module.load <span class="o">(</span>module.js:556:32<span class="o">)</span>
    at tryModuleLoad <span class="o">(</span>module.js:499:12<span class="o">)</span>
    at Function.Module._load <span class="o">(</span>module.js:491:3<span class="o">)</span>
    at Function.Module.runMain <span class="o">(</span>module.js:684:10<span class="o">)</span>
    at startup <span class="o">(</span>bootstrap_node.js:187:16<span class="o">)</span>
    at bootstrap_node.js:608:3
</code></pre></div>

<h3 id="util">Util模块<a class="headerlink" href="#util" title="Permanent link">&para;</a></h3>
<p>util提供常用函数集合，用于弥补核心JavaScript功能方面的不足。</p>
<h3 id="events">Events模块<a class="headerlink" href="#events" title="Permanent link">&para;</a></h3>
<p><code>events</code>是NodeJS最重要的模块，因为NodeJS本身就是基于事件式的架构，该模块提供了唯一接口，所以堪称NodeJS事件编程的基石。<code>events</code>模块不仅用于与下层的事件循环交互，还几乎被所有的模块所依赖。</p>
<p><code>events</code>模块只提供1个<code>events.EventEmitter</code>对象，<code>EventEmitter</code>对象封装了事件发射和事件监听器。每个<code>EventEmitter</code>事件由1个事件名和若干参数组成，事件名是1个字符串。<code>EventEmitter</code>对每个事件支持若干监听器，事件发射时，注册至该事件的监听器依次被调用，事件参数将作为回调函数参数传递。</p>
<p>下面例子中，<code>emitter</code>为事件<code>targetEvent</code>注册2个事件监听器，然后发射<code>targetEvent</code>事件，结果2个事件监听器的回调函数被依次先后调用。</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">events</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;events&quot;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">emitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">events</span><span class="p">.</span><span class="nx">EventEmitter</span><span class="p">();</span>

<span class="nx">emitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;targetEvent&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;listener1&quot;</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">emitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;targetEvent&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;listener2&quot;</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">emitter</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">&quot;targetEvent&quot;</span><span class="p">,</span> <span class="s2">&quot;Hank&quot;</span><span class="p">,</span> <span class="mi">2018</span><span class="p">);</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>$ node app.js
listener1 Hank <span class="m">2018</span>
listener2 Hank <span class="m">2018</span>
</code></pre></div>

<h4>EventEmitter常用API</h4>
<ul>
<li><code>EventEmitter.on(event, listener)</code>：为指定事件注册监听器，接受1个字符串事件名event和1个回调函数listener。</li>
<li><code>EventEmitter.emit(event,[arg1],[arg2],[...])</code>：发射event事件，传递若干可选参数到事件监听器的参数列表。</li>
<li><code>EventEmitter.once(event, listener)</code>：为指定事件注册1个单次监听器，即该监听器最多只会触发一次，触发后立刻解除。</li>
<li><code>EventEmitter.removeListener(event, listener)</code>：移除指定事件的某个监听器，listener必须是该事件已经注册过的监听器。</li>
<li><code>EventEmitter.removeAllListeners([event])</code>：移除所有事件的所有监听器，如果指定event，则移除指定事件的所有监听器。</li>
</ul>
<h3 id="file-system">File System模块<a class="headerlink" href="#file-system" title="Permanent link">&para;</a></h3>
<p><code>fs</code>模块封装了文件操作，提供了文件读取、写入、更名、删除、遍历、链接等POSIX文件系统操作，该模块中所有操作都提供了异步和同步2个版本。</p>
<p><code>fs.readFile(filename,[encoding],[callback(err,data)])</code>用于读取文件，第1个参数<code>filename</code>表示要读取的文件名。第2个参数<code>encoding</code>表示文件的字符编码，第3个参数<code>callback</code>是回调函数，用于接收文件内容。</p>
<p>回调函数提供<code>err</code>和<code>data</code>两个参数，<code>err</code>表示有无错误发生，<code>data</code>是文件内容。如果指定<code>encoding</code>，<code>data</code>将是1个解析后的字符串，否则<code>data</code>将会是以<code>Buffe</code>r`形式表示的二进制数据。</p>
<h4>fs.readFileSync()</h4>
<p>NodeJS提供的<code>fs.readFileSync()</code>函数是<code>readFile()</code>的同步版本，两者接受的参数相同，读取到的文件内容会以函数返回值形式返回。如果有错误发生<code>fs</code>将会抛出异常，需要使用<code>try...catch</code>捕捉并处理异常。</p>
<blockquote>
<p>与同步I/O函数不同，NodeJS中异步函数大多没有返回值。</p>
</blockquote>
<h4>fs.open()</h4>
<p><code>fs.open(path,flags,[mode],[callback(err,fd)])</code>封装了POSIX的<code>open()</code>函数，与C语言标准库中<code>fopen()</code>函数类似。该函数接受2个必选参数，第1个参数<code>path</code>为文件路径，第2个参数<code>flags</code>代表文件打开模式，第3个参数<code>mode</code>用于创建文件时给文件指定权限（<em>默认0666</em>），第4个参数是**回调函数**，函数中需要传递文件描述符<code>fd</code>。</p>
<h4>fs.read()</h4>
<p><code>fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])</code>封装了POSIX的read函数，相比<code>fs.readFile()</code>提供了更底层的接口。</p>
<p><code>fs.read()</code>的功能是从指定的文件描述符fd中读取数据并写入<code>buffer</code>指向的缓冲区对象。<code>offset</code>是<code>buffer</code>的写入偏移量。<code>length</code>是要从文件中读取的字节数。<code>position</code>是文件读取的起始位置，如果<code>position</code>的值为<code>null</code>，则会从当前文件指针的位置读取。回调函数传递<code>bytesRead</code>和<code>buffer</code>，分别表示读取的**字节数**和**缓冲区对象**。</p>
<h3 id="http">Http模块<a class="headerlink" href="#http" title="Permanent link">&para;</a></h3>
<p>NodeJS标准库提供的<code>http</code>模块封装了一个高效的HTTP服务器<code>http.Server</code>和一个简易的HTTP客户端<code>http.request</code>。</p>
<p><code>http</code>模块中的HTTP服务器对象，核心由NodeJS底层依靠C++实现，接口使用JavaScript封装，兼顾了高性能与简易性。</p>
<h2 id="nodejs_3">五、创建Node.js应用<a class="headerlink" href="#nodejs_3" title="Permanent link">&para;</a></h2>
<h3 id="nodehttp">使用Node创建http服务器<a class="headerlink" href="#nodehttp" title="Permanent link">&para;</a></h3>
<p>使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;http&quot;</span><span class="p">);</span>
</code></pre></div>

<p>使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">hostname</span> <span class="o">=</span> <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">port</span> <span class="o">=</span> <span class="mi">8080</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">setHeader</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 终端打印如下信息</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">,</span> <span class="nx">hostname</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Server running at http://</span><span class="si">${</span><span class="nx">hostname</span><span class="si">}</span><span class="sb">:</span><span class="si">${</span><span class="nx">port</span><span class="si">}</span><span class="sb">/`</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>

<p>以上代码我们完成了一个可以工作的 HTTP 服务器。使用 <strong>node</strong> 命令执行以上的代码：</p>
<div class="highlight"><pre><span></span><code><span class="nx">node</span> <span class="nx">server</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">Server</span> <span class="nx">running</span> <span class="nx">at</span> <span class="nx">http</span><span class="o">:</span><span class="c1">//127.0.0.1:8080/</span>
</code></pre></div>

<p>打开浏览器访问 <code>http://127.0.0.1:8080/</code>，会看到一个写着 "Hello World"的网页。</p>
<h3 id="webexpress">web框架express简单使用<a class="headerlink" href="#webexpress" title="Permanent link">&para;</a></h3>
<p>express 是 Node应用最广泛的快速、开放、极简主义 web 框架，现在是 4.x 版本。官方提供了应用程序生成器工具 express-generator 可以快速创建应用程序骨架。安装：</p>
<div class="highlight"><pre><span></span><code>npm install express --save
npm install express-generator -g
</code></pre></div>

<p>创建名称为 <em>ExpressDemo</em> 的 Express 应用。此应用将在当前目录下的 <em>ExpressDemo</em> 目录中创建，并且设置为使用 <a href="https://pugjs.org/">Pug</a> 模板引擎：</p>
<div class="highlight"><pre><span></span><code>express --view<span class="o">=</span>pug ExpressDemo

   create : ExpressDemo/
   create : ExpressDemo/public/
   create : ExpressDemo/public/javascripts/
   create : ExpressDemo/public/images/
   create : ExpressDemo/public/stylesheets/
   create : ExpressDemo/public/stylesheets/style.css
   create : ExpressDemo/routes/
   create : ExpressDemo/routes/index.js
   create : ExpressDemo/routes/users.js
   create : ExpressDemo/views/
   create : ExpressDemo/views/error.pug
   create : ExpressDemo/views/index.pug
   create : ExpressDemo/views/layout.pug
   create : ExpressDemo/app.js
   create : ExpressDemo/package.json
   create : ExpressDemo/bin/
   create : ExpressDemo/bin/www

   change directory:
     $ <span class="nb">cd</span> ExpressDemo

   install dependencies:
     $ npm install

   run the app:
     $ <span class="nv">DEBUG</span><span class="o">=</span>expressdemo:* npm start
</code></pre></div>

<p>按提示安装依赖并启动。</p>
<div class="highlight"><pre><span></span><code><span class="nb">cd</span> ExpressDemo
npm install
<span class="nv">DEBUG</span><span class="o">=</span>expressdemo:* npm start  <span class="c1"># MacOS</span>
</code></pre></div>

<p>在浏览器中打开 <code>http://localhost:3000/</code> 就可以看到这个应用了。</p>
<p>通过生成器创建的应用一般都有如下目录结构：</p>
<div class="highlight"><pre><span></span><code>tree -I <span class="s2">&quot;node_modules&quot;</span>
.
├── app.js
├── bin
│   └── www
├── package-lock.json
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

<span class="m">7</span> directories, <span class="m">10</span> files
</code></pre></div>

<h2 id="promise-async">六、异步编程方案（Promise &amp; Async）<a class="headerlink" href="#promise-async" title="Permanent link">&para;</a></h2>
<p>异步是Node得天独厚的特点和优势，但我们经常还是会需要解决同步执行的场景。如方法A执行完才可以执行方法B。如下面这个例子：</p>
<div class="highlight"><pre><span></span><code><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">3000</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">);</span>
</code></pre></div>

<p>执行结果为:</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span>Running<span class="o">]</span> node <span class="s2">&quot;test.js&quot;</span>
B
A
<span class="o">[</span>Done<span class="o">]</span> exited with <span class="nv">code</span><span class="o">=</span><span class="m">0</span> in <span class="m">3</span>.12 seconds
</code></pre></div>

<p>如果想要输出结果为 <code>A B</code>，可以采取 <code>Promise</code> 或 <code>Async</code> 来实现。</p>
<h3 id="promise">基于Promise实现同步控制<a class="headerlink" href="#promise" title="Permanent link">&para;</a></h3>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。ES6 原生提供了<code>Promise</code>对象，提供统一的 API，各种异步操作都可以用同样的方法进行处理。示例如下：</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">);</span>
        <span class="nx">resolve</span><span class="p">();</span>
    <span class="p">},</span> <span class="mi">3000</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">);</span>
<span class="p">},</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Err&#39;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>

<p>执行结果：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span>Running<span class="o">]</span> node <span class="s2">&quot;test.js&quot;</span>
A
B
<span class="o">[</span>Done<span class="o">]</span> exited with <span class="nv">code</span><span class="o">=</span><span class="m">0</span> in <span class="m">3</span>.123 seconds
</code></pre></div>

<p>可以把 <code>Promise</code> 对象比喻为一个容器，里面有一个异步操作，<code>Promise</code> 容器只有在收到信号（resolve或者reject）时才会调用then方法。通过 <code>Promise.All</code>方法将多个Promise对象实例包装，生成并返回一个新的Promise实例，等执行完所有异步操作之后执行then方法：</p>
<div class="highlight"><pre><span></span><code><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">();</span>
  <span class="p">},</span> <span class="mi">3000</span><span class="p">);</span>
<span class="p">});</span>

<span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">();</span>
  <span class="p">},</span> <span class="mi">3000</span><span class="p">);</span>
<span class="p">});</span>


<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]).</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>

<p>执行结果如下：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span>Running<span class="o">]</span> node test.js
A
B
end

<span class="o">[</span>Done<span class="o">]</span> exited with <span class="nv">code</span><span class="o">=</span><span class="m">0</span> in <span class="m">3</span>.122 seconds
</code></pre></div>

<h4>Promise 扩展信息</h4>
<p><code>Promise</code> 构造函数接受一个函数作为参数，该函数两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 avaScript 引擎提供。<code>resolve</code> 函数在异步操作成功时用，其作用是将<code>Promise</code>对象的状态从“pending”变为resolved”，并将异步操作的结果作为参数传递出去；<code>reject函数在异步操作失败时调用，其作用是将</code>Promise`对象的状态从pending”变为“rejected”，并将异步操作报出的错误作为参传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定resolved<code>状态和</code>rejected<code>状态的回调函数。</code>then<code>方法以接受两个回调函数作为参数，第一个回调函数是</code>Promise<code>对的状态变为</code>resolved<code>时调用，第二个回调函数（可选提供）是Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都受<code>Promise</code>对象传出的值作为参数。</p>
<p><img alt="Promise状态转换图" src="https://pic.lixl.cn/2020/20200308170211.png" /></p>
<p><code>Promise</code>对象有以下两个特点。</p>
<ul>
<li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就会一直保持不再改变,称为 resolved。</li>
</ul>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="s1">&#39;done.&#39;</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">);</span>  <span class="c1">//会立即执行</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="nx">f</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`resolve result: </span><span class="si">${</span><span class="nx">result</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}),</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`reject error: </span><span class="si">${</span><span class="nx">error</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>

<p>上面代码中，<code>f1</code>方法返回一个<code>Promise</code>实例，表示一段时以后才会发生的结果。过了指定的时间（3000毫秒）以后，Promise<code>实例的状态为</code>resolved<code>，就会触发</code>then`方法定的回调函数。执行结果如下:</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span>Running<span class="o">]</span> node <span class="s2">&quot;test.js&quot;</span>
A
resolve result: <span class="k">done</span>.
<span class="o">[</span>Done<span class="o">]</span> exited with <span class="nv">code</span><span class="o">=</span><span class="m">0</span> in <span class="m">3</span>.175 seconds
</code></pre></div>

<p>另外，<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例。<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<blockquote>
<p>Promise也有一些缺点。首先是无法取消，一旦新建它就会立即执行，无法中途取消；其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段。</p>
</blockquote>
<h3 id="async">基于Async实现同步控制<a class="headerlink" href="#async" title="Permanent link">&para;</a></h3>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。随着Node.js 8的发布，期待已久的async函数也在其中默认实现了。async 函数的实现原理，是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变（除非遇到<code>return</code>语句或者抛出错误），再接着执行函数体内后面的语句。看下面这个例子:</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="s1">&#39;Hello&#39;</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nx">async</span> <span class="kd">function</span> <span class="nx">asyncF</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//前面的 `async` 关键字，表明该函数内部有异步操作。</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">);</span>
  <span class="nx">await</span> <span class="nx">f</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span> <span class="c1">// return语句的返回值，会成为`then`方法回调函数的参数。</span>
<span class="p">}</span>

<span class="nx">asyncF</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">));</span>
</code></pre></div>

<p>执行结果如下:</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span>Running<span class="o">]</span> node <span class="s2">&quot;test.js&quot;</span>
B      <span class="c1">#立即输出</span>
A      <span class="c1">#立即输出</span>
Hello  <span class="c1">#3秒后输出</span>
C
world
<span class="o">[</span>Done<span class="o">]</span> exited with <span class="nv">code</span><span class="o">=</span><span class="m">0</span> in <span class="m">3</span>.165 seconds
</code></pre></div>

<p><code>async</code> 函数的<code>await</code>命令后面，可以是 Promise 对象或原始类型的值（数值、字符串和布尔值，但会自动转成立即 resolved 的 Promise 对象）。</p>
<p><code>sync</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。如下面这个例子：</p>
<div class="highlight"><pre><span></span><code><span class="nx">async</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
<span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;发生异常&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span>
<span class="nx">result</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`resolve result: </span><span class="si">${</span><span class="nx">result</span><span class="si">}</span><span class="sb">`</span><span class="p">),</span>
<span class="nx">error</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>

<p>执行结果：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span>Running<span class="o">]</span> node <span class="s2">&quot;test.js&quot;</span>
Error: 发生异常
 at f <span class="o">(</span>/Users/lixl.cn/nodework/blog/test.js:4:9<span class="o">)</span>
 at Object.&lt;anonymous&gt; <span class="o">(</span>/Users/lixl.cn/nodework/blog/test.js:7:1<span class="o">)</span>
 at Module._compile <span class="o">(</span>internal/modules/cjs/loader.js:701:30<span class="o">)</span>
 at Object.Module._extensions..js <span class="o">(</span>internal/modules/cjs/loader.js:712:10<span class="o">)</span>
 at Module.load <span class="o">(</span>internal/modules/cjs/loader.js:600:32<span class="o">)</span>
 at tryModuleLoad <span class="o">(</span>internal/modules/cjs/loader.js:539:12<span class="o">)</span>
 at Function.Module._load <span class="o">(</span>internal/modules/cjs/loader.js:531:3<span class="o">)</span>
 at Function.Module.runMain <span class="o">(</span>internal/modules/cjs/loader.js:754:12<span class="o">)</span>
 at startup <span class="o">(</span>internal/bootstrap/node.js:283:19<span class="o">)</span>
 at bootstrapNodeJSCore <span class="o">(</span>internal/bootstrap/node.js:622:3<span class="o">)</span>

<span class="o">[</span>Done<span class="o">]</span> exited with <span class="nv">code</span><span class="o">=</span><span class="m">0</span> in <span class="m">0</span>.153 seconds
</code></pre></div>

<h2 id="eslint">七、基于ESLint保障质量<a class="headerlink" href="#eslint" title="Permanent link">&para;</a></h2>
<p>JavaScript 是一个动态的弱类型语言，在开发中比较容易出错，一般会借助 Lint 工具来保障质量。</p>
<p><code>ESLint</code> 是新一代开源 JavaScript 代码检查工具，使用 Node.js 编写，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 全局安装 ESLint</span>
npm install -g eslint

<span class="c1"># 进入项目</span>
<span class="nb">cd</span> ~/NodeWork/NodeDemo

<span class="c1"># 初始化 package.json</span>
npm init -f

<span class="c1"># 初始化 ESLint 配置</span>
eslint --init
</code></pre></div>

<p>通过 Lint 工具可以让我们：</p>
<ul>
<li>避免低级bug，找出可能发生的语法错误</li>
<li>提示删除多余的代码</li>
<li>确保代码遵循最佳实践 (可参考 <a href="https://github.com/airbnb/javascript">airbnb style</a>、<a href="https://github.com/standard/standard">javascript standard</a>)</li>
<li>统一团队的代码风格</li>
</ul>
<p>项目初始化完毕，可以开始在 <code>ESLint</code> 的提示下，高质量编写代码了。</p>
<h2 id="_6">八、参考<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<ul>
<li>Node官方文档：<a href="https://nodejs.org/zh-cn/docs/">https://nodejs.org/zh-cn/docs/</a></li>
<li>express官网：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a></li>
<li>ESLint官方指南： <a href="https://cn.eslint.org/docs/user-guide/getting-started">https://cn.eslint.org/docs/user-guide/getting-started</a></li>
<li>深入浅出Node.js：<a href="https://book.douban.com/subject/25768396/">https://book.douban.com/subject/25768396/</a></li>
<li>ECMAScript 6 入门：<a href="http://es6.ruanyifeng.com/">http://es6.ruanyifeng.com/</a></li>
</ul>
                
                  
                
              
              
                <!--读取配置文件-->

<!--meta可以覆盖全局配置-->


<!--首页不显示-->


  <!--outline-->
  <h2 id="__comments" data-no-instant>评论</h2>
  <form id="gitalk-form" onsubmit="return false;" data-no-instant>
    <div id="gitalk-container" data-no-instant></div>
  </form>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/blueimp/JavaScript-MD5@latest/js/md5.min.js"></script>
  <script>
    const gitalk = new Gitalk({
      clientID: 'd032ec0dfbe5a4b4ec6f',
      clientSecret: 'afe793d53f24ebd7f53d0eb4dd21f3bc706dab06',
      repo: 'site',  // 使用单独的仓评论
      owner: 'lxl80',  // 仓库所有者
      admin: ['lxl80'],  // 仓库管理员列表
      id: md5(location.pathname),
      distractionFreeMode: false,  // 全屏遮罩效果
      pagerDirection: 'last'  // 排序方式：first按评论创建时间正序，last倒序
    })
    gitalk.render('gitalk-container')
  </script>

              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="">
        
          <a href="../Electron%E6%9E%84%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8/" title="Electron构建跨平台应用" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" /></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                Electron构建跨平台应用
              </div>
            </div>
          </a>
        
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            &copy; 2020 悟尘纪  　|　基于
            <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
              Material for MkDocs</a> 构建　|　<a href="http://www.beian.miit.gov.cn/">冀ICP备20001325号</a>
          </div>
        
      </div>
      
  <div class="md-footer-social">
    
      
      
      <a href="https://github.com/lxl80" target="_blank" rel="noopener" title="github.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
      </a>
    
      
      
      <a href="https://twitter.com/lxl823" target="_blank" rel="noopener" title="twitter.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
      </a>
    
      
      
      <a href="https://www.linkedin.com/in/lxl" target="_blank" rel="noopener" title="www.linkedin.com" class="md-footer-social__link">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z"/></svg>
      </a>
    
  </div>

    </div>
  </div>
</footer>
  
      
    </div>
    
      <script src="../../assets/javascripts/vendor.36cbf620.min.js"></script>
      <script src="../../assets/javascripts/bundle.00c583dd.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "", "search.config.separator": "[\\uff0c\\u3002]+", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.7f7c8775.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="../../extra/baidu-tongji.js"></script>
      
    
  </body>
</html>