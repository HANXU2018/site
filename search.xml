<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo-admonition 插件安装使用指南</title>
      <link href="/2020/041837756.html"/>
      <url>/2020/041837756.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hexo 内容辅助插件，支持将类似 <a href="https://docutils.sourceforge.io/docs/ref/rst/directives.html" target="_blank" rel="noopener">reStructuredText</a> 的警告提示块添加到 Markdown 文档中。例如 note、warning、error 等提示块，如图：</p><p><img src="https://pic.lixl.cn/2020/image-20200419230838823.png" alt="hexo-admonition 示例效果"></p><p>开发这个插件的动机，是想让 hexo 与 mkdocs 的提示信息兼容，让系列文章在基于 mkdocs 搭建的子站中有更好的阅读体验。<br>查看更多内容，请访问博文：<a href="https://www.lixl.cn/2020/041837756.html">hexo-admonition 插件安装使用指南</a>。</p><h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-admonition --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><p>admonition 遵循一种简单的语法：每个块都以 <code>!!!</code> 开头，然后是代表提示类型的关键字（<code>type</code>）及标题（<code>title</code>）。例如:</p><pre class="line-numbers language-text"><code class="language-text">!!! note "Hexo-admonition 插件使用示例"    这是基于 hexo-admonition 插件渲染的一条提示信息。类型为 note，并设置了自定义标题。    提示内容开头留 4 个空格，可以有多行，最后用空行结束此标记。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 hexo 渲染前，将被转换成如下内容：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>admonition note <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>admonition-title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hexo-admonition 插件使用示例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是基于 hexo-admonition 插件渲染的一条提示信息。类型为 note，并设置了自定义标题。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>提示内容开头留 4 个空格，可以有多行，最后用空行结束此标记。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终呈现效果如下：</p><p><img src="https://pic.lixl.cn/2020/image-20200419231541395.png" alt="hexo-admonition 插件 note 提示示例"></p><h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><p>提示类型 <code>type</code> 将用作 CSS 类名称，暂支持如下类型：</p><ul><li><code>note</code></li><li><code>info, todo</code></li><li><code>warning, attention, caution</code></li><li><code>error, failure, missing, fail</code></li></ul><h3 id="设置-隐藏标题"><a href="#设置-隐藏标题" class="headerlink" title="设置/隐藏标题"></a>设置/隐藏标题</h3><p>标题 <code>title</code> 是可选的，当未设置时，将以 <code>type</code> 作为默认值:</p><pre class="line-numbers language-text"><code class="language-text">!!! warning    这是一条采用默认标题的警告信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>效果如下：</p><p><img src="https://pic.lixl.cn/2020/image-20200419232137875.png" alt="默认标题警告提示块"></p><p>如果不想显示标题，可以将 <code>title</code> 设置为 <code>&quot;&quot;</code>：</p><pre class="line-numbers language-text"><code class="language-text">!!! Warning ""    这是一条不带标题的警告信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>效果如下：</p><p><img src="https://pic.lixl.cn/2020/image-20200419232337937.png" alt="无标题警告提示块"></p><h3 id="嵌套-markdown-标记"><a href="#嵌套-markdown-标记" class="headerlink" title="嵌套 markdown 标记"></a>嵌套 markdown 标记</h3><p>在 <code>hexo-admonition</code> 内部，还可以嵌套标准 Markdown 标签，例如：</p><pre class="line-numbers language-text"><code class="language-text">!!! node "嵌套链接及引用块"    欢迎访问我的博客链接：[悟尘纪](https://www.lixl.cn)    >这里嵌套一行引用信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下:</p><p><img src="https://pic.lixl.cn/2020/image-20200419232539536.png" alt="嵌套效果"></p><h3 id="样式配置"><a href="#样式配置" class="headerlink" title="样式配置"></a>样式配置</h3><p>将如下样式放入 hexo 主题的自定义样式文件中（如：<code>my.css</code>），并按自己喜好修改：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.admonition</span> </span><span class="token punctuation">{</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">1.5625</span>em <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">.6</span>rem<span class="token punctuation">;</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">.64</span>rem<span class="token punctuation">;</span>  <span class="token property">page-break-inside</span><span class="token punctuation">:</span> avoid<span class="token punctuation">;</span>  <span class="token property">border-left</span><span class="token punctuation">:</span> <span class="token number">.3</span>rem solid <span class="token hexcode">#42b983</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">.3</span>rem<span class="token punctuation">;</span>  <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0.1</span>rem <span class="token number">0.4</span>rem <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>,<span class="token number">0</span>,<span class="token number">0</span>,<span class="token number">.05</span><span class="token punctuation">)</span>, <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0.05</span>rem <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>,<span class="token number">0</span>,<span class="token number">0</span>,<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#fafafa</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">p<span class="token class">.admonition-title</span> </span><span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> -<span class="token number">.6</span>rem -<span class="token number">.6</span>rem <span class="token number">.8</span>em -<span class="token number">.6</span>rem <span class="token important">!important</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">.4</span>rem <span class="token number">.6</span>rem <span class="token number">.4</span>rem <span class="token number">2.5</span>rem<span class="token punctuation">;</span>  <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">700</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">66</span>, <span class="token number">185</span>, <span class="token number">131</span>, <span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">.9</span>rem<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">1</span>rem<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#42b983</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.info</span>><span class="token class">.admonition-title</span>, <span class="token class">.todo</span>><span class="token class">.admonition-title</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>,<span class="token number">184</span>,<span class="token number">212</span>,<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.warning</span>><span class="token class">.admonition-title</span>, <span class="token class">.attention</span>><span class="token class">.admonition-title</span>, <span class="token class">.caution</span>><span class="token class">.admonition-title</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>,<span class="token number">145</span>,<span class="token number">0</span>,<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.failure</span>><span class="token class">.admonition-title</span>, <span class="token class">.missing</span>><span class="token class">.admonition-title</span>, <span class="token class">.fail</span>><span class="token class">.admonition-title</span>, <span class="token class">.error</span>><span class="token class">.admonition-title</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>,<span class="token number">82</span>,<span class="token number">82</span>,<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition.info</span>, <span class="token class">.admonition.todo</span> </span><span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> <span class="token hexcode">#00b8d4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition.warning</span>, <span class="token class">.admonition.attention</span>, <span class="token class">.admonition.caution</span> </span><span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ff9100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition.failure</span>, <span class="token class">.admonition.missing</span>, <span class="token class">.admonition.fail</span>, <span class="token class">.admonition.error</span> </span><span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ff5252</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.info</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>, <span class="token class">.todo</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#00b8d4</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.warning</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>, <span class="token class">.attention</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>, <span class="token class">.caution</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ff9100</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.failure</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>,<span class="token class">.missing</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>,<span class="token class">.fail</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>,<span class="token class">.error</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span></span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ff5252</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition</span>><span class="token pseudo-class">:last-child</span> </span><span class="token punctuation">{</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://squidfunk.github.io/mkdocs-material/extensions/admonition/" target="_blank" rel="noopener">Material for MkDocs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨团队、流程和应用的主动变革，支撑企业数字化转型</title>
      <link href="/2020/032252398.html"/>
      <url>/2020/032252398.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>如今已既成事实的是每家公司其实都是软件公司，快速向客户提供新服务和新功能是公司的关键竞争优势之一。IT 敏捷性是有些初创公司能战胜巨头的基石。</p><p>对于以基础架构为中心的环境而言，其结果之一就是开发人员对自己代码的用途失去了感知力。产品的发布周期较长，而更改速度较慢。在开发人员完成相关工作后，代码将进入测试或运转流程，然后要在数月之后才能发布。由于前期准备时间长，工程师失去了作为开发人员的乐趣，也就是做出创造性工作并见证它在现实生活中发挥作用的乐趣。</p><p>数字化转型以及相关的文化和技术变革（例如 DevOps）所引发的巨变之一，就是重新带来了创建代码的乐趣。开发人员可以创建代码并实际看到运行。这是一种巨大的转变。使得代码创建的即时性得到重现。由于能实时查看应用，从而为开发人员员提供了一个反馈回路，藉此可以让他们重新设计和改进代码，并实现项目的快速推进。</p><h2 id="二、数字化转型意味着什么"><a href="#二、数字化转型意味着什么" class="headerlink" title="二、数字化转型意味着什么"></a>二、数字化转型意味着什么</h2><p>数字化转型是企业的一种战略性变革。促使公司在竞争压力发生变化或新法规出台时能够调整核心服务，在发现漏洞后可以立即推出更新。</p><p>但是，除了“改变现状”之外，还没有数字化转型的通用定义。数字化转型一词有时用于表示新的架构（如微服务）、新的流程（如 DevOps）或新的技术（如容器和应用编程接口（API））。数字化转型并不是某个能够实现的具体目标。这是一种每个企业都必须为自己量身定制的东西。</p><p>没有任何一个架构模式或技术平台可以完美地应用于各种环境。成功实现数字化转型需要清楚地了解企业目标和文化。关键点不在于专注某种模式或某项技术，而是从团队、当前技术债务及业务策略的评估入手，专心致志地按照既定方向将企业向前推进，最终得到想要的结果。</p><p>借助明确的目标和策略，无论现在处于什么状况，都可以不断克服困难（技术债务、设计缺陷等等），实现所设想的进化。这意味着您必须清楚地了解自己所要完成的任务以及与现实之间的差距。</p><h2 id="三、注意房间内的大象"><a href="#三、注意房间内的大象" class="headerlink" title="三、注意房间内的大象"></a>三、注意房间内的大象</h2><p>评估当前的技术前景并完善业务策略绝非易事，往往很难得到这种视角。有一个众所周知的寓言是 “盲人摸象”。故事的重点在于每个人都有不同的观点、有限的信息，以及基于上述观点的假设。这些不同观点所引发的结果说明了团队内部的内在沟通和关系⸺有些可以跳出自己的观点局限，有些则分崩离析。我们所看到的取决于我们是谁、我们在哪里、我们要寻找什么、我们知道什么，以及我们不知道什么。</p><p>任何采用传统应用（和传统团队）的企业，其房间内不止有一只“大象”，其中包括：</p><ul><li>当前的团队结构和沟通模式。</li><li>开发、测试、构建和发布流程。</li><li>技术债务和现有的商用应用。</li><li>部门之间的目标或战略愿景不同。</li></ul><p>这些都是大象，而每个利益相关者都可以从不同的角度看待这些大象。</p><h2 id="四、数字化转型的达尔文进化论观点"><a href="#四、数字化转型的达尔文进化论观点" class="headerlink" title="四、数字化转型的达尔文进化论观点"></a>四、数字化转型的达尔文进化论观点</h2><p>不同类型的改变可能需要不同的基础性变革，有时可能还取决于文化和流程的改变。 罗马不是一日建成的，将数字化转型视为一个逐层推进、环环相扣的连续过程，可能会更具建设性。</p><p><img src="https://pic.lixl.cn/2020/image-20200322163913398.png" alt="“数字进化论主义”的各个阶段"></p><h3 id="1、DevOps-与流程改变"><a href="#1、DevOps-与流程改变" class="headerlink" title="1、DevOps 与流程改变"></a>1、DevOps 与流程改变</h3><p>数字进化的基础是 DevOps。和业务策略一样，应用也体现了创建过程中团队及沟通的情况。DevOps（或类似的流程改变）让更多的利益相关者参与到开发讨论中，并提供了有关运营团队如何维护软件和基础架构（以及客户和合作伙伴如何实际使用这些应用）的深入见解。</p><p>DevOps 在团队之间建立了更紧密的反馈回路，并且需要开诚布公的交流。这种开诚布公的交流是其他演进阶段的基础。</p><h3 id="2、自助式基础架构"><a href="#2、自助式基础架构" class="headerlink" title="2、自助式基础架构"></a>2、自助式基础架构</h3><p>该阶段是一种以技术为中心的变革，旨在引入通常与现代化技术平台相关联的高效率。容器和自助服务目录使开发人员、测试人员和运营团队可以快速启动一致的环境。在有些企业中，新实例的交付时间已从几天缩短到几分钟，而不是让技术人员等待几天。</p><h3 id="3、构建自动化和编排"><a href="#3、构建自动化和编排" class="headerlink" title="3、构建自动化和编排"></a>3、构建自动化和编排</h3><p>构建自动化涉及两方面的改变。从技术角度看，可以采用如 Kubernetes 等高级部署引擎，但也需要流程的改变。许多企业都围绕变更和风险管理制定了严格的流程。如果不对这些流程采用更敏捷的方法，就无法充分利用新的技术。</p><h3 id="4、持续集成-持续交付-CI-CD-管道"><a href="#4、持续集成-持续交付-CI-CD-管道" class="headerlink" title="4、持续集成/持续交付 (CI/CD) 管道"></a>4、持续集成/持续交付 (CI/CD) 管道</h3><p>持续交付就是承诺以快速、迭代的方式交付软件变更。管道的思路是：同时采用流程和技术手段，减少不良代码（或损坏的代码）从制作到部署的风险。它反映了先前步骤（DevOps 以及团队之间的开放式交流、围绕测试和构建的流程，以及自动测试与部署）的成熟度。待所有这些阶段都确定之后，就有可能快速推送代码。这就是管道。</p><h3 id="5、高级部署路径"><a href="#5、高级部署路径" class="headerlink" title="5、高级部署路径"></a>5、高级部署路径</h3><p>一旦用于快速部署的流程和基础架构就位，便可以使用部署系统来减轻更新所带来的任何风险， 评估功能的有效性，并为新想法提供实实在在的测试基础。这其中可以包括在部署过程中（蓝绿部署）采用独立的环境并在它们之间进行负载平衡，使用两个不同的环境来测试用户交互（A/B 测试），或向少数用户推出更新并安全地增加用户数量 （金丝雀发布）。</p><h3 id="6、微服务（或分布式系统）"><a href="#6、微服务（或分布式系统）" class="headerlink" title="6、微服务（或分布式系统）"></a>6、微服务（或分布式系统）</h3><p>微服务是一种执行离散、功能单一的小型应用。整个应用架构可能需要执行数十个或数百个不同的功能，而且每一项功能都要在微服务中定义和编排。微服务架构（或任何分布式计算架构）既复杂又简单。单个服务更为简单，更易于维护、添加和停用，但总体架构却更为复杂。如果做法得当，“基于微服务的设计就会成为您所学优秀应用设计的最终体现”。这种高度分散型架构可以更轻松地进行扩展，更容易引入新的服务或更新，并且降低了系统范围故障的风险。</p><blockquote><p><strong>微服务是一种必需的状态吗？</strong></p><p>鉴于维护的复杂性，数字化演进的最后阶段是微服务。但是，企业演进的最后阶段一定要是微服务吗？</p><p>未必。</p><p>如果演进的其他方面都到位， 那么单体式架构仍可以每周发布一次，并使用高级部署技术、CI/CD 和分布式可扩展基础架构。只有在团队规模较大且需要比按周发布更快的速度，或需要按不同的时间表进行发布时，才应考虑微服务。小型团队或小型代码库不需要分解为微服务代码库。</p></blockquote><h2 id="五、文化改变是前提"><a href="#五、文化改变是前提" class="headerlink" title="五、文化改变是前提"></a>五、文化改变是前提</h2><p>DevOps 将紧急、全力以赴式的工作方法转变为在团队规划、开发、测试和部署中实现更平稳、 更可持续的迭代。这是 DevOps 团队在效率方面实现天文数字式增长的原因所在。</p><p>值得注意的关键点是达尔文（软件）进化过程不只是技术的改变。流程和人员的改变以及基础架构的改变交替发生，而文化的革新更是首当其冲。</p><blockquote><p>康威定律：“任何采用系统设计的企业，其设计结构最终都会不可避免地与该企业的沟通结构相一致。” 针对这方面，有两个彼此相关的解释：</p><ul><li>除非也改变沟通结构，否则单纯改变架构或基础架构不会带来任何改变。</li><li>无论基础架构如何，改变沟通结构都会带来流程和基础架构的改进。</li></ul></blockquote><p>Gartner 实际上有这方面的数据：“有 90% 尝试使用 DevOps 、但没有针对性地解决自身文化基础的企业会走向失败。”</p><p>DevOps 是一种文化的转变，努力打破开发人员、运维团队和业务利益相关者之间的隔阂。这种隔阂是真实存在的，但也是人为造成的。一个团队中可以不止包含工作职能相同的人员。 DevOps 试图重新定义团队，将应用生命周期中涉及的每个人员都纳入其中，并在这些团队之间实现有效沟通。</p><p>文化上的改变是所有技术和流程改变的基础。 如果您更改了沟通方式，结果也会随之而变。一些重大更改有时是从非常简单的步骤开始的。</p><p>无论您的最终应用架构是更完善的单体式应用还是分布式微服务，都需要改变团队结构和沟通方式。无论是在规划应用前还是在部署应用后，都必须确保沟通的顺畅。除非建立并启用支持开放式沟通和反馈的文化，否则按照不同的服务来划分团队很容易造成公司分化成一个个孤岛。</p><h2 id="六、应用架构设计：关注微服务"><a href="#六、应用架构设计：关注微服务" class="headerlink" title="六、应用架构设计：关注微服务"></a>六、应用架构设计：关注微服务</h2><h3 id="设计必要性、技术债务与策略选择"><a href="#设计必要性、技术债务与策略选择" class="headerlink" title="设计必要性、技术债务与策略选择"></a>设计必要性、技术债务与策略选择</h3><p>不知道该如何处理当前的应用，是企业变革的一大阻碍。这就是许多数字化转型计划考虑采用 “淘汰和替换”方法的原因之一；有些时候，重新开始似乎更容易。</p><p>但是，问题在于技术债务是设计的结果。在不清楚要替换什么的情况下拿掉一个应用，意味着同一个不被接受的架构最终还会再次出现。</p><p>您所开发的一切都是您的技术债务。对于非常新的应用，团队经常会在没有明确设计的情况下开始开发工作，这不一定是坏事。不过，也有观点认为，好的设计造就稳定发展，而没有设计则平淡无奇。</p><p><img src="https://pic.lixl.cn/2020/designStaminaGraph.gif" alt="Martin Fowler 设计持久力假设"></p><p>在开始规划架构之前，需要对战略重点和目标有非常清楚的了解。您必须确定客户或最终用户是谁，客户看重的是什么，期望的结果是什么，以及如何衡量成功。</p><ul><li>谁是您的客户或用户？</li><li>他们想要做什么？</li><li>您使用什么基础架构？</li><li>该基础架构生命周期有多长？</li><li>单个工作流有哪些服务或功能需求？</li><li>该工作流的生命周期有多长？</li><li>您的部署路径是什么？需要多久部署一次？</li><li>这会影响哪些业务功能？</li></ul><p>换句话说，不要一开始就想着如何完成某个任务或要使用哪种架构。要从战略目标开始，然后设计支持该目标的架构。</p><h3 id="微服务和单体式应用"><a href="#微服务和单体式应用" class="headerlink" title="微服务和单体式应用"></a>微服务和单体式应用</h3><p>简单来说，单体式应用就是在单个应用中包含所有功能的应用堆栈。无论是服务之间的交互还是开发与交付方式，都采用紧密耦合的形式。更新或扩展单体式应用的某个方面也会对整个应用及其基础架构产生影响。</p><p>单体式应用存在的潜在问题是动态扩展和故障转移。这些问题通常可通过简单的扩展性设计来加以解决，例如横向扩展（在集群中复制该功能）或纵向扩展（镜像实例和扩展硬件）。开发和运维团队也很少考虑可扩展性问题。如果需要一个完整的 50 人团队每 6 到 9 个月发布一个单体式应用，那么通过让五个独立的团队提供五个较小的应用并每隔几周发布一次更新，即可提高可扩展性。</p><p>考虑到最初的简单性以及服务与依赖项之间的清晰关系，单体式架构可能称得上是最古老的应用架构。该架构也更能反映有限的、基于商品的 IT 基础架构以及更严格的开发和发布流程。 由于单体式是一种较为陈旧的架构形式，因此它们常常与传统应用相关联。相比而言，更为现代化的架构则尝试按功能或业务能力来拆分服务，以带来更好的灵活性。这在面向客户的界面（如 API、移动应用或 Web 应用）中尤为常见。这些界面通常较小，需要更加频繁的更新才能满足客户的期望。</p><p>分布式架构的最新定义之一是微服务。与其他模块化设计，像面向服务的架构（SOA）有一些相似之处，但微服务将服务之间的松散耦合转变为服务独立性。通常，单个服务的定义较为明确，可以轻松地在较大的架构中添加、升级或删除服务。这对于动态可扩展性和容错能力都有一定的好处：可以在不占用大量基础架构的情况下按需扩展单个服务，或者可以在不影响其他服务的情况下进行故障转移。</p><p>哪种架构模式最为合适。下意识的反应是认为新的总是最好的，但重要的是应退后一步，评估什么最适合您想要的业务成果。Etsy 和 Netflix 的工程师就微服务持续部署和开发人员自主权的必要性在 Twitter 上展开了一场友好的辩论。Etsy 的工程师指出，他们拥有小规模、 基于功能的敏捷开发团队，可在运行单体式应用的情况下仍实现超快部署（每天约 60 次）。他们找到了一种适合自己和企业文化的系统。</p><p>对于企业而言，问题不在于我们能否用微服务来取代单体式架构，而在于我们的战略目标是什么，为了实现这一目标我们需要做些什么。了解沟通结构和文化、业务功能以及所需的工作流程之后，就会影响服务的耦合方式、服务的生命周期，以及最终的应用架构。</p><h3 id="有关分布式计算的错误见解"><a href="#有关分布式计算的错误见解" class="headerlink" title="有关分布式计算的错误见解"></a>有关分布式计算的错误见解</h3><p>必须要重视有关微服务的错误见解，原因很简单：没有任何系统是完美的。这么做的目的不是要找到解决问题的完美技术（或架构）。相反，专注于文化和沟通并不断完善流程将有助于创建一个成熟、有效的组织体系。在这个基础上，企业才有能力设计满足特定目标的有效架构。</p><h4 id="1、增加了成本和交易费用"><a href="#1、增加了成本和交易费用" class="headerlink" title="1、增加了成本和交易费用"></a>1、增加了成本和交易费用</h4><p>对于真正的分布式计算，所需的基础架构更改可能需要大量的费用。此外，还要涉及重新培训、 学习新技能、调整团队结构以及迁移系统等间接成本。当然，这部分费用将来会改善一些指标 （如上市时间和停机时间的缩短（如果有效实施了新架构）），但这些好处并非立竿见影。</p><h4 id="2、增加了复杂性"><a href="#2、增加了复杂性" class="headerlink" title="2、增加了复杂性"></a>2、增加了复杂性</h4><p>不像单体式架构那样只有单个（灾难性）故障点，微服务架构可能有数百个不同的潜在故障点。 与单体式架构类似，这些故障往往很难跟踪，因为根本原因可能并不那么明显。不过，微服务会增加额外的复杂性，因为服务之间的依赖性更不明显。 甚至更快的发布周期和更敏捷的团队结构也会增加复杂性。有效的沟通对于微服务而言至关重要。每个软件架构都要平衡内在的复杂性。这种复杂性可能隐藏在应用本身中（单体式架构）， 也可能融于团队沟通结构内（微服务）。</p><h4 id="3、系统化思维与设计"><a href="#3、系统化思维与设计" class="headerlink" title="3、系统化思维与设计"></a>3、系统化思维与设计</h4><p>要设计有效的微服务架构，需要缜密的系统化思维。您必须了解服务、业务功能与用户体验之间的相互影响。这种系统化思维还必须扩展到企业文化中的沟通结构和流程层面。Gartner 指出， 在不了解整个系统的情况下，微服务架构的性能与刻板的单体式架构非常像：“如果不采用统筹考虑软件架构、开发基础架构和开发流程的整体化方法，则无法提供最佳结果，会继续遭受单体式软件系统的诸多弊端所带来的切肤之痛。”</p><h4 id="4、资源限制"><a href="#4、资源限制" class="headerlink" title="4、资源限制"></a>4、资源限制</h4><p>鉴于在扩展方面存在的问题，单体式架构的资源限制是显而易见的。系统要么有足够的硬件容量来处理繁重服务上的峰值负载，从而导致不必要的容量冗余，要么就会面对没有足够的容量来处理高峰期的风险。 借助微服务，架构将变得灵活自如，并且由于各个服务的规模都非常小，因此很容易在轻量级的临时资源（例如容器或云实例）上扩展新服务。 因为给定服务的单个资源需求相对较少，所以有时可以忽略整个架构的独特资源需求，或将其压缩到最小。当然，这是基于以下假设：</p><ul><li>网络始终可靠。</li><li>无延迟。</li><li>无限带宽。</li><li>网络保持安全。</li><li>基础架构拓扑不会改变。</li><li>有一个管理员。</li><li>传输成本为零。</li><li>网络同构。</li></ul><h3 id="重新思考有意义的应用"><a href="#重新思考有意义的应用" class="headerlink" title="重新思考有意义的应用"></a>重新思考有意义的应用</h3><p>很多有关数字化转型的讨论都是集中在基础架构和文化上。鉴于它们属于基本要素，这样做是有道理的。但是，基础架构和文化毕竟是“方法”，它对应的“目的”是创建一个对用户有用、与企业相关的应用。</p><p>有意义的应用具有以下特征：</p><ul><li>可以响应用户</li><li>反映核心业务功能或商业目的</li><li>对环境的动态变化具有适应性或应变性</li><li>跨环境互联互通</li><li>轻便、灵活，可进行功能的添加和维护</li></ul><p>当某个应用满足以上这些特征时，它就是一个有意义的应用。单体式和微服务架构都可以反映这些特征。</p><h2 id="七、快速可靠的驱动技术"><a href="#七、快速可靠的驱动技术" class="headerlink" title="七、快速可靠的驱动技术"></a>七、快速可靠的驱动技术</h2><p>数字化转型的主要目标之一是加快应用发布速度。但是，速度只是效率的提高。要想实现转型， 速度还需要有一定的目的性⸺实现快速创新，交付新功能，以及检验新创意。</p><p>评估一个好创意的方法是进行全面、有效的测试，其中不仅包括代码质量，还包括用户体验和偏好。实践出真知。这正是持续交付和高级部署技术的目的。</p><p>CI/CD 是一个快速部署平台；部署技术则是进行实验和完善的工具。 这两个阶段背后则是文化的改变，即鼓励创新并支持失败和冒险。</p><h3 id="自助服务、自动化和-CI-CD"><a href="#自助服务、自动化和-CI-CD" class="headerlink" title="自助服务、自动化和 CI/CD"></a>自助服务、自动化和 CI/CD</h3><p>在数字化转型中，最初的重构举措之一就是转向采用小型动态团队并倡导相互沟通的 DevOps 文化。接下来是技术方面，旨在提供一个支持快速开发周期的基础架构。</p><p>这里有两个密切相关的技术阶段：</p><ul><li><p>弹性、自助服务式基础结构 ― <em>可以根据确切的规范近乎实时地请求和接收实例。</em></p></li><li><p>自动化或编排 ― <em>可以在整个环境中自动创建和管理多个实例。</em></p></li></ul><p>这些技术具有互补性：没有弹性环境，也就无法实现自动化；没有工具来确保一致性和可重复性，也就难以管理数百个实例。弹性基础架构既可以是云（公共云或私有云）、虚拟机，也可以是容器。自动化既可以是基础架构系统中的组件，也可以是外部工具（例如 Kubernetes）。</p><p>容器之所以与 CI/CD 如此密切相关，原因之一就是它们都可以提供严格且可重复的系统环境，这也意味着在完全不同的企业环境之间迁移时问题会更少。</p><p>这种一致性为 CI/CD 的第一部分（持续集成）奠定了良好的基础。借助持续集成，可以在每次检入时不断编译和构建开发中的变更，因而更容易暴露问题。这项工作通常与自动化测试套件结合在一起，用于验证稳定性或功能性。检入、构建和测试所构成的连续过程可确保代码的更高质量。</p><p>一旦持续集成投入运行，企业即可实现持续部署，从而更快地将变更转化为生产。这种速度的提升既有利于开发人员，也有利于运维团队。</p><p>对于庞大的单体式架构（采用完善的流程和技术，以及更传统的应用架构），可以每周发布一次，且进行一次性整体更新，此时对敏捷冲刺流程的要求构成了唯一的约束条件。对于微服务，由于任何服务都可以进行更新，而且冲刺周期可以重叠，因此可以每天对整个架构进行更新。</p><h3 id="高级部署和创新"><a href="#高级部署和创新" class="headerlink" title="高级部署和创新"></a>高级部署和创新</h3><h4 id="用于实验的应用基础架构"><a href="#用于实验的应用基础架构" class="headerlink" title="用于实验的应用基础架构"></a>用于实验的应用基础架构</h4><p>多语言编程代表了敏捷开发环境的核心需求之一。创建实验用平台时，必须考虑开发环境的灵活性和有关的选项。实验用环境必须支持：</p><ul><li>多种语言。</li><li>多个运行时。</li><li>灵活的部署环境。<em>例如云环境、物理环境或混合环境。</em></li><li>灵活或可变的应用架构。<em>让应用可在整个生命周期中适应环境的变化。</em></li><li>开放标准，或实现迭代标准化的能力。</li></ul><p>容器就是这种支持的一个范例。</p><h4 id="创新的部署模式"><a href="#创新的部署模式" class="headerlink" title="创新的部署模式"></a>创新的部署模式</h4><p>先进的部署技术能在结构和透明度方面实现创新。成熟的部署方法能够构建一个真正实现实验、 反馈和分析的环境。更好的实验有助于实现更好的创新。</p><p>这些是常见的部署模式。任何一种方法或全部方法都可能适用，具体取决于您的应用和用户环境的性质。</p><h5 id="蓝绿环境"><a href="#蓝绿环境" class="headerlink" title="蓝绿环境"></a>蓝绿环境</h5><p>蓝绿环境是缓解因推广更改而带来的风险的一种方法。新的构建版本会穿过 CI/CD 管道中的所有环境。对于生产而言，有两个相同的环境（蓝和绿），但只有一个处于活动状态。所做的更改会被推广至生产中的空闲环境。然后，待环境完成验证后，将会切换路由并将流量移至已更新的环境。</p><p><img src="https://pic.lixl.cn/2020/image-20200324103924321.png" alt="蓝绿部署管道"></p><h5 id="金丝雀发布（Canary-releases）"><a href="#金丝雀发布（Canary-releases）" class="headerlink" title="金丝雀发布（Canary releases）"></a>金丝雀发布（Canary releases）</h5><p>金丝雀发布与蓝绿部署类似，不同之处在于其初始发布只针对环境中的部分用户。随着从用户那里不断收集反馈，可以逐渐增加人数，直到最终切换至所有用户为止。</p><p>这可以用作测试技术的一部分，以针对当前生产环境中的一小部分用户，借助实际的流量和使用模式来评估应用的不同功能或设计。</p><h5 id="A-B-测试"><a href="#A-B-测试" class="headerlink" title="A/B 测试**"></a>A/B 测试**</h5><p>A/B 测试将向用户展示两种不同的设计，然后根据所需的指标来评估哪种设计效果更好。既可以直接让用户对自己的体验进行评分或提供反馈，也可以用更加不易察觉的方式完成。例如，将 A/B 测试与金丝雀发布结合在一起，可以对比两种潜在的设计甚至隐藏的功能，然后以当前环境为基准评估用户对不同设计的反应。</p><p>如同金丝雀发布一样，一旦给出的设计取得成功，就可以将它发布到更大的环境中。如果一切进展顺利，还可以将生产环境转变为实验环境，这样团队在设计中就会更具创新性和关联性。</p><p>这种测试正是“数据胜过直觉”的核心所在。</p><h2 id="八、如何教大象跳舞"><a href="#八、如何教大象跳舞" class="headerlink" title="八、如何教大象跳舞"></a>八、如何教大象跳舞</h2><h3 id="1、选择现有阶段"><a href="#1、选择现有阶段" class="headerlink" title="1、选择现有阶段"></a>1、选择现有阶段</h3><p>在更传统的瀑布式环境与完全分布式的微服务之间，有很多阶段。因为数字化转型的目标是让文化、流程、架构和技术发生显著改变。这就意味着您要了解这种变更所要实现的目标，然后清楚地评估实现该目标所需的条件。请思考几个问题：</p><ul><li>您当前有哪些团队或小组？</li><li>这些小组之间采用什么沟通方式？</li><li>规划周期内目前涉及哪些人？</li><li>从功能角度看，当前应用架构与目标应用架构之间有多大差距？</li><li>您的企业对风险或失败的容忍度有多高？</li><li>对自己材料和信息流的了解程度如何？（这是企业价值的体现。）</li><li>您需要多久发布一次更新，以满足客户或运营需求？</li><li>业务目标或开发需求需要哪些新功能？</li></ul><h3 id="2、制定操作规则"><a href="#2、制定操作规则" class="headerlink" title="2、制定操作规则"></a>2、制定操作规则</h3><p>文化的改变是企业针对数字化转型所做的所有流程、技术或架构改变的基础。 尽管道理浅显易懂，但制定一系列得到管理层和不同团队支持的核心规则确实有助于强化数字化转型计划并统一队伍。</p><p>这些规则可能比较简单，但保持清晰明了的态度和行为却大有用处，而这些对于文化的改变而言最为重要，尤其是在其中一些态度或行为（例如鼓励冒险和实验）与当前文化背道而驰的情况下。例如：</p><ul><li>失败不可避免</li><li>要敢于实验</li><li>企业（人员）优先</li><li>追求持续改进</li><li>终身学习</li><li>始终负责</li><li>保持透明</li></ul><h3 id="3、告别庞然大物"><a href="#3、告别庞然大物" class="headerlink" title="3、告别庞然大物"></a>3、告别庞然大物</h3><p>数字化转型会影响您当前的应用和架构。如果您现在采用的是单体式应用，则有两种相关的方法可以开始解决该技术债务：</p><ul><li>在需要更新或替换时，中断现有服务（strangling）。</li><li>在另外的独立服务中创建新功能（starving）。</li></ul><p>这些都不需要全面采用微服务。Gartner 建议将这种渐进式方法应用于分布式架构，因为它“迭代的同时专注于价值领域”。</p><p>无论企业数字化演进的最后阶段是什么，所选择的方法都应涵盖三个基本方面：</p><ul><li>架构设计的敏捷性。</li><li>实验性。</li><li>自动化。</li></ul><h4 id="实现敏捷性设计架构"><a href="#实现敏捷性设计架构" class="headerlink" title="实现敏捷性设计架构"></a>实现敏捷性设计架构</h4><p>无论您的侧重点是简化流程以改进单体式架构的性能还是创建微服务，架构基础都必须具有敏捷性。通常，敏捷就意味着混合。</p><p>Gartner 建议新项目以单体式架构开始，待成熟后再推出微服务。Gartner 研究得出的结论：先采用单体式架构的方法可以降低风险、提高初始生产率，并确保将应用分离和分解为正确的微服务集。”</p><p>请认真阅读 Martin Fowler 的 <a href="https://martinfowler.com/bliki/DesignStaminaHypothesis.html" target="_blank" rel="noopener">DesignStaminaHypothesis</a>，创建一个侧重于清晰性和简易性的开发流程。代码应做到易于理解。功能和用途要明确。随着应用不断成熟，就可以将其发展成更具分布特性的架构形式。拥有良好的开发和部署流程会让这一途径保持敏捷。</p><h4 id="预留试验用的时间和预算"><a href="#预留试验用的时间和预算" class="headerlink" title="预留试验用的时间和预算"></a>预留试验用的时间和预算</h4><p>必须要留出试验新技术和应用功能的预算空间。技术本身并不是目标，但是，数字化战略目标经常需要技术变革作为支撑。缩短服务上市时间可能需要移至容器。 还要预留资源，让开发人员和运维团队可以识别有用的技术并培养相关的技能，以支持最终部署的任何基础架构。</p><h4 id="一切皆自动化"><a href="#一切皆自动化" class="headerlink" title="一切皆自动化"></a>一切皆自动化</h4><p>自动化主要有两个明显的优势：通过消除手动步骤来提高效率，以及内在的一致性和可重复性。实现每个开发（开始时）和部署（随着流程不断成熟）步骤的自动化，也就是可就每个步骤的改变以及在利益相关者从开发向运营再向客户转换时为您的团队提供反馈回路。这种方法提高了整体代码质量。</p><p>第一步，为企业的当前状态设置一条基线，以将其纳入自动化策略。接下来的步骤包括：</p><ul><li>定义相关指标。</li><li>可视化或图解当前的工作流。</li><li>确定不同步骤的主要参与者。</li></ul><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>长期以来，企业应用往往会演变成死板僵化的庞然大物⸺不够透明、更新起来繁琐，且迟迟无法纳入新的功能。然而，这些企业应用同时也提供了开展业务和实现创收的核心功能。这就像是房间里的大象。</p><p>只要对最终状态有明确的认识，就可以将那头大象训练得敏捷并且具备转变能力。数字化转型是个进化过程，没有一种所谓理想的结果，每条演变路径都反映了企业本身的独特意图和个性。</p><p>评估数字化演进的每个阶段：DevOps、自助服务或弹性环境、自动化、CI/CD 管道、高级部署和微服务。围绕最能满足您业务需求的进化阶段，构建自己的数字化转型策略。</p><p>聚焦于打造文化，并在技术变更与相应的流程变更之间取得平衡，以确保您的技术得到团队的全力支持。</p><p>随着流程不断成熟，开始评估您的应用和架构。必要时，隔离或开发独立的服务，并创建可以随着业务优先级变化或出现而调整的敏捷架构。</p><p>最后，培养创新能力。这意味着对风险和失败要有一定的容忍度（在业务目标和客户需求的范围内）。这就要求架构规范在时间、成本和基础架构方面预留出一定资源。</p><p>试验是创新的根本，也为数字化转型的成功提供了更好的机会。此外，试验也让人们重拾最初的喜悦，正是这些喜悦吸引着众多开发人员和运维人员热爱技术， 从事创造性工作并见证创新的产生。</p><h2 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h2><ul><li><a href="https://www.redhat.com/cms/managed-files/mi-middleware-teaching-elephant-to-dance-ebook-f8980kc-201709-a4-zh.pdf" target="_blank" rel="noopener">教大象跳舞</a></li><li><a href="http://highscalability.com/blog/2014/7/28/the-great-microservices-vs-monolithic-apps-twitter-melee.html" target="_blank" rel="noopener">卓越的微服务与单体式应用 Twitter Melee</a></li><li><a href="https://martinfowler.com/bliki/DesignStaminaHypothesis.html" target="_blank" rel="noopener">Design stamina hypothesis</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字化转型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生（Cloud Native）应用开发，助力企业数字化转型</title>
      <link href="/2020/03214710.html"/>
      <url>/2020/03214710.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>要在快节奏的软件驱动型市场中取得成功，公司必须改变他们设计、构建和使用应用的方式。应用的快速开发和交付已成为数字化企业必须要满足的一项新需求。</p><p>云原生应用开发是根据众所周知的云计算技巧与技术构建、运行和改进应用的一种方法。基于云技术原理，利用相关服务，并采用为实现云计算敏捷性和自动化而过优化的各种流程，从而完成现有应用的现代化转型并构建新的应用。</p><h2 id="二、什么是云原生应用"><a href="#二、什么是云原生应用" class="headerlink" title="二、什么是云原生应用"></a>二、什么是云原生应用</h2><p>云原生应用旨在充分利用云计算模型，从而提高速度、灵活性和质量并降低部署风险。虽然名字中包含“云原生”三字，但云原生方案的重点并不是应用部署在何处，而是如何构建、部署和管理应用。</p><p>云原生方案与微服务架构类似。然而，尽管微服务可通过构建云原生应用来交付，可企业仍需采取许多措施，才能在生产中熟练地管理微服务。而要想享受云原生应用的各种益处，也并非一定需要微服务。很多企业都通过基于相同的原则，构建出更优秀的模块化单体式应用，从而取得云原生方案的种种效益。</p><p>向云原生应用的开发和交付转型，是一次全方位的变革，涉及企业的文化、流程、架构和技术。因此，这是企业的必经之路，而不是所要到达的目标。这段旅程代表着一个变革周期，而实现变革从来不是一件容易的事。</p><h2 id="三、传统应用开发与云原生应用"><a href="#三、传统应用开发与云原生应用" class="headerlink" title="三、传统应用开发与云原生应用"></a>三、传统应用开发与云原生应用</h2><p>云原生应用开发与传统应用开发之间的差别，充分彰显了变革的必要性。</p><p><strong>表 1. 传统应用开发与云原生应用开发</strong></p><table><thead><tr><th></th><th>传统</th><th>云原生</th></tr></thead><tbody><tr><td>重点关注</td><td>使用寿命和稳定性</td><td>上市速度</td></tr><tr><td>开发方法</td><td>瀑布式半敏捷型开发</td><td>敏捷开发、DevOps</td></tr><tr><td>团队</td><td>相互独立的开发、运维、质量保证和 安全团队</td><td>协作式 DevOps 团队</td></tr><tr><td>交付周期</td><td>长</td><td>短且持续</td></tr><tr><td>应用架构</td><td>紧密耦合<br />单体式</td><td>松散耦合<br />基于服务<br />基于应用编程接口（API）的通信</td></tr><tr><td>基础架构</td><td>以服务器为中心<br />适用于企业内部<br />依赖于基础架构<br />纵向扩展<br />针对峰值容量预先进行置备</td><td>以容器为中心<br />适用于企业内部和云环境<br />可跨基础架构进行移植<br />横向扩展<br />按需提供容量</td></tr></tbody></table><br />由于云原生应用非常注重上市速度，因此，在开发时需要实施更加敏捷且基于服务和 API 的方案和持续交付策略。而这些方案能否成功实施又取决于以下几点：<ul><li>开发和交付团队间的 DevOps 协 作；</li><li>模块化程度更高的架构；</li><li>能够按需横向扩展、</li><li>支持多种环境并实现应用可移植性的灵活基础 架构。</li></ul><p>在利用现代化云技术实现灵活性和敏捷性后，企业会想将传统应用迁移到云环境中，以便进一步提高敏捷性，并充分利用按需提供的计算容量。</p><p>但是，传统平台中内置的很多运维功能，要么对于云环境而言早已过时，要么云环境本身就会提供并实施这些功能。云环境不但能简化主机的生命周期管理，还能帮助企业充分利用不变的基础架构原则，并对主机进行精调以满足单个应用实例的需求。</p><p>每个企业的云原生应用的构建之路可能都不尽相同。仅凭创建微服务无法实现数字化业务所需的服务质量和交付频率。同样地，仅凭采用支持敏捷开发或 IT 自动化的工具也无法加快云原生方案的速度。要想取得成功，企业必须综合考虑相关的实践、技术、流程和理念。</p><h2 id="四、云原生应用开发-amp-部署原则"><a href="#四、云原生应用开发-amp-部署原则" class="headerlink" title="四、云原生应用开发&amp;部署原则"></a>四、云原生应用开发&amp;部署原则</h2><p>云原生应用开发所构建和运行的应用，旨在充分利用基于四大原则的云计算模型：基于服务的架构、基于 API 的通信、基于容器的基础架构以及 DevOps 流程。</p><p><img src="https://pic.lixl.cn/2020/image-20200321104115727.png" alt="云原生应用开发和部署的四大原则"></p><h3 id="1、基于服务的架构"><a href="#1、基于服务的架构" class="headerlink" title="1、基于服务的架构"></a>1、基于服务的架构</h3><p>基于服务的架构（如微服务）提倡构建松散耦合的模块化服务。其他模块化架构 方案（如迷你服务）采用基于服务的松散耦合设计，可帮助企业提高应用创建速 度，但不会增加复杂性。</p><h3 id="2、基于-API-的通信"><a href="#2、基于-API-的通信" class="headerlink" title="2、基于 API 的通信"></a>2、基于 API 的通信</h3><p>服务通过与技术无关的轻量级 API 来提供，这些 API 可以降低与部署、可扩展性和维护相关的复杂性和费用。企业可以通过所提供的 API 在内部和外部创建新的功能，创造新的商机。</p><p>采用基于 API 的设计时，只能在网上通过调用服务接口来通信，这样可避免因直接链接、共享内存模型或直接读取其他团队的数据存储而带来的风险。这种设计能让应用和服务延伸到不同的设备、拓展出不同的形式。</p><h3 id="3、基于容器的基础架构"><a href="#3、基于容器的基础架构" class="headerlink" title="3、基于容器的基础架构"></a>3、基于容器的基础架构</h3><p>云原生应用依靠容器来构建跨技术环境的通用运行模型，并在不同的环境和基础架构（包括公共、私有和混合云）间实现真正的应用可移植性。容器技术会利用操作系统虚拟化功能来划分多个应用的可用计算资源，并确保这些应用安全无虞、相互独立。</p><p>云原生应用采用横向扩展模式，因此，只需添加更多应用实例，即可增加容量， 而且这样的添加常通过容器基础架构中的自动化功能来实现。</p><p>由于容器的费用低、密度高，因而可在同一虚拟机或物理服务器内托管大量容器， 这使得容器成了交付云原生应用的理想之选。</p><h3 id="4、DevOps-流程"><a href="#4、DevOps-流程" class="headerlink" title="4、DevOps 流程"></a>4、DevOps 流程</h3><p>采用云原生方案时，企业会使用敏捷的方法，依据持续交付和 DevOps 原则来开发应用，这些方法和原则要求开发、质量保证、安全、IT 运维团队以及交付过程中所涉及的其他团队以协作方式构建和交付应用。</p><h2 id="五、八步法构建云原生应用"><a href="#五、八步法构建云原生应用" class="headerlink" title="五、八步法构建云原生应用"></a>五、八步法构建云原生应用</h2><h3 id="1、发展-DEVOPS-文化和实践"><a href="#1、发展-DEVOPS-文化和实践" class="headerlink" title="1、发展 DEVOPS 文化和实践"></a>1、发展 DEVOPS 文化和实践</h3><p>要完成云原生应用的构建之路，开发和 IT 运维团队必须进行多方面的变革，以便更加快速高效地构建和部署应用。要想充分利用新技术，采用更加快速的方案，实现更为密切的合作，企业必须切实遵循 DevOps 的原则和文化价值，并围绕这些价值来进行 组织和规划。</p><p>DevOps 文化的推行不仅要靠工具和技术，也取决于员工是否愿意和信任用集成度和协作度更高的方案来开发和交付应用。企业可以把开源软件项目的文化作为参考，来构建 DevOps 文化。</p><p>倡导大胆尝试、迅速纠误、提升决策透明度，并通过表扬和奖励来促进团队间的相互信任和紧密协作，有助于引导企业完成 DevOps 之旅。</p><p><img src="https://pic.lixl.cn/2020/image-20200321110712585.png" alt="开源文化推动开放创新"></p><p><strong>进一步了解：</strong> <a href="https://www.redhat.com/zh/resources/open-innovation-labs-ebook" target="_blank" rel="noopener">红帽开放创新实验室如何帮助您完成 DevOps 之旅</a></p><h3 id="2、为现有单体应用提速"><a href="#2、为现有单体应用提速" class="headerlink" title="2、为现有单体应用提速"></a>2、为现有单体应用提速</h3><p>组织不能抛弃现有的单体应用程序，这些应用程序这些年来一直在有效地运行其业务。该如何加快现有单体式应用的运行速度？正确的方法是：将您现有的单体式架构迁移到模 块化程度更高、且基于服务的架构中，并采用基于 API 的通信方式，从而实施快速单体式方案。</p><p>在开始实施将单体式应用重构为微服务的艰巨任务前，您可以通过将这些现有应用程序迁移到基于容器的现代平台来加快速度，这不仅可以提高自动化程度，而且可以提高开发速度。然后，您可以识别可使用 API 公开的单体应用程序组件。</p><h3 id="3、使用中间件来加速"><a href="#3、使用中间件来加速" class="headerlink" title="3、使用中间件来加速"></a>3、使用中间件来加速</h3><p>可重用性一直是加快软件开发速度的关键，云原生应用程序也不例外。当您可以使用已优化并集成到基于基础容器的现有服务时，为什么要重新创建如缓存服务，规则或工作流引擎或无服务器框架等基础设施？这些应用程序服务，无论是软件即服务（SaaS），平台即服务（PaaS）还是 iPaaS 产品，都是有效的即用型开发人员工具。将这些可重用组件用于云原生应用程序，最好是已被优化并集成到底层云原生基础架构中的组件，以充分发挥它们的价值。</p><h3 id="4、选择正确的工具"><a href="#4、选择正确的工具" class="headerlink" title="4、选择正确的工具"></a>4、选择正确的工具</h3><p>组织正在从各种运行时和框架中选择最佳工具来解决特定任务。随着语言或框架的选择越来越适合特定的业务应用程序需求，构建云原生应用程序变得越来越多样化。随之而来的复杂性增加值得使用基于容器的应用程序平台，该平台支持框架，语言和体系结构的正确组合，以支持云原生开发。有许多技术和框架可以实现云原生应用程序，例如 Quarkus，Spring Boot，Eclipse MicroProfile，Eclipse Vert.x，DropWizard，Python，Apache OpenWhisk，Node.js，Golang 和 Jakarta EE。根据您要解决的问题，选择最能帮助您解决问题的工具/框架。</p><h3 id="5、构建自助式按需基础架构"><a href="#5、构建自助式按需基础架构" class="headerlink" title="5、构建自助式按需基础架构"></a>5、构建自助式按需基础架构</h3><p>通过自助式地按需置备基础架构，开发人员可以在需要时访问所需的基础架构。</p><p>容器和容器编排技术抽象并简化了对于底层基础架构的访问，并可针对各种基础架构环境（如数据中心、私有云和公共云）进行有效的应用生命周期管理。容器平台还可提供额外的自助服务、自动化和应用生命周期管理功能。该模式使开发人员和运维团队能够快速启用一致的环境，帮助开发人员专注于构建应用，而不会困于与置备基础架构相关的障碍和延迟。</p><p>标准化也是自助模式的要素之一。它有助于企业以一致的方式实现自动化和交付，达成业务目标。容器还有助于实现应用可移植性，包括创建可部署和运行于任何云提供商的云原生应用。</p><p><strong>进一步了解：</strong><a href="https://rht-labs.github.io/practice-library/" target="_blank" rel="noopener">详细了解有助于开启云原生之旅的不同实践和技术</a></p><h3 id="6、通过-IT-自动化加速应用交付"><a href="#6、通过-IT-自动化加速应用交付" class="headerlink" title="6、通过 IT 自动化加速应用交付"></a>6、通过 IT 自动化加速应用交付</h3><p>避免手动执行 IT 任务，是加速交付云原生应用的重点，而实现 IT 或基础架构自动化就是其中的关键所在。从网络和基础架构置备，到应用部署和配置管理，自动化可以整合并应用于任何任务 或组件。</p><p>IT 管理和自动化工具会创建可重复的流程、规则和框架，以替代或减少会延迟上市的劳动密集型人工介入。 这些工具可以进一步延伸到具体的技术（如容器）、方法（如 DevOps），再到更广泛的领域（如云计算、安全性、测试、监控和警报）。因此，自动化是 IT 优化和数字化转型的关键，可以缩短实现价值所需的总时长。</p><p><strong>进一步了解：</strong><a href="https://www.redhat.com/zh/engage/automated-enterprise-ebook-20171115" target="_blank" rel="noopener">自动化企业</a></p><h3 id="7、实施持续交付和高级部署技术"><a href="#7、实施持续交付和高级部署技术" class="headerlink" title="7、实施持续交付和高级部署技术"></a>7、实施持续交付和高级部署技术</h3><p>敏捷开发方法经过不断演变，形成了“早发布，常发布”模式。DevOps 和持续交付方案通过密切联合开发人员、运维、质量保证和安全团队，扩展了这些方法的应用领域，从而改善了软件的交付流程。因此，代码的变动可以快速可靠地推送至生产环境，为开发人员提供快速反馈。这种迭代式快速反馈循环借助 CI/CD 实现， 可将基础架构自动化扩展到端到端自动交付系统，从而涵盖应用 交付的方方面面，包括自动化测试、漏洞扫描、安全合规性和法规检查。自动化交付管道旨在不影响运维能力的情况下提供更新，同时降低交付风险。</p><p>要实现持续交付（CD），首先要实现持续集成（CI）。CI 系统是一组 Build 系统，它们可以监控各种源代码控制存储库的变更情况，运行任何适用的测试，并通过每个源代码控制变更自动构建最新的应用版本，如 Jenkins。</p><p>高级部署模式旨在降低与软件发布相关的风险，构建结果受控且不会对客户造成意外负面影响的 实验环境。该目标对于推动整个企业不断创新至关重要。</p><p>通过消除新部署对客户造成的不便，这些技术使企业能够按照业务所需的频率来交付更新和发布版本。以下是一些可用于实现零停机部署的常用部署技术，具体技术根据用例而定：</p><p><strong>滚动部署</strong>模式不会一次更新应用的所有实例，它会依次将各个实例从负载均衡器中排除，使其无法接收流量，然后再单独更新各个实例。实例更新后，会再次纳入负载均衡器中。此流程会持续进行，直到所有实例都已更新。</p><p><strong>蓝/绿部署</strong>描述的是运行两个相同环境的做法：一个环境处于活动状态，而另一个处于空闲状态。 所做的更改会被推广至空闲环境；然后，待更改在生产中完成验证后，实时流量会切换到已更新的环境。回滚到先前版本就像切换回流量一样简单，但前提是得考虑数据的传输。</p><p><strong>金丝雀发布</strong>类似于蓝/绿部署，需使用两个相同的环境。但是，它的不同之处在于发布的控制方式。 部署新版本后，会向一小部分客户发送新版本，供其在生产中进行测试。如新版本验证成功，则流量会逐渐转移到新版本，同时监控并验证结果，直到向所有用户发送完新版本。</p><p><strong>A/B 测试</strong>将向用户展示两种不同的设计，然后根据所需的指标来评估哪种设计效果更好。既可以直接让用户对自己的体验进行评分或提供反馈，也可以用更加不易察觉的方式完成。例如，将 A/B 测试与金丝雀发布结合在一起，可以对比两种潜在的设计甚至隐藏的功能，然后以当前环境为基准评估用户对不同设计的反应。</p><p>进一步了解：<a href="https://www.redhat.com/cms/managed-files/mi-middleware-teaching-elephant-to-dance-ebook-f8980kc-201709-a4-zh.pdf" target="_blank" rel="noopener">教大象跳舞 — 跨团队、流程和应用的主动变革</a></p><h3 id="8、演进更具模块化的架构"><a href="#8、演进更具模块化的架构" class="headerlink" title="8、演进更具模块化的架构"></a>8、演进更具模块化的架构</h3><p>有许多方法可以演化出更具模块化的体系结构。在微服务体系结构编写软件的方法中，应用程序分解为彼此独立的最小组件。微服务架构非常适合构建云原生应用程序，因为它们满足了云原生应用程序开发的关注焦点，即基于服务和基于 API 的原则。</p><p>但是，微服务架构不容易实现或维护。因此，分析师和主题专家建议对微服务采用 <a href="https://martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="noopener">MonolithFirst</a> 方案，即要先构建一个单体式应用，就算您想创建的是微服务架构。这么做的目的是：先充分理解您的应用所属的域，然后更好地识别其所含的有限上下文——这些上下文将作为转换成微服务的候选内容。这样做，有助于避免技术债务，比如还没有了解应用的所属域和有限上下文就构建一组微服务，由此产生的修复成本。</p><p>微服务的另一种替代方案是迷你服务。迷你服务是按域划分的多个服务的集合，通常在应用服务器上运行。迷你服务可以提高敏捷性并进行扩展，而无需担心基于微服务的设计和基础架构所带来的复杂性问题。</p><h2 id="六、云原生应用业务场景及方案"><a href="#六、云原生应用业务场景及方案" class="headerlink" title="六、云原生应用业务场景及方案"></a>六、云原生应用业务场景及方案</h2><p>在实现数字化转型时，各个企业都有不同的优先事务。有些企业会遵循现代化的云原生原则，使其现有的应用架构和基础架构实现现代化转型，而有些企业会利用全新的业务模式和应用来实现创新。无论具体的意图和业务场景如何，这些企业的目标都是提高速度和灵活性，并为数字化转型做好准备。</p><p>云原生应用的常见场景大致可根据以下四项业务挑战进行分类：</p><h3 id="1、加速应用交付"><a href="#1、加速应用交付" class="headerlink" title="1、加速应用交付"></a>1、加速应用交付</h3><p><strong>目标：</strong> 加快向客户交付现有应用和新应用的速度。</p><p><strong>方案：</strong> 容器可以提供一个通用平台，使开发、运维、安全性、质量保证和其他团队联合起来，一同采用独立 于基础架构和应用技术的 DevOps。借助 DevOps 方案，团队可以采用自动化及 CI/CD 实践来快速、 放心地发布软件。利用基于容器的自动化功能解决部署问题后，可以缩短应用的交付周期，并使其 适应业务的发展步伐，而不是根据 IT 部门所能交付的内容来调整业务的发展步伐。</p><h3 id="2、对现有应用进行现代化改造"><a href="#2、对现有应用进行现代化改造" class="headerlink" title="2、对现有应用进行现代化改造"></a>2、对现有应用进行现代化改造</h3><p><strong>目标：</strong> 对现有应用进行现代化改造，以满足市场和客户需求，从而加速实现变革。</p><p><strong>方案：</strong> 许多产生价值的业务应用都是传统应用，其设计年代可能远早于数字时代。但是，直接淘汰换新不一定就是最优对策，至少在经济层面上并不可行。此外，也并非所有的传统应用都能现代化。</p><p>如果将传统应用迁移至云环境行得通，容器就可以为其提供相应的支持，消除对于底层基础架构的依赖性。这样，应用就能从企业内部基础架构移植到云端；如果需要，还可以对应用进行重构和重新架构，以实现云原生。容器平台方案还可利用平台的自动化功能和 DevOps 实践来简化现有应用的迁移。</p><h3 id="3、开发新的云原生应用"><a href="#3、开发新的云原生应用" class="headerlink" title="3、开发新的云原生应用"></a>3、开发新的云原生应用</h3><p><strong>目标：</strong> 加快新应用的开发速度，把握各种新商机。</p><p><strong>方案：</strong> 如果企业能将理念快速转化为服务和产品、快速评估它们在新领域中所取得的业务成果，然后再进行快速的调整，那么不断变化的业务和客户需求将为企业带来巨大的商机。集基于服务的架构、 API 整合、容器化服务和编排以及各种 DevOps 实践、自动化功能和工具的强大支持于一身，旨在构建新应用的云原生方案可以加速从理念到创新应用的转化过程。</p><h3 id="4、推动业务创新"><a href="#4、推动业务创新" class="headerlink" title="4、推动业务创新"></a>4、推动业务创新</h3><p><strong>目标：</strong> 加快整个企业的创新速度，以满足不断变化的业务需求。</p><p><strong>方案：</strong> 面对日新月异的世界，停滞不前就意味着落后。IT 团队正在你追我赶，力图快速推出各种新功能和服务，让客户满意并帮助员工更智能地工作。成功取决于不断创新，而不仅仅依赖于新的工具和技 术。要想取得成功，需要推行变革性的新文化、新工具和新流程，以便于在整个企业内实现创新和开展实验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.redhat.com/zh/engage/cloud-native-application-development-20180622" target="_blank" rel="noopener">云原生应用的构建之路</a></li><li><a href="http://highscalability.com/blog/2014/7/28/the-great-microservices-vs-monolithic-apps-twitter-melee.html" target="_blank" rel="noopener">卓越的微服务与单体式应用 Twitter Melee</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora常用快捷键（翻译）</title>
      <link href="/2020/031019385.html"/>
      <url>/2020/031019385.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文来自 <a href="https://www.lixl.cn">悟尘纪</a>，获取更新内容可查看原文： <a href="https://www.lixl.cn/2020/031019385.html">https://www.lixl.cn/2020/031019385.html</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>您可以使用快捷键快速插入或修改样式，或者执行 Typora 支持的其他操作。</p><p>您可以在菜单栏中的每个菜单项的右侧找到快捷键。</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h3><p>在macOS上，您可以按Esc键打开内联数学预览、自动完成表情符号等功能。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">新建</td><td align="left">Ctrl + N</td><td>Command + N</td></tr><tr><td align="left">新窗口</td><td align="left">Ctrl + Shift + N</td><td>Command + Shift + N</td></tr><tr><td align="left">新标签</td><td align="left"><em>（不支持）</em></td><td>Command + T</td></tr><tr><td align="left">打开</td><td align="left">Ctrl + O</td><td>Command + O</td></tr><tr><td align="left">快速打开</td><td align="left">Ctrl + P</td><td>Command + Shift + O</td></tr><tr><td align="left">重新打开已关闭文件</td><td align="left">Ctrl + Shift + T</td><td>Command + Shift + T</td></tr><tr><td align="left">保存</td><td align="left">Ctrl + S</td><td>Command + S</td></tr><tr><td align="left">另存为/复制</td><td align="left">Ctrl + Shift + S</td><td>Command + Shift + S</td></tr><tr><td align="left">偏好</td><td align="left">Ctrl + ，</td><td>Command + ，</td></tr><tr><td align="left">关闭</td><td align="left">Ctrl + W</td><td>Command + W</td></tr></tbody></table><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">新段落</td><td align="left">Enter</td><td>Enter</td></tr><tr><td align="left">新线</td><td align="left">Shift + Enter</td><td>Shift + Enter</td></tr><tr><td align="left">剪切</td><td align="left">Ctrl + X</td><td>Command + X</td></tr><tr><td align="left">复制</td><td align="left">Ctrl + C</td><td>Command + C</td></tr><tr><td align="left">粘贴</td><td align="left">Ctrl + V</td><td>Command + V</td></tr><tr><td align="left">复制为 Markdown</td><td align="left">Ctrl + Shift + C</td><td>Command + Shift + C</td></tr><tr><td align="left">粘贴为纯文本</td><td align="left">Ctrl + Shift + V</td><td>Command + Shift + V</td></tr><tr><td align="left">全选</td><td align="left">Ctrl + A</td><td>Command + A</td></tr><tr><td align="left">选择行/句子 <br />选择行（在表中）</td><td align="left">Ctrl + L</td><td>Command + L</td></tr><tr><td align="left">删除行（在表中）</td><td align="left">Ctrl + Shift +退格键</td><td>Command + Shift + 退格键</td></tr><tr><td align="left">选择样式范围<br />选择单元格（在表中）</td><td align="left">Ctrl + E</td><td>Command + E</td></tr><tr><td align="left">选择单词</td><td align="left">Ctrl + D</td><td>Command + D</td></tr><tr><td align="left">删除单词</td><td align="left">Ctrl + Shift + D</td><td>Command + Shift + D</td></tr><tr><td align="left">跳到顶部</td><td align="left">Ctrl +Home</td><td>Command + ↑</td></tr><tr><td align="left">跳至选择</td><td align="left">Ctrl + J</td><td>Command + J</td></tr><tr><td align="left">跳到底部</td><td align="left">Ctrl + End</td><td>Command + ↓</td></tr><tr><td align="left">查找</td><td align="left">Ctrl + F</td><td>Command + F</td></tr><tr><td align="left">查找下一个</td><td align="left">F3 / Enter</td><td>Command + G / Enter</td></tr><tr><td align="left">查找上一个</td><td align="left">Shift + F3 / Shift + Enter</td><td>Command + Shift + G / Shift + Enter</td></tr><tr><td align="left">替换</td><td align="left">Ctrl + H</td><td>Command + H</td></tr></tbody></table><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">标题 1 至 6</td><td align="left">Ctrl + 1/2/3/4/5/6</td><td>Command + 1/2/3/4/5/6</td></tr><tr><td align="left">段落</td><td align="left">Ctrl + 0</td><td>Command + 0</td></tr><tr><td align="left">增加标题级别</td><td align="left">Ctrl + =</td><td>Command + =</td></tr><tr><td align="left">降低标题级别</td><td align="left">Ctrl +-</td><td>Command + -</td></tr><tr><td align="left">表</td><td align="left">Ctrl + T</td><td>Command + Option + T</td></tr><tr><td align="left">代码围栏</td><td align="left">Ctrl + Shift + K</td><td>Command + Option + C</td></tr><tr><td align="left">数学块</td><td align="left">Ctrl + Shift + M</td><td>Command + Option + B</td></tr><tr><td align="left">引用</td><td align="left">Ctrl + Shift + Q</td><td>Command + Option + Q</td></tr><tr><td align="left">有序列表</td><td align="left">Ctrl + Shift + [</td><td>Command + Option + O</td></tr><tr><td align="left">无序列表</td><td align="left">Ctrl + Shift +]</td><td>Command + Option + U</td></tr><tr><td align="left">缩进</td><td align="left">Ctrl + [ / Tab</td><td>Command + [ / Tab</td></tr><tr><td align="left">突出</td><td align="left">Ctrl +] / Shift + Tab</td><td>Command +] / Shift + Tab</td></tr></tbody></table><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">加粗</td><td align="left">Ctrl + B</td><td>Command + B</td></tr><tr><td align="left">重点</td><td align="left">Ctrl + I</td><td>Command + I</td></tr><tr><td align="left">下划线</td><td align="left">Ctrl + U</td><td>Command + U</td></tr><tr><td align="left">代码</td><td align="left">Ctrl + Shift + `</td><td>Command + Shift + `</td></tr><tr><td align="left">Strike</td><td align="left">Alt + Shift + 5</td><td>Ctrl + Shift + `</td></tr><tr><td align="left">超链接</td><td align="left">Ctrl + K</td><td>Command + K</td></tr><tr><td align="left">图片</td><td align="left">Ctrl + Shift + I</td><td>Command + Control + I</td></tr><tr><td align="left">清除格式</td><td align="left">Ctrl + \</td><td>Comand + \</td></tr></tbody></table><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">切换侧边栏</td><td align="left">Ctrl + Shift + L</td><td>Command + Shift + L</td></tr><tr><td align="left">大纲</td><td align="left">Ctrl + Shift + 1</td><td>Command + Shift + 1</td></tr><tr><td align="left">文章</td><td align="left">Ctrl + Shift + 2</td><td>Command + Control + 2</td></tr><tr><td align="left">文件树</td><td align="left">Ctrl + Shift + 3</td><td>Command + Control + 3</td></tr><tr><td align="left">源代码模式</td><td align="left">Ctrl + /</td><td>Command + /</td></tr><tr><td align="left">聚焦模式</td><td align="left">F8</td><td>F8</td></tr><tr><td align="left">打字机模式</td><td align="left">F9</td><td>F9</td></tr><tr><td align="left">切换全屏</td><td align="left">F11</td><td>Command + Option + F</td></tr><tr><td align="left">实际尺寸</td><td align="left">Ctrl + Shift + 0</td><td><em>（不支持）</em></td></tr><tr><td align="left">放大</td><td align="left">Ctrl + Shift + =</td><td><em>（不支持）</em></td></tr><tr><td align="left">缩小</td><td align="left">Ctrl + Shift +-</td><td><em>（不支持）</em></td></tr><tr><td align="left">在打开的文档之间切换</td><td align="left">Ctrl + Tab</td><td>Command + `</td></tr><tr><td align="left">切换开发工具</td><td align="left">Ctrl + Shift + I</td><td>-</td></tr></tbody></table><h2 id="更改快捷键"><a href="#更改快捷键" class="headerlink" title="更改快捷键"></a>更改快捷键</h2><p>用户可以在 Typora 的菜单栏中设置或重新分配命令的快捷键。</p><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><p>我们使用 macOS 的系统功能来自定义 Typora 在 macOS 上的按键绑定。</p><ol><li><p>打开<code>System Preference</code>→ <code>Keyboard</code>，选择选项卡<code>Shortcuts</code>。<code>App Shortcuts</code>在其左侧面板中选择。</p><p><img src="https://pic.lixl.cn/2020/Snip20160814_1.png" alt="快捷键设置"></p></li><li><p>单击“ +”按钮，将弹出一个对话框。从字段中选择“ Typora.app” <code>Application</code>，然后输入要添加的菜单命令的确切名称，然后键入要分配的快捷键组合。</p><p>例如，假设您要添加/更改快捷键以固定 Typora 的窗口，则可以如下所示填充对话框：</p><p><img src="https://pic.lixl.cn/2020/Snip20160814_5.png" alt="绑定快捷键"></p><p>然后<code>Command+Shift+P</code>将成为菜单命令“ always on top”的快捷键</p></li></ol><h3 id="Windows-Linux"><a href="#Windows-Linux" class="headerlink" title="Windows / Linux"></a>Windows / Linux</h3><blockquote><p>提示：这需要 Typora ≥ v0.9.16 的版本。</p></blockquote><ol><li><p>在 Typora 中打开<code>Menu</code>→ <code>Preference</code>，然后单击“打开高级设置”。</p><p><img src="https://pic.lixl.cn/2020/sshot-1.png" alt="打开高级设置"></p></li><li><p><code>conf.user.json</code>从打开的“文件浏览”中打开和编辑。如果没有这样的文件，请创建一个。</p></li><li><p>设置或添加表示键绑定的 JSON 对象，例如：</p><p><img src="https://pic.lixl.cn/2020/Snip20160814_7.png" alt="添加快捷键"></p></li><li><p>重新启动 Typora，将应用新的键绑定。</p><p><img src="https://pic.lixl.cn/2020/sshot-2.png" alt="应用新的快捷键"></p></li></ol><p>您可以本机窗口样式设置或更改菜单栏中菜单项的快捷键。</p><p><strong>问: 快捷键在 Ubuntu 上不起作用？</strong></p><p>对于这个问题的解决方案，请参阅:</p><ul><li><a href="https://help.ubuntu.com/community/KeyboardShortcuts" target="_blank" rel="noopener">https://help.ubuntu.com/community/KeyboardShortcuts</a> 和</li><li><a href="https://askubuntu.com/questions/208310/ctrl-a-doesnt-work-in-browsers." target="_blank" rel="noopener">https://askubuntu.com/questions/208310/ctrl-a-doesnt-work-in-browsers.</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>本文翻译自：<a href="https://support.typora.io/Shortcut-Keys/" target="_blank" rel="noopener">https://support.typora.io/Shortcut-Keys/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12、参考 - Docker必知必会</title>
      <link href="/2020/030335048.html"/>
      <url>/2020/030335048.html</url>
      
        <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker docs</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">Docker —— 从入门到实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11、Dockerfile 最佳实践 - Docker必知必会</title>
      <link href="/2020/030233344.html"/>
      <url>/2020/030233344.html</url>
      
        <content type="html"><![CDATA[<h2 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h2><h3 id="1、Dockerfile-简介"><a href="#1、Dockerfile-简介" class="headerlink" title="1、Dockerfile 简介"></a>1、Dockerfile 简介</h3><p>Dockfile 是一种被 Docker 程序解释的脚本，由一条一条的指令组成，每条指令对应 Linux 下面的一条命令。</p><p>Docker 通过从<code>Dockerfile</code>文本文件中读取指令来自动构建映像，该文本文件按顺序包含构建镜像所需的所有命令。遵循特定的格式和指令集，您可以在 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile 参考</a> 中找到详细信息。</p><p>Docker 镜像由只读层组成，每个只读层代表一个 Dockerfile 指令。各个层堆叠在一起，每个层都是上一层变化的增量。运行镜像并生成容器时，可以在基础层之上添加一个新的可写层（“容器层”）。对运行中容器所做的所有更改（例如写入新文件，修改现有文件和删除文件）都将写入到此可写容器层。</p><h3 id="2、Dockerfile-编写建议"><a href="#2、Dockerfile-编写建议" class="headerlink" title="2、Dockerfile 编写建议"></a>2、Dockerfile 编写建议</h3><p>Dockerfile 的指令是忽略大小写的，建议使用大写，使用<code>#</code>作为注释，每一行只支持一条指令，每条指令可以携带多个参数。Dockerfile 常用指令：</p><table><thead><tr><th>类型</th><th>命令</th></tr></thead><tbody><tr><td>基础镜像信息</td><td>FROM</td></tr><tr><td>维护者信息</td><td>MAINTAINER</td></tr><tr><td>镜像操作指令</td><td>RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME 等</td></tr><tr><td>容器启动时执行指令</td><td>CMD、ENTRYPOINT</td></tr></tbody></table><p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p><h4 id="FROM（指定基础镜像）"><a href="#FROM（指定基础镜像）" class="headerlink" title="FROM（指定基础镜像）"></a>FROM（指定基础镜像）</h4><p>该指令有两种格式：使用 <code>FROM &lt;image&gt;</code> 指定基础镜像为该 image 的最后修改版本。或者实使用 <code>FROM &lt;image&gt;:&lt;tag&gt;</code> 指定基础 image 为该 image 的一个 tag 版本。</p><p>尽可能使用官方仓库当前版本作为你的基础镜像。推荐使用 <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">Alpine</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p><h4 id="LABEL（向映像添加元数据）"><a href="#LABEL（向映像添加元数据）" class="headerlink" title="LABEL（向映像添加元数据）"></a>LABEL（向映像添加元数据）</h4><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个键值对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p><blockquote><p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p></blockquote><pre class="line-numbers language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># Set one or more individual labels</span><span class="token keyword">LABEL</span> com.example.version=<span class="token string">"0.0.1-beta"</span><span class="token keyword">LABEL</span> vendor=<span class="token string">"ACME Incorporated"</span><span class="token keyword">LABEL</span> com.example.release<span class="token punctuation">-</span>date=<span class="token string">"2015-02-12"</span><span class="token keyword">LABEL</span> com.example.version.is<span class="token punctuation">-</span>production=<span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个镜像可以包含多个标签，可以在一行中指定多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># Set multiple labels at once, using line-continuation characters to break long lines</span><span class="token keyword">LABEL</span> vendor=ACME\ Incorporated \    com.example.is<span class="token punctuation">-</span>beta= \    com.example.is<span class="token punctuation">-</span>production=<span class="token string">""</span> \    com.example.version=<span class="token string">"0.0.1-beta"</span> \    com.example.release<span class="token punctuation">-</span>date=<span class="token string">"2015-02-12"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于标签的更多信息，可以参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">Understanding object labels</a>。</p><h4 id="RUN（一般用于安装软件）"><a href="#RUN（一般用于安装软件）" class="headerlink" title="RUN（一般用于安装软件）"></a>RUN（一般用于安装软件）</h4><p><code>RUN</code> 指令是在新镜像内部执行的命令，可以运行任何被基础 image 支持的命令，如：执行某些动作、安装系统软件、配置系统信息之类。为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p><h5 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h5><p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p><p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p><p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \    package<span class="token punctuation">-</span>bar \    package<span class="token punctuation">-</span>baz \    package<span class="token punctuation">-</span>foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>18.04<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>18.04<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p><p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \    package<span class="token punctuation">-</span>bar \    package<span class="token punctuation">-</span>baz \    package<span class="token punctuation">-</span>foo=1.3.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p><p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \    aufs<span class="token punctuation">-</span>tools \    automake \    build<span class="token punctuation">-</span>essential \    curl \    dpkg<span class="token punctuation">-</span>sig \    libcap<span class="token punctuation">-</span>dev \    libsqlite3<span class="token punctuation">-</span>dev \    mercurial \    reprepro \    ruby1.9.1 \    ruby1.9.1<span class="token punctuation">-</span>dev \    s3cmd=1.1.* \ &amp;&amp; rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p><p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p><blockquote><p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p></blockquote><h4 id="CMD（设置容器启动时默认操作）"><a href="#CMD（设置容器启动时默认操作）" class="headerlink" title="CMD（设置容器启动时默认操作）"></a>CMD（设置容器启动时默认操作）</h4><p><code>CMD</code> 指令的主要目的是为正在执行的容器提供缺省值。指定容器启动时执行的操作。该操作可以是执行自定义脚本，也可以是执行系统命令。该指令只能在文件中存在一次，如果有多个，则只执行最后一条。</p><p><code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p><p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。</p><p><code>CMD</code> 应该在极少的情况下以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p><blockquote><p>注意: 不要将 RUN 与 CMD 混淆。 Run 实际上是运行一个命令并提交结果; CMD 在构建时不执行任何操作，但会指定镜像的预期命令。</p></blockquote><h4 id="ENTRYPOINT（设置镜像主命令）"><a href="#ENTRYPOINT（设置镜像主命令）" class="headerlink" title="ENTRYPOINT（设置镜像主命令）"></a>ENTRYPOINT（设置镜像主命令）</h4><p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，与 <code>CMD</code> 非常相似。当 <code>CMD</code> 和 <code>ENTRYPOINT</code> 都存在时，<code>CMD</code> 的指令变成了 <code>ENTRYPOINT</code> 指令的参数。并且此 CMD 提供的参数会被 docker run 后面的命令覆盖。</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM ubuntuCMD ["-l"]ENTRYPOINT ["/usr/bin/ls"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你使用 CMD 命令且 CMD 是一个完整的可执行的命令，那么 CMD 指令和 ENTRYPOINT 会互相覆盖只有最后一个 CMD 或者 ENTRYPOINT 有效。</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># CMD指令将不会被执行，只有ENTRYPOINT指令被执行CMD echo “Hello, World!”ENTRYPOINT ls -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p><p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">set</span> -e<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">=</span> <span class="token string">'postgres'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token function">chown</span> -R postgres <span class="token string">"<span class="token variable">$PGDATA</span>"</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"$(ls -A "</span><span class="token variable">$PGDATA</span><span class="token string">")"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        gosu postgres initdb    <span class="token keyword">fi</span>    <span class="token function">exec</span> gosu postgres <span class="token string">"<span class="token variable">$@</span>"</span><span class="token keyword">fi</span><span class="token function">exec</span> <span class="token string">"<span class="token variable">$@</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p></blockquote><p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> ./docker<span class="token punctuation">-</span>entrypoint.sh /<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">"/docker-entrypoint.sh"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p><p>你可以很简单地启动 <code>Postgres</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run postgres<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以执行 <code>Postgres</code> 并传递参数：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run postgres postgres --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --rm -it postgres <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="EXPOSE（暴露容器端口）"><a href="#EXPOSE（暴露容器端口）" class="headerlink" title="EXPOSE（暴露容器端口）"></a>EXPOSE（暴露容器端口）</h4><p><code>EXPOSE</code> 指令用于指将容器中的端口映射成宿主机的某个端口。当你需要访问容器的时候，可以不使用容器的 IP 地址而是使用宿主机器的 IP 地址和映射后的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p><p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用 <code>-p</code> 标志来将容器的指定端口映射到宿主机所选择的端口。</p><h4 id="ENV（设置环境变量）"><a href="#ENV（设置环境变量）" class="headerlink" title="ENV（设置环境变量）"></a>ENV（设置环境变量）</h4><p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。</p><p>例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p><p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p><p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ENV</span> PG_MAJOR 9.3<span class="token keyword">ENV</span> PG_VERSION 9.3.4<span class="token keyword">RUN</span> curl <span class="token punctuation">-</span>SL http<span class="token punctuation">:</span>//example.com/postgres<span class="token punctuation">-</span>$PG_VERSION.tar.xz <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xJC /usr/src/postgress &amp;&amp; …<span class="token keyword">ENV</span> PATH /usr/local/postgres<span class="token punctuation">-</span>$PG_MAJOR/bin<span class="token punctuation">:</span>$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p><p>在使用 ENV 设置环境变量时，有几点需要注意：</p><ul><li>1）具有传递性，也就是当前镜像被用作其它镜像的基础镜像时，新镜像会拥有当前这个基础镜像所有的环境变量</li><li>2）ENV 定义的环境变量，可以在 dockerfile 被后面的所有指令（CMD 除外）中使用，但不能被 docker run 的命令参数引用</li></ul><h4 id="ADD-和-COPY（复制文件到容器）"><a href="#ADD-和-COPY（复制文件到容器）" class="headerlink" title="ADD 和 COPY（复制文件到容器）"></a>ADD 和 COPY（复制文件到容器）</h4><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p><p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> requirements.txt /tmp/<span class="token keyword">RUN</span> pip install <span class="token punctuation">-</span><span class="token punctuation">-</span>requirement /tmp/requirements.txt<span class="token keyword">COPY</span> . /tmp/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p><p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ADD</span> http<span class="token punctuation">:</span>//example.com/big.tar.xz /usr/src/things/<span class="token keyword">RUN</span> tar <span class="token punctuation">-</span>xJf /usr/src/things/big.tar.xz <span class="token punctuation">-</span>C /usr/src/things<span class="token keyword">RUN</span> make <span class="token punctuation">-</span>C /usr/src/things all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而是应该使用下面这种方法：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> mkdir <span class="token punctuation">-</span>p /usr/src/things \    &amp;&amp; curl <span class="token punctuation">-</span>SL http<span class="token punctuation">:</span>//example.com/big.tar.xz \    <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xJC /usr/src/things \    &amp;&amp; make <span class="token punctuation">-</span>C /usr/src/things all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面使用的管道操作，所以没有中间文件需要删除。</p><p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p><h4 id="VOLUME（指定挂载点）"><a href="#VOLUME（指定挂载点）" class="headerlink" title="VOLUME（指定挂载点）"></a>VOLUME（指定挂载点）</h4><p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p><h4 id="USER（指定运行镜像时使用的用户）"><a href="#USER（指定运行镜像时使用的用户）" class="headerlink" title="USER（指定运行镜像时使用的用户）"></a>USER（指定运行镜像时使用的用户）</h4><p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p><blockquote><p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。</p></blockquote><p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener">gosu</a>。</p><p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p><h4 id="WORKDIR（切换目录）"><a href="#WORKDIR（切换目录）" class="headerlink" title="WORKDIR（切换目录）"></a>WORKDIR（切换目录）</h4><p>为跟在它后面的 <code>RUN</code>、 <code>CMD</code>、 <code>ENTRYPOINT</code>、 <code>COPY</code> 和 <code>ADD</code> 指令设置工作目录。其效果类似于 Linux 命名中的<code>cd</code> 命令，用于目录的切换，但是和 <code>cd</code> 不一样的是：如果切换到的目录不存在，WORKDIR 会为此创建目录。</p><p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p><h4 id="ONBUILD（在子镜像中执行）"><a href="#ONBUILD（在子镜像中执行）" class="headerlink" title="ONBUILD（在子镜像中执行）"></a>ONBUILD（在子镜像中执行）</h4><p>Onbuild 指令向镜像添加一个触发器指令，以便在以后将该映像用作另一个构建的基础镜像时执行。 意思就是：这个镜像创建时不会执行，以后，如果其它镜像以这个镜像为基础，会先执行这个镜像的 ONBUILD 命令。</p><p>任何构建指令都可以注册为触发器。如果 <code>Onbuild</code> 指令执行失败，子镜像的 FROM 指令就会中止。执行完触发器后，将从最终图像中清除触发器。换句话说，它们不会传递到“孙子代”版本镜像中。</p><h4 id="ARG（设置构建镜像时变量）"><a href="#ARG（设置构建镜像时变量）" class="headerlink" title="ARG（设置构建镜像时变量）"></a>ARG（设置构建镜像时变量）</h4><p>ARG 定义的变量只在建立 image 时有效，建立完成后变量就失效消失。用户可以在 <code>docker build</code> 时使用带有<code>--build-arg =</code> 标志的命令将变量传递给构建器。</p><p>同时使用<code>ARG</code>或<code>ENV</code>指令为 <code>RUN</code> 指令设置变量时，<code>ENV</code> 指令定义的环境变量 会始终覆盖<code>ARG</code>同名指令。例如:</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM ubuntuARG CONT_IMG_VERENV CONT_IMG_VER v1.0.0RUN echo $CONT_IMG_VER<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，使用以下命令构建镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build --build-arg CONT_IMG_VER<span class="token operator">=</span>v2.0.1 <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在情况下，<code>RUN</code>指令将使用<code>v1.0.0</code>，而不是<code>ARG</code>用户传递的值：<code>v2.0.1</code>。</p><p>Docker 有一组预定义的 ARG 变量，您可以在 Dockerfile 中不使用相应的 ARG 指令而使用它们：</p><ul><li><code>HTTP_PROXY</code></li><li><code>http_proxy</code></li><li><code>HTTPS_PROXY</code></li><li><code>https_proxy</code></li><li><code>FTP_PROXY</code></li><li><code>ftp_proxy</code></li><li><code>NO_PROXY</code></li><li><code>no_proxy</code></li></ul><p>要使用它们，只需在命令行上使用 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志赋值。默认情况下，这些预定义的变量被排除在 docker 历史记录的输出之外。 这可以降低意外泄漏 httpproxy 变量中敏感的身份验证信息的风险。</p><p>例如，使用 <code>--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com</code> 构建镜像时，httpproxy 变量的值在 docker 历史记录中不可用，也不会被缓存。</p><h3 id="3、一般准则和建议"><a href="#3、一般准则和建议" class="headerlink" title="3、一般准则和建议"></a>3、一般准则和建议</h3><h4 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h4><p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置的工作量应该是极小的。</p><h4 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 .dockerignore 文件</h4><p>使用 <code>Dockerfile</code> 构建镜像时最好将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p><h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>在 <code>Docker 17.05</code> 以上版本中，你可以使用多阶段构建来减少所构建镜像的大小。</p><h4 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h4><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p><h4 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" class="headerlink" title="一个容器只运行一个进程"></a>一个容器只运行一个进程</h4><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web 应用、数据库、缓存。</p><p>如果容器互相依赖，你可以使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/network/linking.html" target="_blank" rel="noopener">Docker 自定义网络</a> 来把这些容器连接起来。</p><h4 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" class="headerlink" title="镜像层数尽可能少"></a>镜像层数尽可能少</h4><p>每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p><h4 id="将多行参数排序"><a href="#将多行参数排序" class="headerlink" title="将多行参数排序"></a>将多行参数排序</h4><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p><p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \  bzr \  cvs \  git \  mercurial \  subversion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用构建缓存"><a href="#使用构建缓存" class="headerlink" title="使用构建缓存"></a>使用构建缓存</h4><p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p><p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会或不会找到匹配的镜像，遵循的基本规则如下：</p><ul><li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li><li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li><li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li><li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li></ul><p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p><h3 id="4、官方镜像示例"><a href="#4、官方镜像示例" class="headerlink" title="4、官方镜像示例"></a>4、官方镜像示例</h3><p>这些官方镜像的 Dockerfile 都是参考典范：<a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">https://github.com/docker-library/docs</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10、Docker 常用命令 - Docker必知必会</title>
      <link href="/2020/030137160.html"/>
      <url>/2020/030137160.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令列表"><a href="#常用命令列表" class="headerlink" title="常用命令列表"></a>常用命令列表</h2><p>一张图总结 Docker 常用命令及状态变化：</p><p><img src="https://pic.lixl.cn/2020/image-20200325192936728.png" alt="Docker常用命令及状态变化图"></p><p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p><ul><li><code>attach</code>：依附到一个正在运行的容器中；</li><li><code>build</code>：从一个 Dockerfile 创建一个镜像；</li><li><code>commit</code>：从一个容器的修改中创建一个新的镜像；</li><li><code>cp</code>：在容器和本地宿主系统之间复制文件中；</li><li><code>create</code>：创建一个新容器，但并不运行它；</li><li><code>diff</code>：检查一个容器内文件系统的修改，包括修改和增加；</li><li><code>events</code>：从服务端获取实时的事件；</li><li><code>exec</code>：在运行的容器内执行命令；</li><li><code>export</code>：导出容器内容为一个 <code>tar</code> 包；</li><li><code>history</code>：显示一个镜像的历史信息；</li><li><code>images</code>：列出存在的镜像；</li><li><code>import</code>：导入一个文件（典型为 <code>tar</code> 包）路径或目录来创建一个本地镜像；</li><li><code>info</code>：显示一些相关的系统信息；</li><li><code>inspect</code>：显示一个容器的具体配置信息；</li><li><code>kill</code>：关闭一个运行中的容器 (包括进程和所有相关资源)；</li><li><code>load</code>：从一个 tar 包中加载一个镜像；</li><li><code>login</code>：注册或登录到一个 Docker 的仓库服务器；</li><li><code>logout</code>：从 Docker 的仓库服务器登出；</li><li><code>logs</code>：获取容器的 log 信息；</li><li><code>network</code>：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li><li><code>node</code>：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</li><li><code>pause</code>：暂停一个容器中的所有进程；</li><li><code>port</code>：查找一个 nat 到一个私有网口的公共口；</li><li><code>ps</code>：列出主机上的容器；</li><li><code>pull</code>：从一个 Docker 的仓库服务器下拉一个镜像或仓库；</li><li><code>push</code>：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li><li><code>rename</code>：重命名一个容器；</li><li><code>restart</code>：重启一个运行中的容器；</li><li><code>rm</code>：删除给定的若干个容器；</li><li><code>rmi</code>：删除给定的若干个镜像；</li><li><code>run</code>：创建一个新容器，并在其中运行给定命令；</li><li><code>save</code>：保存一个镜像为 tar 包文件；</li><li><code>search</code>：在 Docker index 中搜索一个镜像；</li><li><code>service</code>：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li><li><code>start</code>：启动一个容器；</li><li><code>stats</code>：监控容器的 CPU 利用率、内存使用量、网络 IO 总量以及磁盘 IO 总量等信息；</li><li><code>stop</code>：终止一个运行中的容器；</li><li><code>swarm</code>：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li><li><code>tag</code>：为一个镜像打标签；</li><li><code>top</code>：查看一个容器中的正在运行的进程信息；</li><li><code>unpause</code>：将一个容器内所有的进程从暂停状态中恢复；</li><li><code>update</code>：更新指定的若干容器的配置信息；</li><li><code>version</code>：输出 Docker 的版本信息；</li><li><code>volume</code>：管理 Docker volume，包括查看、创建、删除等；</li><li><code>wait</code>：阻塞直到一个容器终止，然后输出它的退出符。</li></ul><h2 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h2><h3 id="查看-Docker-版本和系统信息"><a href="#查看-Docker-版本和系统信息" class="headerlink" title="查看 Docker 版本和系统信息"></a>查看 Docker 版本和系统信息</h3><p>无论是在本地还是云端，我们都需要检查 Docker 版本和系统信息，可以使用以下命令找到 Docker 版本：</p><pre class="line-numbers language-bash"><code class="language-bash">docker versionClient:Version: 18.03.0-ceAPI version: 1.37Go version: go1.9.4Git commit: 0520e24Built: Wed Mar 21 23:06:22 2018OS/Arch: darwin/amd64Experimental: <span class="token boolean">false</span>Orchestrator: swarmServer:Engine:Version: 18.03.0-ceAPI version: 1.37 <span class="token punctuation">(</span>minimum version 1.12<span class="token punctuation">)</span>Go version: go1.9.4Git commit: 0520e24Built: Wed Mar 21 23:14:32 2018OS/Arch: linux/amd64Experimental: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个重要命令是 docker info：</p><pre class="line-numbers language-bash"><code class="language-bash">docker infoContainers: 0Running: 0Paused: 0Stopped: 0Images: 0Server Version: 18.03.0-ceStorage Driver: overlay2Backing Filesystem: extfsSupports d_type: <span class="token boolean">true</span>Native Overlay Diff: <span class="token boolean">true</span>Logging Driver: json-fileCgroup Driver: cgroupfsPlugins:Volume: localNetwork: bridge host ipvlan macvlan null overlayLog: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该命令将显示部分设备信息，比如服务器版本、存储驱动程序、内核版本、操作系统、总内存等。当尝试为当前 Docker 安装启动新资源或尝试找出系统级资源分配问题时，这些信息非常有用，这也是检查运行、停止容器数量及下载镜像数量的快速方法。</p><h3 id="搜索下载-Docker-镜像"><a href="#搜索下载-Docker-镜像" class="headerlink" title="搜索下载 Docker 镜像"></a>搜索下载 Docker 镜像</h3><p>可以使用 docker search 命令在 Docker Hub 搜索已有镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker search ubuntuNAME DESCRIPTION STARS OFFICIAL AUTOMATEDubuntu Ubuntu is a Debian-based Linux operating sys… 7861 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>dorowu/ubuntu-desktop-lxde-vnc Ubuntu with openssh-server and NoVNC 190 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>rastasheep/ubuntu-sshd Dockerized SSH service, built on <span class="token function">top</span> of offi… 156 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>ansible/ubuntu14.04-ansible Ubuntu 14.04 LTS with ansible 93 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>ubuntu-upstart Upstart is an event-based replacement <span class="token keyword">for</span> th… 87 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>neurodebian NeuroDebian provides neuroscience research s… 50 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上对 ubuntu 的搜索显示可用镜像、描述和官方状态等信息。如果要下载 ubuntu 镜像，可以使用 docker pull 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull ubuntuUsing default tag: latestlatest: Pulling from library/ubuntu6b98dfc16071: Pull complete4001a1209541: Pull complete6319fc68c576: Pull completeb24603670dc3: Pull complete97f170c87c6f: Pull completeDigest: sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6dStatus: Downloaded newer image <span class="token keyword">for</span> ubuntu:latest$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>使用 docker info 命令查找拥有镜像数量：</p><pre class="line-numbers language-bash"><code class="language-bash">docker infoContainers: 0Running: 0Paused: 0Stopped: 0Images: 1…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker images 命令可详细列出拥有镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              latest              113a43faa138        2 weeks ago         81.2MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>假设下载 NGINX 镜像，可以运行 docker pull 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果检查 Docker 镜像，会看到如下内容：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              latest              113a43faa138        2 weeks ago         81.2MBnginx               latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果寻找 Ubuntu 16.04 版本，可使用 16.04 标签下载特定版本：</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull ubuntu:16.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>随后，将出现两个 Ubuntu 映像版本：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              16.04               5e8b97a2a082        2 weeks ago         114MBubuntu              latest              113a43faa138        2 weeks ago         81.2MBnginx               latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：无需注册 Docker Hub 即可提取镜像。如果想将镜像推送到 Docker Hub，需要注册然后使用 docker login 命令登录：</p><pre class="line-numbers language-bash"><code class="language-bash">docker login --username<span class="token operator">=</span>yourhubusername --email<span class="token operator">=</span>youremail@company.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="运行-Docker-容器"><a href="#运行-Docker-容器" class="headerlink" title="运行 Docker 容器"></a>运行 Docker 容器</h3><p>假设想在 docker 上运行 NGINX 服务器，可运行以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -p 8080:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果已用 run 命令从 Docker Hub 提取 nginx 映像创建 NGINX 容器。 -p 8080:80 会告诉 Docker 将 localhost 端口 8080 映射到 Docker 容器端口 80，应该能够从 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 访问 NGINX 服务器。</p><p>NGINX 容器已附加到命令行。如果退出命令行，容器将会停止，可使用 detach（’- d）启动 NGINX 容器，这样即使退出命令行也可继续运行。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -p 8080:80 -d nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令将以分离模式启动容器并返回命令行。<code>docker run</code> 命令格式：</p><pre class="line-numbers language-bash"><code class="language-bash">Usage: docker run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGE <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>-a, --attach<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#登录容器（以docker run -d启动的容器）</span>-c, --cpu-shares<span class="token operator">=</span>0 <span class="token comment" spellcheck="true">#设置容器CPU权重，在CPU共享场景使用</span>--cap-add<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</span>--cap-drop<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</span>--cidfile<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</span>--cpuset<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</span>-d, --detach<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#指定容器运行于前台还是后台</span>--device<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#添加主机设备给容器，相当于设备直通</span>--dns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器的dns服务器</span>--dns-search<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</span>-e, --env<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定环境变量，容器中可以使用该环境变量</span>--entrypoint<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#覆盖image的入口点</span>--env-file<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定环境变量文件，文件格式为每行一个环境变量</span>--expose<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器暴露的端口，即修改镜像的暴露端口</span>-h, --hostname<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器的主机名</span>-i, --interactive<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#打开STDIN，用于控制台交互</span>--link<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器间的关联，使用其他容器的IP、env等信息</span>--lxc-conf<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器的配置文件，只有在指定--exec-driver=lxc时使用</span>-m, --memory<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器的内存上限</span>--name<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</span>--net<span class="token operator">=</span><span class="token string">"bridge"</span> <span class="token comment" spellcheck="true">#容器网络设置，待详述</span>-P, --publish-all<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#指定容器暴露的端口，待详述</span>-p, --publish<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器暴露的端口，待详述</span>--privileged<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#指定容器是否为特权容器，特权容器拥有所有的capabilities</span>--restart<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器停止后的重启策略，待详述</span>--rm<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</span>--sig-proxy<span class="token operator">=</span>true <span class="token comment" spellcheck="true">#设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</span>-t, --tty<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#分配tty设备，该可以支持终端登录</span>-u, --user<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器的用户</span>-v, --volume<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#给容器挂载存储卷，挂载到容器的某个目录</span>--volumes-from<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#给容器挂载其他容器上的卷，挂载到容器的某个目录</span>-w, --workdir<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器的工作目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列出-Docker-容器"><a href="#列出-Docker-容器" class="headerlink" title="列出 Docker 容器"></a>列出 Docker 容器</h3><p>docker ps 命令允许查找正在运行的所有容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID         IMAGE         COMMAND         CREATED           STATUS          PORTS             NAMES6162daed25da         nginx  <span class="token string">"nginx -g 'daemon of…"</span> 7 minutes ago   Up 7 minutes  0.0.0.0:8080-<span class="token operator">></span>80/tcp  hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如上显示容器的各种属性，可以看到是从 nginx 镜像创建并显示端口转发信息。CONTAINER ID 和 NAMES 属性需要特别提及，可以使用上述两大属性唯一标识容器。二者都可自动生成，但也可在容器创建过程中为容器命名。<br>创建一个名为 my_nginx 的 NGINX 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --name my_nginx -p 8888:80 -d nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次列出所有 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMESe7b19b6ad778        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   About a minute ago   Up About a minute   0.0.0.0:8888-<span class="token operator">></span>80/tcp   my_nginx6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   15 minutes ago       Up 16 minutes       0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，新容器的名称为“my_nginx”。 处理大量容器时，可以使用命名约定，这可以更好得组织容器。<br>docker ps 命令仅显示正在运行的容器。如果对上述情况使用 docker info 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker infoContainers: 2Running: 2Paused: 0Stopped: 0Images: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到有两个容器正在运行，如果一个暂停或已停止，则不会仅使用 docker ps 命令查看这些容器，必须使用 all（ - a）选项：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="启动，停止，重启和杀死容器"><a href="#启动，停止，重启和杀死容器" class="headerlink" title="启动，停止，重启和杀死容器"></a>启动，停止，重启和杀死容器</h3><p>假设要停止’my_nginx’容器，可使用 CONTAINER ID 或 NAME。</p><pre class="line-numbers language-bash"><code class="language-bash">docker stop my_nginxmy_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   27 minutes ago      Up 27 minutes       0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvaldsdocker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS                  NAMESe7b19b6ad778        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   12 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About a minute ago                          my_nginx6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   27 minutes ago      Up 27 minutes                   0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在没有 -a 选项的情况下运行 docker ps，只显示正在运行的容器。在第二种情况下，可以看到’my_nginx’容器处于退出状态。</p><p>让我们 docker start 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker start my_nginxmy_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>检查 Docker 容器列表：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMESe7b19b6ad778        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   16 minutes ago      Up 29 seconds       0.0.0.0:8888-<span class="token operator">></span>80/tcp   my_nginx6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   30 minutes ago      Up 30 minutes       0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 STATUS 显示容器’my_nginx’再次被启动。<br>如果由于某些问题而需重启容器，则可使用 restart 命令，这比单独停止和启动容器速度更快：</p><pre class="line-numbers language-bash"><code class="language-bash">docker restart my_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以像进程一样终止 docker 容器，比如终止 my_nginx 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">kill</span> my_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS                  NAMESe7b19b6ad778        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   22 minutes ago      Exited <span class="token punctuation">(</span>137<span class="token punctuation">)</span> 7 seconds ago                          my_nginx6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   36 minutes ago      Up 36 minutes                0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>容器 my_nginx 未运行。此外，可在信息中看到一个正在运行的容器和一个已停止容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker infoContainers: 2Running: 1Paused: 0Stopped: 1Images: 3…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker-Exec-Bash-和-Docker-SSH"><a href="#Docker-Exec-Bash-和-Docker-SSH" class="headerlink" title="Docker Exec Bash 和 Docker SSH"></a>Docker Exec Bash 和 Docker SSH</h3><p>如果需要与 shell 进行交互以创建服务或解决问题，可以使用 docker exec 命令创建交互式 shell。比如，用 bash shell 从 ubuntu 映像启动一个容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --name my_ubuntu -it ubuntu:latest <span class="token function">bash</span>root@a19c770b8621:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>root @haracle＃表示位于 Docker 容器的 bash shell 中，可以运行 shell 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">root@a19c770b8621:/<span class="token comment" spellcheck="true"># ls</span>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@a19c770b8621:/<span class="token comment" spellcheck="true"># pwd</span>/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMESa19c770b8621        ubuntu:latest       <span class="token string">"bash"</span>                   About a minute ago   Up About a minute                          my_ubuntu6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   About an hour ago    Up About an hour    0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如上，my_ubuntu 正在运行。假设想将 Docker ssh 放入’my_ubuntu’容器中，可以使用 docker exec bash：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it my_ubuntu <span class="token function">bash</span>root@a19c770b8621:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 docker exec 向容器发出命令。例如，可以直接用命令提示符在 my_ubuntu 容器上运行 ls 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it my_ubuntu <span class="token function">ls</span>bin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="以分离模式启动容器并-attach"><a href="#以分离模式启动容器并-attach" class="headerlink" title="以分离模式启动容器并 attach"></a>以分离模式启动容器并 attach</h3><p>以上示例用附加模式启动 ubuntu 容器，我们也可在分离模式下启动：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -d --name my_ubuntu_2 ubuntu:latest <span class="token function">bash</span>75b28b7208359137b3e1dc2843387918e28b4c6c4860ef0cdeac79c205f5cbc4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>验证容器是否正在运行：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES75b28b720835        ubuntu:latest       <span class="token string">"bash"</span>                   3 minutes ago       Up 3 minutes                               my_ubuntu_2a19c770b8621        ubuntu:latest       <span class="token string">"bash"</span>                   15 minutes ago      Up 15 minutes                              my_ubuntu6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   2 hours ago         Up 2 hours          0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 docker attach 命令获取 docker exec bash-like 效果：</p><pre class="line-numbers language-bash"><code class="language-bash">docker attach my_ubuntu_2root@75b28b720835:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="检查-Docker-镜像历史"><a href="#检查-Docker-镜像历史" class="headerlink" title="检查 Docker 镜像历史"></a>检查 Docker 镜像历史</h3><p>Docker 社区镜像是分层创建的，可使用 Docker history 命令查看镜像创建方式。先看看有哪些镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              16.04               5e8b97a2a082        2 weeks ago         114MBubuntu              latest              113a43faa138        2 weeks ago         81.2MBnginx               latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 nginx 镜像历史：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">history</span> nginxIMAGE               CREATED             CREATED BY                                      SIZE                COMMENTcd5239a0906a        2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  CMD ["nginx" "-g" "daemon…   0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  STOPSIGNAL [SIGTERM]         0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  EXPOSE 80/tcp                0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token function">ln</span> -sf /dev/stdout /var/log/nginx…   22B<span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token keyword">set</span> -x  <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> update  <span class="token operator">&amp;&amp;</span> apt…   53.7MB<span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  ENV NJS_VERSION=1.15.0.0.…   0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  ENV NGINX_VERSION=1.15.0-…   0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           7 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  LABEL maintainer=NGINX Do…   0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           8 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  CMD ["bash"]                 0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           8 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ADD file:ec5be7eec56a74975…   55.3MB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用镜像历史命令查找最近更改，如果在新版本镜像中发现问题，则此命令可帮助找到原因，也可用以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker image <span class="token function">history</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Docker-检查容器"><a href="#Docker-检查容器" class="headerlink" title="Docker 检查容器"></a>Docker 检查容器</h3><p>可以使用 docker inspect 命令查找有关系统的信息，运行 docker ps 命令列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   2 hours ago         Up 2 hours          0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 CONTAINER ID 检查容器（也可使用容器名称）：</p><pre class="line-numbers language-bash"><code class="language-bash">docker inspect 6162daed25da<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"6162daed25da50b98afca5f7ed8caca2289bf309b2547d87ae8674b899d604a4"</span>,<span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2018-06-25T05:46:37.902211302Z"</span>,<span class="token string">"Path"</span><span class="token keyword">:</span> <span class="token string">"nginx"</span>,<span class="token string">"Args"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>………<span class="token string">"DriverOpts"</span><span class="token keyword">:</span> null<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该命令将以 JSON 格式提供大量信息，以下是查找容器 IP 地址的技巧：</p><pre class="line-numbers language-bash"><code class="language-bash">docker inspect 6162daed25da <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"IPAddress"</span>            <span class="token string">"SecondaryIPAddresses"</span><span class="token keyword">:</span> null,            <span class="token string">"IPAddress"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2"</span>,                    <span class="token string">"IPAddress"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器与主机间文件复制"><a href="#容器与主机间文件复制" class="headerlink" title="容器与主机间文件复制"></a>容器与主机间文件复制</h3><p>再次列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   3 hours ago         Up 3 hours          0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>NGINX 容器在端口 8080 上运行。因此，如果转到 http//localhost:8080，将看到以下内容：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"Welcome to nginx!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果看到此页面，则 nginx Web 服务器已成功安装并正常运行，需要进一步配置。<br>首先，在本地目录中创建 index.html：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>My Website<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    Hello world  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用带有 ls 的 docker exec 命令检查 NGINX 容器中具有 index.html 的文件夹：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it hardcore_torvalds <span class="token function">ls</span> /usr/share/nginx/html50x.html index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用创建的本地文件覆盖容器 index.html 文件：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">cp</span> index.html hardcore_torvalds:usr/share/nginx/html/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果再次检查<a href="http://localhost/" target="_blank" rel="noopener">http://localhost:</a>8080，应该可以看到问候语“Hello world”。<br>可使用 docker cp 命令在本地计算机和创建容器间移动文件，此方法可用于覆盖配置文件。</p><h3 id="创建-Docker-镜像"><a href="#创建-Docker-镜像" class="headerlink" title="创建 Docker 镜像"></a>创建 Docker 镜像</h3><p>如果想复制更多“Hello World”容器，必须将当前容器保存为镜像。<br>首先，停止容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker stop hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出所有 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS               NAMES75b28b720835        ubuntu:latest       <span class="token string">"bash"</span>                   About an hour ago   Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About an hour ago                       my_ubuntu_2a19c770b8621        ubuntu:latest       <span class="token string">"bash"</span>                   2 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About an hour ago                       my_ubuntu6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   3 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 27 seconds ago                          hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 STATUS 中，可以看到 NGINX’corecore_torvalds’容器已停止。使用 docker commit 命令创建新镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker commit 6162daed25da nginx_hello_world_templatesha256:117d060587a316035ed5a776e613d9cfbeee9fbfe202c6edc9203820c7da987b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果现在检查，将看到新镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY                   TAG                 IMAGE ID            CREATED             SIZEnginx_hello_world_template   latest              117d060587a3        40 seconds ago      109MBubuntu                       16.04               5e8b97a2a082        2 weeks ago         114MBubuntu                       latest              113a43faa138        2 weeks ago         81.2MBnginx                        latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用此镜像并启动新 Docker 容器，新创建容器将具有“Hello world”页面，而不是“Welcome NGINX”页面。示例如下：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -d -p 8886:80 nginx_hello_world_template4e042d76c39125471951626ba42cd609a65c73f041943298f74f4fc43dc5596a$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="删除-Docker-容器和镜像"><a href="#删除-Docker-容器和镜像" class="headerlink" title="删除 Docker 容器和镜像"></a>删除 Docker 容器和镜像</h3><p>Docker 容器和镜像会占用硬盘空间，因此最好定期清理。首先停止所有容器，然后列出所有容器，使用以下 Docker 命令执行操作：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS                         PORTS               NAMES4e042d76c391        nginx_hello_world_template   <span class="token string">"nginx -g 'daemon of…"</span>   2 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 8 seconds ago                           boring_keldysh75b28b720835        ubuntu:latest                <span class="token string">"bash"</span>                   2 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About an hour ago                       my_ubuntu_2a19c770b8621        ubuntu:latest                <span class="token string">"bash"</span>                   2 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About an hour ago                       my_ubuntu6162daed25da        nginx                        <span class="token string">"nginx -g 'daemon of…"</span>   3 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 11 minutes ago                          hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，有 4 个处于停止状态的容器，可使用 docker rm 命令删除容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">rm</span> 4e042d76c391 75b28b720835 a19c770b8621 6162daed25da4e042d76c39175b28b720835a19c770b86216162daed25da<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可使用 NAMES 代替 CONTAINER ID，容器列表现在应该是干净的：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出 Docker 镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY                   TAG                 IMAGE ID            CREATED             SIZEnginx_hello_world_template   latest              117d060587a3        11 minutes ago      109MBubuntu                       16.04               5e8b97a2a082        2 weeks ago         114MBubuntu                       latest              113a43faa138        2 weeks ago         81.2MBnginx                        latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可使用 docker rmi 命令和 IMAGE ID 删除 docker 镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker rmi 117d060587a3 5e8b97a2a082 113a43faa138 cd5239a0906a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，Docker 镜像列表应该是干净的：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://dzone.com/articles/top-docker-commands-itsyndicate" target="_blank" rel="noopener">Top Docker Commands Any Expert Should Know</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9、Docker Compose - Docker必知必会</title>
      <link href="/2020/022828889.html"/>
      <url>/2020/022828889.html</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>本文基于 Docker v19.03版本编写和测试，请留意版本差异。</li><li>本文参考/翻译自 Docker 官方文档，更详细的内容可查看 <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose</a></li></ul><h2 id="一、Docker-Compose-概述"><a href="#一、Docker-Compose-概述" class="headerlink" title="一、Docker Compose 概述"></a>一、Docker Compose 概述</h2><h3 id="1、Docker-Compose-是什么"><a href="#1、Docker-Compose-是什么" class="headerlink" title="1、Docker Compose 是什么"></a>1、Docker Compose 是什么</h3><p> <code>Compose</code> 项目是 <code>Docker</code> 官方的开源项目，基于 Python 编写，用于定义和运行多容器Docker应用程序。Compose 使用 YAML 文件来配置应用程序的服务。然后，使用一个命令，就可以从配置中创建并启动所有服务。</p><div class="admonition note"><p>使用 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。<code>Compose</code> 刚好可以满足这样的需求。</p></div><p>Compose 有着用于管理应用程序整个生命周期的各种命令:</p><ul><li>启动、停止和重建服务</li><li>查看正在运行的服务的状态</li><li>实时查看运行服务的日志输出</li><li>仅执行一次命令即可运行整个服务</li></ul><h3 id="2、Compose-使用步骤"><a href="#2、Compose-使用步骤" class="headerlink" title="2、Compose 使用步骤"></a>2、Compose 使用步骤</h3><p>使用 Compose 基本上有三个步骤:</p><ol><li>使用 <code>Dockerfile</code> 定义应用程序的环境，这样它就可以在任何地方复制。</li><li>用 <code>docker-compose. yml</code> 定义组成应用程序的服务，使其可以在一个独立的环境中一起运行。</li><li>运行 <code>docker-Compose up</code> ，Compose 启动并运行您的整个应用程序。</li></ol><h3 id="3、典型-docker-compose-文件示例"><a href="#3、典型-docker-compose-文件示例" class="headerlink" title="3、典型 docker-compose 文件示例"></a>3、典型 docker-compose 文件示例</h3><p>使用 <code>docker-compose</code> 您主要的任务是编写 <code>docker-compose.yml</code> 文件。以下是一个 <code>WordPress</code> 的 yaml 文件模板：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>        <span class="token comment" spellcheck="true"># 定义版本，不指定默认为版本 1</span><span class="token key atrule">services</span><span class="token punctuation">:</span>           <span class="token comment" spellcheck="true"># 定义容器，就像 docker run</span>   <span class="token key atrule">db</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 容器名称，也是 network 中 DNS 名称</span>     <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7   </span><span class="token comment" spellcheck="true"># 镜像，如果自定义镜像可以不指定这个参数，而用 build</span>     <span class="token key atrule">volumes</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># 定义数据卷，类似 -v</span>       <span class="token punctuation">-</span> db_data<span class="token punctuation">:</span>/var/lib/mysql       <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/lxl80   <span class="token comment" spellcheck="true"># 挂载当前目录到容器中的 /lxl80 目录</span>     <span class="token key atrule">restart</span><span class="token punctuation">:</span> always  <span class="token comment" spellcheck="true"># 类似 --restart。'no' 默认，不自动重启；always 总是自动重启； on-failure 当失败时自动重启；unless-stopped 除非手动停止，否者一直重启</span>     <span class="token key atrule">environment</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 定义环境变量，类似 -e</span>       <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> somewordpress       <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> wordpress       <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> wordpress       <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> wordpress   <span class="token key atrule">wordpress</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 第二个容器</span>     <span class="token key atrule">labels</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># 为容器添加 Docker 元数据（metadata）信息。</span>       <span class="token key atrule">cn.lixl.title</span><span class="token punctuation">:</span> <span class="token string">"This label will appear on all containers for the web service"</span>     <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 定义容器之间的关系。启动 wordpress 时会先启动 db</span>       <span class="token punctuation">-</span> db     <span class="token key atrule">image</span><span class="token punctuation">:</span> wordpress<span class="token punctuation">:</span>latest     <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 端口，类似 -p</span>       <span class="token punctuation">-</span> <span class="token string">"8000:80"</span>     <span class="token key atrule">restart</span><span class="token punctuation">:</span> always     <span class="token key atrule">environment</span><span class="token punctuation">:</span>       <span class="token key atrule">WORDPRESS_DB_HOST</span><span class="token punctuation">:</span> db<span class="token punctuation">:</span><span class="token number">3306</span>       <span class="token key atrule">WORDPRESS_DB_USER</span><span class="token punctuation">:</span> wordpress       <span class="token key atrule">WORDPRESS_DB_PASSWORD</span><span class="token punctuation">:</span> wordpress<span class="token key atrule">volumes</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true"># 可选，需要创建的数据卷，类似 docker volume create</span>  <span class="token key atrule">db_data</span><span class="token punctuation">:</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>         <span class="token comment" spellcheck="true"># 可选，需要创建的网络，类似 docker network create</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、Compose安装及卸载"><a href="#二、Compose安装及卸载" class="headerlink" title="二、Compose安装及卸载"></a>二、Compose安装及卸载</h2><h3 id="1、安装-Compose"><a href="#1、安装-Compose" class="headerlink" title="1、安装 Compose"></a>1、安装 Compose</h3><p><code>Docker Desktop</code> for Mac/Windows 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose --versiondocker-compose version 1.24.1, build 4667896b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 Linux 上的也安装十分简单，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">></span> /usr/local/bin/docker-compose<span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为 <code>bash</code> 安装 <a href="https://docs.docker.com/compose/completion/" target="_blank" rel="noopener">命令补全</a> 功能：</p><pre class="line-numbers language-bash"><code class="language-bash">curl -L https://raw.githubusercontent.com/docker/compose/1.24.1/contrib/completion/bash/docker-compose <span class="token operator">></span> /etc/bash_completion.d/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、卸载-Compose"><a href="#2、卸载-Compose" class="headerlink" title="2、卸载 Compose"></a>2、卸载 Compose</h3><p>如果基于 <code>curl</code> 安装，通过以下命令卸载Docker Compose ：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rm</span> /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果基于 <code>pip</code> 安装，通过以下命令卸载Docker Compose ：</p><pre class="line-numbers language-bash"><code class="language-bash">pip uninstall docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、Docker-Compose-入门"><a href="#三、Docker-Compose-入门" class="headerlink" title="三、Docker Compose 入门"></a>三、Docker Compose 入门</h2><h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><p>   <code>Compose</code> 中有两个重要的概念：</p><ul><li><p>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p></li><li><p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</p></li></ul><p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p><h3 id="示例应用介绍"><a href="#示例应用介绍" class="headerlink" title="示例应用介绍"></a>示例应用介绍</h3><p>接下来，将构建一个运行在 Docker Compose 上的简单 Python web 应用程序。 该应用程序使用了 Flask 框架，并在 Redis 维护了一个点击计数器。</p><p>首选，需要确保已经安装了 Docker 引擎和 Docker Compose。 不需要安装 Python 或 Redis，因为它们都是由 Docker 镜像提供的。</p><h3 id="第一步：设置"><a href="#第一步：设置" class="headerlink" title="第一步：设置"></a>第一步：设置</h3><p>定义应用程序的依赖关系：</p><p>1、为项目创建一个目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> composetest<span class="token function">cd</span> composetest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、在项目目录中创建一个名为 app.py 的文件，内容如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> redis<span class="token keyword">from</span> flask <span class="token keyword">import</span> Flaskapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>cache <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'redis'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_hit_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    retries <span class="token operator">=</span> <span class="token number">5</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> cache<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>ConnectionError <span class="token keyword">as</span> exc<span class="token punctuation">:</span>            <span class="token keyword">if</span> retries <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> exc            retries <span class="token operator">-=</span> <span class="token number">1</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> get_hit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'Hello World! I have been seen {} times.\n'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本例中，redis 是应用程序网络上 redis 容器的主机名。 这里使用 Redis 的默认端口，6379。</p><p>3、在项目目录中创建另一个叫 <code>requirements.txt</code> 的文件，内容如下：</p><pre class="line-numbers language-python"><code class="language-python">flaskredis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="第二步：创建一个Dockerfile"><a href="#第二步：创建一个Dockerfile" class="headerlink" title="第二步：创建一个Dockerfile"></a>第二步：创建一个Dockerfile</h3><p>在这个步骤中，将编写一个 <code>Dockerfile</code> 来构建一个 Docker 镜像。镜像包含 Python 应用程序所需的所有依赖项，包括 Python 本身。</p><p>在项目目录中，创建一个名为 Dockerfile 的文件，内容如下：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM python:3.7-alpineWORKDIR /codeENV FLASK_APP app.pyENV FLASK_RUN_HOST 0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headersCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtCOPY . .CMD ["flask", "run"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这告诉 Docker：</p><ul><li>基于 Python 3.7 镜像构建</li><li>将工作目录设置为 <code>/code</code></li><li>设置 <code>flask</code> 命令使用的环境变量</li><li>安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以加速编译</li><li>复制 <code>requirements.txt</code> 并安装 Python 依赖项</li><li>将主机上的项目目录（当前目录）复制到镜像中的 <code>.</code> 工作目录</li><li>将容器的默认命令设置为 <code>flask run</code></li></ul><h3 id="第三步：用-Compose-文件定义服务"><a href="#第三步：用-Compose-文件定义服务" class="headerlink" title="第三步：用 Compose 文件定义服务"></a>第三步：用 Compose 文件定义服务</h3><p>在项目目录中创建一个名为 <code>docker-compose.yml</code> 的文件，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .   <span class="token comment" spellcheck="true"># 相当于 docker build .</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此 Compose 文件定义了两个服务：<code>web</code> 和 <code>redis</code>。</p><p><code>web</code>服务使用从当前目录中的 <code>Dockerfile</code> 构建的映像。然后将容器和主机绑定到公开端口 5000。 此示例服务使用 Flask web 服务器的默认端口5000。</p><p>Redis 服务使用从 dockerhub 注册表中提取的公共 Redis 映像。</p><h3 id="第四步：用-Compose-构建和运行应用"><a href="#第四步：用-Compose-构建和运行应用" class="headerlink" title="第四步：用 Compose 构建和运行应用"></a>第四步：用 Compose 构建和运行应用</h3><p>1、在项目目录中，通过运行 <code>docker-compose up</code> 启动应用程序。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose upCreating network <span class="token string">"composetest_default"</span> with the default driverCreating composetest_web_1 <span class="token punctuation">..</span>.Creating composetest_redis_1 <span class="token punctuation">..</span>.Creating composetest_web_1Creating composetest_redis_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>Attaching to composetest_web_1, composetest_redis_1web_1    <span class="token operator">|</span>  * Running on http://0.0.0.0:5000/ <span class="token punctuation">(</span>Press CTRL+C to quit<span class="token punctuation">)</span>redis_1  <span class="token operator">|</span> 1:C 17 Aug 22:11:10.480 <span class="token comment" spellcheck="true"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span>redis_1  <span class="token operator">|</span> 1:C 17 Aug 22:11:10.480 <span class="token comment" spellcheck="true"># Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just started</span>redis_1  <span class="token operator">|</span> 1:C 17 Aug 22:11:10.480 <span class="token comment" spellcheck="true"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span>web_1    <span class="token operator">|</span>  * Restarting with <span class="token function">stat</span>redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 * Running mode<span class="token operator">=</span>standalone, port<span class="token operator">=</span>6379.redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 <span class="token comment" spellcheck="true"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span>web_1    <span class="token operator">|</span>  * Debugger is active<span class="token operator">!</span>redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 <span class="token comment" spellcheck="true"># Server initialized</span>redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 <span class="token comment" spellcheck="true"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span>web_1    <span class="token operator">|</span>  * Debugger PIN: 330-787-903redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Compose 会拉取一个 Redis 镜像，为您的代码构建一个镜像，并启动您定义的服务。 在这种情况下，代码会在构建时静态复制到镜像中。</p><p>2、在浏览器中输入 <a href="http://localhost:5000/" target="_blank" rel="noopener">http://localhost:5000/</a> ，查看该应用程序的运行情况。</p><p>您应该在浏览器中看到一条消息，内容为：</p><pre class="line-numbers language-html"><code class="language-html">Hello World! I have been seen 1 times.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、刷新页面，数字应该会递增。</p><pre class="line-numbers language-html"><code class="language-html">Hello World! I have been seen 2 times.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、切换到另一个终端窗口，键入 <code>docker image ls</code> 查看本地镜像。此时列出的镜像应返回 <code>redis</code> 和 <code>composetest_web</code> 。</p><p>5、要停止应用程序，可以在另一个终端中进入项目目录运行 <code>docker-compose stop</code>，或者在启动应用程序的原始终端中按 <code>ctrl + c</code>。如果要停止并清除数据，以便再次启动后重新计数，可以执行 ``docker-compose down`。</p><h3 id="第五步：编辑-Compose-文件添加挂载"><a href="#第五步：编辑-Compose-文件添加挂载" class="headerlink" title="第五步：编辑 Compose 文件添加挂载"></a>第五步：编辑 Compose 文件添加挂载</h3><p>在项目目录中编辑 <code>docker-compose. yml</code>，为 web 服务添加一个 <code>bind mount</code>：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/code    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">FLASK_ENV</span><span class="token punctuation">:</span> development  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新增加 <code>volumes</code> 配置，将主机上的项目目录（当前目录）安装到容器内部的 <code>/code</code> 目录，使您可以即时修改代码，而不必重建镜像。新增 <code>environment</code> 键设置了 <code>FLASK_ENV</code> 环境变量，指示 <code>flask run</code> 要在开发模式下运行并在更改时重新加载代码。此模式仅应在开发中使用。</p><h3 id="第六步：重新构建并运行"><a href="#第六步：重新构建并运行" class="headerlink" title="第六步：重新构建并运行"></a>第六步：重新构建并运行</h3><p>从项目目录中，先输入 <code>docker-compose stop</code> 停止营业，然后输入 <code>docker-Compose up</code> 以构建带有更新的 Compose 文件的应用程序，并运行它。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose stopStopping composetest_web_1   <span class="token punctuation">..</span>. <span class="token keyword">done</span>Stopping composetest_redis_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>$ docker-compose upRecreating composetest_web_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>Starting composetest_redis_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>Attaching to composetest_redis_1, composetest_web_1redis_1  <span class="token operator">|</span> 1:C 17 Apr 2020 02:25:49.466 <span class="token comment" spellcheck="true"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>web_1    <span class="token operator">|</span>  * Serving Flask app <span class="token string">"app.py"</span> <span class="token punctuation">(</span>lazy loading<span class="token punctuation">)</span>web_1    <span class="token operator">|</span>  * Environment: developmentweb_1    <span class="token operator">|</span>  * Debug mode: onweb_1    <span class="token operator">|</span>  * Running on http://0.0.0.0:5000/ <span class="token punctuation">(</span>Press CTRL+C to quit<span class="token punctuation">)</span>web_1    <span class="token operator">|</span>  * Restarting with <span class="token function">stat</span>web_1    <span class="token operator">|</span>  * Debugger is active<span class="token operator">!</span>web_1    <span class="token operator">|</span>  * Debugger PIN: 143-909-154<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次检查浏览器中的 Hello World 提示消息，并刷新以查看计数增量。</p><blockquote><p>如果出现运行时错误指示找不到应用程序文件，拒绝卷安装或服务无法启动，请尝试启用文件或驱动器共享。有关更多信息，请参阅 Docker for Mac 上的 <a href="https://docs.docker.com/docker-for-mac/#file-sharing" target="_blank" rel="noopener">文件共享</a> 章节。</p></blockquote><h3 id="第七步：更新应用程序"><a href="#第七步：更新应用程序" class="headerlink" title="第七步：更新应用程序"></a>第七步：更新应用程序</h3><p>因为现在应用程序代码是使用卷安装到容器中的，所以可以对代码进行更改并立即生效，而无需重建镜像。</p><ol><li><p>更改 <code>app.py</code> 中的提示语并保存。例如，将 <code>Hello World!</code> 更改为 <code>Hello from Docker!</code> ：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">return</span> <span class="token string">'Hello from Docker! I have been seen {} times.\n'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在浏览器中刷新应用。会发现提示语已更新，并且计数器仍在增加。</p></li></ol><h3 id="第八步：尝试其它命令"><a href="#第八步：尝试其它命令" class="headerlink" title="第八步：尝试其它命令"></a>第八步：尝试其它命令</h3><p>如果要让服务在后台运行，可以将 <code>-d</code> 参数（用于“分离”模式）传递给 <code>docker-compose up</code> ，并用 <code>docker-compose ps</code> 查看当前正在运行的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose up  -dStarting composetest_web_1   <span class="token punctuation">..</span>. <span class="token keyword">done</span>Starting composetest_redis_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>$ docker-compose <span class="token function">ps</span>       Name                      Command               State           Ports-------------------------------------------------------------------------------------composetest_redis_1   docker-entrypoint.sh redis <span class="token punctuation">..</span>.   Up      6379/tcpcomposetest_web_1     flask run                        Up      0.0.0.0:5000-<span class="token operator">></span>5000/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>docker-compose run</code> 命令允许为服务运行一次性命令。 例如，查看 <code>web</code> 服务可用的环境变量：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose run web <span class="token function">env</span>PATH<span class="token operator">=</span>/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME<span class="token operator">=</span>4b3f1e39dc5d<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>FLASK_APP<span class="token operator">=</span>app.pyFLASK_RUN_HOST<span class="token operator">=</span>0.0.0.0HOME<span class="token operator">=</span>/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请参阅 <code>docker-compose --help</code> 以查看其他可用命令。您还可以为 bash 和 zsh shell 安装 <a href="https://docs.docker.com/compose/completion/" target="_blank" rel="noopener">命令补全</a> 功能，这将将自动提示可用的命令。</p><h2 id="四、Compose-进阶"><a href="#四、Compose-进阶" class="headerlink" title="四、Compose 进阶"></a>四、Compose 进阶</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>ddd</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8、多阶段构建镜像 - Docker必知必会</title>
      <link href="/2020/022722120.html"/>
      <url>/2020/022722120.html</url>
      
        <content type="html"><![CDATA[<h2 id="多阶段构建镜像"><a href="#多阶段构建镜像" class="headerlink" title="多阶段构建镜像"></a>多阶段构建镜像</h2><p>如何减小所构建镜像的体积最非常具有挑战性的事情。Docker 17.05版本以后，新增了Dockerfile多阶段构建。所谓多阶段构建，实际上是允许一个Dockerfile 中出现多个 <code>FROM</code> 指令。</p><h3 id="单-Dockerfile-方式"><a href="#单-Dockerfile-方式" class="headerlink" title="单 Dockerfile 方式"></a>单 Dockerfile 方式</h3><p>如果将所有的构建过程都包含在一个 <code>Dockerfile</code> 中，包括项目及其依赖库的编译、测试、打包等流程，这样会带来的一些问题：</p><ul><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄露的风险</li></ul><p>下面是一个简单示例：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM golang:1.14-alpineRUN apk --no-cache add git ca-certificatesWORKDIR /go/src/github.com/go/lixl.cn/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \  && CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \  && cp /go/src/github.com/go/lixl.cn/helloworld/app /rootWORKDIR /root/CMD ["./app"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像：<code>docker build -t go/helloworld:1 -f Dockerfile1 .</code></p><h3 id="Builder-模式"><a href="#Builder-模式" class="headerlink" title="Builder 模式"></a>Builder 模式</h3><p>为了解决上面提到的问题，可以采用 <a href="http://blog.alexellis.io/mutli-stage-docker-builds/" target="_blank" rel="noopener">Builder 模式</a>：创建两个 Dockerfile，一个用于开发（包含构建应用程序所需的一切），另一个用于生产（仅包含您的应用程序以及运行该应用程序所需的内容），然后用编译脚本将其整合：</p><ul><li><p><code>Dockerfile.build</code> 文件:</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM golang:1.14-alpineRUN apk --no-cache add git ca-certificatesWORKDIR /go/src/github.com/go/lixl.cn/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \    && CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Dockerfile2</code> 文件：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY app .CMD ["./app"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>build.sh</code> 文件:</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#!/bin/sh</span><span class="token function">echo</span> Building go<span class="token operator">/</span>helloworld:builddocker build <span class="token operator">-</span>t go<span class="token operator">/</span>helloworld:build <span class="token punctuation">.</span> <span class="token operator">-</span>f Dockerfile<span class="token punctuation">.</span>builddocker create <span class="token operator">--</span>name extract go<span class="token operator">/</span>helloworld:builddocker <span class="token function">cp</span> extract:<span class="token operator">/</span>go<span class="token operator">/</span>src<span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>go<span class="token operator">/</span>lixl<span class="token punctuation">.</span>cn<span class="token operator">/</span>helloworld<span class="token operator">/</span>app <span class="token punctuation">.</span><span class="token operator">/</span>appdocker <span class="token function">rm</span> <span class="token operator">-</span>f extract<span class="token function">echo</span> Building go<span class="token operator">/</span>helloworld:2docker build <span class="token operator">--</span>no<span class="token operator">-</span>cache <span class="token operator">-</span>t go<span class="token operator">/</span>helloworld:2 <span class="token punctuation">.</span> <span class="token operator">-</span>f Dockerfile2<span class="token function">rm</span> <span class="token punctuation">.</span><span class="token operator">/</span>app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>构建镜像：<code>chmod u+x build.sh &amp;&amp; sh ./build.sh</code></p><p>这种方式生成的镜像会很小，不过过程比较复杂，而且生成的多个镜像都会占用系统空间。</p><h3 id="多阶段构建方式"><a href="#多阶段构建方式" class="headerlink" title="多阶段构建方式"></a>多阶段构建方式</h3><p>为了解决这些问题，自 Docker v17.05 开始支持<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="noopener">多阶段构建</a>。每一条 <code>FROM</code> 指令都是一个构建阶段，多条 <code>FROM</code> 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。示例如下：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM golang:1.14-alpine as builderRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/lixl.cn/helloworld/RUN go get -d -v github.com/go-sql-driver/mysqlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest as prodRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=0 /go/src/github.com/go/lixl.cn/helloworld/app .CMD ["./app"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二<code>FROM</code>条指令以<code>alpine:latest</code>为基础开始新的构建阶段。<code>COPY --from=0</code> 行仅将先前阶段中构建的工件复制到新阶段（第一个<code>FROM</code>条指令的起始编号为 0），Go SDK 和任何中间工件都不会保存在最终镜像中。</p><p>接下来，使用 <code>docker build -t go/helloworld:3 .</code> 构建镜像，然后对比三种方式生成的镜像大小。</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY             TAG           IMAGE ID            CREATED             SIZEgo/helloworld          3             5fb7cd98ef33        2 minutes ago       8.22MBgo/helloworld          2             7c30b66f73f9        2 minutes ago       8.22MBgo/helloworld          1             28fb4443a052        2 hours ago         401MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，单 Dockerfile 方式构建的镜像非常大。后两种方式构建的映像大小一致，但多阶段构建大大降低了复杂性。</p><blockquote><p>使用多阶段构建：</p><ul><li><p>可以在 <code>Dockerfile</code> 中使用多个 <code>FROM</code> 语句，每个 <code>FROM</code> 指令可以使用不同的基础镜像。</p></li><li><p>每个 <code>FORM</code> 都会开始新的构建阶段，可以有选择地将工件从一个阶段复制到另一个阶段。</p></li><li><p>通过在 <code>FROM</code> 指令中添加 <code>AS name</code> 来可以命名阶段，然后使用 <code>COPY --from=name</code> 而非数字来引用。</p></li><li><p>可以指定目标阶段来构建映像（使用 <code>--target name</code> 指令），而不是必须构建整个 Dockerfile。</p></li><li><p>可以直接引用外部的镜像，如：<code>COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code>。</p></li><li><p>可以在使用 <code>FROM</code> 指令时引用前一个阶段，从上一个阶段结束。例如：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM alpine:latest as builderRUN apk --no-cache add build-baseFROM builder as build1COPY source1.cpp source.cppRUN g++ -o /binary source.cppFROM builder as build2COPY source2.cpp source.cppRUN g++ -o /binary source.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>更详细的介绍，可以参考：<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="noopener">https://docs.docker.com/develop/develop-images/multistage-build/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7、数据持久化存储与性能调优 - Docker必知必会</title>
      <link href="/2020/022615220.html"/>
      <url>/2020/022615220.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据持久化存储与性能调优"><a href="#数据持久化存储与性能调优" class="headerlink" title="数据持久化存储与性能调优"></a>数据持久化存储与性能调优</h2><h3 id="数据持久保存"><a href="#数据持久保存" class="headerlink" title="数据持久保存"></a>数据持久保存</h3><p>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着当该容器不再存在时，数据也将丢失。</p><p>为了让数据脱离容器持久保存，Docker 提供了两个选项来将文件持久存储在主机中： <code>volume</code> 和 <code>bind mount</code> 。如果您在 Linux 上运行 Docker，则还可以使用 _tmpfs 挂载_。如果您在 Windows 上运行 Docker，则还可以使用<em>命名管道</em>。</p><p><img src="https://pic.lixl.cn/2020/types-of-mounts.png" alt="挂载的类型以及它们在Docker主机上的位置"></p><ul><li><strong>volume（卷）</strong>存储在主机文件系统的一部分中，该文件系统<em>由 Docker 管理</em>（<code>/var/lib/docker/volumes/</code>在 Linux 上）。非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久保存数据的最佳方法。</li><li><strong>bind mount（绑定挂载）</strong>可以存储在主机系统上的<em>任何位置</em>。它们甚至可能是重要的系统文件或目录。Docker 主机或 Docker 容器上的非 Docker 进程可以随时对其进行修改。</li><li><strong><code>tmpfs</code>挂载</strong> 仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统中。</li></ul><p><code>volume</code> 和 <code>bind mount</code> 都可以使用 <code>-v</code> 或 <code>--volume</code> 标志安装到容器中，但是两者的语法略有不同。</p><blockquote><p>关于挂载类型的更多详细信息：<a href="https://docs.docker.com/storage/#more-details-about-mount-types" target="_blank" rel="noopener">Manage data in Docker</a></p></blockquote><h3 id="挂载卷性能调优"><a href="#挂载卷性能调优" class="headerlink" title="挂载卷性能调优"></a>挂载卷性能调优</h3><p>在 macOS（和其他非 Linux 平台）上，保证容器内和主机文件一致性的开销很大。然而，在许多情况下，容器与主机之间不需要完美的一致性。区分不同情况可以显着提高性能。</p><p>通过在 <code>docker run -v</code>， <code>--volume</code> 的 option 中指定 <code>cached</code> 或 <code>delegated</code>，可以显着提高 Docker Desktop for Mac 上已装载卷访问的性能。您可以根据情况调整所需的一致性级别：</p><ul><li><code>consistent</code>：默认值，完美的一致性，即主机和容器实时一致。</li><li><code>cached</code>：主机具有权威性。容器执行的写操作对主机是立即可见的，但是在主机上执行的写操作可能不会立即反应在容器内。</li><li><code>delegated</code>：容器的内容具有权威性。提供最弱保证，由容器执行的写操作可能不会立即反映在主机文件系统上，提供的性能要比其他配置好得多。</li></ul><p>为每个挂载卷独立设置缓存策略，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run \    -v /Users/lixl.cn/project:/project:cached \    -v /host/another-path:/mount/another-point:consistent \    alpine <span class="token function">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6、Docker 网络配置 - Docker必知必会</title>
      <link href="/2020/022535558.html"/>
      <url>/2020/022535558.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-网络配置"><a href="#Docker-网络配置" class="headerlink" title="Docker 网络配置"></a>Docker 网络配置</h2><h3 id="Docker-网络基本原理"><a href="#Docker-网络基本原理" class="headerlink" title="Docker 网络基本原理"></a>Docker 网络基本原理</h3><p>要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包。如果不同子网之间要进行通信，需要路由机制。</p><p>Docker 中的网络接口默认都是虚拟接口，虚拟接口的优势之一是转发效率较高。 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。</p><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥（ Linux 的一个 bridge），它会在挂载到它的网口之间进行转发。同时，Docker 随机分配一个本地未占用的私有网段中的一个地址给 <code>docker0</code> 接口，此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。</p><p><img src="https://pic.lixl.cn/2020/network.png" alt="Docker 网络"></p><p>关于 Docker 网络的更多内容，可以访问：<a href="https://docs.docker.com/network/" target="_blank" rel="noopener">https://docs.docker.com/network/</a>&gt;</p><h3 id="Docker-网络类型"><a href="#Docker-网络类型" class="headerlink" title="Docker 网络类型"></a>Docker 网络类型</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p><ul><li>创建一对虚拟接口，分别放到本地主机和新容器中；</li><li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</li><li>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</li><li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</li></ul><p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p><p>可以在 <code>docker run</code> 的时候通过 <code>--net</code> 参数来指定容器的网络配置，有 4 个可选值：</p><ul><li><code>--net=bridge</code> 这个是默认值，连接到默认的网桥。</li><li><code>--net=host</code> 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 <code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈。</li><li><code>--net=container:NAME_or_ID</code> 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 <code>lo</code> 环回接口通信。</li><li><code>--net=none</code> 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</li></ul><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。想要允许外部访问容器，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用（可以多次使用 <code>-p</code> 标记来绑定多个端口）。</p><p>使用 <code>docker ps</code> 可以看到，本地主机的 80 被映射到了容器的 <code>80</code> 端口。此时访问本机的 <code>80</code> 端口即可访问容器内 <code>nginx</code> 应用提供的界面。</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID  IMAGE   COMMAND        CREATED        STATUS        PORTS               NAMESbc533791f3f5  nginx   <span class="token string">"nginx -g '…"</span>  5 days ago     Up 4 days     0.0.0.0:80-<span class="token operator">></span>80/tcp  nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="容器间互联"><a href="#容器间互联" class="headerlink" title="容器间互联"></a>容器间互联</h3><p>先创建一个新的 Docker 网络：</p><pre class="line-numbers language-bash"><code class="language-bash">docker network create -d bridge lixl-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code>，<code>overlay</code>。其中 <code>overlay</code> 网络类型用于 Swarm mode。</li></ul><p>运行一个容器并连接到新建的 <code>lixl-net</code> 网络</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it --rm --name busybox1 --network lixl-net busybox sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开新的终端，再运行一个容器并加入到 <code>lixl-net</code> 网络</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it --rm --name busybox2 --network lixl-net busybox sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再打开一个新的终端查看容器信息</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID     IMAGE      COMMAND    CREATED            STATUS         PORTS     NAMESb47060aca56b     busybox    <span class="token string">"sh"</span>       1 minutes ago      Up 1 minutes             busybox28720575823ec     busybox    <span class="token string">"sh"</span>       1 minutes ago      Up 1 minutes             busybox1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><pre class="line-numbers language-bash"><code class="language-bash">/ <span class="token comment" spellcheck="true"># ping busybox2</span>PING busybox2 <span class="token punctuation">(</span>172.19.0.3<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.19.0.3: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.072 ms64 bytes from 172.19.0.3: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.118 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><pre class="line-numbers language-bash"><code class="language-bash">/ <span class="token comment" spellcheck="true"># ping busybox1</span>PING busybox1 <span class="token punctuation">(</span>172.19.0.2<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.19.0.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.064 ms64 bytes from 172.19.0.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.143 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><blockquote><p>如果有多个容器之间需要互相连接，推荐使用 <a href="#docker-compose">Docker Compose</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5、Docker 镜像仓库 - Docker必知必会</title>
      <link href="/2020/022440628.html"/>
      <url>/2020/022440628.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-镜像仓库"><a href="#Docker-镜像仓库" class="headerlink" title="Docker 镜像仓库"></a>Docker 镜像仓库</h2><p>Repository（仓库）是集中存放镜像的地方。一个 Docker Registry 中可以包含多个 Repository（仓库），每个仓库可以包含多个 Tag（标签），每个标签对应一个 Image（镜像）。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry。用户也可以创建本地仓库方便内部使用。</p><h3 id="1、官方公共仓库-Docker-Hub"><a href="#1、官方公共仓库-Docker-Hub" class="headerlink" title="1、官方公共仓库 Docker Hub"></a>1、官方公共仓库 Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>lxl823</code> 请替换为你的 Docker 账号用户名。</p><pre class="line-numbers language-bash"><code class="language-bash">docker tag nginx lxl823/nginx:1.17.9docker image <span class="token function">ls</span>REPOSITORY       TAG            IMAGE ID            CREATED             SIZEnginx            latest          6678c7c2e56c        6 days ago          127MBlxl823/nginx     1.17.9          6678c7c2e56c        6 days ago          127MBdocker push lxl823/nginx:1.17.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>登录 <a href="https://hub.docker.com/repositories" target="_blank" rel="noopener">hub.docker.com</a> ，可以看到镜像已经发布到仓库中。</p><p><img src="https://pic.lixl.cn/2020/image-20200326185134980.png" alt="Docker hub 镜像仓库"></p><h4 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h4><p>Docker Hub 可以自动从外部存储库中的源代码构建映像，并将生成的映像自动推送到您的 Docker 存储库。</p><p>设置自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p><p>要配置自动构建，包括如下的步骤：</p><ul><li>登录 Docker Hub；</li><li>在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站；</li><li>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</li><li>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</li><li>指定 <code>Dockerfile</code> 的位置，并保存。</li></ul><p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p><p>进一步了解：<a href="https://docs.docker.com/docker-hub/builds/" target="_blank" rel="noopener">Set up automated builds</a></p><h3 id="2、基于-docker-registry-搭建本地仓库"><a href="#2、基于-docker-registry-搭建本地仓库" class="headerlink" title="2、基于 docker-registry 搭建本地仓库"></a>2、基于 docker-registry 搭建本地仓库</h3><p><a href="https://docs.docker.com/registry/" target="_blank" rel="noopener"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener"><code>docker-registry</code></a> v2.x 版本。</p><h4 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h4><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d -p 5000:5000 --restart<span class="token operator">=</span>always --name registry registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后使用 <code>docker push</code> 推送它到仓库。</p><h3 id="3、基于-Nexus3-搭建本地仓库"><a href="#3、基于-Nexus3-搭建本地仓库" class="headerlink" title="3、基于 Nexus3 搭建本地仓库"></a>3、基于 Nexus3 搭建本地仓库</h3><p>在企业中把内部的一些工具包放入 Nexus 中是比较常见的做法。 Nexus 不仅能够用于创建 Maven 私服，还可以用来创建 yum、pypi、npm、nuget、rubygems 等各种私有仓库。而且，Nexus 从 3.0 版本也开始支持创建 Docker 镜像仓库了！</p><h4 id="拉取并启动-nexus-容器"><a href="#拉取并启动-nexus-容器" class="headerlink" title="拉取并启动 nexus 容器"></a>拉取并启动 nexus 容器</h4><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \    --name nexus \    -p 8085:8081 \    -p 8086:8086 \    -v nexus_data:/nexus-data \    sonatype/nexus3:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等待 3-5 分钟，如果 <code>nexus</code> 容器没有异常退出，就可以使用浏览器打开 <code>http://localhost:8085</code> 访问 Nexus 了。</p><h4 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h4><p>创建一个私有仓库的方法： <code>Repository -&gt; Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p><ul><li>Name：仓库的名称</li><li>HTTP：仓库单独的访问端口，如 <code>8086</code></li><li>Hosted -&gt; Deployment pollcy：请选择 Allow redeploy 否则无法上传 Docker 镜像。</li></ul><p>还可以创建一个 docker (proxy) 类型的仓库连接到 DockerHub 上。再创建一个 docker (group) 类型的仓库把刚才的 hosted 与 proxy 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将连接到 DockerHub 中下载并缓存到 Nexus 中。</p><h4 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h4><p>菜单 <code>Security -&gt; Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><h4 id="Nginx-加密代理"><a href="#Nginx-加密代理" class="headerlink" title="Nginx 加密代理"></a>Nginx 加密代理</h4><p>部署 Nginx 时，我们先需要获得 SSL 证书。目前提供免费证书的云服务商很多，也可以使用 <code>openssl</code> 自行签发证书。我们还还需要 2 个域名，一个用来展示 nexus 前台，另一个用做 docker 仓库。Nginx 配置如下:</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">nexus3.lixl.cn;  # nexus 前台</span><span class="token attr-name">    location</span> <span class="token attr-value">/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://local.lixl.cn:8085;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Host $host;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Real-IP $remote_addr;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Via "nginx";</span>    }<span class="token attr-name">    error_page</span> <span class="token attr-value">  500 502 503 504  /50x.html;</span><span class="token attr-name">    location</span> <span class="token punctuation">=</span> <span class="token attr-value">/50x.html {</span><span class="token attr-name">        root</span> <span class="token attr-value">  /usr/share/nginx/html;</span>    }}<span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">443 ssl;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">nexus.lixl.cn;  # docker 仓库</span><span class="token attr-name">    ssl_certificate</span> <span class="token attr-value">/etc/nginx/certs/nexus.lixl.cn.crt;</span><span class="token attr-name">    ssl_certificate_key</span> <span class="token attr-value">/etc/nginx/certs/nexus.lixl.cn.key;</span><span class="token attr-name">    ssl_session_timeout</span> <span class="token attr-value"> 5m;</span><span class="token attr-name">    ssl_ciphers</span> <span class="token attr-value">HIGH:!aNULL:!MD5;</span><span class="token attr-name">    ssl_protocols</span> <span class="token attr-value">SSLv3 TLSv1 TLSv1.1 TLSv1.2;</span><span class="token attr-name">    ssl_prefer_server_ciphers</span> <span class="token attr-value">  on;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://local.lixl.cn:8086;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Host $host;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Real-IP $remote_addr;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Via "nginx";</span><span class="token attr-name">        client_max_body_size</span> <span class="token attr-value">1024M;</span>    }<span class="token attr-name">    error_page</span> <span class="token attr-value">  500 502 503 504  /50x.html;</span><span class="token attr-name">    location</span> <span class="token punctuation">=</span> <span class="token attr-value">/50x.html {</span><span class="token attr-name">        root</span> <span class="token attr-value">  /usr/share/nginx/html;</span>    }}<span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">nexus.lixl.cn;  # docker 仓库</span><span class="token attr-name">    return</span> <span class="token attr-value">301 https://$server_name$request_uri;</span>}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="登录本地仓库并推送镜像"><a href="#登录本地仓库并推送镜像" class="headerlink" title="登录本地仓库并推送镜像"></a>登录本地仓库并推送镜像</h4><p>使用 <code>docker login</code> 进行测试，用户名密码与 Nexus 账号一致。</p><pre class="line-numbers language-bash"><code class="language-bash">docker login https://nexus.lixl.cnUsername: adminPassword:Login Succeeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>docker push</code> 命令将自己的镜像推送到 Nexus：</p><pre class="line-numbers language-bash"><code class="language-bash">docker tag nginx nexus.lixl.cn/nginx:20200326docker image <span class="token function">ls</span>REPOSITORY             TAG             IMAGE ID            CREATED             SIZEnginx                  latest          6678c7c2e56c        6 days ago          127MBnexus.lixl.cn/nginx    20200326        6678c7c2e56c        6 days ago          127MBdocker push nexus.lixl.cn/nginx:20200326<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推送成功。在本地仓库即可看到新推送的镜像：</p><p><img src="https://pic.lixl.cn/2020/image-20200326201622029.png" alt="本地仓库新推送的镜像"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4、构建并运行镜像 - Docker必知必会</title>
      <link href="/2020/02231623.html"/>
      <url>/2020/02231623.html</url>
      
        <content type="html"><![CDATA[<h2 id="构建并运行镜像"><a href="#构建并运行镜像" class="headerlink" title="构建并运行镜像"></a>构建并运行镜像</h2><p>要构建一个容器，需要做很多的工作，设置很多的配置，如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么经常被提及的无法重复、镜像构建透明性、体积等问题就都会解决。 这个脚本就是 Dockerfile。</p><h3 id="准备-Dockerfile-文件"><a href="#准备-Dockerfile-文件" class="headerlink" title="准备 Dockerfile 文件"></a>准备 Dockerfile 文件</h3><p>下载示例项目，请在终端中运行以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">curl -LO https://github.com/dockersamples/node-bulletin-board/archive/master.zipunzip master.zip<span class="token function">cd</span> node-bulletin-board-master/bulletin-board-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>该<code>node-bulletin-board</code>项目是一个简单的公告板应用程序，使用 Node.js 编写。在此示例中，假设您编写了此应用程序，现在正尝试对其进行容器化。</p></blockquote><p><code>Dockerfile</code> 描述如何为容器组装专用文件系统，并且还可以包含一些元数据，这些元数据描述了如何基于该镜像运行容器。公告板应用程序 <code>Dockerfile</code> 内容如下：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># Use the official image as a parent image.FROM node:current-slim# Set the working directory.WORKDIR /usr/src/app# Copy the file from your host to your current location.COPY package.json .# Run the command inside your image filesystem.RUN npm install# Inform Docker that the container is listening on the specified port at runtime.EXPOSE 8080# Run the specified command within the container.CMD [ "npm", "start" ]# Copy the rest of your app's source code from your host to your image filesystem.COPY . .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写 Dockerfile 是容器化应用程序的第一步，这些 Dockerfile 命令是构建镜像的步骤。 这个步骤如下:</p><ul><li>使用 <code>FORM</code> 指定基于已经存在的 <code>node:current-slim</code> 基础镜像构建。这是一个由 nodejs 官方构建的镜像。</li><li>使用 <code>WORKDIR</code> 指定所有后续操作均从镜像文件系统中的 <code>/usr/src/app</code> 目录中执行（而不是主机的文件系统中）。</li><li>将文件 <code>package.json</code> 从主机复制到镜像中的当前位置（.）（复制到 ``/usr/src/app/package.json`）</li><li>在镜像文件系统中运行命令 <code>npm install</code>（读取 <code>package.json</code> 以确定并安装应用程序依赖）</li><li>将应用的其余源代码从主机复制到镜像文件系统。</li></ul><blockquote><p>这些步骤与在主机上设置和安装应用程序所采取的步骤几乎相同。但是，将它们保存为 <code>Dockerfile</code> 可以使您在可移植的隔离 Docker 镜像中执行相同的操作。</p></blockquote><p>上面的步骤构建了我们镜像的文件系统，但是 Dockerfile 中还有其他几行。</p><ul><li><p><code>CMD</code> 指令在镜像中指定一些元数据，该元数据描述了如何基于该镜像运行容器。在本示例中该图像的容器化过程是 <code>npm start</code>。</p></li><li><p><code>EXPOSE 8080</code> 通知 Docker 该容器在运行时监听 8080 端口。</p></li></ul><p>上面是组织一个简单的 Dockerfile 的方法。始终以 <code>FROM</code> 命令开头，然后按照步骤构建您的私有文件系统，并以任何元数据规范作为结束。 Dockerfile 指令比上面看到的要多。有关完整列表，请参阅 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile 参考</a>。</p><h3 id="构建并测试镜像"><a href="#构建并测试镜像" class="headerlink" title="构建并测试镜像"></a>构建并测试镜像</h3><p>现在您已经有了一些源代码和一个 Dockerfile，现在该构建您的第一个映像，并确保从其启动的容器能够按预期工作。让我们构建您的公告板图像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build --tag bulletinboard:1.0 <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您将看到 Docker 逐步完成 Dockerfile 中的每条指令，并逐步构建镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">Sending build context to Docker daemon  45.57kBStep 1/7 <span class="token keyword">:</span> FROM node:current-slimcurrent-slim: Pulling from library/node48839397421a: Pull completecbb6511d79bf: Pull complete04ec6202052a: Pull complete29c5eab4674c: Pull complete8df5bb5f8d2e: Pull completeDigest: sha256:c92fad90875a6ce7251c72701f9c88e1e3f3efc2eb1d7d1ffb2184204e4f7d98Status: Downloaded newer image <span class="token keyword">for</span> node:current-slim ---<span class="token operator">></span> 6d9a17519d40Step 2/7 <span class="token keyword">:</span> WORKDIR /usr/src/app ---<span class="token operator">></span> Running <span class="token keyword">in</span> 9dfd5c099558Removing intermediate container 9dfd5c099558 ---<span class="token operator">></span> 6062c6d2e488Step 3/7 <span class="token keyword">:</span> COPY package.json <span class="token keyword">.</span> ---<span class="token operator">></span> 2ddc37525da9Step 4/7 <span class="token keyword">:</span> RUN <span class="token function">npm</span> <span class="token function">install</span> ---<span class="token operator">></span> Running <span class="token keyword">in</span> 6ce3fed8ecd7<span class="token operator">></span> ejs@2.7.4 postinstall /usr/src/app/node_modules/ejs<span class="token operator">></span> node ./postinstall.jsThank you <span class="token keyword">for</span> installing EJS: built with the Jake JavaScript build tool <span class="token punctuation">(</span>https://jakejs.com/<span class="token punctuation">)</span><span class="token function">npm</span> notice created a lockfile as package-lock.json. You should commit this file.<span class="token function">npm</span> WARN vue-event-bulletin@1.0.0 No repository field.<span class="token function">npm</span> WARN The package morgan is included as both a dev and production dependency.added 91 packages from 168 contributors and audited 221 packages <span class="token keyword">in</span> 16.854sfound 0 vulnerabilitiesRemoving intermediate container 6ce3fed8ecd7 ---<span class="token operator">></span> 38a27fea6567Step 5/7 <span class="token keyword">:</span> EXPOSE 8080 ---<span class="token operator">></span> Running <span class="token keyword">in</span> c7528a178327Removing intermediate container c7528a178327 ---<span class="token operator">></span> 97f454f32f95Step 6/7 <span class="token keyword">:</span> CMD <span class="token punctuation">[</span> <span class="token string">"npm"</span>, <span class="token string">"start"</span> <span class="token punctuation">]</span> ---<span class="token operator">></span> Running <span class="token keyword">in</span> 72a6340e3d58Removing intermediate container 72a6340e3d58 ---<span class="token operator">></span> 0a90efca7ea9Step 7/7 <span class="token keyword">:</span> COPY <span class="token keyword">.</span> <span class="token keyword">.</span> ---<span class="token operator">></span> 84c4f69e2893Successfully built 84c4f69e2893Successfully tagged bulletinboard:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将镜像作为容器运行"><a href="#将镜像作为容器运行" class="headerlink" title="将镜像作为容器运行"></a>将镜像作为容器运行</h3><ol><li><p>根据您的新镜像启动一个容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --publish 8000:8080 --detach --name board bulletinboard:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里有几个常见的标志：</p><ul><li><code>--publish</code>要求 Docker 将主机端口 8000 上传入的流量转发到容器的端口 8080。容器具有自己的专用端口集，因此，如果要从网络访问某个端口，则必须以这种方式将流量转发到该端口。否则，作为默认的安全状态，防火墙规则将阻止所有网络流量到达您的容器。</li><li><code>--detach</code> 要求 Docker 在后台运行此容器。</li><li><code>--name</code>指定一个名称，您可以使用该名称在后续命令中引用您的容器，在这种情况下为<code>board</code>。</li></ul><p>还要注意，您没有指定容器要运行的程序。您不必这样做，因为在构建 Dockerfile 时使用了<code>CMD</code>指令。Docker 知道在容器启动时会自动运行<code>npm start</code> 程序。</p></li><li><p>在的浏览器中访问您的应用程序<code>localhost:8000</code>，您应该看到公告板应用程序已启动并正在运行。</p><p><img src="https://pic.lixl.cn/2020/image-20200406000641171.png" alt="公告板应用程序运行中"></p></li><li><p>对公告板容器正常工作感到满意后，可以将其删除：</p><pre class="line-numbers language-script"><code class="language-script">docker rm --force board<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该<code>--force</code>选项将删除正在运行的容器。如果停止容器运行，<code>docker stop board</code>则无需使用<code>--force</code>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、Docker 安装 - Docker必知必会</title>
      <link href="/2020/022239349.html"/>
      <url>/2020/022239349.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><h3 id="1、获取-Docker"><a href="#1、获取-Docker" class="headerlink" title="1、获取 Docker"></a>1、获取 Docker</h3><p>Docker 分为 CE 和 EE 两大版本。Docker CE 分为 <code>stable</code>、 <code>test</code> 和 <code>nightly</code> 三个更新频道。官方网站上有各种环境下的 <a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">安装指南</a>，可以根据自己的情况进行安装。</p><h3 id="2、镜像加速"><a href="#2、镜像加速" class="headerlink" title="2、镜像加速"></a>2、镜像加速</h3><p>一般国内在使用过程中拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。各个镜像站测试结果请到 <a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions" target="_blank" rel="noopener">docker-practice/docker-registry-cn-mirror-test</a> 查看。</p><p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧参考如下内容编辑 json 文件：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://dockerhub.azk8s.cn"</span><span class="token punctuation">,</span> <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像。执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p><pre class="line-numbers language-bash"><code class="language-bash">Registry Mirrors: https://dockerhub.azk8s.cn/ https://hub-mirror.c.163.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3、小试牛刀"><a href="#3、小试牛刀" class="headerlink" title="3、小试牛刀"></a>3、小试牛刀</h3><p>以下命令运行一个<code>ubuntu</code>容器，以交互方式附加到本地命令行会话，然后运行<code>/bin/bash</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -i -t ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当您运行此命令时，会发生以下情况（假设您使用的是默认仓库配置）：</p><ol><li>如果您在<code>ubuntu</code>本地没有该映像，则 Docker 会将其从已配置的仓库中拉出，就像您已<code>docker pull ubuntu</code>手动运行一样。</li><li>Docker 会创建一个新容器，就像您已<code>docker container create</code> 手动运行命令一样。</li><li>Docker 将一个读写文件系统分配给容器，作为其最后一层。这允许运行中的容器在其本地文件系统中创建或修改文件和目录。</li><li>Docker 创建了一个网络接口以将容器连接到默认网络，因为您未指定任何网络选项。这包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。</li><li>Docker 启动容器并执行<code>/bin/bash</code>。因为容器是交互式运行的，并且已附加到您的终端（由于<code>-i</code>和<code>-t</code> 标志），所以您可以在输出记录到终端时使用键盘提供输入。</li><li>当您键入<code>exit</code>以终止<code>/bin/bash</code>命令时，容器将停止但不会被删除。您可以重新启动或删除它。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、Docker 架构 - Docker必知必会</title>
      <link href="/2020/022127918.html"/>
      <url>/2020/022127918.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 使用客户端-服务器架构。Docker <em>客户端</em> 与 Docker <em>守护进程</em> 进行对话，该<em>守护进程</em> 完成了构建、运行和分发 Docker 容器的繁重工作。Docker 客户端和守护程序可以在同一系统上运行，或者您可以将 Docker 客户端连接到远程 Docker 守护程序。Docker 客户端和守护程序在 UNIX 套接字或网络接口上使用 REST API 进行通信。</p><p><img src="https://pic.lixl.cn/2020/image-20200325194141346.png" alt="Docker架构图" title="Docker架构图"></p><h2 id="Docker-守护进程"><a href="#Docker-守护进程" class="headerlink" title="Docker 守护进程"></a>Docker 守护进程</h2><p>Docker 守护程序（<code>dockerd</code>）侦听 Docker API 请求并管理 Docker 对象，例如 images（镜像），containers（容器），networks（网络）和 volume（卷）。守护程序还可以与其他守护程序通信以管理 Docker 服务。</p><h2 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h2><p>Docker 客户端（<code>docker</code>）是许多 Docker 用户与 Docker 交互的主要方式。当您使用诸如<code>docker run</code> 之类的命令时，客户端会将这些命令发送到 <code>dockerd</code>，以执行这些命令。该<code>docker</code>命令使用 Docker API。Docker 客户端可以与多个守护程序通信。</p><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>Docker 仓库存储 Docker 镜像。Docker Hub 是任何人都可以使用的公共仓库，并且 Docker 配置为默认在 Docker Hub 上查找映像。您甚至可以运行自己的私人仓库。如果使用 Docker 数据中心（DDC），则其中包括 Docker 可信仓库（DTR）。</p><p>使用<code>docker pull</code>或<code>docker run</code>命令时，所需的镜像将从配置的仓库中提取。使用该<code>docker push</code>命令时，会将映像推送到配置的仓库。</p><h2 id="Docker-对象"><a href="#Docker-对象" class="headerlink" title="Docker 对象"></a>Docker 对象</h2><p>使用 Docker 时，您正在创建和使用镜像，容器，网络，卷，插件和其他对象。本节是其中一些对象的简要概述。</p><h3 id="Images（镜像）"><a href="#Images（镜像）" class="headerlink" title="Images（镜像）"></a>Images（镜像）</h3><p>镜像是一个只读模板（不包含任何动态数据，其内容在构建之后也不会被改变 ），其中包含创建 Docker 容器的说明。通常，一个镜像基于另一个镜像，并带有一些额外的定制。 例如，你可以建立一个基于 ubuntu 镜像的镜像，安装 ubuntu Apache HTTP Server 和你的应用程序，以及运行你的应用程序所需的配置细节。</p><p>您可以创建自己的镜像，也可以仅使用其他人创建并在仓库中发布的镜像。要构建自己的镜像，您可以 使用简单的语法创建一个 <code>Dockerfile</code>，以定义创建镜像并运行它所需的步骤。<code>Dockerfile</code> 中的每条指令都会在镜像中创建一个层。更改 <code>Dockerfile</code> 并重建镜像时，仅重建那些已更改的层。与其他虚拟化技术相比，这是使镜像如此轻巧，小型和快速的部分原因。</p><h3 id="Containers-（容器）"><a href="#Containers-（容器）" class="headerlink" title="Containers （容器）"></a>Containers （容器）</h3><p>容器是镜像的可运行实例。您可以使用 Docker API 或 CLI 创建，启动，停止，移动或删除容器。您可以将容器连接到一个或多个网络，将存储附加到该网络，甚至根据其当前状态创建新映像。</p><p>默认情况下，容器与其他容器及其主机之间的隔离程度相对较高。您可以控制容器的网络，存储或其他基础子系统与其他容器或与主机的隔离程度。</p><p>容器由其映像以及在创建或启动时为其提供的任何配置选项定义。删除容器后，未存储在持久性存储中的状态更改将消失。</p><blockquote><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 Volume（数据卷）、或者挂载宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p></blockquote><h3 id="Service-（服务）"><a href="#Service-（服务）" class="headerlink" title="Service （服务）"></a>Service （服务）</h3><p>服务允许跨多个 Docker 守护进程调度容器，这些守护进程以多个管理者和工作者的群体形式协同工作。集群的每个成员都是一个 Docker 守护进程，并且所有守护进程都使用 Docker API 进行通信。服务允许您定义所需的状态，例如在任何给定时间必须可用的服务副本数。默认情况下，该服务在所有工作节点之间实现负载平衡。对于使用者而言，Docker 服务似乎是一个单独的应用程序。Docker Engine 在 Docker 1.12 及更高版本中支持集群模式。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、Docker概述 - Docker必知必会</title>
      <link href="/2020/02208729.html"/>
      <url>/2020/02208729.html</url>
      
        <content type="html"><![CDATA[<h2 id="系列文章导航"><a href="#系列文章导航" class="headerlink" title="系列文章导航"></a>系列文章导航</h2><ul><li><a href="/">1、Docker 概述</a></li><li><a href="/">2、Docker 架构</a></li><li>…</li></ul><h2 id="Docker-概述"><a href="#Docker-概述" class="headerlink" title="Docker 概述"></a>Docker 概述</h2><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的快速交付，测试和部署代码的方法，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><p>容器化越来越受欢迎，是因为容器：</p><ul><li><strong>灵活</strong>：即使最复杂的应用程序也可以容器化。</li><li><strong>轻量级</strong>：容器利用并共享主机内核，在系统资源方面比虚拟机更加有效。</li><li><strong>可移植性</strong>：您可以在本地构建，部署到云并在任何地方运行。</li><li><strong>松散耦合</strong>：容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们。</li><li><strong>可扩展</strong>：您可以在数据中心内增加并自动分发容器副本。</li><li><strong>安全</strong>：容器将积极的约束和隔离应用于流程，而无需用户方面的任何配置。</li></ul><h3 id="Docker-平台"><a href="#Docker-平台" class="headerlink" title="Docker 平台"></a>Docker 平台</h3><p>Docker 提供了在松散隔离的环境（称为容器）中打包和运行应用程序的功能。隔离和安全性使您可以在给定主机上同时运行多个容器。容器是轻量级的，因为它们不需要管理程序的额外负担，而是直接在主机的内核中运行。这意味着与使用虚拟机相比，您可以在给定的硬件组合上运行更多的容器。您甚至可以在实际上是虚拟机的主机中运行 Docker 容器！</p><p>Docker 提供了工具和平台来管理容器的生命周期：</p><ul><li>使用容器开发应用程序及其支持组件。</li><li>容器成为分发和测试应用程序的单元。</li><li>准备就绪后，可以将应用程序作为容器或协调服务部署到生产环境中。无论您的生产环境是本地数据中心，云提供商还是两者的混合，其工作原理都相同。</li></ul><h3 id="我可以将-Docker-用于什么"><a href="#我可以将-Docker-用于什么" class="headerlink" title="我可以将 Docker 用于什么"></a>我可以将 Docker 用于什么</h3><h4 id="快速，一致地交付您的应用程序"><a href="#快速，一致地交付您的应用程序" class="headerlink" title="快速，一致地交付您的应用程序"></a>快速，一致地交付您的应用程序</h4><p>Docker 通过允许开发人员使用提供您的应用程序和服务的本地容器在标准化环境中工作，从而简化了开发生命周期。容器非常适合持续集成和持续交付（CI / CD）工作流程。</p><h4 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h4><p>Docker 基于容器的平台允许高度可移植的工作负载。Docker 容器可以在开发人员的本地笔记本电脑上，数据中心中的物理或虚拟机上，云提供商上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性还使您可以轻松地动态管理工作负载，并根据业务需求指示实时扩展或关闭应用程序和服务。</p><h4 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h4><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行且经济高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合高密度环境和中小型部署，而您需要用更少的资源做更多的事情。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode-aliyun-oss-paste-image 插件安装使用指南</title>
      <link href="/2020/021659830.html"/>
      <url>/2020/021659830.html</url>
      
        <content type="html"><![CDATA[<p>VSCode扩展插件，在 Markdown 类型文件编辑过程中，支持一键上传截图到阿里云OSS并将图片粘贴到博文中。</p><p>详见博文：<a href="https://www.lixl.cn/2020/021737756.html">aliyun-oss-paste-image 插件安装使用指南</a>。</p><h2 id="理想的-Markdown-博文写作及发布体验"><a href="#理想的-Markdown-博文写作及发布体验" class="headerlink" title="理想的 Markdown 博文写作及发布体验"></a>理想的 Markdown 博文写作及发布体验</h2><ol><li>截图后一键粘贴（ <code>Shift + p</code> ）并实时预览，内容编辑所见即所得。</li><li><code>hexo g -d</code> 一键发布到多个托管平台（ 如Github + COS ）。</li><li>自建的博客平台拥有超快的访问速度且几乎零成本。</li><li>直接粘贴/导入 Markdown 博文到第三方平台（如知乎、简书、CSDN）。</li></ol><p>推荐使用 <a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> + <a href="https://www.lixl.cn/2020/020936412.html">hexo-deployer-cos-cdn</a>插件 实现如上体验。</p><p>喜欢使用 VSCode 的话，可以通过本插件来提高博文撰写体验。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在插件应用商店搜索 <code>aliyun-oss-paste-image</code> ，点击 <code>install</code> 安装。如图:</p><p><img src="https://pic.lixl.cn/2020/15da665cf0d5309abc2b054508b61d76.png" alt="插件检索及安装"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>先截图/复制图片内容，然后在 markdown 文件编辑过程中，使用 <code>Shift + p</code> 一键上传。</p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul><li><code>region</code>: 地域。在阿里云对象存储的bucket概览中有EndPoint（地域节点），如 <code>oss-cn-beijing.aliyuncs.com</code> 中的 <code>oss-cn-beijing</code> 就是地域。</li><li><code>accessKeyId</code>: accessKeyId（RAM中生成的accessKeyId）</li><li><code>accessKeySecret</code>: accessKeySecret（RAM中生成的accessKeySecret）</li><li><code>bucket</code>: 输入bucket名称</li><li><code>remotePath</code>: 图片存储目录。例如希望的图片地址为 <code>http://${你的域名}/static/${filename}.png</code>，则填写 <code>static</code> ）</li><li><code>domain</code>: 阿里云oss域名，建议绑定自定义域名并开启CDN加速</li><li><code>localTempPath</code>: 本地临时文件路径（默认: /tmp/.aliyun-oss-paste-image）</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=vvkee.aliyun-oss-upload-image" target="_blank" rel="noopener">vscode-aliyun-upload-image</a></li><li><a href="http://blog.haoji.me/vscode-plugin-overview.html" target="_blank" rel="noopener">VSCode插件开发全攻略</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> PasteImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-deployer-cos-cdn 插件安装使用指南</title>
      <link href="/2020/020936412.html"/>
      <url>/2020/020936412.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h2><p>Hexo部署插件，支持将静态博客发布到腾讯云、阿里云对象存储中，并同步刷新被更新文件的CDN缓存。</p><p>详见博文：<a href="https://www.lixl.cn/2020/020936412.html">hexo-deployer-cos-cdn 插件安装使用指南</a>。按量付费，一般访问量不高的话，体验期过后一个月也花不了几块钱。</p><p><img src="https://pic.lixl.cn/2020/20200212145243.png/w1280" alt="hexo-deployer-cos-cdn 插件运行流程"></p><h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><ol><li>全站 CDN 加速，速度超快，成本几乎为零。</li><li>支持同时使用阿里云和腾讯云对象存储服务。</li><li>支持将网站和图片发布到各自的 bucket 中。</li><li>每次上传时会对比本地与云端文件MD5值，只发布变更内容。</li><li>支持同步部署到到多个博客托管服务，如 <code>COS</code> + <code>Github Pages</code></li><li>支持将 Markdown 源文件中图片路径替换为 CDN 地址，便于直接粘贴/导入到第三方平台。</li><li>支持自动清理远程 bucket 中的多余文件，默认不启用。</li></ol><h2 id="三、理想的博文写作及发布体验"><a href="#三、理想的博文写作及发布体验" class="headerlink" title="三、理想的博文写作及发布体验"></a>三、理想的博文写作及发布体验</h2><ol><li><code>Ctrl + v</code> 一键粘贴包括多张图片和文本组成的混合内容并实时预览，内容编辑所见即所得。</li><li><code>hexo g -d</code> 一键发布到多个托管平台（如Github+COS）。</li><li>自建的博客平台拥有超快的访问速度且几乎零成本。</li><li>直接粘贴/导入 Markdown 博文到第三方平台（如知乎、简书、CSDN）。</li></ol><p>推荐使用 <a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> + 本插件 实现如上体验。<code>Typora</code> 配置参照下图：</p><p><img src="https://pic.lixl.cn/2020/20200209161415.png/w1440" alt="Typora图像配置"></p><p>经过以上配置以后，在 <code>Typora</code> 中编辑 MarkDown 文档时，截图后直接 <code>Ctrl + v</code> 即可粘贴并实时预览。尤其是一键粘贴包括多张图片及文本的混合内容，并保留原格式非常方便。<code>hexo d</code> 部署以后，网站及图片会自动上传到云对象存储中。</p><h2 id="四、安装配置"><a href="#四、安装配置" class="headerlink" title="四、安装配置"></a>四、安装配置</h2><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-cos-cdn --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、最简单配置示例"><a href="#2、最简单配置示例" class="headerlink" title="2、最简单配置示例"></a>2、最简单配置示例</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> cos<span class="token punctuation">-</span>cdn  <span class="token key atrule">cloud</span><span class="token punctuation">:</span> tencent  <span class="token key atrule">bucket</span><span class="token punctuation">:</span> blog<span class="token punctuation">-</span><span class="token number">1234567890</span>  <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>shanghai  <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX  <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上配置，图片和文件将发布到 腾讯云的 同一个 bucket 中，默认开启CDN加速，CDN加速域名为 <code>_config.yml</code> 中配置的 <code>url</code>，图片上传后，Markdown 源文件中图片依然是相对路径。</p><h3 id="3、网站与图片放在不同的bucket中"><a href="#3、网站与图片放在不同的bucket中" class="headerlink" title="3、网站与图片放在不同的bucket中"></a>3、网站与图片放在不同的bucket中</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> cos<span class="token punctuation">-</span>cdn  <span class="token key atrule">cloud</span><span class="token punctuation">:</span> tencent  <span class="token key atrule">bucket</span><span class="token punctuation">:</span> blog<span class="token punctuation">-</span><span class="token number">1234567890</span>  <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>shanghai  <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX  <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR  <span class="token key atrule">imageConfig</span><span class="token punctuation">:</span>    <span class="token key atrule">cloud</span><span class="token punctuation">:</span> aliyun    <span class="token key atrule">cdnUrl</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//pic.lixl.cn    <span class="token key atrule">bucket</span><span class="token punctuation">:</span> lxl80    <span class="token key atrule">region</span><span class="token punctuation">:</span> oss<span class="token punctuation">-</span>cn<span class="token punctuation">-</span>beijing    <span class="token key atrule">folder</span><span class="token punctuation">:</span> static    <span class="token key atrule">cdnEnable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token key atrule">deleteExtraFiles</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true">#谨慎开启</span>    <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX    <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上配置，文件将发布到 腾讯云 的 bucket 中，图片发布到阿里云的 bucket 中。图片使用单独的 CDN 加速域名。图片cdn没有开启CDN换新及删除多余文件功能。</p><h3 id="4、免备案部署配置示例"><a href="#4、免备案部署配置示例" class="headerlink" title="4、免备案部署配置示例"></a>4、免备案部署配置示例</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/lxl80/blog.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> cos<span class="token punctuation">-</span>cdn    <span class="token key atrule">cloud</span><span class="token punctuation">:</span> tencent    <span class="token key atrule">bucket</span><span class="token punctuation">:</span> blog<span class="token punctuation">-</span><span class="token number">1234567890</span>    <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>shanghai    <span class="token key atrule">cdnEnable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">deleteExtraFiles</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">updatePosts</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX    <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR    <span class="token key atrule">imageConfig</span><span class="token punctuation">:</span>      <span class="token key atrule">cloud</span><span class="token punctuation">:</span> aliyun      <span class="token key atrule">cdnUrl</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//cdn.jsdelivr.net/gh/lxl80/blog@gh<span class="token punctuation">-</span>pages/static      <span class="token key atrule">bucket</span><span class="token punctuation">:</span> lxl80      <span class="token key atrule">region</span><span class="token punctuation">:</span> oss<span class="token punctuation">-</span>cn<span class="token punctuation">-</span>beijing      <span class="token key atrule">folder</span><span class="token punctuation">:</span> static      <span class="token key atrule">cdnEnable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token key atrule">deleteExtraFiles</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#谨慎开启</span>      <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX      <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上配置，需要安装 <a href="https://www.npmjs.com/package/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> 插件。会同步将网站发布到 Github Pages 及 云对象存储 中；如果 bucket 中有多余文件会删除；图片上传成功后，会将 Markdown 源文件中图片路径替换为 CDN 地址。</p><p>也可以使用免费的 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr CDN</a> 来加速，如上面示例的 <code>cdnUrl</code> 配置成了 jsDelivr CDN 加速地址，这样配置的话，图片在阿里云OSS中只保存备份，用户访问的是基于免费的 jsDelivr CDN 来加速 Github 图床的效果，全球访问速度都很快，还省去了占网站流量大头的图片流量 CDN 加速成本。 详情可参见博文：<a href="https://www.lixl.cn/2019/120114500.html#toc-heading-6">使用Typora + PicGo 图床 + jsDelivr CDN实现高效 Markdown 创作</a>。</p><blockquote><p>补充： jsDelivr 是唯一具有中国政府颁发的有效ICP许可证的全球公共CDN，其直接在中国大陆设有数百个节点。</p></blockquote><h3 id="5、通过-Netlify-来加速"><a href="#5、通过-Netlify-来加速" class="headerlink" title="5、通过 Netlify 来加速"></a>5、通过 Netlify 来加速</h3><p>如果嫌 <code>Github Pages</code> 国内访问导致html页面加载太慢，可以通过 <a href="https://app.netlify.com/" target="_blank" rel="noopener">netlify</a> 来提速。在 netlify 中基于 git 创建站点，关联 github 仓库，以后通过 <code>hexo g -d</code>一键部署时，netlify 中的内容也会自动更新。示例站点: <a href="https://netlify.lixl.cn/" target="_blank" rel="noopener">https://netlify.lixl.cn/</a></p><p><img src="https://pic.lixl.cn/2020/image-20200309142734992.png" alt="基于Github仓库创建netlify站点"></p><h2 id="五、参数说明"><a href="#五、参数说明" class="headerlink" title="五、参数说明"></a>五、参数说明</h2><ul><li><p><code>type</code>： 固定填: cos-cdn</p></li><li><p><code>cloud</code>： 指定云服务商，目前支持阿里云 <code>aliyun</code> 和腾讯云 <code>tencent</code></p></li><li><p><code>bucket</code> 和 <code>region</code>： 以腾讯云为例，进入控制台 - 对象存储 - 存储桶列表 页面，存储桶名称即: <code>bucket</code> ，所属地域代号即: region，参照下图红框圈住的部分:</p></li></ul><p><img src="https://pic.lixl.cn/2020/20200208200709.png/w1280" alt="腾讯云存储桶列表"></p><ul><li><code>secretId</code> 和 <code>secretKey</code>：以腾讯云为例，进入控制台 - 访问管理 - 访问秘钥 - API秘钥管理，参照下图红框圈住的部分:</li></ul><p><img src="https://pic.lixl.cn/2020/20200208201510.png/w1280" alt="腾讯云API秘钥管理"></p><ul><li><p><code>cdnEnable</code>: 是否启用CDN加速，默认为 <code>true</code>，如果为 <code>false</code> ，将不会刷新 CDN 缓存。</p></li><li><p><code>deleteExtraFiles</code>: 是否删除云端多余文件(本地不包含的文件)，默认为 <code>false</code>，请谨慎选择。</p></li><li><p><code>updatePosts</code>：是否更新 Markdown 源文中的图片地址为CDN路径。默认为 <code>false</code> ，如果设置为 <code>true</code> ，之后再次修改 <code>imageConfig.cdnUrl</code>时，需要手动将 Markdown 源文中的图片地址批量替换为相对路径，否则不生效。</p></li><li><p><code>imageConfig.cdnUrl</code>： 用于存储图片的 bucket 绑定的 CDN 加速域名。对费用敏感的话，可以参考与其它部署插件共存的配置示例，采用 jsDelivr CDN 节省流量成本。</p></li><li><p><code>imageConfig.folder</code>：本地博客 <code>hexo/source/</code> 目录内，用户存放本地图片文件的目录。</p></li></ul><h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><ol><li>使用云对象存储及 CDN 服务，网站需要先备案。</li><li>超出免费额度要付费，记得开启防盗链。</li><li>更新 CDN 缓存需要授权，如果使用子账号，请同时赋予该账号此权限。</li><li>如果想将 markdown 源文直接导入/粘贴到第三方平台，记得在图片 CDN 防盗链配置中增加白名单。</li></ol><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/75k/hexo-deployer-cos-enhanced" target="_blank" rel="noopener">hexo-deployer-cos-enhanced</a></li><li><a href="https://github.com/aliyun/openapi-core-nodejs-sdk" target="_blank" rel="noopener">openapi-core-nodejs-sdk</a></li><li><a href="https://www.npmjs.com/package/ali-oss" target="_blank" rel="noopener">oss-js-sdk</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron 构建跨平台应用</title>
      <link href="/2020/020957109.html"/>
      <url>/2020/020957109.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Electron-简介"><a href="#一、Electron-简介" class="headerlink" title="一、Electron 简介"></a>一、Electron 简介</h2><p><a href="https://electronjs.org" target="_blank" rel="noopener">Electron</a> 是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将 <a href="https://www.chromium.org/Home" target="_blank" rel="noopener">Chromium</a> 和 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p><p><img src="https://pic.lixl.cn/2020/components.png" alt="Electron components"></p><p>最初为 GitHub 开发 Atom 编辑器, 目前已成为开源开发者、初创企业和老牌公司常用的开发工具。 <a href="https://electronjs.org/apps" target="_blank" rel="noopener">看看谁在使用Electron</a>。</p><h3 id="Electron-发展历程"><a href="#Electron-发展历程" class="headerlink" title="Electron 发展历程"></a>Electron 发展历程</h3><table><thead><tr><th align="left"><strong>2013年4月</strong></th><th align="left"><a href="https://github.com/electron/electron/commit/6ef8875b1e93787fa9759f602e7880f28e8e6b45" target="_blank" rel="noopener">Atom Shell 项目启动</a> 。</th></tr></thead><tbody><tr><td align="left"><strong>2014年5月</strong></td><td align="left"><a href="https://blog.atom.io/2014/05/06/atom-is-now-open-source.html" target="_blank" rel="noopener">Atom Shell 被开源</a> 。</td></tr><tr><td align="left"><strong>2015年4月</strong></td><td align="left"><a href="https://github.com/electron/electron/pull/1389" target="_blank" rel="noopener">Atom Shell 被重命名为 Electron</a> 。</td></tr><tr><td align="left"><strong>2016年5月</strong></td><td align="left"><a href="https://electronjs.org/blog/electron-1-0" target="_blank" rel="noopener">Electron 发布了 <code>v1.0.0</code> 版本</a> 。</td></tr><tr><td align="left"><strong>2016年5月</strong></td><td align="left"><a href="https://www.electronjs.org/docs/tutorial/mac-app-store-submission-guide" target="_blank" rel="noopener">Electron 构建的应用程序可上架 Mac App Store</a> 。</td></tr><tr><td align="left"><strong>2016年8月</strong></td><td align="left"><a href="https://www.electronjs.org/docs/tutorial/windows-store-guide" target="_blank" rel="noopener">Windows Store 支持 Electron 构建的应用程序</a> 。</td></tr></tbody></table><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><p><strong>1. 安装 electron</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g electron<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2. 克隆一个仓库、快速启动一个项目</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆示例项目的仓库</span><span class="token function">git</span> clone https://github.com/electron/electron-quick-start<span class="token comment" spellcheck="true"># 进入这个仓库</span><span class="token function">cd</span> electron-quick-start<span class="token comment" spellcheck="true"># 安装依赖并运行</span><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&amp;&amp;</span> <span class="token function">npm</span> start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 手动搭建一个 electron 项目</strong></p><ol><li>新建一个项目目录 例如: <code>electrondemo01</code></li><li>在 <code>electrondemo01</code> 目录下面新建三个文件: <code>index.html</code>、<code>main.js</code> 、<code>package.json</code></li><li><code>index.html</code> 里面用 <code>css</code> 进行布局（以前怎么写现在还是怎么写）</li><li>在 <code>main.js</code> 中写如下代码：</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> electron <span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//electron 对象的引用</span><span class="token keyword">const</span> app<span class="token operator">=</span>electron<span class="token punctuation">.</span>app<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//BrowserWindow 类的引用</span><span class="token keyword">const</span> BrowserWindow<span class="token operator">=</span>electron<span class="token punctuation">.</span>BrowserWindow<span class="token punctuation">;</span><span class="token keyword">let</span> mainWindow<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//监听应用准备完成的事件 app.on('ready',function(){</span><span class="token comment" spellcheck="true">//监听应用准备完成的事件</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'ready'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建窗口</span>    mainWindow<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>width<span class="token punctuation">:</span> <span class="token number">800</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">600</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mainWindow<span class="token punctuation">.</span><span class="token function">loadFile</span><span class="token punctuation">(</span><span class="token string">'index.html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mainWindow<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mainWindow <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//监听所有窗口关闭的事件$</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-all-closed'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// On OS X it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q$</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>platform <span class="token operator">!==</span> <span class="token string">'darwin'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        app<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>运行</li></ol><pre class="line-numbers language-bash"><code class="language-bash">electron <span class="token keyword">.</span> <span class="token comment" spellcheck="true">#注意:命令后面有个点</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4. electron-forge 搭建一个 electron 项目</strong></p><blockquote><p><code>electron-forge</code> 相当于 <code>electron</code> 的一个脚手架，可以让我们更方便的创建、运行、打包 <code>electron</code> 项目</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g electron-forge$electron-forge init my-new-app$<span class="token function">cd</span> my-new-app<span class="token function">npm</span> start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、Electron-运行流程"><a href="#三、Electron-运行流程" class="headerlink" title="三、Electron 运行流程"></a>三、Electron 运行流程</h2><h3 id="1-Electron-运行的流程"><a href="#1-Electron-运行的流程" class="headerlink" title="1 Electron 运行的流程"></a>1 Electron 运行的流程</h3><p><img src="https://pic.lixl.cn/2020/app-files.png" alt="Electron app components diagram"></p><h3 id="2-Electron-主进程和渲染进程"><a href="#2-Electron-主进程和渲染进程" class="headerlink" title="2 Electron 主进程和渲染进程"></a>2 Electron 主进程和渲染进程</h3><ul><li><p><code>Electron</code> 运行 <code>package.json</code> 的 <code>main</code> 脚本的进程被称为主进程。</p></li><li><p>在主进程中运行的脚本通过创建 <code>web</code> 页面来展示用户界面。 一个 <code>Electron</code> 应用总是有且只有一个主进程。</p></li><li><p>由于 <code>Electron</code> 使用了 <code>Chromium</code>(谷歌浏览器)来展示 <code>web</code> 页面，所以 <code>Chromium</code> 的 多进程架构也被使用到。 每个 <code>Electron</code> 中的 <code>web</code> 页面运行在它自己的渲染进程中。</p></li><li><p>主进程使用 <code>BrowserWindow</code> 实例创建页面。每个 <code>BrowserWindow</code> 实例都在自己的渲 染进程里运行页面。 当一个 <code>BrowserWindow</code>实例被销毁后，相应的渲染进程也会被终止。</p></li></ul><h3 id="3-Electron-渲染进程中通过-Nodejs-读取本地文件"><a href="#3-Electron-渲染进程中通过-Nodejs-读取本地文件" class="headerlink" title="3 Electron 渲染进程中通过 Nodejs 读取本地文件"></a>3 Electron 渲染进程中通过 Nodejs 读取本地文件</h3><blockquote><p>在普通的浏览器中，<code>web</code>页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 <code>Electron</code> 的用户在 <code>Node.js</code> 的 <code>API</code>支持下可以在页面中和操作系统进行一些底层交互。<br><code>Nodejs</code> 在主进程和渲染进程中都可以使用。渲染进程因为安全限制，不能直接操作生 <code>GUI</code>。虽然如此，因为集成了 Nodejs，渲染进程也有了操作系统底层 <code>API</code>的能力，<code>Nodejs</code> 中常用的 <code>Path</code>、<code>fs</code>、<code>Crypto</code> 等模块在 <code>Electron</code> 可以直接使用，方便我们处理链接、路径、 文件 <code>MD5</code> 等，同时 <code>npm</code> 还有成千上万的模块供我们选择。</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'package.json'</span><span class="token punctuation">,</span><span class="token string">'utf8'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        content<span class="token punctuation">.</span>textContent <span class="token operator">=</span> data<span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-Electron-开启调试模式"><a href="#4-Electron-开启调试模式" class="headerlink" title="4 Electron 开启调试模式"></a>4 Electron 开启调试模式</h3><pre class="line-numbers language-js"><code class="language-js">mainWindow<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="四、Electron-模块介绍"><a href="#四、Electron-模块介绍" class="headerlink" title="四、Electron 模块介绍"></a>四、Electron 模块介绍</h2><blockquote><p><code>Electron</code> 模块介绍、<code>remote</code> 模块、通 过 <code>BrowserWindow</code> 打开新窗口</p></blockquote><h3 id="1-Electron-主进程和渲染进程中的模块"><a href="#1-Electron-主进程和渲染进程中的模块" class="headerlink" title="1 Electron 主进程和渲染进程中的模块"></a>1 Electron 主进程和渲染进程中的模块</h3><p><img src="https://pic.lixl.cn/2020/image-20200220150228297.png" alt="image-20200220150228297"></p><p><img src="https://pic.lixl.cn/2020/52.png" alt="img"></p><h3 id="2-Electron-remote-模块"><a href="#2-Electron-remote-模块" class="headerlink" title="2 Electron remote 模块"></a>2 Electron remote 模块</h3><blockquote><p><code>remote</code> 模块提供了一种在渲染进程(网页)和主进程之间进行进程间通讯(<code>IPC</code>)的简便途径。在 <code>Electron</code> 中, 与 <code>GUI</code> 相关的模块(如 <code>dialog</code>, <code>menu</code> 等)只存在于主进程，而不在渲染进程中 。为了能从渲染进程中使用它们，需要用<code>ipc</code>模块来给主进程发送进程间消息。使用 <code>remote</code> 模块，可以调用主进程对象的方法，而无需显式地发送进程间消息，这类似于 <code>Java</code> 的 <code>RMI</code>。</p></blockquote><h3 id="3-通过BrowserWindow-打开新窗口"><a href="#3-通过BrowserWindow-打开新窗口" class="headerlink" title="3 通过BrowserWindow 打开新窗口"></a>3 通过BrowserWindow 打开新窗口</h3><blockquote><p><code>Electron</code> 渲染进程中通过 <strong><code>remote</code> 模块调用主进程中的 <code>BrowserWindow</code></strong> 打开新窗口，详情可参考：<br><a href="https://electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">https://electronjs.org/docs/api/browser-window</a></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 主进程代码</span><span class="token keyword">const</span> electron <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 控制应用生命周期的模块</span><span class="token keyword">const</span> <span class="token punctuation">{</span>app<span class="token punctuation">}</span> <span class="token operator">=</span> electron<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建本地浏览器窗口的模块</span><span class="token keyword">const</span> <span class="token punctuation">{</span>BrowserWindow<span class="token punctuation">}</span> <span class="token operator">=</span> electron<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指向窗口对象的一个全局引用，如果没有这个引用，那么当该 javascript 对象被垃圾回收 的</span><span class="token comment" spellcheck="true">// 时候该窗口将会自动关闭</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建一个新的浏览器窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>width<span class="token punctuation">:</span> <span class="token number">1104</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">620</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//570+50</span>   $    <span class="token comment" spellcheck="true">// 并且装载应用的 index.html 页面</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`file://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>__dirname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/html/index.html`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>   $    <span class="token comment" spellcheck="true">// 打开开发工具页面</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   $    <span class="token comment" spellcheck="true">//当窗口关闭时调用的方法</span>    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里 // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 当 Electron 完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。</span><span class="token comment" spellcheck="true">// 有些 API 只能在该事件发生后才能被使用</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'ready'</span><span class="token punctuation">,</span> createWindow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当所有的窗口被关闭后退出应用</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-all-closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对于 OS X 系统，应用和相应的菜单栏会一直激活直到用户通过 Cmd + Q 显式退出$</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>platform <span class="token operator">!==</span> <span class="token string">'darwin'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        app<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'activate'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对于 OS X 系统，当 dock 图标被点击后会重新创建一个 app 窗口，并且不会有其他</span>    <span class="token comment" spellcheck="true">// 窗口打开</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>win <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。$</span><span class="token comment" spellcheck="true">// 也可以把这些代码放在另一个文件中然后在这里导入</span><span class="token comment" spellcheck="true">// 渲染进程代码 /src/render/index.js</span><span class="token comment" spellcheck="true">// 打开新窗口属性用法有点类似vscode打开新的窗口</span><span class="token keyword">const</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> BrowerWindow <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remote<span class="token punctuation">.</span>BrowserWindow<span class="token punctuation">;</span>btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowerWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>$        width<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span>$        frame<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// false隐藏关闭按钮、菜单选项 true显示</span>        fullscreen<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 全屏展示</span>        transparent<span class="token punctuation">:</span> <span class="token boolean">true</span>$    <span class="token punctuation">}</span><span class="token punctuation">)</span>$    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span><span class="token string">'news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/53.png" alt="img"></p><h2 id="五、自定义顶部菜单-右键菜单"><a href="#五、自定义顶部菜单-右键菜单" class="headerlink" title="五、自定义顶部菜单/右键菜单"></a>五、自定义顶部菜单/右键菜单</h2><p><img src="https://pic.lixl.cn/2020/54.png" alt="img"></p><h3 id="1-主进程中调用Menu模块-自定义软件顶部菜单"><a href="#1-主进程中调用Menu模块-自定义软件顶部菜单" class="headerlink" title="1 主进程中调用Menu模块-自定义软件顶部菜单"></a>1 主进程中调用Menu模块-自定义软件顶部菜单</h3><blockquote><p><a href="https://electronjs.org/docs/api/menu-item" target="_blank" rel="noopener">https://electronjs.org/docs/api/menu-item</a><br><code>Electron</code> 中 <code>Menu</code> 模块可以用来创建原生菜单，它可用作应用菜单和 <code>context</code> 菜单<br>这个模块是一个主进程的模块，并且可以通过 <code>remote</code> 模块给渲染进程调用</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main/menu.js</span><span class="token keyword">const</span> <span class="token punctuation">{</span> Menu <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 文档 https://electronjs.org/docs/api/menu-item</span><span class="token comment" spellcheck="true">// 菜单项目</span><span class="token keyword">let</span> menus <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'文件'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'新建文件'</span><span class="token punctuation">,</span>                accelerator<span class="token punctuation">:</span> <span class="token string">'ctrl+n'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 绑定快捷键</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 绑定事件</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'新建文件'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'新建窗口'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'新建窗口'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'编辑'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'复制'</span><span class="token punctuation">,</span>                role<span class="token punctuation">:</span> <span class="token string">'copy'</span> <span class="token comment" spellcheck="true">// 调用内置角色实现对应功能</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'剪切'</span><span class="token punctuation">,</span>                role<span class="token punctuation">:</span> <span class="token string">'cut'</span>  <span class="token comment" spellcheck="true">// 调用内置角色实现对应功能</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'视图'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'浏览'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'搜索'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token keyword">let</span> m <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>menus<span class="token punctuation">)</span>Menu<span class="token punctuation">.</span><span class="token function">setApplicationMenu</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/menu.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/55.png" alt="img"></p><blockquote><p>我们给菜单绑定事件，在命令行控制台可以看到</p></blockquote><p><img src="https://pic.lixl.cn/2020/56.png" alt="img"></p><h3 id="2-渲染进程中调用Menu模块"><a href="#2-渲染进程中调用Menu模块" class="headerlink" title="2 渲染进程中调用Menu模块"></a>2 渲染进程中调用Menu模块</h3><blockquote><p>不推荐使用这种方式，建议在主进程中使用</p></blockquote><p><strong>1. remote</strong></p><blockquote><p>通过<code>remote</code>调用主进程的方法</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 菜单引入的方式发生变化</span><span class="token keyword">const</span> <span class="token punctuation">{</span> Menu <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remote<span class="token comment" spellcheck="true">// 其他代码和上面菜单一样</span><span class="token comment" spellcheck="true">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 加入index.html</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/menu.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-渲染进程中自定义右键菜单"><a href="#3-渲染进程中自定义右键菜单" class="headerlink" title="3 渲染进程中自定义右键菜单"></a>3 渲染进程中自定义右键菜单</h3><p><strong>1. 定义菜单</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// render/menu.js</span><span class="token comment" spellcheck="true">// 在渲染进程中通过remote模块调用主进程中的模块</span><span class="token keyword">const</span> <span class="token punctuation">{</span> Menu <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remote<span class="token keyword">const</span> <span class="token punctuation">{</span> remote <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 文档 https://electronjs.org/docs/api/menu-item</span><span class="token comment" spellcheck="true">// 菜单项目</span><span class="token keyword">let</span> menus <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'文件'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'新建文件'</span><span class="token punctuation">,</span>                accelerator<span class="token punctuation">:</span> <span class="token string">'ctrl+n'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 绑定快捷键</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 绑定事件</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'新建文件'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'新建窗口'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'新建窗口'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'编辑'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'复制'</span><span class="token punctuation">,</span>                role<span class="token punctuation">:</span> <span class="token string">'copy'</span> <span class="token comment" spellcheck="true">// 调用内置角色实现对应功能</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'剪切'</span><span class="token punctuation">,</span>                role<span class="token punctuation">:</span> <span class="token string">'cut'</span>  <span class="token comment" spellcheck="true">// 调用内置角色实现对应功能</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'视图'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'浏览'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'搜索'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token keyword">let</span> m <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>menus<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Menu.setApplicationMenu(m)</span><span class="token comment" spellcheck="true">// 绑定右键菜单</span>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'contextmenu'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   m<span class="token punctuation">.</span><span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    window<span class="token punctuation">:</span> remote<span class="token punctuation">.</span><span class="token function">getCurrentWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/57.png" alt="img"></p><p><strong>2. 引入</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/menu.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="六、进程通信"><a href="#六、进程通信" class="headerlink" title="六、进程通信"></a>六、进程通信</h2><p><img src="https://pic.lixl.cn/2020/58.png" alt="img"></p><ul><li>渲染进程 <a href="https://electronjs.org/docs/api/ipc-renderer" target="_blank" rel="noopener">https://electronjs.org/docs/api/ipc-renderer</a></li><li>主进程 <a href="https://electronjs.org/docs/api/ipc-main" target="_blank" rel="noopener">https://electronjs.org/docs/api/ipc-main</a></li></ul><h3 id="1-主进程与渲染进程之间的通信"><a href="#1-主进程与渲染进程之间的通信" class="headerlink" title="1 主进程与渲染进程之间的通信"></a>1 主进程与渲染进程之间的通信</h3><blockquote><p>有时候我们想在渲染进程中通过一个事件去执行主进程里面的方法。或者在渲染进程中通知 主进程处理事件，主进程处理完成后广播一个事件让渲染进程去处理一些事情。这个时候就 用到了主进程和渲染进程之间的相互通信</p></blockquote><blockquote><p><code>Electron</code> 主进程，和渲染进程的通信主要用到两个模块:<code>ipcMain</code> 和 <code>ipcRenderer</code></p></blockquote><ul><li><code>ipcMain</code>:当在主进程中使用时，它处理从渲染器进程(网页)发送出来的异步和同步信息,当然也有可能从主进程向渲染进程发送消息。</li><li><code>ipcRenderer</code>: 使用它提供的一些方法从渲染进程 (<code>web</code> 页面) 发送同步或异步的消息到主进程。 也可以接收主进程回复的消息</li></ul><h4 id="1-1-渲染进程给主进程发送异步消息"><a href="#1-1-渲染进程给主进程发送异步消息" class="headerlink" title="1.1 渲染进程给主进程发送异步消息"></a>1.1 渲染进程给主进程发送异步消息</h4><blockquote><p>间接实现渲染进程执行主进程里面的方法</p></blockquote><p><strong>1. 引入ipcRender</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"send"</span><span class="token operator">></span>在 渲染进程中执行主进程里的方法（异步）<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/ipcRender.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程发送消息</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/ipcRender.js</span><span class="token comment" spellcheck="true">//渲染进程</span><span class="token keyword">let</span> send <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#send'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>send<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 传递消息给主进程</span>    <span class="token comment" spellcheck="true">// 异步</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'sendMsg'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 主进程接收消息</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain.js</span><span class="token comment" spellcheck="true">//主进程</span><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcMain <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 主进程处理渲染进程广播数据</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'sendMsg'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data\n '</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event\n '</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/59.png" alt="img"></p><h4 id="1-2-渲染进程发送消息，主进程接收消息并反馈"><a href="#1-2-渲染进程发送消息，主进程接收消息并反馈" class="headerlink" title="1.2 渲染进程发送消息，主进程接收消息并反馈"></a>1.2 渲染进程发送消息，主进程接收消息并反馈</h4><blockquote><p>渲染进程给主进程发送异步消息，主进程接收到异步消息以后通知渲染进程</p></blockquote><p><strong>1. 引入ipcRender</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendFeedback"</span><span class="token operator">></span>在 渲染进程中执行主进程里的方法，并反馈给主进程（异步）<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/ipcRender.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程发送消息</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/ipcRender.js</span><span class="token comment" spellcheck="true">//渲染进程</span><span class="token keyword">let</span> sendFeedback <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#sendFeedback'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 向主进程发送消息</span>sendFeedback<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 触发主进程里面的方法</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'sendFeedback'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 主进程收到消息处理并广播反馈通知渲染进程</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain.js</span><span class="token comment" spellcheck="true">//主进程</span><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcMain <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 主进程处理渲染进程广播数据，并反馈给渲染进程</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'sendFeedback'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// console.log('data\n ', data)</span>    <span class="token comment" spellcheck="true">// console.log('event\n ', event)</span>   $    <span class="token comment" spellcheck="true">// 主进程给渲染进程广播数据</span>    event<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'sendFeedbackToRender'</span><span class="token punctuation">,</span> <span class="token string">'来自主进程的反馈'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. 渲染进程处理主进程广播的数据</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/ipcRender.js</span><span class="token comment" spellcheck="true">// 向主进程发送消息后，接收主进程广播的事件</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'sendFeedbackToRender'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event\n '</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data\n '</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/60.png" alt="img"></p><h4 id="1-3-渲染进程给主进程发送同步消息"><a href="#1-3-渲染进程给主进程发送同步消息" class="headerlink" title="1.3 渲染进程给主进程发送同步消息"></a>1.3 渲染进程给主进程发送同步消息</h4><p><strong>1. 引入ipcRender</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendSync"</span><span class="token operator">></span>渲染进程和主进程同步通信<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/ipcRender.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程给主进程同步通信</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/ipcMain.js</span><span class="token keyword">let</span> sendSync <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#sendSync'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和主进程同步通信</span>sendSync<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 同步广播数据</span>   <span class="token keyword">let</span> msg <span class="token operator">=</span>  ipcRenderer<span class="token punctuation">.</span><span class="token function">sendSync</span><span class="token punctuation">(</span><span class="token string">'sendsync'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   $   <span class="token comment" spellcheck="true">// 同步返回主进程反馈的数据</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'msg\n '</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 主进程接收数据处理</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain.js</span><span class="token comment" spellcheck="true">// 渲染进程和主进程同步通信 接收同步广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'sendsync'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// console.log('data\n ', data)</span>    <span class="token comment" spellcheck="true">// console.log('event\n ', event)</span>    <span class="token comment" spellcheck="true">// 主进程给渲染进程广播数据</span>    event<span class="token punctuation">.</span>returnValue <span class="token operator">=</span><span class="token string">'渲染进程和主进程同步通信 接收同步广播，来自主进程的反馈.'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/61.png" alt="img"></p><h4 id="1-4-渲染进程广播通知主进程打开窗口"><a href="#1-4-渲染进程广播通知主进程打开窗口" class="headerlink" title="1.4 渲染进程广播通知主进程打开窗口"></a>1.4 渲染进程广播通知主进程打开窗口</h4><blockquote><p>一般都是在渲染进程中执行广播操作，去通知主进程完成任务</p></blockquote><p><strong>1. 引入openWindow</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendSync"</span><span class="token operator">></span>渲染进程和主进程同步通信<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/openWindow.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain2</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain2.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程通知主进程打开窗口</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/openWindow.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> openWindow <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#openWindow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和渲染进程直接的通信========</span>openWindow<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过广播的形式 通知主进程执行操作</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 主进程收到通知执行操作</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain2.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> <span class="token punctuation">{</span> ipcMain<span class="token punctuation">,</span>BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收到广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用window打开新窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/62.png" alt="img"></p><h3 id="2-渲染进程与渲染进程之间的通信"><a href="#2-渲染进程与渲染进程之间的通信" class="headerlink" title="2 渲染进程与渲染进程之间的通信"></a>2 渲染进程与渲染进程之间的通信</h3><blockquote><p>也就是两个窗口直接的通信</p></blockquote><h4 id="2-1-localstorage传值"><a href="#2-1-localstorage传值" class="headerlink" title="2.1 localstorage传值"></a>2.1 localstorage传值</h4><blockquote><p><code>Electron</code> 渲染进程通过 <code>localstorage</code> 给另一个渲染进程传值</p></blockquote><p><strong>1. 引入openWindow</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendSync"</span><span class="token operator">></span>渲染进程和主进程同步通信<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/openWindow.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain2</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain2.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程通知主进程打开窗口</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/openWindow.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> openWindow <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#openWindow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和渲染进程直接的通信========</span>openWindow<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过广播的形式 通知主进程执行操作</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   $    <span class="token comment" spellcheck="true">// ======= localstorage传值 =====</span>     localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token string">'poetries'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 新建news页面</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>news<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>  <span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>body<span class="token operator">></span>    news page  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/news.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span class="token comment" spellcheck="true">// src/render/news.js</span><span class="token keyword">let</span> username <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. 主进程收到通知执行操作</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain2.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> <span class="token punctuation">{</span> ipcMain<span class="token punctuation">,</span>BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收到广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用window打开新窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-BrowserWindow和webContents方式实现"><a href="#2-2-BrowserWindow和webContents方式实现" class="headerlink" title="2.2 BrowserWindow和webContents方式实现"></a>2.2 BrowserWindow和webContents方式实现</h4><blockquote><p>通过 <code>BrowserWindow</code> 和 <code>webContents</code> 模块实现渲染进程和渲染进程的通信</p></blockquote><blockquote><p><code>webContents</code> 是一个事件发出者.它负责渲染并控制网页，也是 <code>BrowserWindow</code> 对象的属性</p></blockquote><p><strong>需要了解的几个知识点</strong></p><ol><li>获取当前窗口的 <code>id</code></li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> winId <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>监听当前窗口加载完成的事件</li></ol><pre class="line-numbers language-js"><code class="language-js">win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'did-finish-load'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   $<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>同一窗口之间广播数据</li></ol><pre class="line-numbers language-js"><code class="language-js">win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'did-finish-load'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'msg'</span><span class="token punctuation">,</span>winId<span class="token punctuation">,</span><span class="token string">'我是 index.html 的数据'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>通过 <code>id</code> 查找窗口</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> win <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">fromId</span><span class="token punctuation">(</span>winId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>下面是具体演示</p></blockquote><p><strong>1. 引入openWindow</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendSync"</span><span class="token operator">></span>渲染进程和主进程同步通信<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/openWindow.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain2</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain2.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程通知主进程打开窗口</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/openWindow.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> openWindow <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#openWindow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和渲染进程直接的通信========</span>openWindow<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过广播的形式 通知主进程执行操作</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 主进程收到通知执行操作</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain2.js</span><span class="token keyword">let</span> <span class="token punctuation">{</span> ipcMain<span class="token punctuation">,</span>BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收到广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> userInfo<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用window打开新窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新开窗口调试模式</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 把渲染进程传递过来的数据再次传递给渲染进程news</span>    <span class="token comment" spellcheck="true">// 等待窗口加载完</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'did-finish-load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span>        win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'toNews'</span><span class="token punctuation">,</span> userInfo<span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>   $    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. news接收主进程传递的数据</strong></p><blockquote><p>数据经过渲染进程-&gt;主进程-&gt;<code>news</code>渲染进程</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>news页面<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>  <span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>body<span class="token operator">></span>    news page  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/news.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span class="token comment" spellcheck="true">// src/render/news.js</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// let username = localStorage.getItem('username')</span><span class="token comment" spellcheck="true">// console.log(username)</span><span class="token comment" spellcheck="true">// 监听主进程传递过来的数据$</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'toNews'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> userInfo<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/63.png" alt="img"></p><p><img src="https://pic.lixl.cn/2020/64.png" alt="img"></p><blockquote><p>那么，这里有一个问题，<code>news</code>进程接收到了广播后如何给出反馈呢？</p></blockquote><p><img src="https://pic.lixl.cn/2020/65.png" alt="img"></p><p><strong>1. 在主进程中获取窗口ID传递</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain2.js</span><span class="token keyword">let</span> <span class="token punctuation">{</span> ipcMain<span class="token punctuation">,</span>BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收到广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> userInfo<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 获取当前窗口ID 放在第一行保险  因为后面也打开了新窗口使得获取的ID有问题</span>    <span class="token keyword">let</span> winId <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>id    <span class="token comment" spellcheck="true">// 调用window打开新窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新开窗口调试模式</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span> $    <span class="token comment" spellcheck="true">// 把渲染进程传递过来的数据再次传递给渲染进程news</span>    <span class="token comment" spellcheck="true">// 等待窗口加载完</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'did-finish-load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span>        win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'toNews'</span><span class="token punctuation">,</span> userInfo<span class="token punctuation">,</span> winId<span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>   $    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 在news进程中广播数据</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/news.js</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 注意这里 在渲染进程中需要从remote中获取BrowserWindow</span><span class="token keyword">const</span> BrowerWindow <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remote<span class="token punctuation">.</span>BrowserWindow<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// let username = localStorage.getItem('username')</span><span class="token comment" spellcheck="true">// console.log(username)</span><span class="token comment" spellcheck="true">// 监听主进程传递过来的数据$</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'toNews'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> userInfo<span class="token punctuation">,</span> winId<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// windID 第一个窗口ID</span>    <span class="token comment" spellcheck="true">// 获取对应ID的窗口</span>    <span class="token keyword">let</span> firstWin <span class="token operator">=</span> BrowerWindow<span class="token punctuation">.</span><span class="token function">fromId</span><span class="token punctuation">(</span>winId<span class="token punctuation">)</span>    firstWin<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'toIndex'</span><span class="token punctuation">,</span> <span class="token string">'来自news进程反馈的信息'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 在另一个渲染进程中处理广播</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> openWindow <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#openWindow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和渲染进程直接的通信========</span>openWindow<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 传递消息给主进程</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 传递给打开的窗口 渲染进程和渲染进程直接的通信</span>    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token string">'poetries'</span><span class="token punctuation">)</span>   $<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接收news渲染进程传递回来的消息</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'toIndex'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'==='</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/66.png" alt="img"></p><h2 id="七、Electron-Shell-模块"><a href="#七、Electron-Shell-模块" class="headerlink" title="七、Electron Shell 模块"></a>七、Electron Shell 模块</h2><p><img src="https://pic.lixl.cn/2020/67.png" alt="img"></p><h3 id="1-Shell-模块使用"><a href="#1-Shell-模块使用" class="headerlink" title="1 Shell 模块使用"></a>1 Shell 模块使用</h3><blockquote><p>文档 <a href="https://electronjs.org/docs/api/shell" target="_blank" rel="noopener">https://electronjs.org/docs/api/shell</a><br><code>Electron Shell</code> 模块在用户默认浏览器 中打开 <code>URL</code> 以及 <code>Electron DOM webview</code> 标签。<code>Shell</code>既属于主进程模块又是渲染进程模块<br><code>shell</code> 模块提供了集成其他桌面客户端的关联功能</p></blockquote><p><strong>1. 引入</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"shellDom"</span><span class="token operator">></span>通过shell打开外部链接<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/shell.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. shell.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/shell.js</span><span class="token keyword">const</span> <span class="token punctuation">{</span> shell <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">let</span> shellDom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#shellDom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shellDom<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span><span class="token string">'https://github.com/poetries'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-Electron-DOM-标签"><a href="#2-Electron-DOM-标签" class="headerlink" title="2 Electron DOM `` 标签"></a>2 <code>Electron DOM</code> `` 标签</h3><blockquote><p><code>Webview</code> 与 <code>iframe</code> 有点相似，但是与 <code>iframe</code> 不同, <code>webview</code> 和你的应用运行的是不同的进程。它不拥有渲染进程的权限，并且应用和嵌入内容之间的交互全部都是异步的。因为这能 保证应用的安全性不受嵌入内容的影响。</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html中引入<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>webview id<span class="token operator">=</span><span class="token string">"webview"</span> src<span class="token operator">=</span><span class="token string">"http://blog.poetries.top"</span> style<span class="token operator">=</span><span class="token string">"position:fixed; width:100%; height:100%"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>webview<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-shell模块-结合Menu模块使用案例"><a href="#3-shell模块-结合Menu模块使用案例" class="headerlink" title="3 shell模块``结合Menu模块使用案例"></a>3 <code>shell</code>模块``结合<code>Menu</code>模块使用案例</h3><p><strong>1. 新建src/render/webview.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> myWebview <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#myWebview'</span><span class="token punctuation">)</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwebview'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    myWebview<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入src/index.html</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>webview id<span class="token operator">=</span><span class="token string">"myWebview"</span> src<span class="token operator">=</span><span class="token string">"http://blog.poetries.top"</span> style<span class="token operator">=</span><span class="token string">"position:fixed; width:100%; height:100%"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>webview<span class="token operator">></span>   $<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/webview.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 新建src/main/menu.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">const</span> <span class="token punctuation">{</span> shell<span class="token punctuation">,</span> Menu<span class="token punctuation">,</span> BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前窗口渲染网页</span><span class="token keyword">function</span> <span class="token function">openWebView</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取当前窗口Id</span>    <span class="token keyword">let</span> win <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 广播通知渲染进程打开webview</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwebview'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在窗口外打开网页</span><span class="token keyword">function</span> <span class="token function">openWeb</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> template <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'帮助'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'关于我们'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWeb</span><span class="token punctuation">(</span><span class="token string">'http://blog.poetries.top'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                type<span class="token punctuation">:</span> <span class="token string">'separator'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'联系我们'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWeb</span><span class="token punctuation">(</span><span class="token string">'https://github.com/poetries'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'加载网页'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'博客'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'http://blog.poetries.top'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token comment" spellcheck="true">// 分隔符</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'GitHub'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://github.com/poetries'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token comment" spellcheck="true">// 分隔符</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'简书'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://www.jianshu.com/users/94077fcddfc0/timeline'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span>    label<span class="token punctuation">:</span> <span class="token string">'视频网站'</span><span class="token punctuation">,</span>    submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'优酷'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://www.youku.com'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token comment" spellcheck="true">// 分隔符</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'爱奇艺'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://www.iqiyi.com/'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token comment" spellcheck="true">// 分隔符</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'腾讯视频'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://v.qq.com/'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token keyword">let</span> m <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span>Menu<span class="token punctuation">.</span><span class="token function">setApplicationMenu</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 引入menu</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/menu.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/68.png" alt="img"></p><h2 id="八、Electron-dialog-弹出框"><a href="#八、Electron-dialog-弹出框" class="headerlink" title="八、Electron dialog 弹出框"></a>八、Electron dialog 弹出框</h2><p><img src="https://pic.lixl.cn/2020/69.png" alt="img"></p><blockquote><p>文档 <a href="https://electronjs.org/docs/api/dialog" target="_blank" rel="noopener">https://electronjs.org/docs/api/dialog</a><br><code>dialog</code>属于主进程中的模块<br><code>dialog</code> 模块提供了 <code>api</code> 来展示原生的系统对话框，例如打开文件框，<code>alert</code> 框， 所以 <code>web</code> 应用可以给用户带来跟系统应用相同的体验</p></blockquote><p><strong>1. 在src/index.html中引入</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"showError"</span><span class="token operator">></span>showError<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"showMsg"</span><span class="token operator">></span>showMsg<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"showOpenDialog"</span><span class="token operator">></span>showOpenDialog<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"saveDialog"</span><span class="token operator">></span>saveDialog<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/dialog.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 新建render/dialog.js</strong> </p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// render/dialog.js</span><span class="token keyword">let</span> showError <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#showError'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> showMsg <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#showMsg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> showOpenDialog <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#showOpenDialog'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> saveDialog <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#saveDialog'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span>remote<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span>showError<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showErrorBox</span><span class="token punctuation">(</span><span class="token string">'警告'</span><span class="token punctuation">,</span> <span class="token string">'操作有误'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>showMsg<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showMessageBox</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">'info'</span><span class="token punctuation">,</span>        title<span class="token punctuation">:</span> <span class="token string">'提示信息'</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'内容'</span><span class="token punctuation">,</span>        buttons<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'确定'</span><span class="token punctuation">,</span> <span class="token string">'取消'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>showOpenDialog<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showOpenDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 打开文件夹</span>        properties<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'openDirectory'</span><span class="token punctuation">,</span> <span class="token string">'openFile'</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 打开文件</span>        <span class="token comment" spellcheck="true">// properties: ['openFile']</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>saveDialog<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showSaveDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">'Save File'</span><span class="token punctuation">,</span>        defaultPath<span class="token punctuation">:</span> <span class="token string">'/Users/poetry/Downloads/'</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// filters 指定一个文件类型数组，用于规定用户可见或可选的特定类型范围</span>        filters<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Images'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'jpg'</span><span class="token punctuation">,</span> <span class="token string">'png'</span><span class="token punctuation">,</span> <span class="token string">'gif'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Movies'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'mkv'</span><span class="token punctuation">,</span> <span class="token string">'avi'</span><span class="token punctuation">,</span> <span class="token string">'mp4'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Custom File Type'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'as'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'All Files'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'*'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 不是真的保存 ，具体还需nodejs处理</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>showError</strong></p><pre class="line-numbers language-js"><code class="language-js">remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showErrorBox</span><span class="token punctuation">(</span><span class="token string">'警告'</span><span class="token punctuation">,</span> <span class="token string">'操作有误'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/70.png" alt="img"></p><p><strong>showMessageBox</strong></p><pre class="line-numbers language-js"><code class="language-js">remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showMessageBox</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    type<span class="token punctuation">:</span> <span class="token string">'info'</span><span class="token punctuation">,</span>    title<span class="token punctuation">:</span> <span class="token string">'提示信息'</span><span class="token punctuation">,</span>    message<span class="token punctuation">:</span> <span class="token string">'内容'</span><span class="token punctuation">,</span>    buttons<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'确定'</span><span class="token punctuation">,</span> <span class="token string">'取消'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/71.png" alt="img"></p><p><strong>showOpenDialog</strong></p><pre class="line-numbers language-js"><code class="language-js">remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showOpenDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 打开文件夹</span>    properties<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'openDirectory'</span><span class="token punctuation">,</span> <span class="token string">'openFile'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 打开文件</span>    <span class="token comment" spellcheck="true">// properties: ['openFile']</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/72.png" alt="img"></p><p><strong>showSaveDialog</strong></p><pre class="line-numbers language-js"><code class="language-js">remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showSaveDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    title<span class="token punctuation">:</span> <span class="token string">'Save File'</span><span class="token punctuation">,</span>    defaultPath<span class="token punctuation">:</span> <span class="token string">'/Users/poetry/Downloads/'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// filters 指定一个文件类型数组，用于规定用户可见或可选的特定类型范围</span>    filters<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Images'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'jpg'</span><span class="token punctuation">,</span> <span class="token string">'png'</span><span class="token punctuation">,</span> <span class="token string">'gif'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Movies'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'mkv'</span><span class="token punctuation">,</span> <span class="token string">'avi'</span><span class="token punctuation">,</span> <span class="token string">'mp4'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Custom File Type'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'as'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'All Files'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'*'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 不是真的保存 ，具体还需nodejs处理</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/73.png" alt="img"></p><h2 id="九、实现一个简易记事本代码编辑器"><a href="#九、实现一个简易记事本代码编辑器" class="headerlink" title="九、实现一个简易记事本代码编辑器"></a>九、实现一个简易记事本代码编辑器</h2><blockquote><p>代码 <a href="https://github.com/poetries/electron-demo/tree/master/notepad" target="_blank" rel="noopener">https://github.com/poetries/electron-demo/tree/master/notepad</a></p></blockquote><h2 id="十、系统托盘、托盘右键菜单、托盘图标闪烁"><a href="#十、系统托盘、托盘右键菜单、托盘图标闪烁" class="headerlink" title="十、系统托盘、托盘右键菜单、托盘图标闪烁"></a>十、系统托盘、托盘右键菜单、托盘图标闪烁</h2><p><img src="https://pic.lixl.cn/2020/74.png" alt="img"></p><blockquote><p>文档 <a href="https://electronjs.org/docs/api/tray" target="_blank" rel="noopener">https://electronjs.org/docs/api/tray</a><br>系统托盘，托盘右键菜单、托盘图标闪烁 点击右上角关闭按钮隐藏到托盘(仿杀毒软件)</p></blockquote><p><strong>1. 引入文件</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/index.js</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/tray.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. Electron 创建任务栏图标以及任务栏图标右键菜单</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/tray.js</span><span class="token keyword">var</span> <span class="token punctuation">{</span>    Menu<span class="token punctuation">,</span> Tray<span class="token punctuation">,</span> app<span class="token punctuation">,</span> BrowserWindow<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> appIcon <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tray</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/lover.png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> menu <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'设置'</span><span class="token punctuation">,</span>        click<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//打开相应页面$</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'帮助'</span><span class="token punctuation">,</span>        click<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'关于'</span><span class="token punctuation">,</span>        click<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'退出'</span><span class="token punctuation">,</span>        click<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>$            <span class="token comment" spellcheck="true">// BrowserWindow.getFocusedWindow().webContents().send('close-main-window');</span>            app<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 鼠标放上去提示信息</span>appIcon<span class="token punctuation">.</span><span class="token function">setToolTip</span><span class="token punctuation">(</span><span class="token string">'hello poetries'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>appIcon<span class="token punctuation">.</span><span class="token function">setContextMenu</span><span class="token punctuation">(</span>menu<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/75.png" alt="img"></p><p><strong>3. 监听任务栏图标的单击、双击事件</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 实现点击关闭按钮，让应用保存在托盘里面，双击托盘打开</span><span class="token keyword">let</span> win <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    win<span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>iconTray<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'double-click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    win<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. Electron 点击右上角关闭按钮隐藏任务栏图标</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> win <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>win<span class="token punctuation">.</span><span class="token function">isFocused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   $    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>win<span class="token punctuation">.</span><span class="token function">isFocused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*阻止应用退出*/</span>        win<span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*隐藏当前窗口*/</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. Electron 实现任务栏闪烁图标</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> appIcon <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tray</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/lover.png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        appIcon<span class="token punctuation">.</span><span class="token function">setImage</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/empty.ico'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        appIcon<span class="token punctuation">.</span><span class="token function">setImage</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/lover.png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十一、消息通知、监听网络变化"><a href="#十一、消息通知、监听网络变化" class="headerlink" title="十一、消息通知、监听网络变化"></a>十一、消息通知、监听网络变化</h2><h3 id="1-消息通知"><a href="#1-消息通知" class="headerlink" title="1 消息通知"></a>1 消息通知</h3><p><strong>1. Electron 实现消息通知</strong></p><blockquote><p><code>Electron</code> 里面的消息通知是基于 <code>h5</code> 的通知 <code>api</code> 实现的<br>文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/notification</a></p></blockquote><p><strong>1. 新建notification.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// h5api实现通知</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>    title<span class="token punctuation">:</span> <span class="token string">'electron 通知API'</span><span class="token punctuation">,</span>    body<span class="token punctuation">:</span> <span class="token string">'hello poetries'</span><span class="token punctuation">,</span>    icon<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'../static/img/favicon2.ico'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 通知图标</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#showNotification'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> myNotification  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">window<span class="token punctuation">.</span>Notification</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>title<span class="token punctuation">,</span> options<span class="token punctuation">)</span>   $    <span class="token comment" spellcheck="true">// 消息可点击</span>    myNotification<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'click notification'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"showNotification"</span><span class="token operator">></span>弹出消息通知<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/notification.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>mac</code>上的消息通知</p><p><img src="https://pic.lixl.cn/2020/76.png" alt="img"></p><h3 id="2-监听网络变化"><a href="#2-监听网络变化" class="headerlink" title="2 监听网络变化"></a>2 监听网络变化</h3><p><strong>1. 基本使用</strong></p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// 监听网络变化</span><span class="token comment" spellcheck="true">// 端开网络 再次连接测试</span> window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'online'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'online'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$$ window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'offline'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'offline'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 监听网络变化实现消息通知</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 端开网络 再次连接测试</span><span class="token comment" spellcheck="true">// 监听网络变化实现消息通知</span> window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'online'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'online'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$ window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'offline'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 断开网络触发事件</span>    <span class="token keyword">var</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">'QQ邮箱'</span><span class="token punctuation">,</span>        body<span class="token punctuation">:</span> <span class="token string">'网络异常，请检查你的网络'</span><span class="token punctuation">,</span>        icon<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'../static/img/favicon2.ico'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 通知图标</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> myNotification  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">window<span class="token punctuation">.</span>Notification</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>title<span class="token punctuation">,</span> options<span class="token punctuation">)</span>    myNotification<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'click notification'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/77.png" alt="img"></p><h2 id="十二、注册全局快捷键-剪切板事件-nativeImage-模块"><a href="#十二、注册全局快捷键-剪切板事件-nativeImage-模块" class="headerlink" title="十二、注册全局快捷键/剪切板事件/nativeImage 模块"></a>十二、注册全局快捷键/剪切板事件/nativeImage 模块</h2><blockquote><p><code>Electron</code> 注册全局快捷键 (<code>globalShortcut</code>) 以及 <code>clipboard</code> 剪 切板事件以及 <code>nativeImage</code> 模块(实现类似播放器点击机器码自动复制功 能)</p></blockquote><h3 id="1-注册全局快捷键"><a href="#1-注册全局快捷键" class="headerlink" title="1 注册全局快捷键"></a>1 注册全局快捷键</h3><p><img src="https://pic.lixl.cn/2020/78.png" alt="img"></p><ul><li><a href="https://electronjs.org/docs/tutorial/keyboard-shortcuts" target="_blank" rel="noopener">keyboard-shortcuts文档</a></li><li><a href="https://electronjs.org/docs/api/app" target="_blank" rel="noopener">app模块参考文档</a></li></ul><p><strong>1. 新建src/main/shortCut.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span>globalShortcut<span class="token punctuation">,</span> app<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'ready'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注册全局快捷键</span>    globalShortcut<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 检测快捷键是否注册成功 true是注册成功</span>    <span class="token keyword">let</span> isRegister <span class="token operator">=</span> globalShortcut<span class="token punctuation">.</span><span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isRegister<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 退出的时候取消全局快捷键</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'will-quit'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    globalShortcut<span class="token punctuation">.</span><span class="token function">unregister</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入src/index.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 注意在外部引入即可 不用放到app中</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/shortCut.js'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-剪切板clipboard、nativeImage-模块"><a href="#2-剪切板clipboard、nativeImage-模块" class="headerlink" title="2 剪切板clipboard、nativeImage 模块"></a>2 剪切板clipboard、nativeImage 模块</h3><p><img src="https://pic.lixl.cn/2020/79.png" alt="img"></p><ul><li><a href="https://electronjs.org/docs/api/clipboard" target="_blank" rel="noopener">剪切板clipboard文档</a></li><li><a href="https://electronjs.org/docs/api/native-image" target="_blank" rel="noopener">nativeImage模块</a></li></ul><p><strong>1. html</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span>h2<span class="token operator">></span>双击下面信息复制<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">'msg'</span><span class="token operator">></span><span class="token number">123456789</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>  <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"plat"</span><span class="token operator">></span>粘贴<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"text"</span> type<span class="token operator">=</span><span class="token string">"text"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span>h2<span class="token operator">></span>复制图片到界面<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"copyImg"</span><span class="token operator">></span>复制图片<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/clipboard.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 新建src/render/clipboard.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// clipboard可以在主进程或渲染进程使用</span><span class="token keyword">const</span> <span class="token punctuation">{</span> clipboard<span class="token punctuation">,</span> nativeImage <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//复制</span><span class="token comment" spellcheck="true">// 运行ctrl+v可看到复制的内容</span><span class="token comment" spellcheck="true">// clipboard.writeText('poetries')</span><span class="token comment" spellcheck="true">// clipboard.readText() //获取复制的内容 粘贴</span><span class="token comment" spellcheck="true">// 双击复制消息</span><span class="token keyword">let</span> msg <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#msg'</span><span class="token punctuation">)</span><span class="token keyword">let</span> plat <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#plat'</span><span class="token punctuation">)</span><span class="token keyword">let</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#text'</span><span class="token punctuation">)</span>msg<span class="token punctuation">.</span>ondblclick  <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    clipboard<span class="token punctuation">.</span><span class="token function">writeText</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span>    <span class="token function">alert</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">}</span>plat<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    text<span class="token punctuation">.</span>value <span class="token operator">=</span> clipboard<span class="token punctuation">.</span><span class="token function">readText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 复制图片显示到界面</span><span class="token keyword">let</span> copyImg <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#copyImg'</span><span class="token punctuation">)</span>copyImg<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 结合nativeImage模块</span>    <span class="token keyword">let</span> image <span class="token operator">=</span> nativeImage<span class="token punctuation">.</span><span class="token function">createFromPath</span><span class="token punctuation">(</span><span class="token string">'../static/img/lover.png'</span><span class="token punctuation">)</span>$    <span class="token comment" spellcheck="true">// 复制图片</span>    clipboard<span class="token punctuation">.</span><span class="token function">writeImage</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 粘贴图片</span>    <span class="token keyword">let</span> imgSrc <span class="token operator">=</span> clipboard<span class="token punctuation">.</span><span class="token function">readImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// base64图片</span>    <span class="token comment" spellcheck="true">// 显示到页面上</span>    <span class="token keyword">let</span> imgDom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    imgDom<span class="token punctuation">.</span>src <span class="token operator">=</span> imgSrc$    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>imgDom<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十三、结合electron-vue"><a href="#十三、结合electron-vue" class="headerlink" title="十三、结合electron-vue"></a>十三、结合electron-vue</h2><h3 id="1-electron-vue-的使用"><a href="#1-electron-vue-的使用" class="headerlink" title="1 electron-vue 的使用"></a>1 electron-vue 的使用</h3><p><strong>1. electron-vue 的一些资源</strong></p><blockquote><p><a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">https://github.com/SimulatedGREG/electron-vue</a></p></blockquote><p><code>Electron-vue</code> 文档 <a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn" target="_blank" rel="noopener">https://simulatedgreg.gitbooks.io/electron-vue/content/cn</a></p><p><strong>2. electron-vue 环境搭建、创建项目</strong></p><pre class="line-numbers language-js"><code class="language-js">npm install <span class="token operator">-</span>g vue<span class="token operator">-</span>clivue init simulatedgreg<span class="token operator">/</span>electron<span class="token operator">-</span>vue my<span class="token operator">-</span>projectcd my<span class="token operator">-</span>projectyarn # or npm installyarn run dev # or npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. electron-vue 目录结构分析</strong></p><p><img src="https://pic.lixl.cn/2020/80.png" alt="img"></p><h3 id="2-electron-vue-中使用-sass-ElementUi"><a href="#2-electron-vue-中使用-sass-ElementUi" class="headerlink" title="2 electron-vue 中使用 sass/ElementUi"></a>2 electron-vue 中使用 sass/ElementUi</h3><p><strong>1. electron-vue UI 框架 ElementUi 的使用</strong></p><blockquote><p><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a></p></blockquote><p><strong>2. electron-vue 中使用 sass</strong></p><ul><li><a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/using_pre-processors.html" target="_blank" rel="noopener">electron-vue 中使用 sass</a></li></ul><pre class="line-numbers language-js"><code class="language-js"># 安装 sass<span class="token operator">-</span>loader<span class="token punctuation">:</span>npm install <span class="token operator">--</span>save<span class="token operator">-</span>dev sass<span class="token operator">-</span>loader node<span class="token operator">-</span>sass<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>vue 文件中修改 style 为如下代码<span class="token punctuation">:</span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>style lang<span class="token operator">=</span><span class="token string">"scss"</span><span class="token operator">></span>$    body <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* SCSS */</span>$    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-electron-vue-中隐藏顶部菜单隐藏"><a href="#3-electron-vue-中隐藏顶部菜单隐藏" class="headerlink" title="3 electron-vue 中隐藏顶部菜单隐藏"></a>3 electron-vue 中隐藏顶部菜单隐藏</h3><blockquote><p>electron-vue 中隐藏顶部菜单隐藏顶部最大化、最小化、关闭按钮 自定最大化、最小化 、关闭按钮</p></blockquote><p><strong>1. electron-vue 中隐藏顶部菜单</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/index.js</span>mainWindow<span class="token punctuation">.</span><span class="token function">setMenu</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2. electron-vue 中隐藏关闭 最大化 最小化按钮</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/index.js</span>mainWindow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    height<span class="token punctuation">:</span> <span class="token number">620</span><span class="token punctuation">,</span>    useContentSize<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    width<span class="token punctuation">:</span> <span class="token number">1280</span><span class="token punctuation">,</span>    frame<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">/*去掉顶部导航 去掉关闭按钮 最大化最小化按钮*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3 .electron-vue 自定义关闭/最大化最小化按钮</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 注意在mac下不需要监听窗口最大最小化、以为系统默认支持，这个只是针对windows平台</span>ipc<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-min'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mainWindow<span class="token punctuation">.</span><span class="token function">minimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//登录窗口最大化$</span>ipc<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-max'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mainWindow<span class="token punctuation">.</span><span class="token function">isMaximized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mainWindow<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        mainWindow<span class="token punctuation">.</span><span class="token function">maximize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>$ipc<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-close'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mainWindow<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. electron-vue 自定义导航可拖拽</strong></p><ul><li>可拖拽的 <code>css</code>: <code>-webkit-app-region: drag;</code></li><li>不可拖拽的 <code>css</code>: <code>-webkit-app-region: no-drag;</code></li></ul><h3 id="4-使用electron-vue开发舆情监控系统"><a href="#4-使用electron-vue开发舆情监控系统" class="headerlink" title="4 使用electron-vue开发舆情监控系统"></a>4 使用electron-vue开发舆情监控系统</h3><h4 id="4-1-配置开发环境"><a href="#4-1-配置开发环境" class="headerlink" title="4.1 配置开发环境"></a>4.1 配置开发环境</h4><p><strong>1. 项目搭建</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g vue-clivue init simulatedgreg/electron-vue my-project<span class="token function">cd</span> my-projectyarn <span class="token comment" spellcheck="true"># or npm install</span>yarn run dev <span class="token comment" spellcheck="true"># or npm run dev</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 安装一些依赖</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装 sass-loader:</span><span class="token function">npm</span> <span class="token function">install</span> --save-dev sass-loader node-sass<span class="token comment" spellcheck="true"># 安装elementUI、js-md5</span><span class="token function">npm</span> i element-ui  js-md5 -S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在<code>.electron-vue/webpack.renderer.config.js</code>中配置<code>sass-loader</code>就可以编写``sass`了</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">&lt;!--vue 文件中修改 style 为如下代码<span class="token pseudo-class">:--</span>>&lt;style lang="scss">$    body </span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* SCSS */</span>$    <span class="token punctuation">}</span>&lt;/style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-主进程配置"><a href="#4-2-主进程配置" class="headerlink" title="4.2 主进程配置"></a>4.2 主进程配置</h4><p><strong>1. <code>src/main/index.js</code></strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> createWindow <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 去掉顶部菜单</span>  mainWindow<span class="token punctuation">.</span><span class="token function">setMenu</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> $  <span class="token comment" spellcheck="true">// 菜单项</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./model/menu.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> $  <span class="token comment" spellcheck="true">// 系统托盘相关</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./model/tray.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. <code>src/main/menu.js</code>菜单配置</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> Menu<span class="token punctuation">,</span>ipcMain<span class="token punctuation">,</span>BrowserWindow<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右键菜单</span><span class="token keyword">const</span> contextMenuTemplate<span class="token operator">=</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'复制'</span><span class="token punctuation">,</span> role<span class="token punctuation">:</span> <span class="token string">'copy'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'黏贴'</span><span class="token punctuation">,</span> role<span class="token punctuation">:</span> <span class="token string">'paste'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>       $    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//分隔线</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'其他功能'</span><span class="token punctuation">,</span>    $        click<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">)</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> contextMenu<span class="token operator">=</span>Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>contextMenuTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'contextmenu'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    contextMenu<span class="token punctuation">.</span><span class="token function">popup</span><span class="token punctuation">(</span>BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. <code>src/main/tray.js</code>系统托盘配置</strong></p><blockquote><p>托盘点击监听事件只有在<code>windows</code>下才生效，<code>mac</code>系统默认支持</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> path<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span>app<span class="token punctuation">,</span>Menu<span class="token punctuation">,</span>BrowserWindow<span class="token punctuation">,</span>Tray<span class="token punctuation">,</span> shell<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建系统托盘</span>    <span class="token keyword">const</span> tray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tray</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__static<span class="token punctuation">,</span> <span class="token string">'favicon.png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//给托盘增加右键菜单</span>    <span class="token keyword">const</span> template<span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'设置'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span><span class="token string">'http://blog.poetries.top'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'帮助'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span><span class="token string">'http://blog.poetries.top/2019/01/06/electron-summary'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'关于'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span><span class="token string">'https://github.com/poetries/yuqing-monitor-electron'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'退出'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// BrowserWindow.getFocusedWindow().webContents().send('close-main-window');</span>                app<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           $            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> menu <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span><span class="token punctuation">;</span>    tray<span class="token punctuation">.</span><span class="token function">setContextMenu</span><span class="token punctuation">(</span>menu<span class="token punctuation">)</span><span class="token punctuation">;</span>    tray<span class="token punctuation">.</span><span class="token function">setToolTip</span><span class="token punctuation">(</span><span class="token string">'舆情监控系统'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//监听关闭事件隐藏到系统托盘</span>    <span class="token comment" spellcheck="true">// 这里需要注意：在window中才生效，mac下系统默认支持</span>    <span class="token comment" spellcheck="true">// var win = BrowserWindow.getFocusedWindow();</span>    <span class="token comment" spellcheck="true">// win.on('close',(e)=>{</span>    <span class="token comment" spellcheck="true">//         if(!win.isFocused()){</span>    <span class="token comment" spellcheck="true">//             win=null;</span>    <span class="token comment" spellcheck="true">//         }else{</span>    <span class="token comment" spellcheck="true">//             e.preventDefault();  </span><span class="token comment" spellcheck="true">/*阻止应用退出*/</span>    <span class="token comment" spellcheck="true">//             win.hide(); </span><span class="token comment" spellcheck="true">/*隐藏当前窗口*/</span>    <span class="token comment" spellcheck="true">//         }      $</span>    <span class="token comment" spellcheck="true">// })</span>    <span class="token comment" spellcheck="true">// //监听托盘的双击事件</span>    <span class="token comment" spellcheck="true">// tray.on('double-click',()=>{              $</span>    <span class="token comment" spellcheck="true">//     win.show();</span>    <span class="token comment" spellcheck="true">// })</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. <code>src/main/shortCut.js</code>快捷键配置</strong></p><p>在<code>src/main/index.js</code>中引入（<code>require(&#39;src/main/shortCut.js&#39;)</code>）即可，不需要放到<code>app</code>监控中</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token punctuation">{</span>globalShortcut<span class="token punctuation">,</span> app<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'ready'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注册全局快捷键</span>    globalShortcut<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 检测快捷键是否注册成功 true是注册成功</span>    <span class="token keyword">let</span> isRegister <span class="token operator">=</span> globalShortcut<span class="token punctuation">.</span><span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isRegister<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 退出的时候取消全局快捷键</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'will-quit'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    globalShortcut<span class="token punctuation">.</span><span class="token function">unregister</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-渲染进程配置"><a href="#4-3-渲染进程配置" class="headerlink" title="4.3 渲染进程配置"></a>4.3 渲染进程配置</h4><p><strong>1. src/render/main.js配置</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token keyword">import</span> ElementUI <span class="token keyword">from</span> <span class="token string">'element-ui'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'element-ui/lib/theme-chalk/index.css'</span><span class="token punctuation">;</span><span class="token keyword">import</span> VueHighcharts <span class="token keyword">from</span> <span class="token string">'vue-highcharts'</span><span class="token punctuation">;</span><span class="token keyword">import</span> VueSocketIO <span class="token keyword">from</span> <span class="token string">'vue-socket.io'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>ElementUI<span class="token punctuation">)</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueHighcharts<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入socket.io配置连接</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VueSocketIO</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  debug<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  connection<span class="token punctuation">:</span> <span class="token string">'http://118.123.14.36:3000'</span><span class="token punctuation">,</span>  vuex<span class="token punctuation">:</span> <span class="token punctuation">{</span>      store<span class="token punctuation">,</span>      actionPrefix<span class="token punctuation">:</span> <span class="token string">'SOCKET_'</span><span class="token punctuation">,</span>      mutationPrefix<span class="token punctuation">:</span> <span class="token string">'SOCKET_'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>IS_WEB<span class="token punctuation">)</span> Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue-electron'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Vue<span class="token punctuation">.</span>http <span class="token operator">=</span> Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$http <span class="token operator">=</span> axiosVue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment" spellcheck="true">/* eslint-disable no-new */</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span> App <span class="token punctuation">}</span><span class="token punctuation">,</span>  router<span class="token punctuation">,</span>  store<span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;App/>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 路由配置src/renderer/router/index.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/Home'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/report'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'report'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/Report'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/negativereport'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'negativereport'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/NegativeReport'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/positivereport'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'positivereport'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/PositiveReport'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/keyword'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'keyword'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/KeyWord'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/alarm'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'alarm'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/Alarm'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/msg'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'msg'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/Msg'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span>      redirect<span class="token punctuation">:</span> <span class="token string">'/home'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://github.com/poetries/yuqing-monitor-electron/tree/master/src/renderer" target="_blank" rel="noopener">其他页面更多详情Github</a></p></blockquote><p><strong>3. 在渲染进程中使用主进程方式</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// electron挂载到了vue实例上 $electron</span><span class="token keyword">this</span><span class="token punctuation">.</span>$electron<span class="token punctuation">.</span>shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-4-多平台打包"><a href="#4-4-多平台打包" class="headerlink" title="4.4 多平台打包"></a>4.4 多平台打包</h4><blockquote><p>需要注意的是打包<code>mac</code>版本在<code>mac</code>系统上打包，打包<code>window</code>则在<code>windows</code>上打包，可以避免很多问题</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在不同平台上执行即可打包应用</span><span class="token function">npm</span> run build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-4-1-打包介绍"><a href="#4-4-1-打包介绍" class="headerlink" title="4.4.1 打包介绍"></a>4.4.1 打包介绍</h5><blockquote><p><a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/using-electron-packager.html" target="_blank" rel="noopener">electron-vue打包文档</a></p></blockquote><p><strong>1. electron 中构建应用最常用的模块</strong></p><ul><li><code>electron-packager</code></li><li><code>electron-builder</code></li></ul><blockquote><p><code>electron-packager</code> 和 <code>electron-builder</code>在自己单独创建的应用用也可以完成打包功 能。但是由于配置太复杂所以我们不建议单独配置</p></blockquote><p><strong>2. electron-forge</strong></p><blockquote><p><a href="https://github.com/electron-userland/electron-forge" target="_blank" rel="noopener">https://github.com/electron-userland/electron-forge</a></p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">electron-forge package$electron-forge <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3. electron-vue中的打包方式</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># https://simulatedgreg.gitbooks.io/electron-vue/content/cn/using-electron-packager. html</span><span class="token comment" spellcheck="true"># 之需要执行一条命令</span><span class="token function">npm</span> run build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="4-4-2-修改应用信息"><a href="#4-4-2-修改应用信息" class="headerlink" title="4.4.2 修改应用信息"></a>4.4.2 修改应用信息</h5><p><strong>1. 修改package.json</strong></p><p><img src="https://pic.lixl.cn/2020/81.png" alt="img"></p><p><strong>2. 修改src/index.ejs标题信息</strong></p><p><strong>3. 修改build/icons图标</strong></p><h5 id="4-4-3-打包遇到的问题"><a href="#4-4-3-打包遇到的问题" class="headerlink" title="4.4.3 打包遇到的问题"></a>4.4.3 打包遇到的问题</h5><p><strong>1. 创建应用托盘的时候可能会遇到错误</strong></p><ul><li>把托盘图片放在根目录<code>static</code>里面，然后注意下面写法。</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> tray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tray</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__static<span class="token punctuation">,</span><span class="token string">'favicon.ico'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果托盘路径没有问题，还是包托盘相关错误的话，把托盘对应的图片换成<code>.png</code> 格式重试</li></ul><p><strong>2. 模块问题可能会遇到的错误</strong></p><p><img src="https://pic.lixl.cn/2020/82.png" alt="img"></p><p><img src="https://pic.lixl.cn/2020/83.png" alt="img"></p><p><strong>解决办法</strong></p><ul><li>删掉 <code>node_modules</code> 然后重新用 <code>npm install</code> 安装依赖</li><li>用 <code>yarn</code> 来安装模块</li><li>用手机创建一个热点电脑连上热点重试</li></ul><blockquote><p>最后执行<code>yarn run build</code>即可</p></blockquote><p><img src="https://pic.lixl.cn/2020/84.png" alt="img"></p><blockquote><p>项目源码 <a href="https://github.com/poetries/yuqing-monitor-electron" target="_blank" rel="noopener">https://github.com/poetries/yuqing-monitor-electron</a></p></blockquote><h2 id="十四、更多参考"><a href="#十四、更多参考" class="headerlink" title="十四、更多参考"></a>十四、更多参考</h2><ul><li><a href="https://www.electronjs.org/docs" target="_blank" rel="noopener">electron官方文档</a></li><li><a href="http://blog.poetries.top/2019/01/06/electron-summary/" target="_blank" rel="noopener">Electron构建跨平台应用mac/windows/linux</a></li><li><a href="https://github.com/poetries/electron-wiki" target="_blank" rel="noopener">electron学习资料整理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea常用快捷键Mac版</title>
      <link href="/2020/020459974.html"/>
      <url>/2020/020459974.html</url>
      
        <content type="html"><![CDATA[<h3 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h3><ul><li><code>⌘</code> Command</li><li><code>⇧</code> Shift</li><li><code>⌥</code> Option</li><li><code>⌃</code> Control</li><li><code>↩︎</code> Return/Enter</li><li><code>⌫</code> Delete</li><li><code>⌦</code> 向前删除键（Fn+Delete）</li><li><code>↑</code> 上箭头</li><li><code>↓</code> 下箭头</li><li><code>←</code> 左箭头</li><li><code>→</code> 右箭头</li><li><code>⇞</code> Page Up（Fn+↑）</li><li><code>⇟</code> Page Down（Fn+↓）</li><li><code>Home</code> Fn + ←</li><li><code>End</code> Fn + →</li><li><code>⇥</code> 右制表符（Tab键）</li><li><code>⇤</code> 左制表符（Shift+Tab）</li><li><code>⎋</code> Escape (Esc)</li></ul><h3 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a>Editing（编辑）</h3><ul><li><code>⌃ Space</code> 基本的代码补全（补全任何类、方法、变量）</li><li><code>⌃ ⇧ Space</code> 智能代码补全（过滤器方法列表和变量的预期类型）</li><li><code>⌘ ⇧ ↩</code> 自动结束代码，行末自动添加分号</li><li><code>⌘ P</code> 显示方法的参数信息</li><li><code>⌃ J, Mid. button click</code> 快速查看文档</li><li><code>⇧ F1</code> 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li><li><code>⌘ 鼠标放在代码上</code> 显示代码简要信息</li><li><code>⌘ F1</code> 在错误或警告处显示具体描述信息</li><li><code>⌘ N, ⌃↩, ⌃N</code> 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li><code>⌃ O</code> 覆盖方法（重写父类方法）</li><li><code>⌃ I</code> 实现方法（实现接口中的方法）</li><li><code>⌘ ⌥ T</code> 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）</li><li><code>⌘ /</code> 注释/取消注释与行注释</li><li><code>⌘ ⌥ /</code> 注释/取消注释与块注释</li><li><code>⌥ ↑</code> 连续选中代码块</li><li><code>⌥ ↓</code> 减少当前选中的代码块</li><li><code>⌃ ⇧ Q</code> 显示上下文信息</li><li><code>⌥ ↩</code> 显示意向动作和快速修复代码</li><li><code>⌘ ⌥ L</code> 格式化代码</li><li><code>⌃ ⌥ O</code> 优化import</li><li><code>⌃ ⌥ I</code> 自动缩进线</li><li><code>⇥ / ⇧⇥</code> 缩进代码 / 反缩进代码</li><li><code>⌘ X</code> 剪切当前行或选定的块到剪贴板</li><li><code>⌘ C</code> 复制当前行或选定的块到剪贴板</li><li><code>⌘ V</code> 从剪贴板粘贴</li><li><code>⌘ ⇧ V</code> 从最近的缓冲区粘贴</li><li><code>⌘ D</code> 复制当前行或选定的块</li><li><code>⌘ ⌫</code> 删除当前行或选定的块的行</li><li><code>⌃ ⇧ J</code> 智能的将代码拼接成一行</li><li><code>⌘ ↩</code> 智能的拆分拼接的行</li><li><code>⇧ ↩</code> 开始新的一行</li><li><code>⌘ ⇧ U</code> 大小写切换</li><li><code>⌘ ⇧ ] / ⌘ ⇧ [</code> 选择直到代码块结束/开始</li><li><code>⌥ ⌦</code> 删除到单词的末尾（⌦键为Fn+Delete）</li><li><code>⌥ ⌫</code> 删除到单词的开头</li><li><code>⌘ + / ⌘ -</code> 展开 / 折叠代码块</li><li><code>⌘ ⇧ +</code> 展开所有代码块</li><li><code>⌘ ⇧ -</code> 折叠所有代码块</li><li><code>⌘ W</code> 关闭活动的编辑器选项卡</li></ul><h3 id="Search-Replace（查询-替换）"><a href="#Search-Replace（查询-替换）" class="headerlink" title="Search/Replace（查询/替换）"></a>Search/Replace（查询/替换）</h3><ul><li><code>Double ⇧</code> 查询任何东西</li><li><code>⌘ F</code> 文件内查找</li><li><code>⌘ G</code> 查找模式下，向下查找</li><li><code>⌘ ⇧ G</code> 查找模式下，向上查找</li><li><code>⌘ R</code> 文件内替换</li><li><code>⌘ ⇧ F</code> 全局查找（根据路径）</li><li><code>⌘ ⇧ R</code> 全局替换（根据路径）</li><li><code>⌘ ⇧ S</code> 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</li><li><code>⌘ ⇧ M</code> 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</li></ul><h3 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h3><ul><li><code>⌥ F7 / ⌘ F7</code> 在文件中查找用法 / 在类中查找用法</li><li><code>⌘ ⇧ F7</code> 在文件中突出显示的用法</li><li><code>⌘ ⌥ F7</code> 显示用法</li></ul><h3 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h3><ul><li><code>⌘ F9</code> 编译Project</li><li><code>⌘ ⇧ F9</code> 编译选择的文件、包或模块</li><li><code>⌃ ⌥ R</code> 弹出 Run 的可选择菜单</li><li><code>⌃ ⌥ D</code> 弹出 Debug 的可选择菜单</li><li><code>⌃ R</code> 运行</li><li><code>⌃ D</code> 调试</li><li><code>⌃ ⇧ R, ⌃ ⇧ D</code> 从编辑器运行上下文环境配置</li></ul><h3 id="Debugging（调试）"><a href="#Debugging（调试）" class="headerlink" title="Debugging（调试）"></a>Debugging（调试）</h3><ul><li><code>F8</code> 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li><code>F7</code> 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</li><li><code>⇧ F7</code> 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</li><li><code>⇧ F8</code> 跳出</li><li><code>⌥ F9</code> 运行到光标处，如果光标前有其他断点会进入到该断点</li><li><code>⌥ F8</code> 计算表达式（可以更改变量值使其生效）</li><li><code>⌘ ⌥ R</code> 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</li><li><code>⌘ F8</code> 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</li><li><code>⌘ ⇧ F8</code> 查看断点信息</li></ul><h3 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h3><ul><li><code>⌘ O</code> 查找类文件</li><li><code>⌘ ⇧ O</code> 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠<code>/</code></li><li><code>⌘ ⌥ O</code> 前往指定的变量 / 方法</li><li><code>⌃ ← / ⌃ →</code> 左右切换打开的编辑tab页</li><li><code>F12</code> 返回到前一个工具窗口</li><li><code>⎋</code> 从工具窗口进入代码文件窗口</li><li><code>⇧ ⎋</code> 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li><code>⌘ ⇧ F4</code> 关闭活动run/messages/find/… tab</li><li><code>⌘ L</code> 在当前文件跳转到某一行的指定处</li><li><code>⌘ E</code> 显示最近打开的文件记录列表</li><li><code>⌘ ⌥ ← / ⌘ ⌥ →</code> 退回 / 前进到上一个操作的地方</li><li><code>⌘ ⇧ ⌫</code> 跳转到最后一个编辑的地方</li><li><code>⌥ F1</code> 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li><code>⌘ B / ⌘ 鼠标点击</code> 进入光标所在的方法/变量的接口或是定义处</li><li><code>⌘ ⌥ B</code> 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li><li><code>⌥ Space, ⌘ Y</code> 快速打开光标所在方法、类的定义</li><li><code>⌃ ⇧ B</code> 跳转到类型声明处</li><li><code>⌘ U</code> 前往当前光标所在方法的父类的方法 / 接口定义</li><li><code>⌃ ↓ / ⌃ ↑</code> 当前光标跳转到当前文件的前一个/后一个方法名位置</li><li><code>⌘ ] / ⌘ [</code> 移动光标到当前所在代码的花括号开始/结束位置</li><li><code>⌘ F12</code> 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li><li><code>⌃ H</code> 显示当前类的层次结构</li><li><code>⌘ ⇧ H</code> 显示方法层次结构</li><li><code>⌃ ⌥ H</code> 显示调用层次结构</li><li><code>F2 / ⇧ F2</code> 跳转到下一个/上一个突出错误或警告的位置</li><li><code>F4 / ⌘ ↓</code> 编辑/查看代码源</li><li><code>⌥ Home</code> 显示到当前文件的导航条</li><li><code>F3</code>选中文件/文件夹/代码行，添加/取消书签</li><li><code>⌥ F3</code> 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li><code>⌃0...⌃9</code> 定位到对应数值的书签位置</li><li><code>⌘ F3</code> 显示所有书签</li></ul><h3 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h3><ul><li><code>F5</code> 复制文件到指定目录</li><li><code>F6</code> 移动文件到指定目录</li><li><code>⌘ ⌫</code> 在文件上为安全删除文件，弹出确认框</li><li><code>⇧ F6</code> 重命名文件</li><li><code>⌘ F6</code> 更改签名</li><li><code>⌘ ⌥ N</code> 一致性</li><li><code>⌘ ⌥ M</code> 将选中的代码提取为方法</li><li><code>⌘ ⌥ V</code> 提取变量</li><li><code>⌘ ⌥ F</code> 提取字段</li><li><code>⌘ ⌥ C</code> 提取常量</li><li><code>⌘ ⌥ P</code> 提取参数</li></ul><h3 id="VCS-Local-History（版本控制-本地历史记录）"><a href="#VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="VCS/Local History（版本控制/本地历史记录）"></a>VCS/Local History（版本控制/本地历史记录）</h3><ul><li><code>⌘ K</code> 提交代码到版本控制器</li><li><code>⌘ T</code> 从版本控制器更新代码</li><li><code>⌥ ⇧ C</code> 查看最近的变更记录</li><li><code>⌃ C</code> 快速弹出版本控制器操作面板</li></ul><h3 id="Live-Templates（动态代码模板）"><a href="#Live-Templates（动态代码模板）" class="headerlink" title="Live Templates（动态代码模板）"></a>Live Templates（动态代码模板）</h3><ul><li><code>⌘ ⌥ J</code> 弹出模板选择窗口，将选定的代码使用动态模板包住</li><li><code>⌘ J</code> 插入自定义动态代码模板</li></ul><h3 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h3><ul><li><code>⌘1...⌘9</code> 打开相应编号的工具窗口</li><li><code>⌘ S</code> 保存所有</li><li><code>⌘ ⌥ Y</code> 同步、刷新</li><li><code>⌃ ⌘ F</code> 切换全屏模式</li><li><code>⌘ ⇧ F12</code> 切换最大化编辑器</li><li><code>⌥ ⇧ F</code> 添加到收藏夹</li><li><code>⌥ ⇧ I</code> 检查当前文件与当前的配置文件</li><li><code>⌘ ,</code> 打开IDEA系统设置</li><li><code>⌘ ;</code> 打开项目结构对话框</li><li><code>⌘ ⇧ A</code> 查找动作（可设置相关选项）</li><li><code>⌃ ⇥</code> 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）</li></ul><h3 id="Other（其它）"><a href="#Other（其它）" class="headerlink" title="Other（其它）"></a>Other（其它）</h3><ul><li><code>⌘ ⇧ 8</code> 竖编辑模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode常用快捷键Mac版</title>
      <link href="/2020/020253487.html"/>
      <url>/2020/020253487.html</url>
      
        <content type="html"><![CDATA[<h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><ul><li>Command + K + Command + S 打开快捷键查找/编辑页</li><li>Command + Shift + P / F1 显示命令面板</li><li>Command + P 快速打开文件</li><li>Command + Shift + N 打开新窗口</li><li>Command + W 关闭窗 口</li></ul><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li>Command + X 剪切（未选中文本的情况下，剪切光标所在行）</li><li>Command + C 复制（未选中文本的情况下，复制光标所在行）</li><li>Option + Up 向上移动行</li><li>Option + Down 向下移动行</li><li>Option + Shift + Up 向上复制行</li><li>Option + Shift + Down 向下复制行</li><li>Command + Shift + K 删除行</li><li>Command + Enter 下一行插入</li><li>Command + Shift + Enter 上一行插入</li><li>Command + Shift +  跳转到匹配的括号</li><li>Command + [ 减少缩进</li><li>Command + ] 增加缩进</li><li>Home 跳转至行首</li><li>End 跳转到行尾</li><li>Command + Up 跳转至文件开头</li><li>Command + Down 跳转至文件结尾</li><li>Ctrl + PgUp 按行向上滚动</li><li>Ctrl + PgDown 按行向下滚动</li><li>Command + PgUp 按屏向上滚动</li><li>Command + PgDown 按屏向下滚动</li><li>Command + Shift + [ 折叠代码块</li><li>Command + Shift + ] 展开代码块</li><li>Command + K Command + [ 折叠全部子代码块</li><li>Command + K Command + ] 展开全部子代码块</li><li>Command + K Command + 0 折叠全部代码块</li><li>Command + K Command + J 展开全部代码块</li><li>Command + K Command + C 添加行注释</li><li>Command + K Command + U 移除行注释</li><li>Command + / 添加、移除行注释</li><li>Option + Shift + A 添加、移除块注释</li><li>Option + Z 自动换行、取消自动换行</li></ul><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><ul><li>Option + 点击 插入多个光标</li><li>Command + Option + Up 向上插入光标</li><li>Command + Option + Down 向下插入光标</li><li>Command + U 撤销上一个光标操作</li><li>Option + Shift + I 在所选行的行尾插入光标</li><li>Command + I 选中当前行</li><li>Command + Shift + L 选中所有与当前选中内容相同部分</li><li>Command + F2 选中所有与当前选中单词相同的单词</li><li>Command + Ctrl + Shift + Left 折叠选中</li><li>Command + Ctrl + Shift + Right 展开选中</li><li>Alt + Shift + 拖动鼠标 选中代码块</li><li>Command + Shift + Option + Up 列选择 向上</li><li>Command + Shift + Option + Down 列选择 向下</li><li>Command + Shift + Option + Left 列选择 向左</li><li>Command + Shift + Option + Right 列选择 向右</li><li>Command + Shift + Option + PgUp 列选择 向上翻页</li><li>Command + Shift + Option + PgDown 列选择 向下翻页</li></ul><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><ul><li>Command + F 查找</li><li>Command + Option + F 替换</li><li>Command + G 查找下一个</li><li>Command + Shift + G 查找上一个</li><li>Option + Enter 选中所有匹配项</li><li>Command + D 向下选中相同内容</li><li>Command + K Command + D 移除前一个向下选中相同内容</li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul><li>Ctrl + Space 打开建议</li><li>Command + Shift + Space 参数提示</li><li>Tab Emmet插件缩写补全</li><li>Option + Shift + F 格式化</li><li>Command + K Command + F 格式化选中内容</li><li>F12 跳转到声明位置</li><li>Option + F12 查看具体声明内容</li><li>Command + K F12 分屏查看具体声明内容</li><li>Command + . 快速修复</li><li>Shift + F12 显示引用</li><li>F2 重命名符号</li><li>Command + Shift + . 替换为上一个值</li><li>Command + Shift + , 替换为下一个值</li><li>Command + K Command + X 删除行尾多余空格</li><li>Command + K M 更改文件语言</li></ul><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul><li>Command + T 显示所有符号</li><li>Ctrl + G 跳转至某行</li><li>Command + P 跳转到某个文件</li><li>Command + Shift + O 跳转到某个符号</li><li>Command + Shift + M 打开问题面板</li><li>F8 下一个错误或警告位置</li><li>Shift + F8 上一个错误或警告位置</li><li>Ctrl + Shift + Tab 编辑器历史记录</li><li>Ctrl + - 后退</li><li>Ctrl + Shift + - 前进</li><li>Ctrl + Shift + M Tab 切换焦点</li></ul><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><ul><li>Shift + Alt + 鼠标左键 列编辑模式</li><li>Command + W 关闭编辑器</li><li>Command + K F 关闭文件夹</li><li>Command +  编辑器分屏</li><li>Command + 1 切换到第一分组</li><li>Command + 2 切换到第二分组</li><li>Command + 3 切换到第三分组</li><li>Command + K Command + Left 切换到上一分组</li><li>Command + K Command + Right 切换到下一分组</li><li>Command + K Command + Shift + Left 左移编辑器</li><li>Command + K Command + Shift + Right 右移编辑器</li><li>Command + K Left 激活左侧编辑组</li><li>Command + K Right 激活右侧编辑组</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li>Command + N 新建文件</li><li>Command + O 打开文件</li><li>Command + S 保存文件</li><li>Command + Shift + S 另存为</li><li>Command + Option + S 全部保存</li><li>Command + W 关闭</li><li>Command + K Command + W 全部关闭</li><li>Command + Shift + T 重新打开被关闭的编辑器</li><li>Command + K Enter 保持打开</li><li>Ctrl + Tab 打开下一个</li><li>Ctrl + Shift + Tab 打开上一个</li><li>Command + K P 复制当前文件路径</li><li>Command + K R 在资源管理器中查看当前文件</li><li>Command + K O 新窗口打开当前文件</li></ul><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><ul><li>Command + Ctrl + F 全屏、退出全屏</li><li>Command + Option + 1 切换编辑器分屏方式（横、竖）</li><li>Command + + 放大</li><li>Command + - 缩小</li><li>Command + B 显示、隐藏侧边栏</li><li>Command + Shift + E 显示资源管理器 或 切换焦点</li><li>Command + Shift + F 显示搜索框</li><li>Ctrl + Shift + G 显示Git面板</li><li>Command + Shift + D 显示调试面板</li><li>Command + Shift + X 显示插件面板</li><li>Command + Shift + H 全局搜索替换</li><li>Command + Shift + J 显示、隐藏高级搜索</li><li>Command + Shift + C 打开新终端</li><li>Command + Shift + U 显示输出面板</li><li>Command + Shift + V Markdown预览窗口</li><li>Command + K V 分屏显示 Markdown预览窗口</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul><li>F9 设置 或 取消断点</li><li>F5 开始 或 继续</li><li>F11 进入</li><li>Shift + F11 跳出</li><li>F10 跳过</li><li>Command + K Command + I 显示悬停信息</li></ul><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><ul><li>Ctrl + ` 显示/关闭终端</li><li>Command + Up 向上滚动</li><li>Command + Down 向下滚动</li><li>PgUp 向上翻页</li><li>PgDown 向下翻页</li><li>Command + Home 滚动到顶部</li><li>Command + End 滚动到底部</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 必知必会（安装配置、应用实例及同步控制）</title>
      <link href="/2020/011231581.html"/>
      <url>/2020/011231581.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Node-js简介"><a href="#一、Node-js简介" class="headerlink" title="一、Node.js简介"></a>一、Node.js简介</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。于2009年由Google Brain团队的软件工程师Ryan Dahl发起创建，2015年后正式被<a href="https://foundation.nodejs.org/" target="_blank" rel="noopener">NodeJS基金会</a>接管。</p><h3 id="NodeJS-架构"><a href="#NodeJS-架构" class="headerlink" title="NodeJS 架构"></a>NodeJS 架构</h3><p><img src="https://pic.lixl.cn/2019/20200113000457.png/w1280" alt="Node.js架构"></p><p>Node使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p><p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p><p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）。在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li>Node.js官网：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></li><li>版本管理工具nvm：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a></li><li>包管理工具npm：<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></li><li>npm中文文档：<a href="https://www.npmjs.cn/" target="_blank" rel="noopener">https://www.npmjs.cn/</a></li><li>国内的 npm 镜像源：<a href="http://cnpmjs.org/" target="_blank" rel="noopener">http://cnpmjs.org/</a></li><li>中文社区：<a href="https://cnodejs.org/" target="_blank" rel="noopener">https://cnodejs.org/</a></li></ul><h2 id="二、安装配置"><a href="#二、安装配置" class="headerlink" title="二、安装配置"></a>二、安装配置</h2><p>建议使用nvm来进行node版本管理，它会安装相应版本的npm。</p><h3 id="安装nvm及Node-js"><a href="#安装nvm及Node-js" class="headerlink" title="安装nvm及Node.js"></a>安装nvm及Node.js</h3><p>nvm全名node.js version management，顾名思义是一个nodejs的版本管理工具。通过它可以安装和切换不同版本的nodejs。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装nvm（ 升级nvm重新执行此命令）:</span>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh <span class="token operator">|</span> <span class="token function">bash</span><span class="token comment" spellcheck="true"># 列出所有可以安装的node版本号</span>nvm ls-remote<span class="token comment" spellcheck="true"># 安装指定版本号的node</span>nvm <span class="token function">install</span> v12.4.1<span class="token comment" spellcheck="true"># 设置 nodejs 默认版本</span>nvm <span class="token function">alias</span> default 12.4.1<span class="token comment" spellcheck="true"># 切换node的版本</span>nvm use v10.15.3<span class="token comment" spellcheck="true"># 当前node版本</span>nvm currentnode -v<span class="token comment" spellcheck="true"># 列出所有已经安装的node版本</span>nvm <span class="token function">ls</span><span class="token comment" spellcheck="true"># 卸载已安装的node版本</span>nvm uninstall v6.9.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm 是世界上最大的软件注册中心，随同NodeJS一起安装，来自全球各地的开源开发人员使用 npm 来共享和复用软件包。npm 由三个独立的部分组成：</p><ul><li>网站： <a href="https://npmjs.com" target="_blank" rel="noopener">https://npmjs.com</a> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</li><li>注册表（registry）：是一个巨大的数据库，保存了每个包（package）的信息。</li><li>命令行工具 (CLI)：通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 npm 版本</span><span class="token function">npm</span> -v<span class="token comment" spellcheck="true"># 更新npm版本</span><span class="token function">npm</span> <span class="token function">install</span> npm@latest -g<span class="token comment" spellcheck="true"># 搜索模块</span><span class="token function">npm</span> search hexo<span class="token comment" spellcheck="true"># 安装依赖包</span><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&lt;</span>Module Name<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span> hexo      <span class="token comment" spellcheck="true"># 本地安装 hexo</span><span class="token function">npm</span> <span class="token function">install</span> hexo -g   <span class="token comment" spellcheck="true"># 全局安装 hexo</span><span class="token comment" spellcheck="true"># 查看所有全局安装的模块</span><span class="token function">npm</span> list -g<span class="token comment" spellcheck="true"># 查看某个模块</span><span class="token function">npm</span> list hexo<span class="token comment" spellcheck="true"># 卸载模块</span><span class="token function">npm</span> uninstall hexo<span class="token comment" spellcheck="true"># 卸载后，查看包是否还存在</span><span class="token function">npm</span> <span class="token function">ls</span><span class="token comment" spellcheck="true"># 更新某个模块</span><span class="token function">npm</span> update hexo<span class="token comment" spellcheck="true"># 创建模块</span><span class="token function">npm</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个版本的 Node 都自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 ~/.nvm/versions/node/${version}/lib/node_modules 这样的目录。</p><p>运行下面这个命令，可以从特定版本导入之前安装过的 npm 包到我们将要安装的新版本 Node 中：</p><pre class="line-numbers language-bash"><code class="language-bash">nvm <span class="token function">install</span> v12.16.1 --reinstall-packages-from<span class="token operator">=</span>v10.15.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、Node特点"><a href="#三、Node特点" class="headerlink" title="三、Node特点"></a>三、Node特点</h2><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>在Node中，绝大多数的操作都以异步的方式进行调用。在底层构建了很多异步I/O的API，从文件读取到网络请求等，均是如此。这样的意义在于，在Node中，我们可以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。在编程模型上可以极大提升效率。<br>下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时：</p><pre class="line-numbers language-js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件1完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path2'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件2完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对于同步I/O而言，它们的耗时是两个任务的耗时之和。这里异步带来的优势是显而易见的。</p><h3 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h3><p>在JavaScript中，函数被作为第一等公民来对待，可以将函数作为对象传递给方法作为实参进行调用。Node将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。</p><p>下面的例子展示的是Ajax异步提交的服务器端处理过程。Node创建一个Web服务器，并侦听8080端口。对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> quertstring <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> postData <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>  req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听请求的data事件</span>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">{</span>    postData <span class="token operator">+</span><span class="token operator">=</span> chunk<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听请求的end事件</span>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器启动完成，监听端口：8080'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相应地，我们在前端为Ajax请求绑定了success事件，在发出请求后，只需关心请求成功时执行相应的业务逻辑即可，相关代码如下：</p><pre class="line-numbers language-js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token string">'url'</span><span class="token punctuation">:</span> <span class="token string">'/url'</span><span class="token punctuation">,</span>  <span class="token string">'method'</span><span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>  <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">'success'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// success事件</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与其他的Web后端编程语言相比，Node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的。代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍。</p><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。<br>同样，单线程也有它自身的弱点。Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：<code>child_process</code>。子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。</p><h3 id="擅长I-O密集型的应用"><a href="#擅长I-O密集型的应用" class="headerlink" title="擅长I/O密集型的应用"></a>擅长I/O密集型的应用</h3><p>通常，说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p><h3 id="性能不俗"><a href="#性能不俗" class="headerlink" title="性能不俗"></a>性能不俗</h3><p>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU，I/O阻塞造成的性能浪费远比CPU的影响小。</p><p><img src="https://pic.lixl.cn/2019/20200113165953.png/w1280" alt="计算斐波那契数列的耗时排行"></p><h2 id="四、Node-js常用模块"><a href="#四、Node-js常用模块" class="headerlink" title="四、Node.js常用模块"></a>四、Node.js常用模块</h2><p>更多模块详细介绍，可查阅官方文档: <a href="https://nodejs.org/api/" target="_blank" rel="noopener">https://nodejs.org/api/</a></p><h3 id="Global模块"><a href="#Global模块" class="headerlink" title="Global模块"></a>Global模块</h3><p>浏览器JavaScript当中window是全局对象，NodeJS中全局对象是global，global最根本的作用是作为全局变量的宿主（即所有的全局变量都是global对象的属性），因此在所有模块中都可以直接使用而无需包含。</p><h3 id="Process模块"><a href="#Process模块" class="headerlink" title="Process模块"></a>Process模块</h3><p>process是全局变量(即global对象的属性)，用于描述当前NodeJS进程状态。</p><h3 id="Console模块"><a href="#Console模块" class="headerlink" title="Console模块"></a>Console模块</h3><p>console用于提供控制台标准输出。</p><p><code>console.log()</code>：向标准输出流打印字符并以换行符结束(<em>如果只有1个参数，则输出该参数的字符串形式；如果有2个参数，则以类似于C语言<code>printf()</code>的格式化输出</em>)。</p><p><code>console.error()</code>：与<code>console.log()</code>的用法相同，只是向标准错误流进行输出。</p><p><code>console.trace()</code>：向标准错误流输出当前的调用栈:</p><pre class="line-numbers language-bash"><code class="language-bash">$ node app.jsTrace    at Object.<span class="token operator">&lt;</span>anonymous<span class="token operator">></span> <span class="token punctuation">(</span>/workspace/app.js:1:71<span class="token punctuation">)</span>    at Module._compile <span class="token punctuation">(</span>module.js:643:30<span class="token punctuation">)</span>    at Object.Module._extensions<span class="token punctuation">..</span>js <span class="token punctuation">(</span>module.js:654:10<span class="token punctuation">)</span>    at Module.load <span class="token punctuation">(</span>module.js:556:32<span class="token punctuation">)</span>    at tryModuleLoad <span class="token punctuation">(</span>module.js:499:12<span class="token punctuation">)</span>    at Function.Module._load <span class="token punctuation">(</span>module.js:491:3<span class="token punctuation">)</span>    at Function.Module.runMain <span class="token punctuation">(</span>module.js:684:10<span class="token punctuation">)</span>    at startup <span class="token punctuation">(</span>bootstrap_node.js:187:16<span class="token punctuation">)</span>    at bootstrap_node.js:608:3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Util模块"><a href="#Util模块" class="headerlink" title="Util模块"></a>Util模块</h3><p>util提供常用函数集合，用于弥补核心JavaScript功能方面的不足。</p><h3 id="Events模块"><a href="#Events模块" class="headerlink" title="Events模块"></a>Events模块</h3><p><code>events</code>是NodeJS最重要的模块，因为NodeJS本身就是基于事件式的架构，该模块提供了唯一接口，所以堪称NodeJS事件编程的基石。<code>events</code>模块不仅用于与下层的事件循环交互，还几乎被所有的模块所依赖。</p><p><code>events</code>模块只提供1个<code>events.EventEmitter</code>对象，<code>EventEmitter</code>对象封装了事件发射和事件监听器。每个<code>EventEmitter</code>事件由1个事件名和若干参数组成，事件名是1个字符串。<code>EventEmitter</code>对每个事件支持若干监听器，事件发射时，注册至该事件的监听器依次被调用，事件参数将作为回调函数参数传递。</p><p>下面例子中，<code>emitter</code>为事件<code>targetEvent</code>注册2个事件监听器，然后发射<code>targetEvent</code>事件，结果2个事件监听器的回调函数被依次先后调用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> events <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"events"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> emitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">events<span class="token punctuation">.</span>EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"targetEvent"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"listener1"</span><span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"targetEvent"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"listener2"</span><span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>emitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">"targetEvent"</span><span class="token punctuation">,</span> <span class="token string">"Hank"</span><span class="token punctuation">,</span> <span class="token number">2018</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ node app.jslistener1 Hank 2018listener2 Hank 2018<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="EventEmitter常用API"><a href="#EventEmitter常用API" class="headerlink" title="EventEmitter常用API"></a>EventEmitter常用API</h4><ul><li><code>EventEmitter.on(event, listener)</code>：为指定事件注册监听器，接受1个字符串事件名event和1个回调函数listener。</li><li><code>EventEmitter.emit(event,[arg1],[arg2],[...])</code>：发射event事件，传递若干可选参数到事件监听器的参数列表。</li><li><code>EventEmitter.once(event, listener)</code>：为指定事件注册1个单次监听器，即该监听器最多只会触发一次，触发后立刻解除。</li><li><code>EventEmitter.removeListener(event, listener)</code>：移除指定事件的某个监听器，listener必须是该事件已经注册过的监听器。</li><li><code>EventEmitter.removeAllListeners([event])</code>：移除所有事件的所有监听器，如果指定event，则移除指定事件的所有监听器。</li></ul><h3 id="File-System模块"><a href="#File-System模块" class="headerlink" title="File System模块"></a>File System模块</h3><p><code>fs</code>模块封装了文件操作，提供了文件读取、写入、更名、删除、遍历、链接等POSIX文件系统操作，该模块中所有操作都提供了异步和同步2个版本。</p><p><code>fs.readFile(filename,[encoding],[callback(err,data)])</code>用于读取文件，第1个参数<code>filename</code>表示要读取的文件名。第2个参数<code>encoding</code>表示文件的字符编码，第3个参数<code>callback</code>是回调函数，用于接收文件内容。</p><p>回调函数提供<code>err</code>和<code>data</code>两个参数，<code>err</code>表示有无错误发生，<code>data</code>是文件内容。如果指定<code>encoding</code>，<code>data</code>将是1个解析后的字符串，否则<code>data</code>将会是以<code>Buffe</code>r`形式表示的二进制数据。</p><h4 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync()"></a>fs.readFileSync()</h4><p>NodeJS提供的<code>fs.readFileSync()</code>函数是<code>readFile()</code>的同步版本，两者接受的参数相同，读取到的文件内容会以函数返回值形式返回。如果有错误发生<code>fs</code>将会抛出异常，需要使用<code>try...catch</code>捕捉并处理异常。</p><blockquote><p>与同步I/O函数不同，NodeJS中异步函数大多没有返回值。</p></blockquote><h4 id="fs-open"><a href="#fs-open" class="headerlink" title="fs.open()"></a>fs.open()</h4><p><code>fs.open(path,flags,[mode],[callback(err,fd)])</code>封装了POSIX的<code>open()</code>函数，与C语言标准库中<code>fopen()</code>函数类似。该函数接受2个必选参数，第1个参数<code>path</code>为文件路径，第2个参数<code>flags</code>代表文件打开模式，第3个参数<code>mode</code>用于创建文件时给文件指定权限（<em>默认0666</em>），第4个参数是<strong>回调函数</strong>，函数中需要传递文件描述符<code>fd</code>。</p><h4 id="fs-read"><a href="#fs-read" class="headerlink" title="fs.read()"></a>fs.read()</h4><p><code>fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])</code>封装了POSIX的read函数，相比<code>fs.readFile()</code>提供了更底层的接口。</p><p><code>fs.read()</code>的功能是从指定的文件描述符fd中读取数据并写入<code>buffer</code>指向的缓冲区对象。<code>offset</code>是<code>buffer</code>的写入偏移量。<code>length</code>是要从文件中读取的字节数。<code>position</code>是文件读取的起始位置，如果<code>position</code>的值为<code>null</code>，则会从当前文件指针的位置读取。回调函数传递<code>bytesRead</code>和<code>buffer</code>，分别表示读取的<strong>字节数</strong>和<strong>缓冲区对象</strong>。</p><h3 id="Http模块"><a href="#Http模块" class="headerlink" title="Http模块"></a>Http模块</h3><p>NodeJS标准库提供的<code>http</code>模块封装了一个高效的HTTP服务器<code>http.Server</code>和一个简易的HTTP客户端<code>http.request</code>。</p><p><code>http</code>模块中的HTTP服务器对象，核心由NodeJS底层依靠C++实现，接口使用JavaScript封装，兼顾了高性能与简易性。</p><h2 id="五、创建Node-js应用"><a href="#五、创建Node-js应用" class="headerlink" title="五、创建Node.js应用"></a>五、创建Node.js应用</h2><h3 id="使用Node创建http服务器"><a href="#使用Node创建http服务器" class="headerlink" title="使用Node创建http服务器"></a>使用Node创建http服务器</h3><p>使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> hostname <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">;</span><span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 终端打印如下信息</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Server running at http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hostname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>port<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。使用 <strong>node</strong> 命令执行以上的代码：</p><pre class="line-numbers language-js"><code class="language-js">node server<span class="token punctuation">.</span>jsServer running at http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开浏览器访问 <code>http://127.0.0.1:8080/</code>，会看到一个写着 “Hello World”的网页。</p><h3 id="web框架express简单使用"><a href="#web框架express简单使用" class="headerlink" title="web框架express简单使用"></a>web框架express简单使用</h3><p>express 是 Node应用最广泛的快速、开放、极简主义 web 框架，现在是 4.x 版本。官方提供了应用程序生成器工具 express-generator 可以快速创建应用程序骨架。安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> express --save<span class="token function">npm</span> <span class="token function">install</span> express-generator -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建名称为 <em>ExpressDemo</em> 的 Express 应用。此应用将在当前目录下的 <em>ExpressDemo</em> 目录中创建，并且设置为使用 <a href="https://pugjs.org/" target="_blank" rel="noopener">Pug</a> 模板引擎：</p><pre class="line-numbers language-bash"><code class="language-bash">express --view<span class="token operator">=</span>pug ExpressDemo   create <span class="token keyword">:</span> ExpressDemo/   create <span class="token keyword">:</span> ExpressDemo/public/   create <span class="token keyword">:</span> ExpressDemo/public/javascripts/   create <span class="token keyword">:</span> ExpressDemo/public/images/   create <span class="token keyword">:</span> ExpressDemo/public/stylesheets/   create <span class="token keyword">:</span> ExpressDemo/public/stylesheets/style.css   create <span class="token keyword">:</span> ExpressDemo/routes/   create <span class="token keyword">:</span> ExpressDemo/routes/index.js   create <span class="token keyword">:</span> ExpressDemo/routes/users.js   create <span class="token keyword">:</span> ExpressDemo/views/   create <span class="token keyword">:</span> ExpressDemo/views/error.pug   create <span class="token keyword">:</span> ExpressDemo/views/index.pug   create <span class="token keyword">:</span> ExpressDemo/views/layout.pug   create <span class="token keyword">:</span> ExpressDemo/app.js   create <span class="token keyword">:</span> ExpressDemo/package.json   create <span class="token keyword">:</span> ExpressDemo/bin/   create <span class="token keyword">:</span> ExpressDemo/bin/www   change directory:     $ <span class="token function">cd</span> ExpressDemo   <span class="token function">install</span> dependencies:     $ <span class="token function">npm</span> <span class="token function">install</span>   run the app:     $ DEBUG<span class="token operator">=</span>expressdemo:* <span class="token function">npm</span> start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按提示安装依赖并启动。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> ExpressDemo<span class="token function">npm</span> <span class="token function">install</span>DEBUG<span class="token operator">=</span>expressdemo:* <span class="token function">npm</span> start  <span class="token comment" spellcheck="true"># MacOS</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在浏览器中打开 <code>http://localhost:3000/</code> 就可以看到这个应用了。</p><p>通过生成器创建的应用一般都有如下目录结构：</p><pre class="line-numbers language-bash"><code class="language-bash">tree -I <span class="token string">"node_modules"</span><span class="token keyword">.</span>├── app.js├── bin│   └── www├── package-lock.json├── package.json├── public│   ├── images│   ├── javascripts│   └── stylesheets│       └── style.css├── routes│   ├── index.js│   └── users.js└── views    ├── error.pug    ├── index.pug    └── layout.pug7 directories, 10 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、异步编程方案（Promise-amp-Async）"><a href="#六、异步编程方案（Promise-amp-Async）" class="headerlink" title="六、异步编程方案（Promise &amp; Async）"></a>六、异步编程方案（Promise &amp; Async）</h2><p>异步是Node得天独厚的特点和优势，但我们经常还是会需要解决同步执行的场景。如方法A执行完才可以执行方法B。如下面这个例子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果为:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>BA<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.12 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要输出结果为 <code>A B</code>，可以采取 <code>Promise</code> 或 <code>Async</code> 来实现。</p><h3 id="基于Promise实现同步控制"><a href="#基于Promise实现同步控制" class="headerlink" title="基于Promise实现同步控制"></a>基于Promise实现同步控制</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。ES6 原生提供了<code>Promise</code>对象，提供统一的 API，各种异步操作都可以用同样的方法进行处理。示例如下：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Err'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>AB<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.123 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以把 <code>Promise</code> 对象比喻为一个容器，里面有一个异步操作，<code>Promise</code> 容器只有在收到信号（resolve或者reject）时才会调用then方法。通过 <code>Promise.All</code>方法将多个Promise对象实例包装，生成并返回一个新的Promise实例，等执行完所有异步操作之后执行then方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node test.jsABend<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.122 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Promise-扩展信息"><a href="#Promise-扩展信息" class="headerlink" title="Promise 扩展信息"></a>Promise 扩展信息</h4><p><code>Promise</code> 构造函数接受一个函数作为参数，该函数两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 avaScript 引擎提供。<code>resolve</code> 函数在异步操作成功时用，其作用是将<code>Promise</code>对象的状态从“pending”变为resolved”，并将异步操作的结果作为参数传递出去；<code>reject函数在异步操作失败时调用，其作用是将</code>Promise`对象的状态从pending”变为“rejected”，并将异步操作报出的错误作为参传递出去。</p><p> <code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定resolved<code>状态和</code>rejected<code>状态的回调函数。</code>then<code>方法以接受两个回调函数作为参数，第一个回调函数是</code>Promise<code>对的状态变为</code>resolved<code>时调用，第二个回调函数（可选提供）是Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都受<code>Promise</code>对象传出的值作为参数。</p><p><img src="https://pic.lixl.cn/2020/20200308170211.png" alt="Promise状态转换图"></p><p> <code>Promise</code>对象有以下两个特点。</p><ul><li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就会一直保持不再改变,称为 resolved。</li></ul><p>下面是一个<code>Promise</code>对象的简单例子。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">'done.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//会立即执行</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`resolve result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`reject error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，<code>f1</code>方法返回一个<code>Promise</code>实例，表示一段时以后才会发生的结果。过了指定的时间（3000毫秒）以后，Promise<code>实例的状态为</code>resolved<code>，就会触发</code>then`方法定的回调函数。执行结果如下:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>Aresolve result: done.<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.175 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外，<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例。<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><blockquote><p>Promise也有一些缺点。首先是无法取消，一旦新建它就会立即执行，无法中途取消；其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段。</p></blockquote><h3 id="基于Async实现同步控制"><a href="#基于Async实现同步控制" class="headerlink" title="基于Async实现同步控制"></a>基于Async实现同步控制</h3><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。随着Node.js 8的发布，期待已久的async函数也在其中默认实现了。async 函数的实现原理，是将 Generator 函数和自动执行器，包装在一个函数里。</p><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变（除非遇到<code>return</code>语句或者抛出错误），再接着执行函数体内后面的语句。看下面这个例子:</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncF</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//前面的 `async` 关键字，表明该函数内部有异步操作。</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// return语句的返回值，会成为`then`方法回调函数的参数。</span><span class="token punctuation">}</span><span class="token function">asyncF</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>B      <span class="token comment" spellcheck="true">#立即输出</span>A      <span class="token comment" spellcheck="true">#立即输出</span>Hello  <span class="token comment" spellcheck="true">#3秒后输出</span>Cworld<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.165 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <code>async</code> 函数的<code>await</code>命令后面，可以是 Promise 对象或原始类型的值（数值、字符串和布尔值，但会自动转成立即 resolved 的 Promise 对象）。</p><p> <code>sync</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。如下面这个例子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'发生异常'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`resolve result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 执行结果：</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span> Error: 发生异常  at f <span class="token punctuation">(</span>/Users/lixl.cn/nodework/blog/test.js:4:9<span class="token punctuation">)</span>  at Object.<span class="token operator">&lt;</span>anonymous<span class="token operator">></span> <span class="token punctuation">(</span>/Users/lixl.cn/nodework/blog/test.js:7:1<span class="token punctuation">)</span>  at Module._compile <span class="token punctuation">(</span>internal/modules/cjs/loader.js:701:30<span class="token punctuation">)</span>  at Object.Module._extensions<span class="token punctuation">..</span>js <span class="token punctuation">(</span>internal/modules/cjs/loader.js:712:10<span class="token punctuation">)</span>  at Module.load <span class="token punctuation">(</span>internal/modules/cjs/loader.js:600:32<span class="token punctuation">)</span>  at tryModuleLoad <span class="token punctuation">(</span>internal/modules/cjs/loader.js:539:12<span class="token punctuation">)</span>  at Function.Module._load <span class="token punctuation">(</span>internal/modules/cjs/loader.js:531:3<span class="token punctuation">)</span>  at Function.Module.runMain <span class="token punctuation">(</span>internal/modules/cjs/loader.js:754:12<span class="token punctuation">)</span>  at startup <span class="token punctuation">(</span>internal/bootstrap/node.js:283:19<span class="token punctuation">)</span>  at bootstrapNodeJSCore <span class="token punctuation">(</span>internal/bootstrap/node.js:622:3<span class="token punctuation">)</span> <span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 0.153 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、基于ESLint保障质量"><a href="#七、基于ESLint保障质量" class="headerlink" title="七、基于ESLint保障质量"></a>七、基于ESLint保障质量</h2><p>JavaScript 是一个动态的弱类型语言，在开发中比较容易出错，一般会借助 Lint 工具来保障质量。</p><p><code>ESLint</code> 是新一代开源 JavaScript 代码检查工具，使用 Node.js 编写，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 全局安装 ESLint</span><span class="token function">npm</span> <span class="token function">install</span> -g eslint<span class="token comment" spellcheck="true"># 进入项目</span><span class="token function">cd</span> ~/NodeWork/NodeDemo<span class="token comment" spellcheck="true"># 初始化 package.json</span><span class="token function">npm</span> init -f<span class="token comment" spellcheck="true"># 初始化 ESLint 配置</span>eslint --init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 Lint 工具可以让我们：</p><ul><li>避免低级bug，找出可能发生的语法错误</li><li>提示删除多余的代码</li><li>确保代码遵循最佳实践 (可参考 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb style</a>、<a href="https://github.com/standard/standard" target="_blank" rel="noopener">javascript standard</a>)</li><li>统一团队的代码风格</li></ul><p>项目初始化完毕，可以开始在 <code>ESLint</code> 的提示下，高质量编写代码了。</p><h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><ul><li>Node官方文档：<a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/docs/</a></li><li>express官网：<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a></li><li>ESLint官方指南： <a href="https://cn.eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener">https://cn.eslint.org/docs/user-guide/getting-started</a></li><li>深入浅出Node.js：<a href="https://book.douban.com/subject/25768396/" target="_blank" rel="noopener">https://book.douban.com/subject/25768396/</a></li><li>ECMAScript 6 入门：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> npm </tag>
            
            <tag> nvm </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用AutoSSH建立SSH隧道，实现内网穿透</title>
      <link href="/2020/010618877.html"/>
      <url>/2020/010618877.html</url>
      
        <content type="html"><![CDATA[<p>当我们使用公司或家中电脑搭建了 Web 服务时，一般不能直接从外网访问，为了实现从外网直接访问到内网的服务，一般会需要用到 <strong>内网穿透</strong> 技术。常用的内网穿透工具有 NAT 转发、DMZ 主机、AutoSSH、ngrok、frp、花生壳等。下面将会介绍如何通过 SSH 端口转发，使内网主机 A 的服务转发至公网主机 B 上。</p><h3 id="需要条件"><a href="#需要条件" class="headerlink" title="需要条件"></a>需要条件</h3><p>​ 一台内网主机 A，一台 Linux 公网主机 B。下文以 CentOS7 系统为例。</p><h3 id="第一步：公网服务器配置"><a href="#第一步：公网服务器配置" class="headerlink" title="第一步：公网服务器配置"></a>第一步：公网服务器配置</h3><p>​ 修改公网主机 B 的 SSH 配置文件<code>/etc/ssh/sshd_config</code></p><pre><code>GatewayPorts yes</code></pre><p>​ 这样可以把监听的端口绑定到任意 IP 0.0.0.0 上，否则只有本机 127.0.0.1 可以访问。</p><p>​ 重启 sshd 服务</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第二步：安装-AutoSSH-服务"><a href="#第二步：安装-AutoSSH-服务" class="headerlink" title="第二步：安装 AutoSSH 服务"></a>第二步：安装 AutoSSH 服务</h3><p>在内网主机 A 上，执行以下命令安装 AutoSSH</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> autossh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第三步：断线免密登录自动重连"><a href="#第三步：断线免密登录自动重连" class="headerlink" title="第三步：断线免密登录自动重连"></a>第三步：断线免密登录自动重连</h3><p>​ ssh 反向链接会因为超时而关闭，如果关闭了那从外网连通内网的通道就无法维持，为此我们需要结合免密码登录及 AutoSSH 来提供稳定的 ssh 反向代理隧道。</p><p>​ 1、在内网主机 A 上产生公钥和私钥</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后按三次回车执行默认选项生成公钥和私钥。会生成密钥文件和私钥文件 id_rsa,id_rsa.pub 或 id_dsa,id_dsa.pub</p><p>​ 2、拷贝秘钥<br>   在内网主机 A 上继续执行如下命令，将内网主机 A 上的秘钥文件 copy 到公网主机 B 中。</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-copy-id  username@ip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中“username”是公网主机 B 的用户名，ip 为公网主机 B 的 ip，然后按照提示输入公网主机 B 的密码就完成了。</p><h3 id="第四步：利用-AutoSSH-实现端口转发"><a href="#第四步：利用-AutoSSH-实现端口转发" class="headerlink" title="第四步：利用 AutoSSH 实现端口转发"></a>第四步：利用 AutoSSH 实现端口转发</h3><p>在内网主机 A 上，利用 AutoSSH 建立一条 SSH 隧道</p><pre class="line-numbers language-bash"><code class="language-bash"> autossh -M 4010 -NR 80:localhost:4000 username@xxx.xxx.xxx.xxx <span class="token punctuation">(</span>-p xxxx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​ <strong>参数解释：</strong></p><ul><li>“-M 4010”意思是使用内网主机 A 的 4010 端口监视 SSH 连接状态，连接出问题了会自动重连</li><li>“ -N”意思是不执行远程命令</li><li>“-R”意思是将远程主机（公网主机 B）的某个端口转发到本地指定机器的指定端口</li></ul><p>​ <strong>代码解释：</strong></p><ul><li><p>“80:localhost:4000”意思是将内网主机 A 的 4000 号端口转发至公网主机 B 的 80 号端口上</p></li><li><p>“username@xxx.xxx.xxx.xxx”意思是公网主机 B 的用户名和 IP</p></li><li><p>“-p xxxx”意思是公网主机 B 的 SSH 端口，如果是默认的 22 号端口，则可以不输入.</p></li></ul><h3 id="第五步：监听端口检查"><a href="#第五步：监听端口检查" class="headerlink" title="第五步：监听端口检查"></a>第五步：监听端口检查</h3><p>​ 分别检查本地主机 A 及公网主机 B 的端口监听情况，出现如下进程则为正常。</p><p>​ 本地主机 A：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># lsof -i:4010</span>COMMAND   PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME<span class="token function">ssh</span>      6710 lixl    5u  IPv6 0x15699cecfe8a4995      0t0  TCP localhost:altserviceboot <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>autossh 46984 lixl    3u  IPv4 0x15699cece41d5e95      0t0  TCP localhost:altserviceboot <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​ 远程主机 B：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># lsof -i:8080</span>COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEsshd    9762 root   10u  IPv4 473994      0t0  TCP *:webcache <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>sshd    9762 root   11u  IPv6 473995      0t0  TCP *:webcache <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第六步：开启自启动"><a href="#第六步：开启自启动" class="headerlink" title="第六步：开启自启动"></a>第六步：开启自启动</h3><p>​ 配置 AutoSSH 开机自启动，输入：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/rc.d/rc.local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​ 添加内容:</p><pre class="line-numbers language-bash"><code class="language-bash">autossh -M 4010 -fCNR 80:localhost:4000 username@xxx.xxx.xxx.xxx <span class="token punctuation">(</span>-p xxxx<span class="token punctuation">)</span><span class="token function">chmod</span> +x /etc/rc.d/rc.local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​ centos7 之后，修改/etc/rc.d/rc.local 启动脚本需要重新赋予可执行权限。</p><p>​ 至此完成了端口转发，在相应的应用（如浏览器）中输入公网服务器 B 的 IP+端口即相当于直接访问内网主机 A 的相应服务，大功告成！</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>配置完通过外网 IP 加端口无法访问： 请检查公网服务器防火墙是否开放响应端口。</li><li>本地服务重启后，通过外部端口无法访问：这种情况是由于没有检测到通道之前已经断开，AutoSSH 应该有类似的机制，还没有仔细研究。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.jianshu.com/p/7accc1e485d3" target="_blank" rel="noopener">https://www.jianshu.com/p/7accc1e485d3</a></li><li><a href="https://blog.csdn.net/weixin_36394852/article/details/72725505" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36394852/article/details/72725505</a></li><li><a href="https://blog.csdn.net/zll_0405/article/details/81208606" target="_blank" rel="noopener">https://blog.csdn.net/zll_0405/article/details/81208606</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD领域驱动设计</title>
      <link href="/2019/122036340.html"/>
      <url>/2019/122036340.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://s.geekbang.org/search/c=2/k=DDD/t=" target="_blank" rel="noopener">DDD</a>和 DSL、DCI 的关系是什么？开发团队为何需要 DDD？它与微服务与中台又有着怎样的联系？目前业界实践 DDD 最大的问题是什么？11 月 30 日，在由 ThoughtWorks 举办的领域驱动设计峰会 <a href="http://www.ddd-china.com/speaker-info.html" target="_blank" rel="noopener">DDD-China 2019</a>上，InfoQ 记者带着这些问题对中兴通讯资深软件架构师张晓龙进行了采访。</p><h2 id="DDD、DSL-和-DCI"><a href="#DDD、DSL-和-DCI" class="headerlink" title="DDD、DSL 和 DCI"></a>DDD、DSL 和 DCI</h2><p>DDD 概念最早提出于 2004 年，作为一种软件开发的指导思想，DDD 对软件开发带来了诸多可能与方向，张晓龙认为 DDD 为软件开发带来的好处主要有以下几点：</p><ul><li>首先，最大好处就是所有参与者围绕一个统一一致的领域模型工作，传统的分析模型和设计模型不再割裂，不管是做设计、做分析还是写代码、写文档，脑海中所构建的画面都是一致的。</li><li>第二，DDD 是一个软件开发过程，它显式地把领域和设计放到了软件开发的核心，软件人员和业务人员被受到同样的重视，他们合作来构建领域模型，使得软件的交付质量更高且维护成本更低；</li><li>第三，DDD 提出的分层架构，有效分离了业务复杂度和技术复杂度，凸显了领域模型，使得领域层的代码和领域模型保持高度一致；</li><li>第四，统一语言非常重要，每个概念在各自的上下文中是清晰的无歧义的，同时要控制领域模型的复杂度，于是 DDD 在战略上提出了分离子域（问题域空间）和拆分 BC（解决方案空间）的模式，BC 间通过 Context Mapping 来集成；</li><li>第五，DDD 在战术层面提出了很多模式（聚合，实体，值对象，服务，工厂，仓储），对领域模型中的元素进行了分类，并给出了每类元素在领域模型中的职责和特征，降低了领域模型的构建成本。</li></ul><p>张晓龙此前曾在 DDD-China 峰会和<a href="https://archsummit.infoq.cn/2019/beijing/" target="_blank" rel="noopener">ArchSummit 全球架构师峰会</a>上分别做过《当 DDD 遇上 DSL（Domain-Specific Language）》、《当 DDD 遇上 DCI（Data，Context， Interactive）》的演讲，在他看来，DDD 和 DSL、DCI 之间存在极强的关联性。</p><p>DDD 和 DSL 的融合有三点：</p><ol><li>面向领域；</li><li>模型的组装方式；</li><li>分层架构演进。</li></ol><p>DSL 可以看作是在领域模型之上的一层外壳，可以显著增强领域模型的能力。它的价值主要有两个，一是提升了开发人员的生产力，二是增进了开发人员与领域专家的沟通。举个例子：想让 BA 负责流程契约的设计，该流程契约是一个活文档，可以跑测试，而 BA 不熟悉宿主语言。于是，我们设计了一种外部 DSL 来专门描述流程契约，对 BA 非常友好，学习成本也很低（不超过 5 分钟就可以学会），最后发现 BA 很快就广泛使用了起来。外部 DSL 并不一定要定义新文法，我们直接复用了 plantUML 文法，安装该插件可以自动生成序列图，非常棒！对于外部 DSL，需要自己实现一个解析器将 DSL 文法解析成语法树，再根据语法树生成语义模型。语义模型可以看作领域模型（严格的讲语义模型是领域模型的子集），外部 DSL 就是对领域模型的一种组装方式。</p><p>DCI 的作用主要体现在两方面：</p><p>首先，DCI 助力 DDD 战术设计：</p><ol><li>显式地对 ROLE 建模，解决了贫血模型与充血模型之争；</li><li>一个聚合可以支持哪些 ROLE，一个 ROLE 可以由哪些聚合扮演，一个场景下哪些聚合要扮演哪些角色；</li><li>当 Aggregate 内部实体行为比较多时可以嵌套使用 DCI 来拆分和组合；</li></ol><p>其次，DCI 助力 DDD 代码落地：</p><ol><li>对象就是 Data，Client 为 Context，对象在 Client 中的行为就是 ROLE。</li><li>根据正交设计原则得到小类（素材库），根据多重继承（only C++）或依赖注入来组合素材，不管是行为类还是数据类，都按 Role 的方式来组合，对像仅仅组合 Role 并注入依赖；</li><li>小类大对象：类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域；领域对象需要真正意义上的生命周期管理。</li></ol><p>张晓龙认为，DCI 对一些开发人员的影响可能比 DDD 和 DSL 还大，因为开发人员每天都在不断倒腾代码，想让代码的组合性更强，以便快速应对需求的变化。</p><h2 id="开发团队真的需要-DDD"><a href="#开发团队真的需要-DDD" class="headerlink" title="开发团队真的需要 DDD"></a>开发团队真的需要 DDD</h2><p>DDD 思想贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，和最终的代码实现，甚至对代码的测试与重构。代码是业务的核心资产，不管是否特性团队，开发团队肯定是代码的编写者和守护者。</p><p>对于开发团队而言，需要关注以下几点：</p><ul><li>首先是统一语言，让团队成员可以做到无障碍的沟通，不管是什么角色都能基于同样的画面进行讨论；</li><li>其次是团队中各个角色都围绕领域模型开展工作；</li><li>第三是代码物理设计容易标准化，比如说在分层设计时，基础设施层怎么设计，应用层怎么设计，DTO 应该放在哪儿，领域层中各个建模元素如何组织？</li></ul><p>更进一步，在分层架构里，应用层更加关注横切面的东西，比如说要上报一个告警，要给用户发送一个 Email，这些最好都集中放到应用层里面。但触发是在领域层发生的，应用层怎么知道？通过领域事件来实现依赖反转，即应用层订阅领域事件，领域层发布领域事件。</p><p>在中兴通讯，核心业务属于通信行业，DDD 的应用场景跟互联网企业有着很大差别：</p><ol><li>嵌入式软件；</li><li>兼业务复杂性和技术复杂性；</li><li>软件规模大，功能复杂，特性交叉；</li><li>高质量，高性能，高可靠等要求。</li></ol><p>张晓龙举例提到，中兴通讯在开发团队中实践 DDD 的经验具体而言有以下几点：</p><ol><li>领域专家下团队，和团队一起交流和协作；</li><li>教练指导，开展战训营，定期 review；</li><li>架构、设计、编码和工程实践：（1）DCI，DSL，正交设计，组合式设计；（2）编码规范和纪律；（3）嵌入式 C/C++ 最佳实践；（4）软件工程能力：开发者测试，小步安全流畅的重构，持续交付流水线，每日 Code Review。</li></ol><h2 id="DDD-与微服务"><a href="#DDD-与微服务" class="headerlink" title="DDD 与微服务"></a>DDD 与微服务</h2><p>DDD 概念提出距今已经有 15 年的历史，前十年时间都一直处于不温不火的状态，而在最近几年才开始大行其道。张晓龙表示，中兴通讯在 2012-2015 年期间也有过一些成功的案例，但对于整个业界来说了解的人并不多。他拿 DDD-China 峰会举例解释：这次峰会的参会者有 500 人的规模，而我们假设峰会在 2015 年之前举办的话，估计参会者不会超过 100 人。因此，我们可以断定是<a href="https://s.geekbang.org/search/c=2/k=微服务/t=" target="_blank" rel="noopener">微服务</a>的热风让人们重新发现了领域驱动设计的价值。</p><p>微服务架构从提出以来一直没有很好的理论支撑如何合理地划分服务边界，人们常常为服务要划分多大而争吵不休。而 DDD 被发现恰好可以弥补微服务的营养不良：（1）服务最大不要大过一个 BC，否则服务内可能会存在有歧义的领域概念；（2）服务最小不要小过一个聚合，否则会引入分布式事务的复杂度；（3）服务间最好通过 Domain Event 来进行交互，这样可以让服务保持松耦合。微服务和 DDD 的结合，让微服务架构看起来似乎更加稳健了。</p><p>“微服务就像是 DDD 的心上人，使得 DDD 真正焕发起了青春。”张晓龙这样解释。</p><p>对于业界目前流行的<a href="https://s.geekbang.org/search/c=2/k=中台/t=" target="_blank" rel="noopener">中台</a>概念，张晓龙同样也有自己的看法：</p><p>中台和 DDD 不是同一个层面的东西，不能为了把它们联系在一起，而强行找相似点。中台实际上就是多条业务线的共同需求，比如对于滴滴公司来说，快车、专车和出租车等业务都是微服务架构，这些业务的很多服务是相似的，考虑将这些服务从各个前台下沉到统一的平台，这个平台就是中台。中台要考虑各个前台的需求，所以复杂性变高了。</p><p>中台是一种企业级的架构模式，从企业全局整体视角来看架构全貌，而 DDD 是一种主流的软件开发方法，用来应对软件的核心复杂性。中台架构可以看作是微服务架构的延伸和发展，服务复杂性很高，所以更需要用 DDD 的方式去设计和建模，但二者之间并不是相同层面的概念。</p><h2 id="DDD-的困局"><a href="#DDD-的困局" class="headerlink" title="DDD 的困局"></a>DDD 的困局</h2><p>最近几年 DDD 的火爆也给业界开发团队带来了一些迷思，为什么我的 DDD 推行不下去？为什么我的 DDD 做起来总是跟敏捷一样，最后都变了味？</p><p>张晓龙总结了 DDD 目前面临的几大困局：</p><ul><li>首先是领域案例面比较窄。目前业界的 DDD 实践案例并不多，而且很多案例是偏向互联网领域的，对于工业领域、嵌入式领域和操作系统领域基本没有涉及；</li><li>第二，DDD 书籍非常少，而且大多数书籍是以 Java 或 C#写的。如果开发团队用的是 C、C++、Python 或 Go 语言，基本没有可参考的书籍，难度也就更大一些（尤其是 C 和 C++）；</li><li>第三，各个巨头公司，比如 Google，微软，BAT 等，很少组织、参与或赞助 DDD 峰会，没有形成引导作用，业界自然也就少有跟随效应；</li><li>第四，开发团队要么找不到领域专家，要么领域专家无法与开发团队长时间保持沟通，导致实践中出现偏差；</li><li>第五，DDD 落地有一定的门槛，对开发者的技能和素质都有较高的要求。</li></ul><p>针对以上几大困局，张晓龙也给出了自己的解决方案：</p><ol><li>培训 OOA、OOD 和 OOP 的基本知识，并实战演练，不断弥补与高手的 gap ；</li><li>领域专家和团队一起工作，确保大家头脑中的画面是一致的；</li><li>DDD 建模要有文档交付物，并和代码同步演进，以便对代码不熟悉的人员也能看到并理解领域驱动设计成果的全貌。</li></ol><p>软件开发没有银弹，DDD 也不是万能的。如果开发团队真的决定用 DDD 的思想指导软件开发，就一定要跟随时代的脚步，吃透 DDD 这个旧瓶里装的新酒。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计方法论 </tag>
            
            <tag> 领域驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物流、商流、资金流、信息流之间的关系</title>
      <link href="/2019/121252656.html"/>
      <url>/2019/121252656.html</url>
      
        <content type="html"><![CDATA[<p>物流、商流、资金流和信息流是流通过程的四大组成部分，这四者构成了一个流通过程。几者的关系“互为存在、相互作用、密不可分”，既相互独立，又是一个综合体。将物流、商流、资金流和信息流有机结合起来，会产生更大的能量，创造更大的经济效益。</p><p>所谓商流，就是一种买卖或者说是一种交易活动过程，通过商流活动发生商品所有权的转移。</p><p>商流是物流、资金流和信息流的起点，也可以说是后”三流”的前提，没有商流一般不可能发生物流、资金流和信息流。反过来，没有物流、资金流和信息流的匹配和支撑，商流也不可能达到目的。”四流”之间有时是互为因果关系。</p><p>比如，A企业与B企业经过商谈，达成了一笔供货协议，确定了商品价格、品种、数量、供货时间、交货地点、运输方式等，并签订了合同，也可以说商流活动开始了。要认真履行这份合同，自然要进入物流过程，将货物进行包装、装卸、保管和运输。同时伴随着信息传递活动。如果商流和物流都顺利进行了，接下来是付款和结算，即进入资金流的过程。无论是买卖交易，还是物流和资金流，这三大过程中都离不开信息的传递和交换，没有及时的信息流，就没有顺畅的商流、物流和资金流。没有资金支付，商流不会成立，物流也不会发生。</p><p>可以讲。商流是动机和目的，资金流是条件，信息流是手段，物流是终结和归缩。</p><p>就是说由于需要或产生购买欲望，才决定购买，购买的原因和理由就是商流的动机和目的；因为想购买或决定购买某种商品，才考虑购买资金的来源或筹措资金问题。不付款商品的所有权就不归你，这就是条件；又因为决定购买，也有了资金，然后才付之行动，这就是买主要向卖主传递一个信息，或去商店向售货员传递购买信息，或电话购物、网上购物，这些都是信息传递的过程，但这种过程只是一种手段；然而，商流、资金流和信息流产生后，必须有一个物流的过程，否则商流、资金流和信息流都没有意义。</p><p>举个例子，一个单位搬进新办公地点后要购买几台空调，这个单位可能直接去商店选购，也可能打电话或网上采购，就产生了商流活动。由此也伴生出资金流(如现金支付，支票付款或银行走账)和信息流。可是只完成这”三流”，并不是事物的完结，还必须将空调送至买主，最终还是少不了运输、装卸等物流过程。</p><p>那么。怎样才能保证将卖出去的空调按买主要求的时间、地点和数量，准确、完全地送货上门呢？</p><p>首先，出售空调的商店里有库存，或者商店给厂家打电话，让厂家从仓库取货。无论从商店取货，还是从仓库取货，都需要有车将空调送过去，如果销售量过于集中，车子跑不过来，或者司机调整不过来怎么办？如果仓库里缺这种型号的空调又怎么办？看来，这都属于物流的问题。</p><p>再往复杂一些说，假如空调厂家对空调的销售量预测的不准确，预测的销售大干实际需要，就产生库存积压，浪费仓库保管费，多占压生产资金。假如预测的销售量小于实际需要，则不仅少赚利润，失去市场，而且还可能影响企业声望。怎样才能既不浪费保管费和占压资金，又能保证供货呢？除了准确的市场需求预测，及时掌握各种信息外，还要构筑一个先进、合理的物流系统。首先要进行商品的需求、购买力、市场容量、销售时点、销售数量等基础性调查研究。然后，再制定一个与商流相配套的物流规划。根据市场情况，决定建几个配适中心，建多大规模，如何构筑配送网络等等。</p><p>因为物流是受商流制约，随商流变化而变化，往往为了占领市场、扩大销售而牺牲物流利益的，所以，在竞争激烈的商品经济社会要加强对物流问题的研究，加强对信息技术等现代科学手段的充分利用。</p><p>商流和资金流是传统性的经济活动，规则性强，已经比较成熟和定型，进一步的科学化管理受时代和经济发展水平限制。信息流主要依赖互联网，由计算机支持，是电子化传输和软件开发问题。这方面的竞争会不断加剧和复杂化，各企业的技术水平将来也会彼此接近。</p><p>前几年兴起的电子商务热，之所以急剧降温，是因 “物流瓶颈”造成的，而不是信息技术自身的问题。而且，商流、资金流和信息流将来都可能由计算机和网络通信部分替代，只有物流难以做到这一点。而旦物流又最落后，物流发展的空间比商流、资金流和信息流要大，合理化、科学化管理的余地要大，节约费用的潜力要大。这是因为：</p><ul><li><p>第一，物流是一门新兴科学，很多人对物流基本知识、物流理论、物流的重要作用、重视物流的必要性和必然性还了解不多，还需要一个认识过程。物流与商流、资金流以及信息流相比，发展滞后。进度缓慢，如不及时超上，要拖其他”三流”的后腿。同时也说明，物流的发展因过去是一流空白，是”黑暗的大陆”。因此它的发展空间也就更大。</p></li><li><p>第二，物流在商品总成本中的费用比例大，过去不受重视，这块庞大的成本，只要我们稍加努力，就会有利可图。这块”第三利润源泉”，是新经济时代最有前景的领域，是节约费用最大的空间。</p></li><li><p>第三，物流发展时间尚短，成熟程度差，物流管理科学化较低。只要我们认识到这一点，认真对待，大力加强对物流的管理，就能大大提高物流生产效率，大幅度增加经济效益。</p></li><li><p>第四，过去还很少有人将物流与商流、资金流、信息流联系起来考虑。也没有将”四流”做为一个大系统对待。今后如果真正把”四流”统一起来、协调起来，那将产生不可估量的效益。目前的主要矛盾表现在物流和信息流两个方面。</p></li></ul><p>在此我们有必要强调，商流、物流、资金演、信息流，虽然各有独立存在的意义，并各有自身的运行规律，但是，”四流”是一个相互联系、互为伴随、共同支撑流通活动的整体。在认识和研究流通经济，或者在进行物流管理过程中一定要把握这一点，以使我们认识问题全面化、科学化，把物流工作做得更有成效。</p>]]></content>
      
      
      <categories>
          
          <category> 供应链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四流合一 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Typora + PicGo 图床 + jsDelivr CDN实现高效 Markdown 创作</title>
      <link href="/2019/120114500.html"/>
      <url>/2019/120114500.html</url>
      
        <content type="html"><![CDATA[<p>本文提到两种插件组合方式，iPic及PicGo，支持Github、SM.MS、阿里OSS、腾讯COS、微博等主流图床。通过工具的搭配使用，我们能轻松地完成在 Markdown 中插图的工作，发布到多个内容平台。</p><p>对于Typora + iPic方式，是Typora默认支持的。尤其在一次性粘贴带有多个图片的图文混合内容时，超级方便。不过iPic是收费软件，可以使用PicGo来替代，只是这样就无法实现一次性粘贴多个图片的图文混合内容了。</p><h2 id="一、iPic方式"><a href="#一、iPic方式" class="headerlink" title="一、iPic方式"></a>一、iPic方式</h2><p>目前，Markdown 编辑器 <a href="https://sspai.com/tag/Typora" target="_blank" rel="noopener">Typora</a> 已经接入 iPicUploader，通过两款工具的搭配，我们能轻松地完成在 Markdown 中插图的工作。</p><h3 id="自动上传图片至图床"><a href="#自动上传图片至图床" class="headerlink" title="自动上传图片至图床"></a>自动上传图片至图床</h3><p>打开 Typora 中的「系统偏好设置 - 图像 - 通过iPic上传图片」选项，在 Typora 中插入本地图片时，i会自动将图片上传图床并使用 Markdown 语法替换文内地址。</p><p><img src="https://pic.lixl.cn/2020/20200114223815.png/w1280" alt=""></p><h3 id="使用快捷键"><a href="#使用快捷键" class="headerlink" title="使用快捷键"></a>使用快捷键</h3><p>如果你的主力 Markdown 工具不是 Typora，在选中图片或截图之后，使用 ⌘ + U 快捷键上传，然后直接在编辑器中粘贴也是一个不错的选择。</p><h2 id="二、PicGo方式"><a href="#二、PicGo方式" class="headerlink" title="二、PicGo方式"></a>二、PicGo方式</h2><p>PicGo是一款开源的图床软件，该软件与iPic的不分伯仲，文档支持中文，支持插件开发。</p><h3 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h3><p>下载地址 <a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a> ，选择下载与系统匹配的安装包，正常安装即可。</p><h3 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h3><p><img src="https://pic.lixl.cn/2020/20200114213053.png/w1280" alt=""></p><p>Github图床配置如上图，参数说明：</p><ul><li>仓库名：按照 <code>账户名/仓库名的格式填写</code></li><li>分支名：一般填写 <code>master</code> 即可</li><li>Token：到 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a> 去生成，然后黏贴在这里</li><li>存储路径：如图配置，会在仓库根目录创建 <code>images/2019</code> 的文件夹</li><li>自定义域名：图片成功上传后，PicGo会将 <code>自定义域名+上传的图片名</code> 生成的访问链接，放到剪切板中。</li></ul><blockquote><p>使用GitHub仓库作为图床，存在的问题是国内访问github的速度很慢，可以利用 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr CDN</a> 来加速访问。jsDelivr 是一个免费开源的 CDN 解决方案，该平台是首个打通中国大陆与海外的免费CDN服务，拥有中国政府颁发的 ICP 许可证，无须担心中国防火墙问题而影响使用。使用jsDelivr加速访问，需要将自定义域名设置为 <code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/</code>。</p><p>这里有一个大小为 700多K 的图片，可以体验一下速度差异：<a href="https://raw.githubusercontent.com/lxl80/blog/master/themes/hexo-theme-matery/source/medias/banner/2.jpg" target="_blank" rel="noopener">Github原始地址</a>　　　　<a href="https://cdn.jsdelivr.net/gh/lxl80/blog/themes/hexo-theme-matery/source/medias/banner/2.jpg" target="_blank" rel="noopener">jsDelivr CDN加速地址</a></p></blockquote><p><img src="https://pic.lixl.cn/2020/20200114203447.png/w1280" alt=""></p><p>阿里云OSS图床配置如上图，参数说明：</p><ul><li><p>Keyii及KeySecret：到 <a href="https://usercenter.console.aliyun.com/#/manage/ak" target="_blank" rel="noopener">阿里云控制台AccessKey管理</a> 申请并输入</p></li><li><p>仓库空间名：在对象存储中创建的Bucket的名称</p></li><li><p>存储区域：创建Bucket时所选区域的英文标识，查询地址：<a href="https://help.aliyun.com/document_detail/31837.html#concept-zt4-cvy-5db" target="_blank" rel="noopener">OSS开通Region</a></p></li><li><p>存储路径：如图配置，会自动在 OSS 存储空间根目录创建 <code>2020</code> 文件夹</p></li><li><p>网址后缀：这是阿里云 OSS 的一个很好用的功能，用于图片处理（如缩略图）。需要去OSS的 <a href="https://help.aliyun.com/document_detail/48884.html" target="_blank" rel="noopener">图片处理规则</a> 中创建样式。以下是我设置的规则，后缀 <code>w1280</code>代表将图片等比缩放到宽度&lt;=1280</p><p><img src="https://pic.lixl.cn/2020/20200114220140.png/w1280" alt=""></p></li><li><p>自定义域名：图片成功上传后，PicGo会将 <code>自定义域名+上传的图片名</code> 生成的访问链接，放到剪切板中。</p></li></ul><h3 id="快捷键及相关配置"><a href="#快捷键及相关配置" class="headerlink" title="快捷键及相关配置"></a>快捷键及相关配置</h3><p><img src="https://pic.lixl.cn/2020/20200114221441.png/w1280" alt=""></p><p>支持快捷键<code>command+shift+p</code>（macOS）或者<code>control+shift+p</code>（Windows\Linux）用以支持快捷上传剪贴板里的图片（第一张）。 PicGo 支持自定义快捷键，使用方法见 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html" target="_blank" rel="noopener">配置手册</a>。</p><p>通过自定义链接格式，可以直接生成符合需要的Markdown代码，方便粘贴。如我喜欢通过OSS将原始图片等比缩放到宽度&lt;=1280px，并将图片缩放50%来优化显示效果及速度，配置如下：</p><p><img src="https://pic.lixl.cn/2020/20200114222126.png/w1280" alt=""></p><p>复制或截图后，通过快捷键上传，然后直接粘贴，即可获得如下可直接粘贴到Markdown文档中的代码：</p><pre class="line-numbers language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://pic.lixl.cn/2020/20200114222126.png/w1280<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">zoom</span><span class="token punctuation">:</span><span class="token number">50%</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>补充：自动生成的代码包括了图片缩放设置，您也可以通过设置自定义链接格式为 <code>![]($url)</code> ，生成标准的Markdown代码:<code>![](https://pic.lixl.cn/2020/20200114222126.png/w1280)</code></p></blockquote><h2 id="三、免安装图床插件方式"><a href="#三、免安装图床插件方式" class="headerlink" title="三、免安装图床插件方式"></a>三、免安装图床插件方式</h2><p>如果使用 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 来搭建本地博客，可以不安装 iPic、PicGo 等图床插件，通过 Typora 将图片保存在本地，基于 <a href="https://www.npmjs.com/package/hexo-deployer-cos-cdn" target="_blank" rel="noopener">hexo-deployer-cos-cdn</a> 插件一键自动部署，详情可参考博文：<a href="https://www.lixl.cn/2020/020936412.html">hexo-deployer-cos-cdn 插件安装使用指南</a>。</p><p><img src="https://pic.lixl.cn/2020/image-20200310103404971.png" alt="配置Typora将图片保存到指定路径"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/d1dac86fbe04" target="_blank" rel="noopener">iPic + Typora，方便快捷地在 Markdown 中插图</a></li><li><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">Molunerfinn/PicGo</a></li><li><a href="https://www.jianshu.com/p/a36e9c64361d" target="_blank" rel="noopener">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的matery主题搭建博客并深度优化</title>
      <link href="/2019/092856736.html"/>
      <url>/2019/092856736.html</url>
      
        <content type="html"><![CDATA[<p>对于有一定技术背景的同学，自己动手搭建博客网站是一个很不错的选择。选择喜欢的主题，按需进行个性化配置，随时在本地用自己喜欢的工具写文章，一键发布到多个博客托管平台，使用自己喜欢的图床/CDN 来加速…</p><blockquote><p><a href="https://www.lixl.cn">演示站点（悟尘纪）</a> 基于 Hexo 的 hexo-theme-matery 主题构建，部署在腾讯云 COS 中并使用 CDN 进行内容加速，通过 PicGo + 阿里云 OSS 作为图床进行静态资源加速。</p></blockquote><h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo</code></li><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用： <code>hexo</code></li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'PATH="<span class="token variable">$PATH</span>:./node_modules/.bin"'</span> <span class="token operator">>></span> ~/.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>后期需要升级的化，进入 blog 目录，先检查更新:</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> outdatedPackage                  Current  Wanted  Latest  Locationhexo                       3.9.0   3.9.0   4.2.0  hexo-sitehexo-deployer-git          1.0.0   1.0.0   2.1.0  hexo-sitehexo-generator-archive     0.1.5   0.1.5   1.0.0  hexo-sitehexo-generator-category    0.1.3   0.1.3   1.0.0  hexo-sitehexo-generator-feed        1.2.2   1.2.2   2.2.0  hexo-sitehexo-generator-index       0.2.1   0.2.1   1.0.0  hexo-sitehexo-generator-tag         0.2.0   0.2.0   1.0.0  hexo-sitehexo-renderer-ejs          0.3.1   0.3.1   1.0.0  hexo-sitehexo-renderer-marked       0.3.2   0.3.2   2.0.0  hexo-sitehexo-renderer-stylus       0.3.3   0.3.3   1.1.0  hexo-sitehexo-server                0.3.3   0.3.3   1.0.0  hexo-site<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 <code>package.json</code> 文件，基于 <code>Latest</code> 列内容更新版本号，然后更新并检查版本号：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> --save<span class="token comment" spellcheck="true"># 检查版本号</span>$ hexo -vhexo: 4.2.0hexo-cli: 3.1.0<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre class="line-numbers language-bash"><code class="language-bash">hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token function">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>此时，通过 <code>hexo s</code> 命令即可在本地启动您的博客站点了。</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 <span class="token keyword">.</span> Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来将安装主题，配置博客托管平台，实现一键发布并刷新 CDN 缓存。</p><h2 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h2><p>在执行过<code>Hexo deploy</code>命令之后，目录结构新增了<code>.deploy_git</code>，<code>public</code>，<code>.gitignore</code>，如下：</p><pre class="line-numbers language-bash"><code class="language-bash"> $ tree -L 2<span class="token keyword">.</span>├── .deploy_git├── node_modules├── public├── scaffolds│   ├── draft.md│   ├── page.md│   └── post.md├── <span class="token function">source</span>│   ├── _posts│   ├── _drafts├── themes├── _config.yml├── db.json├── package.json└── package-lock.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>用来配置博客相关的参数，初始化时自动创建。具体参数设置，可参照 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">Hexo 配置</a> 文档。</p><h3 id="node-modules-和-package-json"><a href="#node-modules-和-package-json" class="headerlink" title="node_modules 和 package.json"></a>node_modules 和 package.json</h3><p>都是在初始化时自动创建。</p><p><code>node_modules</code>用来存储已安装的各类依赖包。<br><code>package.json</code>用来查看 Hexo 的版本以及相关依赖包的版本。</p><p>Hexo 会默认安装：</p><ul><li>hexo：主程序</li><li>hexo-deployer-git：实现 git 部署方式</li><li>hexo-generator-archive：存档页面生成器</li><li>hexo-generator-category：分类页面生成器</li><li>hexo-generator-index：index 生成器</li><li>hexo-generator-tag：标签页面生成器</li><li>hexo-renderer-ejs：支持 EJS 渲染</li><li>hexo-renderer-marked：Markdown 引擎</li><li>hexo-renderer-stylus：支持 stylus 渲染</li><li>hexo-server：支持本地预览，默认地址 localhost:4000</li></ul><p>新安装的依赖包，也会保存在<code>node_module</code>文件夹下。</p><h3 id="scaffold"><a href="#scaffold" class="headerlink" title="scaffold"></a>scaffold</h3><p>模板文件夹，初始化时自动创建。包含<code>page</code>，<code>post</code>，<code>draft</code>三种模板，分别对应 页面、要发布的文章、草稿。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题文件夹，初始化时自动创建。每一个主题，都有一个单独的文件夹。默认主题为 <a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="noopener">landscape</a>。</p><h3 id="source-，-public-和-deploy-git"><a href="#source-，-public-和-deploy-git" class="headerlink" title="source ， public 和 .deploy_git"></a>source ， public 和 .deploy_git</h3><ul><li>source：资源文件夹。用来存放图片、Markdown 文档（文章、草稿）、各种页面（分类、关于页面等）。</li><li>public：将 source 文件夹里的 Markdown 文档，转换成 index.html。再结合主题进行渲染，就是我们最终看到的博客。</li><li>.deploy_git：将 public 文件夹的内容提交到 Github 后生成，内容与 public 文件夹基本一致。</li></ul><p>这三者的关系大致是：source -&gt; public -&gt; .deploy_git</p><p>执行<code>hexo generate</code>，根据 source，更新 public。<br>执行<code>hexo deploy</code>，根据 public，更新 .deploy_git。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a> 是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题，点击 <a href="https://www.lixl.cn">这里</a> 可以查看示例效果。点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到 Hexo 的 <code>themes</code> 文件夹中即可。</p><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议"></a><code>_config.yml</code> 文件的其它修改建议</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">[</span>  <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://www.lixl.cn/medias/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"悟尘记"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"人生就是一场修行，上善若水，厚德载物。"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.lixl.cn/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去参观"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&amp;modificationDate=1540928132000&amp;api=v2"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Fabric"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"A Blockchain Platform for the Enterprise"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://hyperledger-fabric.readthedocs.io/en/master/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://www.bootcdn.cn/assets/img/maoyun.svg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"BootCDN"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"稳定、快速、免费的前端开源项目 CDN 加速服务。"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.bootcdn.cn/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去加速"</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">"preprocess"</span> <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">"tomorrow"</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># default false</span>  custom_css<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span>  <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span>  <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span>  <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span>  <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span>  <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>通过 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> 插件可以实现一键将博客同时部署到多个 git 仓库中。如同时发布到 github 及 gitee 提供的 pages 服务。安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 Hexo 根目录下的 <code>_config.yml</code> 文件中的如下内容:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">## Docs: https://hexo.io/docs/deployment.html</span><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/lxl80/blog.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//gitee.com/lxl80/lxl80.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> master    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也可以如本站一样，采用 <a href="https://github.com/75k/hexo-deployer-cos-enhanced" target="_blank" rel="noopener">hexo-deployer-cos-enhanced</a> 插件将静态内容部署到腾讯云对象存储服务中，在 DNS 配置中将境内线路解析到腾讯云 CDN 地址，实现加速。部署完成后会自动刷新被更新文件的 CDN 缓存。</p></blockquote><p>安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-cos-enhanced --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>_config.yml</code> 配置如下:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/lxl80/blog.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> cos    <span class="token key atrule">bucket</span><span class="token punctuation">:</span> lxl80<span class="token punctuation">-</span>130****    <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>beijing    <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDh9***<span class="token important">*F8FvL</span>    <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> Z3IGiur***<span class="token important">*QZR3PgjXmlVg</span>    <span class="token key atrule">cdnConfig</span><span class="token punctuation">:</span>      <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">cdnUrl</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//static.lixl.cn      <span class="token key atrule">bucket</span><span class="token punctuation">:</span> static<span class="token punctuation">-</span>130****      <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>beijing      <span class="token key atrule">folder</span><span class="token punctuation">:</span> static      <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDh9***<span class="token important">*F8FvL</span>      <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> Z3IGiur***<span class="token important">*QZR3PgjXmlVg</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后通过 <code>hexo g -d</code> 即可实现一键发布，并更新 CDN 缓存。</p><h3 id="文章链接转静态短地址（建议安装）"><a href="#文章链接转静态短地址（建议安装）" class="headerlink" title="文章链接转静态短地址（建议安装）"></a>文章链接转静态短地址（建议安装）</h3><p>如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件生成文章时生成中文拼音的永久链接，或者用<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 生成静态文章链接。以下结合 hexo-abbrlink 生成类似 <code>/yyyy/mmdd+随机数.html</code> 的文章链接地址。</p><p>安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，修改 <code>permalink:</code> ，并在文件末尾新增 <code>abbrlink:</code>配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">permalink</span><span class="token punctuation">:</span> <span class="token punctuation">:</span>year/<span class="token punctuation">:</span>month<span class="token punctuation">:</span>day<span class="token punctuation">:</span>abbrlink.html<span class="token key atrule">abbrlink</span><span class="token punctuation">:</span>  <span class="token key atrule">alg</span><span class="token punctuation">:</span> crc16 <span class="token comment" spellcheck="true">#算法选项：crc16丨crc32</span>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> dec <span class="token comment" spellcheck="true">#输出进制：dec为十进制，hex为十六进制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CND-加速（建议启用）"><a href="#CND-加速（建议启用）" class="headerlink" title="CND 加速（建议启用）"></a>CND 加速（建议启用）</h3><p>放在 Github 的资源在国内加载速度比较慢，因此需要使用 CDN 加速来优化网站打开速度，<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr</a> + Github 便是免费且好用的 CDN，非常适合博客网站使用。也可以选择主流云服务商提供的对象存储+CDN 来获得更快速及稳定的访问效果，费用低到几乎可忽略。</p><p><strong>用法：</strong></p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>例如：</strong></p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源。</p><blockquote><p>还可以配合 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>图床上传工具的<strong>自定义域名前缀</strong>来上传图片，使用极其方便。具体使用方法可参见我的另一篇文章: <a href="/2019/120114500.html">使用 Typora+iPic/PicGo 图床+CDN 实现高效 Markdown 创作</a></p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">" "</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明已经安装成功了。</p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p>如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#4cbf30</span> <span class="token number">0%</span>, <span class="token hexcode">#0f9d58</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>可以直接在 <code>/source/medias/banner</code> 文件夹中更换喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果会 <code>JavaScript</code> 代码，可以修改成自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".bg-cover"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">"background-image"</span><span class="token punctuation">,</span> <span class="token string">"url(/medias/banner/"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".jpg)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，应保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图</td></tr><tr><td>top</td><td><code>true</code></td><td>文章是否置顶，值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td>是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td>该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持</td></tr><tr><td>summary</td><td>无</td><td>文章卡片摘要显示的文字，如果无值程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 基于Hexo的hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>matery主题搭建博客并优化<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-10-03 14:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 基于Hexo的hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>matery主题搭建博客并优化<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-10-03 14:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 悟尘<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> 工具<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> blog  <span class="token punctuation">-</span> hexo<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h2><p>搜索引擎优化，又称为 SEO，即 Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google 自动收录效果还不错，百度就差得远了（<code>GitHub</code>不允许百度的<code>Spider</code>爬取<code>GitHub</code>上的内容）。</p><p>安装 sitemap 插件生成站点地图文件:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-sitemap --save<span class="token function">npm</span> <span class="token function">install</span> hexo-generator-baidu-sitemap --save  <span class="token comment" spellcheck="true">#百度专用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装后直接执行 <code>hexo cl&amp;&amp;hexo g -d</code> 命令，就会在网站根目录生成 <code>sitemap.xml</code> 及 <code>baidusitemap.xml</code> 文件。</p><h3 id="百度优化"><a href="#百度优化" class="headerlink" title="百度优化"></a>百度优化</h3><p>登录<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度搜索资源平台</a>， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击<a href="https://ziyuan.baidu.com/site/siteadd" target="_blank" rel="noopener">添加网站</a>，按提示操作。</p><p><img src="https://pic.lixl.cn/2020/20200129213302.png/w1280" alt="添加网站"></p><blockquote><p>提示：由于百度的 spider 是爬取不到 GitHub 的内容的，所以在第三步验证网站的时候，建议选择<code>CNAME验证</code>的方式。</p></blockquote><p>经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。点击 网站支持 –&gt; 数据引入 –&gt; 链接提交菜单，提交站点地图：<br><img src="https://pic.lixl.cn/2020/20200130153759.png/w1280" alt="提交站点地图"></p><p>另外，<code>hexo-theme-matery</code>主题已经内置了 <code>自动推送</code> 的功能， 检查 <code>themes/hexo-theme-matery/_config.yml</code> 文件中如下配置:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 百度搜索资源平台提交链接</span><span class="token key atrule">baiduPush</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自动推送的 JS 代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。</p><h3 id="谷歌优化"><a href="#谷歌优化" class="headerlink" title="谷歌优化"></a>谷歌优化</h3><p>登录 <a href="https://search.google.com/search-console?hl=zh-CN" target="_blank" rel="noopener">Google Search Console</a>，点击添加资源，输入自己的域名，按提示操作。</p><p><img src="https://pic.lixl.cn/2020/20200129214720.png/w1280" alt="添加资源"></p><blockquote><p>提示：需要进行 DNS 验证，进入 DNS 域名解析设置页面，按提示增加 TXT 记录，如下图:<br><img src="https://pic.lixl.cn/2020/20200129215358.png/w1280" alt="DNS验证内容填写示例"></p></blockquote><p>验证成功后，需要提交站点地图。参照下图提交，然后等待收录。<br><img src="https://pic.lixl.cn/2020/20200129223124.png/w1280" alt="提交站点地图"></p><blockquote><p>注意：hexo 配置文件中的 url 一定要输入正确的域名，插件是根据 url 生成站点地图的。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h3><p><code>hexo server</code> #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><p><code>hexo server -s</code> #以静态模式启动</p><p><code>hexo server -p 5000</code> #更改访问端口 (默认端口为 4000，’ctrl + c’关闭 server)</p><p><code>hexo server -i IP地址</code> #自定义 IP</p><p><code>hexo clean</code> #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的 public 文件夹</p><p><code>hexo g</code> #生成静态网页 (执行 $ <code>hexo g</code>后会在站点根目录下生成 public 文件夹, hexo 会将”/blog/source/“ 下面的.md 后缀的文件编译为.html 后缀的文件,存放在”/blog/public/ “ 路径下)</p><p><code>hexo d</code> #自动生成网站静态文件，并将本地数据部署到设定的仓库(如 github)</p><p><code>hexo init</code> 文件夹名称 #初始化 XX 文件夹名称</p><p><code>npm update hexo -g</code>#升级</p><p><code>npm install hexo -g</code> #安装</p><p><code>node-v</code> #查看 node.js 版本号</p><p><code>npm -v</code> #查看 npm 版本号</p><p><code>git --version</code> #查看 git 版本号</p><p><code>hexo -v</code> #查看 hexo 版本号</p><h3 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令"></a>简写指令</h3><p><code>hexo n &quot;我的第一篇文章&quot;</code> 等价于 <code>hexo new &quot;我的第一篇文章&quot;</code> 还等价于 <code>hexo new post &quot;我的第一篇文章&quot;</code></p><p><code>hexo p</code> 等价于 <code>hexo publish</code></p><p><code>hexo g</code> 等价于 <code>hexo generate</code></p><p><code>hexo s</code>等价于 <code>hexo server</code></p><p><code>hexo d</code> 等价于 <code>hexo deploy</code></p><p><code>hexo g -d</code>等价于<code>hexo generate --deploy</code></p><p>注: <code>hexo clean</code> 没有 简写, <code>git --version</code> 没有简写</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>1. 通过<code>hexo g -d</code>部署时报<code>Error: Spawn failed</code>错误:</strong></p><blockquote><p>这是由于 git 本地记录的提交版本号与 github 上不一致导致的，通过<code>git reset --hard commitCode</code>即可解决。</p></blockquote><ul><li>检查本地最近提交记录，获取最后一次提交记录的更新时间及标识，如<code>280a7fdd46fcfd7d34e652aec15523dcd247fac8</code></li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> .deploy_git<span class="token function">cat</span> .git/logs/HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>获取 github pages 服务所关联分支的最近一次提交记录，获取更新时间及标识。地址一般为：<code>https://github.com/用户名/仓库名/commits/分支名</code>，如<code>https://github.com/lxl80/blog/commits/gh-pages</code></li><li>如果发现提交最新的提交时间/标识不一致，通过以下命令即可解决:</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard f085038efdf79546c09641d37b2a2429c1ae8e60 <span class="token comment" spellcheck="true">#github上最新的提交标识</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h2><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 官方文档</a></li><li><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">闪烁之狐</a></li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">hexo-theme-matery</a></li><li><a href="https://blog.sky03.cn/posts/42790.html#toc-heading-1" target="_blank" rel="noopener">Hexo 进阶之各种优化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow2.0入门实战</title>
      <link href="/2019/090963177.html"/>
      <url>/2019/090963177.html</url>
      
        <content type="html"><![CDATA[<p>TensorFlow 是 2015 年年底开源的一套深度学习框架，是目前最活跃的深度学习框架。本文基于 2.0 版本，首先介绍它的安装和基本用法，然后讨论了深度学习的基本概念，包括神经网络前向计算、损失函数、反向传播计算和优化函数等，接着介绍了卷积神经网络和循环神经网络，最后介绍了在大规模应用的场景下，如何实现分布式的深度学习训练。</p><h3 id="安装-Tensorflow-环境"><a href="#安装-Tensorflow-环境" class="headerlink" title="安装 Tensorflow 环境"></a>安装 Tensorflow 环境</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装python3,pip</span><span class="token function">sudo</span> yum -y <span class="token function">install</span> epel-release<span class="token function">sudo</span> yum -y <span class="token function">install</span> gcc gcc-c++ python3-pip python-devel atlas atlas-devel gcc-gfortran openssl-devel libffi-devel<span class="token comment" spellcheck="true">#更新python国内源</span> <span class="token function">mkdir</span> ~/.pip vim ~/.pip/pip.conf  <span class="token punctuation">[</span>global<span class="token punctuation">]</span>  index-url <span class="token operator">=</span> https://pypi.mirrors.ustc.edu.cn/simple/  <span class="token punctuation">[</span>install<span class="token punctuation">]</span>  trusted-host <span class="token operator">=</span> mirrors.ustc.edu.cn<span class="token comment" spellcheck="true"># 安装virtualenv</span>pip3 <span class="token function">install</span> --upgrade virtualenvvirtualenv --system-site-packages ~/venvs/tensorflowcurl<span class="token function">sudo</span> python get-pip.pypip --version<span class="token function">sudo</span> pip <span class="token function">install</span> virtualenvvirtualevn --version<span class="token comment" spellcheck="true"># 创建python虚拟环境</span>virtualenv --system-site-packages -p python2.7 ./venv<span class="token comment" spellcheck="true"># 激活虚拟环境</span><span class="token function">source</span> venv/bin/activate<span class="token comment" spellcheck="true"># 安装Tensorflow</span>pip <span class="token function">install</span>  -i http://mirrors.aliyun.com/pypi/simple/ tensorflow<span class="token comment" spellcheck="true"># 查看安装的软件</span>pip list installed<span class="token comment" spellcheck="true">#通过python交互式环境验证安装是否成功</span>python<span class="token function">import</span> tensorflow as tfexit<span class="token punctuation">(</span><span class="token punctuation">)</span>  //退出python交互环境deactivate  //退出python虚拟环境<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Helloworld-示例验证"><a href="#Helloworld-示例验证" class="headerlink" title="Helloworld 示例验证"></a>Helloworld 示例验证</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> venv/bin/activatepython //进入python交互式环境<span class="token function">import</span> tensorflow as tfhello <span class="token operator">=</span> tf.constant<span class="token punctuation">(</span>"hello tensorflow.<span class="token punctuation">)</span>sess <span class="token operator">=</span> tf.Session<span class="token punctuation">(</span><span class="token punctuation">)</span>sess.run<span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在-Jupyter-交互式环境中使用-Tensorflow"><a href="#在-Jupyter-交互式环境中使用-Tensorflow" class="headerlink" title="在 Jupyter 交互式环境中使用 Tensorflow"></a>在 Jupyter 交互式环境中使用 Tensorflow</h3><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> jupyterpython -m ipykernel <span class="token function">install</span> --user --name<span class="token operator">=</span>venvjupyter kernelspec listjupyter notebook //自动打开浏览器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在-Docker-中使用-Tensorflow"><a href="#在-Docker-中使用-Tensorflow" class="headerlink" title="在 Docker 中使用 Tensorflow"></a>在 Docker 中使用 Tensorflow</h3><pre class="line-numbers language-bash"><code class="language-bash">docker pull tensorflow/tensorflow:nightly-jupytervim docker-compose.yml <span class="token comment" spellcheck="true">#制作配置文件</span>docker-compose up -d <span class="token comment" spellcheck="true">#初次启动，以后用start/stop</span>docker <span class="token function">exec</span> -it xxxx <span class="token function">bash</span> <span class="token comment" spellcheck="true">#进入docker,然后执行如下命令升级安装Python3</span> <span class="token function">apt-get</span> update <span class="token function">apt-get</span> <span class="token function">install</span> python-software-properties <span class="token function">apt-get</span> <span class="token function">install</span> python3.6 apt <span class="token function">install</span> python3-pip <span class="token comment" spellcheck="true">#更新python国内源</span> <span class="token function">mkdir</span> ~/.pip vim ~/.pip/pip.conf  <span class="token punctuation">[</span>global<span class="token punctuation">]</span>  index-url <span class="token operator">=</span> https://pypi.mirrors.ustc.edu.cn/simple/  <span class="token punctuation">[</span>install<span class="token punctuation">]</span>  trusted-host <span class="token operator">=</span> mirrors.ustc.edu.cn <span class="token comment" spellcheck="true">#在jupyter中启用python3</span> jupyter kernelspec list <span class="token comment" spellcheck="true"># 查看激活的kernel</span> python3 -m pip <span class="token function">install</span> ipykernel python3 -m ipykernel <span class="token function">install</span> --user <span class="token function">rm</span> /usr/local/bin/python <span class="token function">ln</span> -s /usr/bin/python3.6 /usr/local/bin/python python --version  <span class="token comment" spellcheck="true">#显示Python 3.6.x，则安装成功</span> pip <span class="token function">install</span> --upgrade tensorflow jupyter matplotlib pandas seaborn numpy tensorflow-hub tensorflow-datasets pillow pip list installed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 docker-compose 管理容器</li></ul><pre class="line-numbers language-ymal"><code class="language-ymal">version:  '3'services:  tensorflow-jupyter:    image: tensorflow/tensorflow:nightly-jupyter    ports:      - "8888:8888"      - "6006:6006"    volumes:      - .:/tf/notebooks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动： docker-compose up</p><h3 id="Tensorflow-架构介绍"><a href="#Tensorflow-架构介绍" class="headerlink" title="Tensorflow 架构介绍"></a>Tensorflow 架构介绍</h3><p><img src="https://pic4.zhimg.com/80/v2-14f1196030f7bd2db1ceff96bc9b0ddb_hd.jpg" alt="Tensorflow架构图一"><br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/3b16e5b406f603289fdeb140ee76e14190f57f14a72d49c11aea6fbd116b59234c971528be44e40cf6d42d638a2c3b14?pictype=scale&from=30113&version=3.3.3.3&size=750=" alt="Tensorflow架构图二"><br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/4250deb81e391cffa189c9d95f4a4e1c74c1fbb43c6a60b0ddd5efea4acd47ba090e0f3c42b5146ddfe7d7edf6bc8686?pictype=scale&from=30113&version=3.3.3.3&size=750=" alt=""></p><h3 id="实战：使用-CNN-识别彩色尺寸各异的猫狗图片"><a href="#实战：使用-CNN-识别彩色尺寸各异的猫狗图片" class="headerlink" title="实战：使用 CNN 识别彩色尺寸各异的猫狗图片"></a>实战：使用 CNN 识别彩色尺寸各异的猫狗图片</h3><p>​ 参考 <a href="https://colab.research.google.com/drive/1WerlZnNfh7N4RqO26gbctQ6NINkMxPkO" target="_blank" rel="noopener">Colab</a></p><h4 id="扁平化处理"><a href="#扁平化处理" class="headerlink" title="扁平化处理"></a>扁平化处理</h4><p>调整尺寸为一致的 150 * 150，以便可以生成相同大小的一位数组</p><h4 id="彩色图像处理"><a href="#彩色图像处理" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h4><p>使用三维数组建模，增加 RGB 作为 3 维数组的深度值，如图：<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0479c21b4302a6c26eb97984094a43864ca895cb1e33bb3f41de3f5a7d408d9d7a723f11ff403adc1ea9749c252ae77e?pictype=scale&from=30113&version=3.3.3.3&size=750=" alt=""></p><h4 id="对彩色图像执行卷积运算"><a href="#对彩色图像执行卷积运算" class="headerlink" title="对彩色图像执行卷积运算"></a>对彩色图像执行卷积运算</h4><ul><li>将彩色图像分解为 3 维数组<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c50a4ac38c7ce1aba88acd8610c03e76ca95fe46cdd25a11313bf9f5626602d00af10dc4b8cbab30601f6c19eb1a30ae?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=111.png&size=750" alt=""></li><li>利用三个过滤核进行卷积运算示例<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/d5867af3457e0692e7d8e33c54aa169ac453c7e75c4a9a9e634b195027b320c708e3aa95b9f8c2c048096570fffb3f4e?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=112.png&size=450" alt=""></li><li>示例中使用三个三维过滤器进行卷积运算<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c059b5c447235ce967e6a6624cc566aa1905b7e2ab7754c0c23b38b32dd9059dc59fc3c7eae44bdb951220dcbbc79e53?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190913-163837%402x.png&size=750" alt="使用三个过滤核进行卷积运算获得的三维结果"></li><li>代码说明</li></ul><pre class="line-numbers language-python"><code class="language-python">  tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span>filters<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#  参数：过滤器数量, 卷积核形状, ...</span>  <span class="token comment" spellcheck="true">#本例中使用：</span>  tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​ 在训练 CNN 时，将通过损失函数更新三维核中的值，从而最小化损失。</p><h4 id="执行最大池化运算"><a href="#执行最大池化运算" class="headerlink" title="执行最大池化运算"></a>执行最大池化运算</h4><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/9f7687a18e5b38514ae2a90d6fc13fdbeec4ce39957fb08f465afbf43f16b912d982cdb72fb9f3d24e7cd455d1ffec8f?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-175829%402x.png&amp;size=750=" alt=""></p><p>最大池化处理后，获得的三维数组宽度和高度减半，但深度不变。</p><h4 id="使用验证集解决过拟合问题（早停法）"><a href="#使用验证集解决过拟合问题（早停法）" class="headerlink" title="使用验证集解决过拟合问题（早停法）"></a>使用验证集解决过拟合问题（早停法）</h4><p>​ 通常在完成训练后，在测试集上进行验证才能发现过拟合问题。可以通过增加验证集，在每轮训练过程中基于验证集检查效果，分析训练损失和验证损失与周期的函数图，可判断出模型泛化效果。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/e8f7b98ddbbc9f117c5d1bf110d76ef3b414866b0b6e3539338b3216fe451f8aa59c6ffa5601e4c59d970ba8ecffb2db?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190913-201908%402x.png&size=750" alt=""></p><p>可以看出，验证集有助于我们判断 CNN 应该训练多少个周期，即可以达到较好的训练效果又不会出现过拟合，提前结束训练一遍获取最优模型。对于有多个潜在模型可选择时（如为模型选择合适的参数/结构），也可以用这种方法对比选择最优模型。</p><blockquote><p>如果训练集足够广泛（如各种各样可能的图片都有，如大小，位置，猫狗完整性等），将有助于训练出泛化能力强的模型。</p></blockquote><h4 id="使用图像增加技术避免过拟合"><a href="#使用图像增加技术避免过拟合" class="headerlink" title="使用图像增加技术避免过拟合"></a>使用图像增加技术避免过拟合</h4><p>​ 通过应用各种图片变换，可以增加样本数量，提高泛化能力避免过拟合的效果。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0d8bfb44efdffc9b668a4823a975c2cf71f25fa4d821352a1d1ca753744267a8df99e53f85482386e6a262712cfef8dc?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190913-204934%402x.png&size=750" alt=""></p><h3 id="使用随机丢弃避免过拟合（仅限深度神经网络）"><a href="#使用随机丢弃避免过拟合（仅限深度神经网络）" class="headerlink" title="使用随机丢弃避免过拟合（仅限深度神经网络）"></a>使用随机丢弃避免过拟合（仅限深度神经网络）</h3><p>​ 丢弃是指在训练过程中，随机关闭网络中的某些神经元。可以强制其它神经元产生更大的影响，在训练中扮演积极角色，如图：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/2c5a2132d7102530a3931a7105d7a8072be268a23bce15834b5e7535b6980e861cd49cbe5491ab8a854259885654f033?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190913-211219%402x.png&size=750" alt=""></p><p>在实践中，会指定每个训练周期每个神经元被丢弃的概率。</p><h3 id="实战：-图片增强的狗与猫图片分类"><a href="#实战：-图片增强的狗与猫图片分类" class="headerlink" title="实战： 图片增强的狗与猫图片分类"></a>实战： 图片增强的狗与猫图片分类</h3><p>参考<a href="https://colab.research.google.com/drive/1d3BmTUhMi4zFL9p4PMrKObJvfwj1zvFL#scrollTo=LZPYT-EmVrWo" target="_blank" rel="noopener">Colab</a>，我们将遵循一般的机器学习流程:</p><ul><li>Examine and understand data 检查和理解数据</li><li>Build an input pipeline 构建输入管道</li><li>Build our model 建立我们的模型</li><li>Train our model 训练我们的模型</li><li>Test our model 测试我们的模型</li><li>Improve our model/Repeat the process 改进我们的模型 / 重复这个过程</li></ul><h3 id="其它避免过拟合的技巧"><a href="#其它避免过拟合的技巧" class="headerlink" title="其它避免过拟合的技巧"></a>其它避免过拟合的技巧</h3><ul><li><p>收集更多数据及添加噪音：这和数据增强的目的是一样的，但是也会使模型对于自然界中可能遇到的干扰更加稳定。</p></li><li><p>简化模型：通过逐步降低模型的复杂性ーー随机森林中估计值的数目、神经网络中参数的数目等ーー你可以使模型足够简单，不会过度拟合，但也足够复杂，可以从你的数据中学习。 要做到这一点，根据模型的复杂性来查看两个数据集上的错误是很方便的。</p></li><li><p>改变训练方式：包括改变损失函数，或者模型在训练期间的工作方式。</p></li><li><p>正则化：正则化是一个约束模型学习以减少过拟合的过程。 其中一个最强大的和众所周知的技术正则化是增加一个惩罚的损失函数。 最常见的是 L1 和 L2。L1 惩罚的目的是最小化权重的绝对值，这有助于识别数据集中最相关的特性。L2 惩罚的目的是使权重的平方最小化，效率高于 L1。通过惩罚，该模型被迫在权重上做出妥协，因为它不能再将权重任意增加。 这使得模型更加通用，有助于防止过拟合。</p><p>参考文章： <a href="https://hackernoon.com/memorizing-is-not-learning-6-tricks-to-prevent-overfitting-in-machine-learning-820b091dc42" target="_blank" rel="noopener">6 tricks to prevent overfitting in machine learning.</a></p></li></ul><h3 id="练习：增加版花朵图像分类"><a href="#练习：增加版花朵图像分类" class="headerlink" title="练习：增加版花朵图像分类"></a>练习：增加版花朵图像分类</h3><p>​ 参考：<a href="https://colab.research.google.com/drive/1uURGgGNTeeyJ4Zfeoz81ggmUARxuNhfK#scrollTo=tk5NT1PW3j_P" target="_blank" rel="noopener">自行练习版 Colab</a>，<a href="">官方版 Colab</a></p><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>迁移学习的原理是通过使用由机器学习专家创建的经过大型数据训练过的模型，将模型已经学习到的知识迁移到新的数据集上，可以显著提高预测准确率。如上面猫狗识别的实战可以将准确率从 80%提高到 95%</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/8ec95bbbf4a17ab91b71cffaca9dca22f2f4020cd3b621c387f2972b0678f4ae35aec76d835f9c464c5a5f9edfed187b?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-130000%402x.png&size=750=" alt=""></p><p>​ 在迁移学习中，预训练的模型中的参数将被冻结（避免随机初始化权重），只训练最后分类层级的变量，可以显著提高训练速度。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/695902034ea19e36c9a7169926b7872bebc6f2c9f4aa53fa4aa88cc556012da1cb029e18d4688174459ef489ca77d718?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-130849%402x.png&size=750" alt=""><br>​ 示例代码：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/58b0e59034ade88fb41c26a1c7c918efc3eccfae6995ec8fb908883b250ea2273c2653bb2cfc96dbe6a6cb144570c40d?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-132906%402x.png&size=750" alt=""></p><p>​ 参考 Colab：<a href="https://colab.research.google.com/drive/1aGtbtCl2wSrcIMk9aadlJz2LtCHZ601R#scrollTo=3n0Wb9ylKd8R" target="_blank" rel="noopener">对猫狗数据集应用迁移学习</a> , <a href="https://colab.research.google.com/drive/177BHQe1KCLdzMvMW7TvSRfblPsG30fJV#scrollTo=oXiJjX0jfx1o" target="_blank" rel="noopener">通过迁移学习分类花朵图像</a></p><h3 id="实战：房价预测（线性回归）"><a href="#实战：房价预测（线性回归）" class="headerlink" title="实战：房价预测（线性回归）"></a>实战：房价预测（线性回归）</h3><h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/9a5c4539cd94381da65ed1936112134e2b4a12ee162954ca027e4b288fe87ba83dcf95a32a54eaa18a52be096bb2d439?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-151749%402x.png&size=750" alt=""></p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/08aa206814b71996987241fb6f0cfaad6b870417d5ab71ee80d9795d49a33764f92bf4e4aacf94824ecb83a82f88ed63?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-153950%402x.png&size=750" alt=""></p><ul><li><p>matplotlib 是一个 Python 2D 绘图库，可以生成出版物质量级别的图像和各种硬拷贝格式，并广泛支持多种平台，如:Python 脚本，Python，IPython Shell 和 Jupyter Notebook。</p></li><li><p>seaborn 是一个基于 matplotlib 的 Python 数据可视化库。它提供了更易用的高级接口，用于绘制精美且信息丰富的统计图形。</p></li><li><p>mpl_toolkits.mplot3d 是一个基础 3D 绘图(散点图、平面图、折线图等)工具集，也是 matplotlib 库的一部分。同时，它也支持轻量级的独立安装模式。</p></li><li><p>NumPy 是一个 BSD 开源协议许可的，面向 Python 用户的基础科学计算库，在多 维数组上实现了线性代数、傅立叶变换和其他丰富的函数运算。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/f602ee77363996f0a1d8eae20742ca797fbdf93f868417b1733f05ed5dae75508b1bc5c10925984456133eb0f56014b9?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-171026%402x.png&size=750" alt=""></p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://classroom.udacity.com/courses/ud187" target="_blank" rel="noopener">Tensorflow free course</a></li><li><a href="https://medium.com/tensorflow/introducing-tensorflow-hub-a-library-for-reusable-machine-learning-modules-in-tensorflow-cdee41fa18f9" target="_blank" rel="noopener">Introducing TensorFlow Hub: A Library for Reusable Machine Learning Modules in TensorFlow</a></li><li><a href="https://towardsdatascience.com/understanding-your-convolution-network-with-visualizations-a4883441533b" target="_blank" rel="noopener">Understanding your Convolution network with Visualizations</a></li><li><a href="https://time.geekbang.org/course/detail/153-78981" target="_blank" rel="noopener">TensorFlow 快速入门与实战</a></li><li><a href="https://www.cnblogs.com/guoyaohua/p/9265268.html" target="_blank" rel="noopener">Win10 安装 Tensorflow</a></li><li><a href="https://blog.csdn.net/xiaohuihui1994/article/details/83589701" target="_blank" rel="noopener">超详细：win10 安装 tensorflow-gpu1.8.0 完整步骤</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习常用术语</title>
      <link href="/2019/090864521.html"/>
      <url>/2019/090864521.html</url>
      
        <content type="html"><![CDATA[<p>机器学习领域有着许多非常基本的术语，这些术语听来可能相当高深莫测、它们事实上也可能拥有非常复杂的数学背景，本文会对这些常用的基本术语进行说明与解释。</p><ul><li>人工智能：一种计算机科学分支，旨在让计算机达到人类的智慧。实现这一目标有很多方式，包括机器学习和深度学习。</li><li>机器学习：一系列相关技术，用于训练计算机执行特定的任务。</li><li>神经网络：一种机器学习结构，灵感来自人类大脑的神经元网络。神经网络是深度学习的基本概念。</li><li>深度学习：机器学习的一个分支，利用多层神经网络实现目标。通常“机器学习”和“深度学习”可以相互指代。</li><li>监督式学习：</li><li>非监督式学习：</li><li>训练流程：是指将网络的内部变量调整为最佳可能值，使它们能够将输入映射到输出。为了实现这个目标，我们将采用梯度下降法这一优化流程，它会使用数值分析找到模- 型内部变量的最佳可能值。</li><li>梯度下降法：梯度下降法会以迭代方式调整参数，每次朝着正确的方向小幅更改参数，直到达到最佳值。“最佳值”是指再调整的话，会降低模型的效果。在每次迭代过程中- 衡量模型好坏的函数称为“损失函数”，每次调整的目标是“最小化损失函数”。</li><li>特征：模型的输入</li><li>样本：用于训练流程的输入/输出对</li><li>标签：模型的输出</li><li>层级：神经网络中相互连接的节点集合。</li><li>模型：神经网络的表示法</li><li>密集全连接层 (FC)：一个层级中的每个节点都与上个层级中的每个节点相连。</li><li>权重和偏差：模型的内部变量</li><li>损失：期望输出和真实输出之间的差值</li><li>MSE：均方误差，一种损失函数，它会将一小部分很大的差值视作比大量很小的差值更糟糕。</li><li>梯度下降法：每次小幅调整内部变量，从而逐渐降低损失函数的算法。</li><li>优化器：梯度下降法的一种具体实现方法。（有很多算法。在这门课程中，我们将仅使用“Adam”优化器，它是 - ADAptive with Momentum 的简称，并且被视为最佳优化器。）</li><li>学习速率：梯度下降过程中的损失改进“步长”。</li><li>批次：在训练神经网络的过程中使用的一组样本。</li><li>周期：完全经过整个训练数据集一轮</li><li>前向传播：根据输入计算输出值</li><li>反向传播：根据优化器算法计算内部变量的调整幅度，从输出层级开始，并往回计算每个层级，直到抵达输入层。</li><li>扁平化：将二维图像转换为一维向量的过程</li><li>ReLU：一种激活函数，使模型能够解决非线性问题。如果它接收到任何负输入，则该函数返回0，但对于任何正值x，它返回该值。参考：<a href="https://www.kaggle.com/dansbecker/rectified-linear-units-relu-in-deep-learning" target="_blank" rel="noopener">深度学习中的 ReLU</a></li><li>Softmax：一种函数，能够为每个潜在输出类别生成概率</li><li>分类：一种机器学习模型，用于区分两个或多个输出类别</li><li>训练集：用于训练神经网络的数据。</li><li>测试集：用于测试神经网络最终效果的数据。</li><li>验证集：训练完毕时，使用验证集衡量模型的最终准确率。</li><li>递归：输出一个值的模型。例如，估算房屋价值。</li><li>分类：一种模型，能够输出多个类别的概率分布。</li><li>CNN：卷积神经网络。即至少有一个卷积层的网络。典型的 CNN 还包括其他类型的层级，例如池化层和密集层。</li><li>卷积：向图像应用核（滤波器）的过程</li><li>核/滤波器：小于输入的矩阵，用于将输入变成多个小区域</li><li>填充：在输入图像周围添加像素，像素值通常为 0</li><li>池化：通过下采样降低图像大小的过程。池化层有多种类型。例如，平均池化通过求平均值将多个值变成一个值。但是最大池化是最常见- 的池化类型。</li><li>最大池化：一种池化过程，通过获取多个值中的最大值，将多个值变成一个值。</li><li>步长：在图像上滑动核（滤波器）的间隔像素数量。</li><li>下采样：降低图像大小的操作</li></ul><h2 id="其它基础知识常用术语："><a href="#其它基础知识常用术语：" class="headerlink" title="其它基础知识常用术语："></a>其它基础知识常用术语：</h2><ul><li>线性与非线性：</li><li>一维向量：</li><li>方差：是指一组数据中的各个数减这组数据的平均数的平方和的平均数，如（1，2，3,4,5）这组数据的方差，就先求出这组数据的平均数（1+2+3+4+5）÷5＝3，然后再求各个数与平均数的差的平方和，用（1-3）²+（2-3）²+（3-3）²+（4-3）²+（5-3）²＝10，再求平均数10÷5＝2，即这组数据的方差为2. 意义：当数据分布比较分散（即数据在平均数附近波动较大）时，各个数据与平均数的差的平方和较大，方差就较大；当数据分布比较集中时，各个数据与平均数的差的平方和较小。因此方差越大，数据的波动越大；方差越小，数据的波动就越小。方差不仅仅表达了样本偏离均值的程度，更是揭示了样本内部彼此波动的程度，也可以理解为方差代表了样本彼此波动的期望。</li></ul><h2 id="常用算法模型"><a href="#常用算法模型" class="headerlink" title="常用算法模型"></a>常用算法模型</h2><ul><li><p>OpenPose：OpenPose人体姿态识别项目是美国卡耐基梅隆大学（CMU）基于卷积神经网络和监督学习并以caffe为框架开发的开源库。可以实现人体动作、面部表情、手指运动等姿态估计。适用于单人和多人，具有极好的鲁棒性。是世界上首个基于深度学习的实时多人二维姿态估计应用。其成功的一部分原因是它在 GitHub 上开源了其实现代码（ <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose" target="_blank" rel="noopener">https://github.com/CMU-Perceptual-Computing-Lab/openpose</a> ），并配有详细的说明文档。</p></li><li><p>DeepCut：DeepCut（ <a href="https://arxiv.org/abs/1511.06645" target="_blank" rel="noopener">https://arxiv.org/abs/1511.06645</a> ）是一个自底向上的多人人体姿态估计方法。</p></li><li><p>RMPE（AlphaPose）：是一个流行的自顶向下姿态估计算法。该论文的作者认为，自顶向下方法的性能通常依赖于人体检测器的精度，毕竟人体姿态估计是在检测器检出的框的区域内进行的。因此，错误的定位和重复的候选框会使姿态检测算法的性能降低。为解决这一问题，作者提出了使用对称空间变换网络（Symmetric Spatial Transformer Network，SSTN）来从不准确的候选框中抽取高质量的单人区域。然后，作者使用了一个单人的姿态估计器（Single Person Pose Estimator，SPPE）来从抽取到的区域中估计此人的姿态骨架。接着，作者用一个空间逆变换网络（Spatial De-Transformer Network，SDTN），将估计出的姿态重新映射到图像坐标系下。最后，用一个参数化的姿态非极大抑制（Non-Maximum Suppression，NMS）方法来处理重复预测的问题。另外，作者还引入了一种姿态候选生成器（Pose Guided Proposals Generator），来增广训练样本，以便更好地训练 SPPE 和 SSTN 网络。RMPE 的显著特征是，该方法可以推广到任意的人体检测算法和 SSPE 的组合。</p></li><li><p>Mask RCNN：Mask RCNN（ <a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">https://arxiv.org/abs/1703.06870</a> ）是一个非常流行的语义和实例分割架构。该模型可以同时预测图像中多个物体的候选框位置及分割其语义信息的 mask。该模型的基础架构很容易被扩展到人体姿态估计上来。</p></li><li><p>DensePose：这是Mask-RCNN的一种变体，可以以每秒多帧的速度在每个人体区域内密集地回归特定部位的UV坐标。它基于一种能将图像像素通过卷积网络映射到密集网格的系统——DenseReg。模型的目标是决定每个像素在表面的位置以及它所在部分相对应的2D参数。DensePose借用了Mask-RCNN的架构，同时带有Feature Pyramid Network（FPN）的特征，以及ROI-Align池化。除此之外，他们在ROI池化的顶层搭建了一个全卷积网络。想了解DensePose更多的技术细节，请阅读原论文。</p></li><li><p>Realtime Multi-Person Pose Estimation： 这一模型和上面的OpenPose高度相关，同时特征模型能与多种框架相关联。论文的作者提供了一种自下而上的方法，对多人的姿态进行实时估计，不需要用任何人物探测器。这种方法运用了一种非参数表示，我们称为Part Affinity Fields（PAFs），用它可以学习将图中人物和其身体部位联系到一起。有关该技术的具体细节和理论，可以阅读原文。另外，这一方法最棒的特征之一就是它可以在多种不同的框架中实现，针对不同框架，已经公开了相关代码和模型。</p></li><li><p>AlphaPose：lphaPose是一款精准的多人姿态评估工具，并声称是第一款开源系统。AlphaPose既可以在图片、视频或多图中进行姿态估计，也能在画面中对动作进行追踪。它的输出形式非常广泛，包括PNG、JPG和AVI等具有关键点的图片形式，也有JSON格式的输出，这一特点也使其成为众多应用受欢迎的工具。目前，这一工具支持TensorFlow和PyTorch两种实现。AlphaPose利用一种区域性的多人动作估计框架将不精准的人类边界框该进程精确的动作估计。这里有三种元素：对称空间转换网络（SSTN）、参数化姿态非极大抑制（NMS）以及姿态导向的生成器（PGPG）。</p></li><li><p>DeepPose： DeepPose算是比较“古老”的了，论文发布与2014年，提出了一种基于深度神经网络的姿态估计方法，是基于DNN向身体关节回归的问题。它以一种整体的方式估计姿态，并且表述起来非常简洁强大。DeepPose是第一个将深度学习应用到人类姿态估计上的应用，并且取得了当时顶尖的结果，成为了其他方法的baseline。</p></li><li><p>MTCNN人脸检测：是2016年的论文提出来的，MTCNN的“MT”是指多任务学习(Multi-Task)，在同一个任务中同时学习”识别人脸“、”边框回归“、”人脸关键点识别“。相比2015年的CVPR(边框调整和识别人脸分开做)的结构，MTCNN是有创新的。</p></li><li><p>FaceNet：是 Google 研究人员于 2015 年开发的人脸识别系统，一个通用的系统，可以用于人脸验证（是否是同一人？），识别（这个人是谁？）和聚类（寻找类似的人？）。与其他的深度学习方法在人脸上的应用不同，FaceNet并没有用传统的softmax的方式去进行分类学习，然后抽取其中某一层作为特征，而是直接进行端对端学习一个从图像到欧式空间的编码方法，然后基于这个编码再做人脸识别、人脸验证和人脸聚类等。通过卷积神经网络学习将图像映射到欧几里得空间。空间距离直接和图片相似度相关：同一个人的不同图像在空间距离很小，不同人的图像在空间中有较大的距离。</p></li><li><p>CTPN：是在ECCV 2016提出的一种文字检测算法。CTPN结合CNN与LSTM深度网络，能有效的检测出复杂场景的横向分布的文字，是目前比较好的文字检测算法。 <a href="https://zhuanlan.zhihu.com/p/34757009" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34757009</a></p></li><li><p>Faster RCNN：经过R-CNN和Fast RCNN的积淀，Ross B. Girshick在2016年提出了新的Faster RCNN，在结构上，Faster RCNN已经将特征抽取(feature extraction)，proposal提取，bounding box regression(rect refine)，classification都整合在了一个网络中，使得综合性能有较大提高，在检测速度方面尤为明显。</p></li><li><p>SLAM： Simultaneous Localization And Mapping的 英文首字母组合，一般翻译为：同时定位与建图、同时定位与地图构建。SLAM是指当某种移动设备（如机器人、无人机、手机等）从一个未知环境里的未知地点出发，在运动过程中通过传感器（如激光雷达、摄像头等）观测定位自身位置、姿态、运动轨迹，再根据自身位置进行增量式的地图构建，从而达到同时定位和地图构建的目的。定位和建图是两个相辅相成的过程，地图可以提供更好的定位，而定位也可以进一步扩建地图。需要说明的是，上述扫地机器人例子中，定位和建图是SLAM的基本要求，而路径规划是在此基础上的高级功能，不属于SLAM的讨论范畴。</p></li><li><p>SFM：Structure From Motion，通过相机的移动来确定目标的空间和几何关系，是三维重建的一种常见方法。<br>它与Kinect这种3D摄像头最大的不同在于，它只需要普通的RGB摄像头即可，因此成本更低廉，且受环境约束较小，<br>在室内和室外均能使用。</p></li><li><p>ResNet：ResNet是由微软研究院的Kaiming He等四名华人提出，他们通过自己提出的ResNet Unit成功训练出来152层的神经网络并在ILSVRC2015比赛中斩获冠军。ResNet语义分割领域最受欢迎且最广泛运用的神经网络.ResNet的核心思想就是在网络中引入恒等映射，允许原始输入信息直接传到后面的层中，在学习过程中可以只学习上一个网络输出的残差（F(x)），因此ResNet又叫做残差网络。、</p></li><li><p>R-CNN：伯克利大学的Girshick教授等人共同提出了首个在目标检测方向应用的深度学习模型：Region-based Convolutional Neural Network（R-CNN）。该网络模型如下图所示，其主要流程为：先使用selective search算法提取2000个候选框，然后通过卷积网络对候选框进行串行的特征提取，再根据提取的特征使用SVM对候选框进行分类预测，最后使用回归方法对区域框进行修正。</p><p><img src="https://pic2.zhimg.com/80/v2-bd5baff7669ca7ddce811c7149c11799_hd.jpg" alt=""></p></li><li><p>Fast R-CNN：由于R-CNN的效率太低，2015年由Ross等学者提出了它的改进版本：Fast R-CNN。其网络结构图如下图所示（从提取特征开始，略掉了region的选择）Fast R-CNN在传统的R-CNN模型上有所改进的地方是它是直接使用一个神经网络对整个图像进行特征提取，就省去了串行提取特征的时间；接着使用一个RoI Pooling Layer在全图的特征图上摘取每一个RoI对应的特征，再通过FC进行分类和包围框的修正。</p><p><img src="https://pic2.zhimg.com/80/v2-ae08e5aa35c2e8bfd65491e3c39888cd_hd.jpg" alt=""></p></li><li><p>Faster R-CNN：2016年提出的Faster R-CNN可以说有了突破性的进展（虽然还是目标检测哈哈哈），因为它改变了它的前辈们最耗时最致命的部位：selective search算法。它将selective search算法替换成为RPN，使用RPN网络进行region的选取，将2s的时间降低到10ms，其网络结构如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-d7b27123e9e95200303959aeaf8816e2_hd.jpg" alt=""></p><p>​    Faster R-CNN优缺点：</p><ul><li>使用RPN替换了耗时的selective search算法，对整个网络结构有了突破性的优化；</li><li>Faster R-CNN中使用的RPN和selective search比起来虽然速度更快，但是精度和selective search相比稍有不及，如果更注重速度而不是精度的话完全可以只使用RPN；</li></ul></li><li><p>Mask R-CNN：Mask R-CNN（终于到分割了！）是何恺明大神团队提出的一个基于Faster R-CNN模型的一种新型的分割模型，此论文斩获ICCV 2017的最佳论文，在Mask R-CNN的工作中，它主要完成了三件事情：目标检测，目标分类，像素级分割。恺明大神是在Faster R-CNN的结构基础上加上了Mask预测分支，并且改良了ROI Pooling，提出了ROI Align。其网络结构真容就如下图所示啦：</p><p><img src="https://pic4.zhimg.com/80/v2-8123af16197c5b6b486808fafe2246d7_hd.jpg" alt=""></p><p>​    MS R-CNN的优缺点：</p><ul><li>优化了Mask R-CNN中的信息传播，提高了生成预测模板的质量；</li><li>未经大批量训练的情况下，就拿下了COCO 2017挑战赛实例分割任务冠军；</li><li>要说缺点的话。。应该就是整个网络有些庞大，一方面需要ResNet当作主干网络，另一方面需要其它各种Head共同承担各种任务。</li></ul></li><li><p>SetNet：SegNet是剑桥提出的旨在解决自动驾驶或者智能机器人的图像语义分割深度网络，SegNet基于FCN，与FCN的思路十分相似，只是其编码-解码器和FCN的稍有不同，其解码器中使用去池化对特征图进行上采样，并在分各种保持高频细节的完整性；而编码器不使用全连接层，因此是拥有较少参数的轻量级网络：</p><p><img src="https://pic4.zhimg.com/80/v2-f6a18a6bad1cbfd8c359a45656604fe3_hd.jpg" alt=""></p><p>​    SetNet的优缺点：</p><ul><li>保存了高频部分的完整性；</li><li>网络不笨重，参数少，较为轻便；</li><li>对于分类的边界位置置信度较低；</li><li>对于难以分辨的类别，例如人与自行车，两者如果有相互重叠，不确定性会增加。</li></ul></li><li><p>LSTM:长短时记忆（LSTM，Long Short Term Memory）模型在时间信息处理中很受欢迎，关键思想是单元（cell）状态，如图水平线贯穿的顶部。LSTM将信息移除或添加到单元状态（cell state），称为门（gates）：输入门（𝑖𝑡），忘记门（𝑓𝑡）和输出门（𝑜𝑡）可以定义为如下公式：</p><p><img src="https://pic2.zhimg.com/80/v2-3f99658ef0bee863c16c243cf5de9279_hd.jpg" alt=""></p></li><li><p>GRU：Gated Recurrent Unit ，也来自LSTMs。GRU受欢迎的主要原因是计算成本和模型的简单性，如图所示。在拓扑、计算成本和复杂性方面，GRU是比标准LSTM更轻的RNN版。 该技术将遗忘门（forget gates）和输入门（input gates）组合成单个“更新门（update gate）”，并将单元状态、隐藏状态以及一些其他变化合并。更简单的GRU模型越来越受欢迎。数学上GRU可以用表示如下公式：</p><p><img src="https://pic4.zhimg.com/80/v2-15ac0386cacc6f89cd9b4bbe07806ebf_hd.jpg" alt=""></p></li><li><p>RNN： 递归神经网络（Recurrent Neural Network，RNN），不同于CNN，是用来处理序列数据的模型。有一点共同的是，RNN在几个时间点也具有共享权重的特点。RNN是唯一的，它允许随时间推移在一系列向量上进行操作。在Elman架构中，使用隐层的输出和隐层的正常输入一起作为输入。 另一方面，Jordan网络中输出单元的输出作为隐藏层的输入。相反地Jordan使用输出单元的输出同时作为自身和隐藏层的输入。RNN方法的主要问题是梯度消失/下降。如图示意所示。</p><p><img src="https://pic4.zhimg.com/80/v2-4359eedb6d8821257dae8988614b7d23_hd.jpg" alt=""></p></li><li><p>迁移学习：迁移学习是一种机器学习的方法，指的是一个预训练的模型被重新用在另一个任务中。迁移学习是一种优化，是一种节省时间或者得到更好性能的捷径。</p></li><li><p>ArchiGAN: 基于GAN实现公寓户型及家具自动划分，参考地址: <a href="https://devblogs.nvidia.com/archigan-generative-stack-apartment-building-design/?linkId=70968833" target="_blank" rel="noopener">https://devblogs.nvidia.com/archigan-generative-stack-apartment-building-design/?linkId=70968833</a></p></li><li><p>SLAM：同时定位与建图（simultaneous localization and mapping，SLAM）是自动驾驶与增强现实领域中常用的技术。主要研究装置通过各种传感器在未知环境中的感知与定位问题。可以描述为: 机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置估计和地图进行自身定位,同时在自身定位的基础上建造增量式地图，实现机器人的自主定位和导航。使用的基于机器人操作系统（ROS）框架工作的SLAM算法。 在ROS中提供的五种基于2D激光的SLAM算法分别是：HectorSLAM，Gmapping，KartoSLAM，CoreSLAM和LagoSLAM。当然最后还有比较经典的google开源的cartographer，虽然不是基于ROS的但是大牛们已经将它修改为基于ＲＯＳ的版本的cartographer_ros</p></li><li><p>U-Net：在图像分割任务特别是医学图像分割中，U-Net[1]无疑是最成功的方法之一，该方法在2015年MICCAI会议上提出，目前已达到四千多次引用。其采用的编码器（下采样）-解码器（上采样）结构和跳跃连接是一种非常经典的设计方法。目前已有许多新的卷积神经网络设计方式，但很多仍延续了U-Net的核心思想，加入了新的模块或者融入其他设计理念。</p><p><img src="https://pic3.zhimg.com/v2-63be140aee258bc15cfc1541f0a60d22_1200x500.jpg" alt="图像分割的U-Net系列方法"></p></li><li></li></ul><p>参考文章</p><ul><li><a href="https://developers.google.com/machine-learning/glossary/" target="_blank" rel="noopener">Google机器学习和TensorFlow专用术语表</a></li><li><a href="https://zhuanlan.zhihu.com/p/70758906" target="_blank" rel="noopener">最全综述 | 图像分割算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Bash命令收集</title>
      <link href="/2019/081342868.html"/>
      <url>/2019/081342868.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><h3 id="1-hostname-查看主机名"><a href="#1-hostname-查看主机名" class="headerlink" title="1. hostname - 查看主机名"></a>1. hostname - 查看主机名</h3><p><code>hostname</code>命令用于查看系统的主机名，或是修改系统的主机名。</p><p><code>hostname</code>的常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示系统的当前主机名</span><span class="token function">hostname</span><span class="token comment" spellcheck="true"># 修改你系统的主机名</span><span class="token function">hostname</span> blinkfox-system<span class="token comment" spellcheck="true"># 使用 -F 选项，从指定的文件中读取主机名</span><span class="token function">hostname</span> -F /root/hostname.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-uptime-查看系统运行时间"><a href="#2-uptime-查看系统运行时间" class="headerlink" title="2. uptime - 查看系统运行时间"></a>2. uptime - 查看系统运行时间</h3><p><code>uptime</code>命令用于打印系统的运行时间等信息。使用如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">uptime</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-w、who-列出登录的用户"><a href="#3-w、who-列出登录的用户" class="headerlink" title="3. w、who - 列出登录的用户"></a>3. w、who - 列出登录的用户</h3><p><code>w</code>命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">w<span class="token comment" spellcheck="true"># 打印如下</span>22:42  up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75USER     TTY      FROM              LOGIN@  IDLE WHATblinkfox console  -                日19   6days -blinkfox s000     -                五23       - w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>who</code>命令有与<code>w</code>命令类似的用途，但它的功能比<code>w</code>命令更强大一些。语法格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">who</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>FILE <span class="token operator">|</span> ARG1 ARG2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>who</code>常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示当前登录的所有用户信息</span><span class="token function">who</span><span class="token comment" spellcheck="true"># 显示系统的启动时间</span><span class="token function">who</span> -b<span class="token comment" spellcheck="true"># 显示系统登录进程</span><span class="token function">who</span> -l<span class="token comment" spellcheck="true"># 显示与当前标准输入关联的用户信息</span><span class="token function">who</span> -m<span class="token comment" spellcheck="true"># 显示系统的运行级别</span><span class="token function">who</span> -r<span class="token comment" spellcheck="true"># 显示所有登录用户的用户名和登录用户数</span><span class="token function">who</span> -q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-uname-查看系统信息"><a href="#4-uname-查看系统信息" class="headerlink" title="4. uname - 查看系统信息"></a>4. uname - 查看系统信息</h3><p><code>uname</code>命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">uname</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用使用方式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 只打印内核的名称</span><span class="token function">uname</span><span class="token comment" spellcheck="true"># 使用 -n 选项，只打印系统的主机名</span><span class="token function">uname</span> -n<span class="token comment" spellcheck="true"># 使用 -r 选项，打印内核版本信息</span><span class="token function">uname</span> -r<span class="token comment" spellcheck="true"># 使用 -m 选项，打印系统的硬件名称</span><span class="token function">uname</span> -m<span class="token comment" spellcheck="true"># 使用 -p 选项，打印系统的处理器类型信息</span><span class="token function">uname</span> -p<span class="token comment" spellcheck="true"># 使用 -i 选项，打印系统的硬件平台信息</span><span class="token function">uname</span> -i<span class="token comment" spellcheck="true"># 使用 -a 选项，打印上述所有示例中的信息</span><span class="token function">uname</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-date-显示和设置系统日期和时间"><a href="#5-date-显示和设置系统日期和时间" class="headerlink" title="5. date - 显示和设置系统日期和时间"></a>5. date - 显示和设置系统日期和时间</h3><p><code>date</code>命令用于以多种格式显示日期和时间，或设置系统的日期和时间。<code>date</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">date</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>+FORMAT<span class="token punctuation">]</span><span class="token function">date</span> <span class="token punctuation">[</span>-u<span class="token operator">|</span>--utc<span class="token operator">|</span>--universal<span class="token punctuation">]</span> <span class="token punctuation">[</span>MMDDhhmm<span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span><span class="token punctuation">[</span>.ss<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用使用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以默认格式显示系统的当前日期时间</span><span class="token function">date</span><span class="token comment" spellcheck="true"># 格式化当前日期</span><span class="token function">date</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 格式化输出昨天的日期</span><span class="token function">date</span> -d <span class="token string">"1 day ago"</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 2秒后格式化输出</span><span class="token function">date</span> -d <span class="token string">"2 second"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 普通格式化转出</span><span class="token function">date</span> -d <span class="token string">"2009-12-12"</span> +<span class="token string">"%Y/%m/%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># apache格式转换</span><span class="token function">date</span> -d <span class="token string">"Dec 5, 2009 12:00:37 AM"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 日期加减操作</span><span class="token function">date</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前天年月日</span><span class="token function">date</span> -d <span class="token string">"+1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示后一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示上一月的日期</span><span class="token function">date</span> -d <span class="token string">"+1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一月的日期</span><span class="token function">date</span> -d <span class="token string">"-1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一年的日期</span><span class="token function">date</span> -d <span class="token string">"+1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一年的日期</span><span class="token comment" spellcheck="true"># 设定时间</span><span class="token function">date</span> -s <span class="token comment" spellcheck="true"># 设置当前时间，只有root权限才能设置，其他只能查看</span><span class="token function">date</span> -s 20160816 <span class="token comment" spellcheck="true"># 设置成20160816，这样会把具体时间设置成空00:00:00</span><span class="token function">date</span> -s 01:01:01 <span class="token comment" spellcheck="true"># 设置具体时间，不会对日期做更改</span><span class="token function">date</span> -s <span class="token string">"01:01:01 2012-05-23"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"01:01:01 20120523"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"2012-05-23 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"20120523 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-id-显示用户属性"><a href="#6-id-显示用户属性" class="headerlink" title="6. id - 显示用户属性"></a>6. id - 显示用户属性</h3><p><code>id</code>命令用于打印输出用户<code>uid</code>、<code>gid</code>、用户名和组名等用户身份信息。<code>id</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">id</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>USERNAME<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常见使用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息</span><span class="token function">id</span><span class="token comment" spellcheck="true"># 使用 -u 选项，输出用户的 uid</span><span class="token function">id</span> -u<span class="token comment" spellcheck="true">#-u 选项和 -n 选项结合使用，输出账户的用户名</span><span class="token function">id</span> -un<span class="token comment" spellcheck="true"># 使用 -g 选项，输出帐号当前起作用的gid</span><span class="token function">id</span> -g<span class="token comment" spellcheck="true"># -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名</span><span class="token function">id</span> -gn<span class="token comment" spellcheck="true"># 使用 -G 选项，输出帐号所属的所有群组id</span><span class="token function">id</span> -G root<span class="token comment" spellcheck="true"># -G 与 -n 选项结合使用，输出账号所属的所有群组的名称</span><span class="token function">id</span> -Gn root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><h3 id="1-touch-创建文件"><a href="#1-touch-创建文件" class="headerlink" title="1. touch - 创建文件"></a>1. touch - 创建文件</h3><p><code>touch</code>命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。<code>touch</code>命令又如下选项：</p><pre class="line-numbers language-bash"><code class="language-bash">-a: 只改变访问时间-c: 不创建任何文件-m: 只改变修改时间-r: 使用指定文件的时间替代当前时间-t: 使用 <span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span>MMDDhhmm<span class="token punctuation">[</span>.ss<span class="token punctuation">]</span> 替代当前时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>touch 命令的常见用法如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个名为 effyl 的新空文件</span><span class="token function">touch</span> effyl<span class="token comment" spellcheck="true"># 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件</span><span class="token function">touch</span> effyl myeffyl lueffyl<span class="token comment" spellcheck="true"># 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个</span><span class="token function">touch</span> -a effyl<span class="token comment" spellcheck="true"># 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳</span><span class="token function">touch</span> -c effyl<span class="token comment" spellcheck="true"># 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变</span><span class="token function">touch</span> -m effyl<span class="token comment" spellcheck="true"># 使用 -c 和 -t 选项，来明确设置文件的时间</span><span class="token function">touch</span> -c -t YYMMDDHHMM filename<span class="token comment" spellcheck="true"># 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项</span><span class="token function">touch</span> -r myeffyl effyl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-mkdir-创建目录"><a href="#2-mkdir-创建目录" class="headerlink" title="2.mkdir - 创建目录"></a>2.mkdir - 创建目录</h3><p><code>mkdir</code>命令用于创建一个新目录。最基本的<code>mkdir</code>命令的使用方法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下创建一个给定的目录名</span><span class="token function">mkdir</span> <span class="token operator">&lt;</span>dirname<span class="token operator">></span><span class="token comment" spellcheck="true"># 在 backup 中的相对路径创建一个名为 old 的目录</span><span class="token function">mkdir</span> backup/old<span class="token comment" spellcheck="true"># 在 backup 中的绝对路径中创建一个名为 old 的目录</span><span class="token function">mkdir</span> /home/blinkfox/backup/old<span class="token comment" spellcheck="true"># 使用 -p 选项，会自动创建所有还不存在的父目录</span><span class="token function">mkdir</span> -p backup/old<span class="token comment" spellcheck="true"># 使用 -m 选项，可以设置将要创建目录的权限</span><span class="token comment" spellcheck="true"># 如：创建一个任何人都有读写访问权限的目录</span><span class="token function">mkdir</span> -p -m 777 backup/old<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-cp-复制文件或目录"><a href="#3-cp-复制文件或目录" class="headerlink" title="3.cp - 复制文件或目录"></a>3.cp - 复制文件或目录</h3><p><code>cp</code>命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。</p><p>使用 cp 命令复制文件和目录的语法有以下几种：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制源文件到目标文件</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE DEST<span class="token comment" spellcheck="true"># 复制一个或多个源文件到一个目录</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY<span class="token comment" spellcheck="true"># 同上</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> -t DIRECTORY SOURCE<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用使用示例如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txt</span><span class="token function">cp</span> file.txt newfile.txt<span class="token comment" spellcheck="true"># 复制当前目录下的 file.txt 文件到 /tmp 目录下</span><span class="token function">cp</span> file.txt /tmp<span class="token comment" spellcheck="true"># 复制当前目录下的所有文件到 /tmp 目录下</span><span class="token function">cp</span> * /tmp<span class="token comment" spellcheck="true"># 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息</span><span class="token function">cp</span> -p filename /path/to/new/location/myfile<span class="token comment" spellcheck="true"># 使用 -R 或 -r 选项，恶意递归地复制一个目录</span><span class="token comment" spellcheck="true"># 即将一个目录及其下的所有文件和子目录都复制到另一个目录</span><span class="token function">cp</span> -R * /home/blinkfox/backup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-ln-链接文件或目录"><a href="#4-ln-链接文件或目录" class="headerlink" title="4.ln - 链接文件或目录"></a>4.ln - 链接文件或目录</h3><p><code>ln</code>命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在目录 lib 下创建一个软链接 library.so，链接到 /home/blinkfox/src/library.so</span><span class="token function">ln</span> -s /home/blinkfox/src/library.so /home/blinkfox/lib<span class="token comment" spellcheck="true"># 创建目录的软链接</span><span class="token function">ln</span> -s /home/blinkfox/src <span class="token function">source</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-mv-移动文件或目录"><a href="#5-mv-移动文件或目录" class="headerlink" title="5. mv - 移动文件或目录"></a>5. mv - 移动文件或目录</h3><p><code>mv</code>命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，<code>mv</code>命令还可用于修改文件或目录的名字。</p><p>mv 命令的基本语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mv</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将当前目录下的文件 source.txt 移到目录 /tmp 下</span><span class="token function">mv</span> source.txt /tmp<span class="token comment" spellcheck="true"># 将目录 dir1、dir2 移到目录 dir_dist 下</span><span class="token function">mv</span> dir1 dir2 dir_dist<span class="token comment" spellcheck="true"># 将当前目录下的 old.txt 文件更名为 new.txt</span><span class="token function">mv</span> old.txt new.txt<span class="token comment" spellcheck="true"># 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息</span><span class="token function">mv</span> -i old.txt new.txt<span class="token comment" spellcheck="true"># 将当前目录下的所有文件移动到目录 /tmp 下</span><span class="token function">mv</span> * /tmp/<span class="token comment" spellcheck="true"># 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录</span><span class="token function">mv</span> -u dir1/* dir2/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-rm-删除文件或目录"><a href="#6-rm-删除文件或目录" class="headerlink" title="6.rm - 删除文件或目录"></a>6.rm - 删除文件或目录</h3><p><code>rm</code>命令用于删除指定的文件和目录。其语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span><span class="token punctuation">..</span>. FILE<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>rm</code>的常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除当前目录下的文件 file1.txt、file2.txt、file3.txt</span><span class="token function">rm</span> file1.txt file2.txt file3.txt<span class="token comment" spellcheck="true"># 删除当前目录下的所有文件</span><span class="token function">rm</span> *<span class="token comment" spellcheck="true"># 删除你当前帐号主目录下的 temp 目录中的所有文件</span><span class="token function">rm</span> ~/temp/*<span class="token comment" spellcheck="true"># 使用 -i 选项，可以在删除每个文件或目录前提示用户确认</span><span class="token function">rm</span> -i *<span class="token comment" spellcheck="true"># 删除当前目录下所有以".doc"结尾的文件</span><span class="token function">rm</span> *.doc<span class="token comment" spellcheck="true"># 删除当前目录下所有文件名中包含"movie"字符串的文件</span><span class="token function">rm</span> *movie*<span class="token comment" spellcheck="true"># 删除当前目录下所有以"a"开头的文件</span><span class="token function">rm</span> a*<span class="token comment" spellcheck="true"># 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件</span><span class="token function">rm</span> ???<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名有两个字符的所有文件</span><span class="token function">rm</span> *.??<span class="token comment" spellcheck="true"># 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>abc<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件名中包含 0~9 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名是字母 c 或 h 的所有文件</span><span class="token function">rm</span> *.<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除 /tmp 目录下的所有文件及其子目录</span><span class="token function">rm</span> -rf /tmp/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>-f 删除前不提示用户确认，并忽略不存在的文件<br>-r 递归地删除目录及其下的内容</p></blockquote><h3 id="7-ls-列出文件名和目录"><a href="#7-ls-列出文件名和目录" class="headerlink" title="7. ls - 列出文件名和目录"></a>7. ls - 列出文件名和目录</h3><p><code>ls</code>命令是<code>Linux</code>中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入<code>ls</code>命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。</p><p>以下便是<code>ls</code>命令及其选项的作用说明：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 仅列出当前目录下所有文件和目录</span><span class="token function">ls</span><span class="token comment" spellcheck="true"># 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等</span><span class="token function">ls</span> -l<span class="token comment" spellcheck="true"># 将文件大小显示符合人类阅读习惯的格式</span><span class="token function">ls</span> -lh<span class="token comment" spellcheck="true"># 将使用不同的特殊字符归类不同的文件类型</span><span class="token function">ls</span> -F<span class="token comment" spellcheck="true"># 以长列表格式列出某个目录的信息</span><span class="token function">ls</span> -ld /var/log<span class="token comment" spellcheck="true"># 将递归地列出子目录的内容</span><span class="token function">ls</span> -R /etc/sysconfig/<span class="token comment" spellcheck="true"># 以长列表格式按文件或目录的修改时间倒序地列出文件和目录</span><span class="token function">ls</span> -ltr<span class="token comment" spellcheck="true"># 以长列表格式按文件大小顺序列出文件和目录</span><span class="token function">ls</span> -ls<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -a<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -A输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组<span class="token function">ls</span> -n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-cat-连接显示文件内容"><a href="#8-cat-连接显示文件内容" class="headerlink" title="8. cat - 连接显示文件内容"></a>8. cat - 连接显示文件内容</h3><p><code>cat</code> 命令也是 Linux 系统中最常用的命令之一。<code>cat</code>命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。</p><p><code>cat</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>cat</code>常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 cat 命令查看文件 /etc/group 的内容</span><span class="token function">cat</span> /etc/group<span class="token comment" spellcheck="true"># 显示多个文件的内容</span><span class="token function">cat</span> /etc/redhat-release /etc/issue<span class="token comment" spellcheck="true"># -n 选项，可以显示文件内容的行号</span><span class="token function">cat</span> -n /etc/fstab<span class="token comment" spellcheck="true"># -b 选项和 -n 选项类似，但只标识非空白行的行号</span><span class="token function">cat</span> -b /etc/fstab<span class="token comment" spellcheck="true"># -e 选项，将在每一行的结尾显示“$”字符</span><span class="token function">cat</span> -e /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。</p></blockquote><h3 id="9-less、more-分屏显示文件"><a href="#9-less、more-分屏显示文件" class="headerlink" title="9.less、more - 分屏显示文件"></a>9.less、more - 分屏显示文件</h3><p><code>more</code>命令在你使用小的 xterm 窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more 命令是一个用于一次翻阅一整屏文件的过滤器。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看一个文件，自动清空屏幕并显示文件开头部分</span><span class="token function">more</span> /etc/inittab<span class="token comment" spellcheck="true"># 指定一次显示num行</span><span class="token function">more</span> -num /etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与<code>more</code>命令相比，我个人更喜欢<code>less</code>命令来查看文件。<code>less</code>命令与<code>more</code>命令类似，但<code>less</code>命令向前和向后翻页都支持，而且<code>less</code>命令不需要在查看前加载整个文件，即<code>less</code>命令查看文件更快速。</p><p><code>less</code>常用命令参数如下：</p><pre class="line-numbers language-bash"><code class="language-bash">-b  <span class="token operator">&lt;</span>缓冲区大小<span class="token operator">></span> 设置缓冲区的大小-e  当文件显示结束后，自动离开-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g  只标志最后搜索的关键词-i  忽略搜索时的大小写-m  显示类似more命令的百分比-N  显示每行的行号-o  <span class="token operator">&lt;</span>文件名<span class="token operator">></span> 将less 输出的内容在指定文件中保存起来-Q  不使用警告音-s  显示连续空行为一行-S  行过长时间将超出部分舍弃-x  <span class="token operator">&lt;</span>数字<span class="token operator">></span> 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n： 重复前一个搜索（与 / 或 ? 有关）N： 反向重复前一个搜索（与 / 或 ? 有关）b  向后翻一页d  向后翻半页h  显示帮助界面Q  退出less 命令u  向前滚动半页y  向前滚动一行空格键 滚动一行回车键 滚动一页<span class="token punctuation">[</span>pagedown<span class="token punctuation">]</span>： 向下翻动一页<span class="token punctuation">[</span>pageup<span class="token punctuation">]</span>：   向上翻动一页<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-head-显示文件头部"><a href="#10-head-显示文件头部" class="headerlink" title="10.head - 显示文件头部"></a>10.head - 显示文件头部</h3><p><code>head</code>命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前 10 行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的前 N 行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的前5行</span><span class="token function">head</span> -n 5 /etc/inittab（或）head -5 /etc/inittab<span class="token comment" spellcheck="true"># 打印文件的前N个字节的数据</span><span class="token function">head</span> -c 10 /etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-tail-显示文件尾部"><a href="#11-tail-显示文件尾部" class="headerlink" title="11.tail - 显示文件尾部"></a>11.tail - 显示文件尾部</h3><p><code>tail</code>命令和<code>head</code>命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后 10 行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的最后 N 行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的后10行</span><span class="token function">tail</span> -n 10 /etc/inittab<span class="token function">tail</span> -10 /etc/inittab<span class="token comment" spellcheck="true"># 即时打印文件中新写入的行</span><span class="token function">tail</span> -f /var/log/messages<span class="token comment" spellcheck="true"># --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件</span><span class="token function">tail</span> -f /tmp/debug.log --retry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-file-查看文件类型"><a href="#12-file-查看文件类型" class="headerlink" title="12.file - 查看文件类型"></a>12.file - 查看文件类型</h3><p><code>file</code>命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看文件类型</span><span class="token function">file</span> /etc/inittab<span class="token comment" spellcheck="true"># 可以MIME类型的格式显示文件类型的信息</span><span class="token function">file</span> -i  /etc/inittab<span class="token comment" spellcheck="true"># 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示</span><span class="token function">file</span> -N *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-wc-查看文件统计信息"><a href="#13-wc-查看文件统计信息" class="headerlink" title="13.wc - 查看文件统计信息"></a>13.wc - 查看文件统计信息</h3><p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wc</span> filenameX Y Z /etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中 X 表示行数，Y 表示单词数，Z 表示字节数，filename 表示文件名。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -l选项，可以只统计文件的行数信息</span><span class="token function">wc</span> -l /etc/inittab<span class="token comment" spellcheck="true"># -w选项，可以只统计文件的单词数信息</span><span class="token function">wc</span> -w /etc/inittab<span class="token comment" spellcheck="true"># -c选项，可以只统计文件的字节数信息</span><span class="token function">wc</span> -c /etc/inittab<span class="token comment" spellcheck="true"># -L选项，可以只统计文件中最长的行的长度</span><span class="token function">wc</span> -L /etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="14-find-查找文件或目录"><a href="#14-find-查找文件或目录" class="headerlink" title="14.find - 查找文件或目录"></a>14.find - 查找文件或目录</h3><p><code>find</code>命令用于根据你指定的参数搜索和定位文件和目录的列表。<code>find</code>命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。</p><p><code>find</code>命令常用使用和说明如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查找指定目录下的某个文件</span><span class="token function">find</span> /etc/ -name inittab<span class="token comment" spellcheck="true"># 在当前目录下查找名称为 inittab 的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -name inittab<span class="token comment" spellcheck="true"># 在当前目录下，文件不区分大小写是example的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -iname example<span class="token comment" spellcheck="true"># 找出当前目录下所有以 sh 结尾的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -name <span class="token string">"*.sh"</span><span class="token comment" spellcheck="true"># 找出当前目录下，文件权限是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下，文件权限不是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下所有只读文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm /a+w<span class="token comment" spellcheck="true"># 找出你帐号主目录下的所有可执行文件</span><span class="token function">find</span> ~ -type f -perm /a+w<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的.log文件并将其删除：</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">"*.log"</span> -exec <span class="token function">rm</span> -f <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 找出当前目录下的所有空文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -empty<span class="token comment" spellcheck="true"># 找出当前目录下的所有空目录</span><span class="token function">find</span> <span class="token keyword">.</span> -type d -empty<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的所有隐藏文件</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">".*"</span><span class="token comment" spellcheck="true"># 找出 /tmp 目录下，所有者是 root 的文件和目录</span><span class="token function">find</span> /tmp/ -user root<span class="token comment" spellcheck="true"># 找出 /tmp 目录下，用户组是 developer 的文件和目录</span><span class="token function">find</span> /tmp/ -group root<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天前修改的文件</span><span class="token function">find</span> ~ -type f -mtime 3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime -3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30 -mtime -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内变更过的文件</span><span class="token function">find</span> /etc -type f -cmin -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内访问过的文件</span><span class="token function">find</span> /etc -type f -amin -60<span class="token comment" spellcheck="true"># 找出你账号主目录下，大小是50MB的所有文件</span><span class="token function">find</span> ~ -type f -size 50MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于50MB小于100MB的所有文件</span><span class="token function">find</span> ~ -type f -size +50MB -size -100MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于100MB的文件并将其删除</span><span class="token function">find</span> ~ -type f -size +100MB -exec <span class="token function">rm</span> -rf <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="1-sort-文本排序"><a href="#1-sort-文本排序" class="headerlink" title="1. sort - 文本排序"></a>1. sort - 文本排序</h3><p><code>sort</code>命令用于将文本文件的行排序。默认情况下，<code>sort</code>命令是按照字符串的字母顺序排序。</p><p>sort 的常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将文本内容按字母顺序排序</span><span class="token function">sort</span> example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，移除所有重复行后排序</span><span class="token function">sort</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -n 选项，将令数字按数值的大小排序</span><span class="token function">sort</span> -n example.txt<span class="token comment" spellcheck="true"># 使用 -r 选项，以倒序方式排序</span><span class="token function">sort</span> -n -r example.txt<span class="token comment" spellcheck="true"># 同时将 file1、file2 的内容排序</span><span class="token function">sort</span> file1 file2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-uniq-文本去重"><a href="#2-uniq-文本去重" class="headerlink" title="2.uniq - 文本去重"></a>2.uniq - 文本去重</h3><p><code>uniq</code>命令用于移除或发现文件中重复的条目。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 它将移除文件中重复的行并显示单一行</span><span class="token function">uniq</span> example.txt<span class="token comment" spellcheck="true"># 可以统计重复行出现的次数</span><span class="token function">uniq</span> -c example.txt<span class="token comment" spellcheck="true"># 使用 -d 选项，只显示文件中有重复的行并只显示一次</span><span class="token function">uniq</span> -d example.txt<span class="token comment" spellcheck="true"># 使用 -D 选项，显示文件中所有重复的行</span><span class="token function">uniq</span> -D example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，只显示文件中不重复的行</span><span class="token function">uniq</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复</span><span class="token function">uniq</span> -w 3 example.txt<span class="token comment" spellcheck="true"># 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复</span><span class="token function">uniq</span> -s 3 example.txt<span class="token comment" spellcheck="true"># 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复</span><span class="token function">uniq</span> -f 1 example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-tr-替换或删除字符"><a href="#3-tr-替换或删除字符" class="headerlink" title="3.tr - 替换或删除字符"></a>3.tr - 替换或删除字符</h3><p><code>tr</code>命令主要用于删除文件中控制字符或进行字符转换。使用<code>tr</code>时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。<code>tr</code>刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。</p><p><code>tr</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">tr</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. SET1 <span class="token punctuation">[</span>SET2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用命令示例：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 若要将大括号转换为小括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'()'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将大括号转换成方括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'\[]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将小写字符转换成大写，请输入：</span><span class="token function">tr</span> <span class="token string">'a-z'</span> <span class="token string">'A-Z'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要创建一个文件中的单词列表</span><span class="token function">tr</span> -cs <span class="token string">'[:lower:][:upper:]'</span> <span class="token string">'[\n*]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要从某个文件中删除所有空字符</span><span class="token function">tr</span> -d <span class="token string">'\0'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要用单独的换行替换每一序列的一个或多个换行，请输入：</span><span class="token function">tr</span> -s <span class="token string">'\n'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 要以单个“#”字符替换 &lt;space> 字符类中的每个字符序列</span><span class="token function">tr</span> -s <span class="token string">'[:space:]'</span> <span class="token string">'[#*]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-grep-查找字符串"><a href="#4-grep-查找字符串" class="headerlink" title="4.grep - 查找字符串"></a>4.grep - 查找字符串</h3><p><code>grep</code>命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，<code>grep</code>命令只显示匹配的行。</p><p><code>grep</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. PATTERN <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>-e PATTERN <span class="token operator">|</span> -f FILE<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># `grep`命令查找文件/etc/passwd 中帐号 blinkfox 的信息</span><span class="token function">grep</span> blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写</span><span class="token function">grep</span> -i blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -r 选项，可以递归搜索指定目录下的所有文件</span><span class="token function">grep</span> -r blinkfox /etc/<span class="token comment" spellcheck="true"># 使用 -w 选项，只匹配包含指定单词的行</span><span class="token function">grep</span> -w blinkfox /etc/<span class="token comment" spellcheck="true"># 使用 -c 选项，报告文件或文本中模式被匹配的次数</span><span class="token function">grep</span> -c blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -n 选项，显示每一个匹配的行的行号</span><span class="token function">grep</span> -n blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行</span><span class="token function">grep</span> -v blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出</span><span class="token function">grep</span> --color blinkfox /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-diff-比较两个文件"><a href="#5-diff-比较两个文件" class="headerlink" title="5.diff - 比较两个文件"></a>5.diff - 比较两个文件</h3><p><code>diff</code>命令用于比较两个文件，并找出它们之间的不同。<code>diff</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">diff</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. from-file to-file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用使用方式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 比较两个文件</span><span class="token function">diff</span> nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -w 选项，比较时忽略空格</span><span class="token function">diff</span> -w nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -y 选项，以并排的格式输出两个文件的比较结果</span><span class="token function">diff</span> -y nsswitch.conf nsswitch.conf.org使用 -c 选项，以上下对比的格式输出两个文件的比较结果<span class="token function">diff</span> -c nsswitch.conf nsswitch.conf.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/</a></li><li>[2] <a href="https://blinkfox.github.io/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/</a></li><li>[3] <a href="https://blinkfox.github.io/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/</a></li><li><a href="https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Pages+Jekyll+Minimal-Mistakes搭建个人博客</title>
      <link href="/2019/061036412.html"/>
      <url>/2019/061036412.html</url>
      
        <content type="html"><![CDATA[<p>Github pages官方推荐使用Jekyll生成静态网页，jekyll支持各种不同的主题。Minimal Mistakes 是一个灵活的两栏 Jekyll 简约风格主题，非常适合建立个人网站、博客和作品集。除了外观设置外，还支持文章评论、文章搜索、文章标签、文章分类等增强和定制。</p><h2 id="安装Github-pages-Jekyll"><a href="#安装Github-pages-Jekyll" class="headerlink" title="安装Github pages + Jekyll"></a>安装Github pages + Jekyll</h2><ol><li>在github上Fork<a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">mmistakes/minimal-mistakes</a></li><li>参考<a href="https://pages.github.com/" target="_blank" rel="noopener">github pages主页</a>, 设置Fork来的仓库名为 {username}.github.io/blog，并启用GitHub Pages</li><li>clone <code>{username}.github.io/blog</code> 到本地 $Github/lxl80/blog目录</li><li>本地安装jekyll并建立博客</li></ol><pre class="line-numbers language-bash"><code class="language-bash">gem <span class="token function">install</span> jekyll bundler//建立myblog并复制内容到根目录后删除myblog//如果直接在根目录建立，github在编译时可能会软连接错误，暂不知原因<span class="token function">cd</span> <span class="token variable">$Github</span>/lxl80/blog<span class="token function">rm</span> Gemfilejekyll new blogtemp<span class="token function">cd</span> blogtemp<span class="token function">cp</span> -r * <span class="token punctuation">..</span>/<span class="token function">cd</span> <span class="token punctuation">..</span><span class="token function">rm</span> -rf blogtemp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用Minimal-Mistakes主题"><a href="#使用Minimal-Mistakes主题" class="headerlink" title="使用Minimal-Mistakes主题"></a>使用Minimal-Mistakes主题</h2><ol><li><p>修改Gemfile:<br>替换<code>gem &quot;jekyll&quot;</code> 为 <code>gem &quot;github-pages&quot;, group: :jekyll_plugins</code></p></li><li><p>修改_config.yml:<br>替换<code>theme</code>为<code>remote_theme: &quot;mmistakes/minimal-mistakes&quot;</code></p></li><li><p>运行<code>bundle update</code>更新主题</p></li><li><p>更改about.md和 _posts/0000-00-00-welcome-to-jekyll.markdown 中 layout为single。</p></li><li><p>在根目录下删除<code>index.md</code>，添加<code>index.html</code>，内容如下：</p></li></ol><pre class="line-numbers language-bash"><code class="language-bash">---layout: homeauthor_profile: <span class="token boolean">true</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>运行<code>bundle exec jekyll serve</code><br>如果碰到No GitHub API authentication could be found.的问题，参考<a href="https://link.jianshu.com/?t=http%3A%2F%2Fidratherbewriting.com%2Fdocumentation-theme-jekyll%2Fmydoc_install_jekyll_on_mac.html%23githuberror" target="_blank" rel="noopener">Resolve ERRORS</a>。</li><li>访问<code>127.0.0.1:4000</code>查看页面</li><li>push到github，访问commits页面查看部署状态。</li><li>访问<code>{username}.github.io</code>查看博客主页。</li></ol><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="修改Markdown-高亮配色"><a href="#修改Markdown-高亮配色" class="headerlink" title="修改Markdown 高亮配色"></a>修改Markdown 高亮配色</h3><p>Jekyll使用rough作为代码高亮工具，不同的皮肤设置(minimal_mistakes_skin)有不同的高亮配色，这里我使用contrast皮肤，但代码高亮希望将背景从深色改为白色。</p><ol><li>在gems目录/usr/local/lib/ruby/gems/2.4.0/gems/minimal-mistakes-jekyll-{version}下复制 _sass 到博客根目录。</li><li>修改_sass/minimal-mistakes/skins/_contrast.scss，替换 syntax highlighting (base16) 设置，参考<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmmistakes.github.io%2Fminimal-mistakes%2Fdocs%2Fstylesheets%2F%23colors" target="_blank" rel="noopener">Sylesheet/Color</a>。</li></ol><pre class="line-numbers language-bash"><code class="language-bash">/* solarized light syntax highlighting <span class="token punctuation">(</span>base16<span class="token punctuation">)</span> */<span class="token variable">$base00</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#fafafa !default;</span><span class="token variable">$base01</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#073642 !default;</span><span class="token variable">$base02</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#586e75 !default;</span><span class="token variable">$base03</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#657b83 !default;</span><span class="token variable">$base04</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#839496 !default;</span><span class="token variable">$base05</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#586e75 !default;</span><span class="token variable">$base06</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#eee8d5 !default;</span><span class="token variable">$base07</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#fdf6e3 !default;</span><span class="token variable">$base08</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#dc322f !default;</span><span class="token variable">$base09</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#cb4b16 !default;</span><span class="token variable">$base0a</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#b58900 !default;</span><span class="token variable">$base0b</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#859900 !default;</span><span class="token variable">$base0c</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#2aa198 !default;</span><span class="token variable">$base0d</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#268bd2 !default;</span><span class="token variable">$base0e</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#6c71c4 !default;</span><span class="token variable">$base0f</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#d33682 !default;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行 <code>bundle update</code></p><h3 id="设置文字大小"><a href="#设置文字大小" class="headerlink" title="设置文字大小"></a>设置文字大小</h3><p>修改 _sass/minimal-mistakes/_variables.scss 对应font-size。</p><h2 id="添加Disqus评论支持"><a href="#添加Disqus评论支持" class="headerlink" title="添加Disqus评论支持"></a>添加Disqus评论支持</h2><ol><li>参考I want to install disqus on my site注册，添加网站并得到shortname。</li><li>设置_config.yml</li></ol><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">comments</span><span class="token punctuation">:</span><span class="token key atrule">provider</span><span class="token punctuation">:</span> <span class="token string">"disqus"</span><span class="token key atrule">disqus</span><span class="token punctuation">:</span>    <span class="token key atrule">shortname</span><span class="token punctuation">:</span> <span class="token string">"your-disqus-shortname"</span>//<span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token key atrule">default</span><span class="token punctuation">:</span>    <span class="token key atrule">comments</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">Minimal Mistakes Jekyll theme</a></li><li><a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">Minimal Mistakes Quick-Start Guide</a></li><li><a href="https://jekyllrb.com/docs/" target="_blank" rel="noopener">Jekyll docs</a></li><li><a href="https://www.jianshu.com/p/d19eede28520" target="_blank" rel="noopener">Github pages + Minimal-Mistakes + Disqus建立个人博客记录</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Jekyll </tag>
            
            <tag> Minimal-Mistakes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、升级chaincode和背书策略</title>
      <link href="/2019/06048442.html"/>
      <url>/2019/06048442.html</url>
      
        <content type="html"><![CDATA[<h2 id="八、升级chaincode和背书策略"><a href="#八、升级chaincode和背书策略" class="headerlink" title="八、升级chaincode和背书策略"></a>八、升级chaincode和背书策略</h2><h3 id="1、为新组织安装-2-0-版本的-chaincode"><a href="#1、为新组织安装-2-0-版本的-chaincode" class="headerlink" title="1、为新组织安装 2.0 版本的 chaincode"></a>1、为新组织安装 2.0 版本的 chaincode</h3><p>其他组织的 chaincode 版本号是 1，新组织需要更新此版本的 chaincode，因此为新组织直接安装版本为 2 的 chaincode，省得先安装再升级。</p><pre class="line-numbers language-bash"><code class="language-bash">peer chaincode <span class="token function">install</span> -n cfistore -v 2 -p github.com/hyperledger/fabric/chaincode/go/cfistore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、为其他组织安装-2-0-版本-chaincode"><a href="#2、为其他组织安装-2-0-版本-chaincode" class="headerlink" title="2、为其他组织安装 2.0 版本 chaincode"></a>2、为其他组织安装 2.0 版本 chaincode</h3><p>登录每个联盟原有组织 cli，逐一进行更新。</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span>peer chaincode <span class="token function">install</span> -n cfistore -v 2 -p github.com/hyperledger/fabric/chaincode/go/cfistorepeer chaincode upgrade -n cfistore -v 7 -c <span class="token string">'{"Args":["init"]}'</span> -o orderer0.fabric.mbfa.cn:7050 -C cfichannel -P <span class="token string">"OR ('MbfaMSP.member','MscMSP.member','CfecMSP.member','VteamMSP.member')"</span>// 查看channel中已经实例化的链码peer chaincode list --instantiated -C cfichannel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、升级背书策略"><a href="#3、升级背书策略" class="headerlink" title="3、升级背书策略"></a>3、升级背书策略</h3><p>升级背书策略，-v 2 指明版本号，-P “AND (‘MbfaMSP.peer’,’CfecMSP.peer’)”指明新的背书策略（添加了 CfecOrg）。</p><pre class="line-numbers language-bash"><code class="language-bash"> peer chaincode upgrade -n cfistore -v 2 -c <span class="token string">'{"Args":["init"]}'</span> -o orderer0.fabric.mbfa.cn:7050 -C cfichannel -P <span class="token string">"AND ('MbfaMSP.peer','CfecMSP.peer')"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>peer chaincode upgrade 命令将为区块链新增一个块，可以在其他的 peer 的输出中查看。</p><p>查询链码</p><pre class="line-numbers language-bash"><code class="language-bash">peer chaincode query -C cfichannel -n cfistore -c <span class="token string">'{"Args":["query","a"]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、新组织加入channel</title>
      <link href="/2019/060442290.html"/>
      <url>/2019/060442290.html</url>
      
        <content type="html"><![CDATA[<h2 id="七、新组织申请添加到channel中"><a href="#七、新组织申请添加到channel中" class="headerlink" title="七、新组织申请添加到channel中"></a>七、新组织申请添加到channel中</h2><p>启动新组织节点，登录cli，加入到新channel：</p><pre class="line-numbers language-bash"><code class="language-bash">docker-compose -f cfi.yaml updocker <span class="token function">exec</span> -it cli <span class="token function">bash</span><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem<span class="token function">export</span> CHANNEL_NAME<span class="token operator">=</span>cfitestchannel//从 orderer 中获取 channel 创世块配置peer channel fetch 0 cfitestchannel.block -o orderer0.fabric.mbfa.cn:7050 -c <span class="token variable">$CHANNEL_NAME</span> --cafile <span class="token variable">$ORDERER_CA</span>peer channel <span class="token function">join</span> -b cfitestchannel.block<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、新组织加入联盟审核</title>
      <link href="/2019/060416039.html"/>
      <url>/2019/060416039.html</url>
      
        <content type="html"><![CDATA[<h2 id="六、联盟组织生成和提交新-org-配置"><a href="#六、联盟组织生成和提交新-org-配置" class="headerlink" title="六、联盟组织生成和提交新 org 配置"></a>六、联盟组织生成和提交新 org 配置</h2><p>通过 step 3~4，已经生成了 Sy 的证书和配置，但这仅仅是在本地文件系统，还未于区块链网络产生关联。为 channel 新加 Org，对 Fabric而言，是以一笔交易的形式提交的。因此要使得这笔交易能顺利完成，需要提交Sy的配置，到channel中，获得权限认证；然后于网络中发起更新的交易。</p><h3 id="1、登录联盟管理组织的cli"><a href="#1、登录联盟管理组织的cli" class="headerlink" title="1、登录联盟管理组织的cli"></a>1、登录联盟管理组织的cli</h3><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、安装-jq-工具"><a href="#2、安装-jq-工具" class="headerlink" title="2、安装 jq 工具"></a>2、安装 jq 工具</h3><p>jq 是 Linux 下命令行处理 JSON 的工具，可以对 JSON 进行过滤、格式化、修改等等操作。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">apt-get</span> -y update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> jq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、设置orderer-TLS-CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）"><a href="#3、设置orderer-TLS-CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）" class="headerlink" title="3、设置orderer TLS CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）"></a>3、设置orderer TLS CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、获取准备加入channel的配置"><a href="#4、获取准备加入channel的配置" class="headerlink" title="4、获取准备加入channel的配置"></a>4、获取准备加入channel的配置</h3><pre class="line-numbers language-bash"><code class="language-bash">peer channel fetch config vtm_config_block.pb -o orderer0.fabric.mbfa.cn:7050 -c cfitestchannel --cafile <span class="token variable">$ORDERER_CA</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5、联盟管理组织修改原channel配置文件-增加新组织"><a href="#5、联盟管理组织修改原channel配置文件-增加新组织" class="headerlink" title="5、联盟管理组织修改原channel配置文件, 增加新组织"></a>5、联盟管理组织修改原channel配置文件, 增加新组织</h3><h4 id="5-1、解码原有网络的配置文件"><a href="#5-1、解码原有网络的配置文件" class="headerlink" title="5.1、解码原有网络的配置文件"></a>5.1、解码原有网络的配置文件</h4><pre class="line-numbers language-bash"><code class="language-bash">将准备加入channel的pb格式配置信息转换成json格式configtxlator proto_decode --input vtm_config_block.pb --type common.Block <span class="token operator">|</span> jq .data.data<span class="token punctuation">[</span>0<span class="token punctuation">]</span>.payload.data.config <span class="token operator">></span> vtm_config.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成文件内容类似set2中syorg.json内容</p><h4 id="5-2、使用jq工具，合并cfiorg-json与cfi-config-json-形成增加新组织后的完整json格式的配置更新文件"><a href="#5-2、使用jq工具，合并cfiorg-json与cfi-config-json-形成增加新组织后的完整json格式的配置更新文件" class="headerlink" title="5.2、使用jq工具，合并cfiorg.json与cfi_config.json, 形成增加新组织后的完整json格式的配置更新文件"></a>5.2、使用jq工具，合并cfiorg.json与cfi_config.json, 形成增加新组织后的完整json格式的配置更新文件</h4><pre class="line-numbers language-bash"><code class="language-bash">jq -s <span class="token string">'.[0] * {"channel_group":{"groups":{"Application":{"groups": {"VtmMSP":.[1]}}}}}'</span> vtm_config.json ./channel-artifacts/vtmorg.json <span class="token operator">></span> vtm_modified_config.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-3、将-config-json-和-modified-config-json-转为-protobuf-格式"><a href="#5-3、将-config-json-和-modified-config-json-转为-protobuf-格式" class="headerlink" title="5.3、将 config.json 和 modified_config.json 转为 protobuf 格式"></a>5.3、将 config.json 和 modified_config.json 转为 protobuf 格式</h4><pre class="line-numbers language-bash"><code class="language-bash">configtxlator proto_encode --input vtm_config.json --type common.Config <span class="token operator">></span> vtm_config.pbconfigtxlator proto_encode --input vtm_modified_config.json --type common.Config <span class="token operator">></span> vtm_modified_config.pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-4、根据-config-pb-和-modified-config-pb-计算出-org3-update-pb-，计算出增量更新内容。-类似于-diff-操作，但是针对-protobuf-格式，因此会多出好多操作。"><a href="#5-4、根据-config-pb-和-modified-config-pb-计算出-org3-update-pb-，计算出增量更新内容。-类似于-diff-操作，但是针对-protobuf-格式，因此会多出好多操作。" class="headerlink" title="5.4、根据 config.pb 和 modified_config.pb 计算出 org3_update.pb ，计算出增量更新内容。 (类似于 diff 操作，但是针对 protobuf 格式，因此会多出好多操作。)"></a>5.4、根据 config.pb 和 modified_config.pb 计算出 org3_update.pb ，计算出增量更新内容。 (类似于 diff 操作，但是针对 protobuf 格式，因此会多出好多操作。)</h4><pre class="line-numbers language-bash"><code class="language-bash">configtxlator compute_update --channel_id cfitestchannel --original vtm_config.pb --updated vtm_modified_config.pb <span class="token operator">></span> vtm_config_update.pb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-5、解码-config-update-pb-为-json，然后用-jq-修改，然后在编码为-protobuf-格式，最终输出-syorg-update-in-envelope-pb"><a href="#5-5、解码-config-update-pb-为-json，然后用-jq-修改，然后在编码为-protobuf-格式，最终输出-syorg-update-in-envelope-pb" class="headerlink" title="5.5、解码 config_update.pb 为 json，然后用 jq 修改，然后在编码为 protobuf 格式，最终输出 syorg_update_in_envelope.pb"></a>5.5、解码 config_update.pb 为 json，然后用 jq 修改，然后在编码为 protobuf 格式，最终输出 syorg_update_in_envelope.pb</h4><pre class="line-numbers language-bash"><code class="language-bash">configtxlator proto_decode --input cfi_config_update.pb  --type common.ConfigUpdate <span class="token operator">></span> cfi_config_update.json<span class="token keyword">echo</span> <span class="token string">'{"payload":{"header":{"channel_header":{"channel_id":"cfitestchannel", "type":2}},"data":{"config_update":'</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> cfi_config_update.json<span class="token variable">)</span></span><span class="token string">'}}}'</span> <span class="token operator">|</span> jq <span class="token keyword">.</span> <span class="token operator">></span> cfi_config_update_in_envelope.jsonconfigtxlator proto_encode --input cfi_config_update_in_envelope.json --type common.Envelope <span class="token operator">></span> cfiorg_update_in_envelope.pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6、为新组织配置签名"><a href="#6、为新组织配置签名" class="headerlink" title="6、为新组织配置签名"></a>6、为新组织配置签名</h3><p>为配置交易签名，需要 channel 中的大多数 Org 对其进行签名。<br>对于 mychannel 而言，已有了 org1，org2，因此新增 org3 时需要 org1、org2 都签名。<br>签名操作于 cli 中完成，需采用 Anchor Peer，可通过更改环境变量，改变签名者的身份。</p><h4 id="6-1、MBFA组织签名"><a href="#6-1、MBFA组织签名" class="headerlink" title="6.1、MBFA组织签名"></a>6.1、MBFA组织签名</h4><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span>组织签名peer channel signconfigtx -f cfiorg_update_in_envelope.pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2、登录MSC组织CLI继续签名"><a href="#6-2、登录MSC组织CLI继续签名" class="headerlink" title="6.2、登录MSC组织CLI继续签名"></a>6.2、登录MSC组织CLI继续签名</h4><p>（下载MBFA签名后的syorg_update_in_envelope.pb上传到msc组织CLI中，参照MBFA将syorg_update_in_envelope.pb进行签名。）</p><h3 id="7、提交签名后的配置交易至orderer"><a href="#7、提交签名后的配置交易至orderer" class="headerlink" title="7、提交签名后的配置交易至orderer"></a>7、提交签名后的配置交易至orderer</h3><p>注意：需要将syorg_update_in_envelope.pb注意上传到老组织，并逐一叠加签名。然后由生产此pb文件的组织提交更新。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pempeer channel update -f cfiorg_update_in_envelope.pb -c cfitestchannel -o orderer0.fabric.mbfa.cn:7050 --cafile <span class="token variable">$ORDERER_CA</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若成功入链，可以看到以下输出：</p><pre class="line-numbers language-bash"><code class="language-bash">2018-11-01 13:45:17.982 UTC <span class="token punctuation">[</span>kvledger<span class="token punctuation">]</span> CommitWithPvtData -<span class="token operator">></span> INFO 066 <span class="token punctuation">[</span>mbfastorechannel<span class="token punctuation">]</span> Committed block <span class="token punctuation">[</span>2<span class="token punctuation">]</span> with 1 transaction<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> 19ms <span class="token punctuation">(</span>state_validation<span class="token operator">=</span>0ms block_commit<span class="token operator">=</span>13ms state_commit<span class="token operator">=</span>3ms<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出显示，当前提交的块号是 6。块 0 是创世块；1<del>2 是一些初始化；3</del>4 是实例化与调用 chaincode ，更新配置。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、配置新组织节点</title>
      <link href="/2019/060441103.html"/>
      <url>/2019/060441103.html</url>
      
        <content type="html"><![CDATA[<h2 id="五、在新组织节点使用configtxgen生成SyOrg配置JSON文件"><a href="#五、在新组织节点使用configtxgen生成SyOrg配置JSON文件" class="headerlink" title="五、在新组织节点使用configtxgen生成SyOrg配置JSON文件"></a>五、在新组织节点使用configtxgen生成SyOrg配置JSON文件</h2><h3 id="1、生成组织配置文件"><a href="#1、生成组织配置文件" class="headerlink" title="1、生成组织配置文件"></a>1、生成组织配置文件</h3><p>configtx会在当前目录中寻找configtx.yaml配置文件并从中读取SyOrg相关配置。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> org3-artifacts./configtxgen -printOrg SyOrg -profile ./configtx.yaml <span class="token operator">></span> <span class="token punctuation">..</span>/channel-artifacts/syorg.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="configtx-yaml配置文件如下"><a href="#configtx-yaml配置文件如下" class="headerlink" title="configtx.yaml配置文件如下"></a>configtx.yaml配置文件如下</h4><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">Organizations</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token important">&amp;SyOrg</span>        <span class="token key atrule">Name</span><span class="token punctuation">:</span> SyOrg        <span class="token key atrule">ID</span><span class="token punctuation">:</span> SyMSP        <span class="token key atrule">MSPDir</span><span class="token punctuation">:</span> crypto<span class="token punctuation">-</span>config/peerOrganizations/sy.fabric.mbfa.cn/msp        <span class="token key atrule">Policies</span><span class="token punctuation">:</span> <span class="token important">&amp;SyOrgPolicies</span>            <span class="token key atrule">Readers</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.member')"</span>            <span class="token key atrule">Writers</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.member')"</span>            <span class="token key atrule">Admins</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.admin')"</span>        <span class="token key atrule">AnchorPeers</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">Host</span><span class="token punctuation">:</span> peer.sy.fabric.mbfa.cn              <span class="token key atrule">Port</span><span class="token punctuation">:</span> <span class="token number">7051</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、配置新组织节点"><a href="#2、配置新组织节点" class="headerlink" title="2、配置新组织节点"></a>2、配置新组织节点</h3><p>修改cfi.yaml配置文件，需要检查环境差异。需要注意docker配置文件中对应的fabric链镜像版本号。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mv</span> org3-artifacts/crypto-config <span class="token keyword">.</span><span class="token function">cat</span> /etc/resolv.conf//此为正常配置    nameserver 127.0.0.11    options ndots:0//如果输出结果如下，需要在docker compose yaml模板增加环境变量，GODEBUG<span class="token operator">=</span>netdns<span class="token operator">=</span>go以强制使用pure Go resolver    nameserver 127.0.0.11    options timeout:2 attempts:3 rotate single-request-reopen ndots:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、在新组织节点生成证书</title>
      <link href="/2019/060422060.html"/>
      <url>/2019/060422060.html</url>
      
        <content type="html"><![CDATA[<h2 id="四、在新组织节点（ORG）生成证书"><a href="#四、在新组织节点（ORG）生成证书" class="headerlink" title="四、在新组织节点（ORG）生成证书"></a>四、在新组织节点（ORG）生成证书</h2><h3 id="1、生成证书命令"><a href="#1、生成证书命令" class="headerlink" title="1、生成证书命令"></a>1、生成证书命令</h3><p>(依据 crypto-config.yaml 生成，生成后的文件位于 org3-artifacts/crypto-config/ 下)：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> org3-artifacts./cryptogen generate --config<span class="token operator">=</span>./crypto-config.yaml --output ./crypto-config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2、crypto-config-yamll-文件如下"><a href="#2、crypto-config-yamll-文件如下" class="headerlink" title="2、crypto-config.yamll 文件如下"></a>2、crypto-config.yamll 文件如下</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">PeerOrgs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">Name</span><span class="token punctuation">:</span> SyOrg    <span class="token key atrule">Domain</span><span class="token punctuation">:</span> sy.fabric.mbfa.cn    <span class="token key atrule">CA</span><span class="token punctuation">:</span>        <span class="token key atrule">Country</span><span class="token punctuation">:</span> CN        <span class="token key atrule">Province</span><span class="token punctuation">:</span> Beijing        <span class="token key atrule">Locality</span><span class="token punctuation">:</span> Beijing    <span class="token key atrule">Specs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">Hostname</span><span class="token punctuation">:</span> peer    <span class="token key atrule">Users</span><span class="token punctuation">:</span>      <span class="token key atrule">Count</span><span class="token punctuation">:</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、新建channel</title>
      <link href="/2019/060423381.html"/>
      <url>/2019/060423381.html</url>
      
        <content type="html"><![CDATA[<h2 id="三、新建channel"><a href="#三、新建channel" class="headerlink" title="三、新建channel"></a>三、新建channel</h2><p>（MBFA组织任意节点上执行）</p><h3 id="1、创建交易文件"><a href="#1、创建交易文件" class="headerlink" title="1、创建交易文件"></a>1、创建交易文件</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span>:/data/fabric/bin<span class="token function">export</span> ORDERER_GENERAL_GENESISPROFILE<span class="token operator">=</span>MbfaGenesisconfigtxgen -profile MbfaChannel -outputCreateChannelTx ./channel-artifacts/sycfinchannel.tx -channelID syfinchannel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2、为新组织创建channel"><a href="#2、为新组织创建channel" class="headerlink" title="2、为新组织创建channel"></a>2、为新组织创建channel</h3><p>登录docker cli</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、发起创建channel交易"><a href="#3、发起创建channel交易" class="headerlink" title="3、发起创建channel交易"></a>3、发起创建channel交易</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> CORE_PEER_ADDRESS<span class="token operator">=</span>am.mbfa.fabric.mbfa.cn:7051<span class="token function">export</span> CORE_PEER_LOCALMSPID<span class="token operator">=</span>MbfaMSP<span class="token function">export</span> CORE_PEER_TLS_ENABLED<span class="token operator">=</span>false<span class="token function">export</span> CORE_PEER_TLS_CERT_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/server.crt<span class="token function">export</span> CORE_PEER_TLS_KEY_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/server.key<span class="token function">export</span> CORE_PEER_TLS_ROOTCERT_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/ca.crt<span class="token function">export</span> CORE_PEER_MSPCONFIGPATH<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/users/Admin@mbfa.fabric.mbfa.cn/msppeer channel create -o orderer0.fabric.mbfa.cn:7050 -c syfinchannel -f ./channel-artifacts/syfinchannel.tx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、新组织基础环境安装</title>
      <link href="/2019/060413766.html"/>
      <url>/2019/060413766.html</url>
      
        <content type="html"><![CDATA[<h2 id="二、新组织基础环境安装"><a href="#二、新组织基础环境安装" class="headerlink" title="二、新组织基础环境安装"></a>二、新组织基础环境安装</h2><h3 id="1、安装epel源"><a href="#1、安装epel源" class="headerlink" title="1、安装epel源"></a>1、安装epel源</h3><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> epel-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、安装依赖包"><a href="#2、安装依赖包" class="headerlink" title="2、安装依赖包"></a>2、安装依赖包</h3><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> snappy-devel.x86_64 zlib-devel.x86_64 bzip2-devel.x86_64 libtool-ltdl-devel.x86_64 libtool <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、安装docker"><a href="#3、安装docker" class="headerlink" title="3、安装docker"></a>3、安装docker</h3><pre class="line-numbers language-bash"><code class="language-bash">yum localinstall docker-ce-18.05.0.ce-3.el7.centos.x86_64.rpm <span class="token punctuation">(</span>安装包见附件<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、安装docker-compose"><a href="#4、安装docker-compose" class="headerlink" title="4、安装docker-compose"></a>4、安装docker-compose</h3><pre class="line-numbers language-bash"><code class="language-bash">curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">></span> /usr/local/bin/docker-compose<span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5、配置docker源（如果不配置拉取的是国外的镜像源）"><a href="#5、配置docker源（如果不配置拉取的是国外的镜像源）" class="headerlink" title="5、配置docker源（如果不配置拉取的是国外的镜像源）"></a>5、配置docker源（如果不配置拉取的是国外的镜像源）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span> -d /etc/docker <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"docker dir Already exist"</span> <span class="token operator">||</span> <span class="token function">mkdir</span> /etc/docker<span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;</span>-<span class="token string">'EOF'</span><span class="token punctuation">{</span>  <span class="token string">"registry-mirrors"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"https://k03hynjl.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下"><a href="#6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下" class="headerlink" title="6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下"></a>6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">scp</span> -r cfichain@xxx.xxx.xxx.xxx:/home/cfichain/cfi_network <span class="token keyword">.</span><span class="token function">sudo</span> <span class="token function">scp</span> -r cfichain@xxx.xxx.xxx.xxx:/home/cfichain/bin <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7、清理数据"><a href="#7、清理数据" class="headerlink" title="7、清理数据"></a>7、清理数据</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">rm</span> -fr /data/fabric/bin/channel-artifacts/*<span class="token function">rm</span> -fr /data/fabric/bin/crypto-config/*<span class="token function">rm</span> -fr /data/fabric/bin/chaindata/*/*/*<span class="token function">rm</span> -fr /data/fabric/bin/chainData/*/*/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、文章摘要</title>
      <link href="/2019/060448940.html"/>
      <url>/2019/060448940.html</url>
      
        <content type="html"><![CDATA[<p>一个商用的区块链网络，随着业务的发展变化，经常需要动态的新增/移除组织，以满足业务/安全等管理需要。本文在既有组织/节点的基础上，新增一个组织两个节点。</p><p>Fabric 是联盟链，一个 Channel 就好比一个子链，如果有新的机构需要加入，则必须得到联盟内的成员的认可。基于这样的场景，Fabric 在为 channel 新增 org 时，会涉及诸多的权限和证书操作。</p><h2 id="Fabric-动态新增组织步骤"><a href="#Fabric-动态新增组织步骤" class="headerlink" title="Fabric 动态新增组织步骤"></a>Fabric 动态新增组织步骤</h2><ol><li>为新 org 生成证书</li><li>为新 org 生成配置文件</li><li>生成和提交新 org 的配置<ol><li>peer channel fetch config 创建添加新 org 的配置交易，为网络新增 org</li><li>peer channel signconfigtx 为配置交易签名，需网络中 MAJORITY 的 org 都签名</li><li>peer channel update 提交签名后的配置交易至 orderer</li></ol></li><li>将新 org 添加入 channel<ol><li>启动新 org 集群，一般会有一个 cli 和多个 peer</li><li>peer channel fetch 于 cli 中从 orderer 中获取 channel 创世块</li><li>peer channel join 将新 org 下的 peer 加入 channel</li></ol></li><li>升级chaincode和背书策略<ol><li>peer chaincode install 为新 org 的 peer 安装 chaincode，于新 org 的 cli 中完成</li><li>peer chaincode install, 为其他 org 升级 chaincode，于原 org 的 cli 中完成</li><li>peer chaincode upgrade 升级背书策略，于原 org 的 cli 中完成<br>此文通过 fabric-samples 下的 first-network 样例为基础，在其区块链网络上，为通道 cfichannel 新增一个组织Cfec，CfecOrg 包含个 peer。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式（Bridge Pattern）</title>
      <link href="/2018/121928602.html"/>
      <url>/2018/121928602.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要 4 个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>桥接模式</strong>(<code>Bridge Pattern</code>)：将抽象和实现解耦，使得两者可以独立地变化。它是一种对象结构型模式，又称为桥梁模式。</p></blockquote><h3 id="模式角色"><a href="#模式角色" class="headerlink" title="模式角色"></a>模式角色</h3><p>桥接模式包含如下角色：</p><ul><li><code>Abstraction</code>：抽象类角色</li><li><code>RefinedAbstraction</code>：扩充抽象类</li><li><code>Implementor</code>：实现化角色</li><li><code>ConcreteImplementor</code>：具体实现化角色的实现类</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p><img src="https://pic.lixl.cn/java-design-bridge.jpg" alt="桥接模式UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，是实现化角色<code>Abstraction</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 实现化角色 Implementor. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是各个具体的实现化角色类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ConcreteImplementor1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementor1</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor1 的业务逻辑 doSomething."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor1 的业务逻辑 doAnything."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ConcreteImplementor2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementor2</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor2 的业务逻辑 doSomething."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor2 的业务逻辑 doAnything."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，是抽象类角色<code>Abstraction</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>bridge<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象化角色 Abstraction. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义对实现化角色的引用. */</span>    <span class="token keyword">private</span> Implementor impl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param impl 实现类的实例     */</span>    <span class="token keyword">public</span> <span class="token function">Abstraction</span><span class="token punctuation">(</span>Implementor impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl <span class="token operator">=</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * impl 的 getter方法.     *     * @return impl     */</span>    <span class="token keyword">public</span> Implementor <span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自身的请求处理方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次，是扩展的具体抽象化角色类<code>RefinedAbstraction</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * RefinedAbstraction. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefinedAbstraction</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param impl 实现类的实例     */</span>    <span class="token keyword">public</span> <span class="token function">RefinedAbstraction</span><span class="token punctuation">(</span>Implementor impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 覆盖后的请求处理方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RefinedAbstraction 开始做业务处理."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Client. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定义一个实现化角色和抽象化角色,并执行请求方法.</span>        Implementor impl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementor1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Abstraction abs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefinedAbstraction</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>        abs<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>理解桥接模式，重点需要理解如何将抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，使得二者可以独立地变化。</p><ul><li><strong>抽象化</strong>：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li><li><strong>实现化</strong>：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li><li><strong>脱耦</strong>：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。<strong>桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</strong></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>桥接模式的优点:</p><ul><li>分离抽象接口及其实现部分。</li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li><li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li><li>实现细节对客户透明，可以对用户隐藏实现细节。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>桥接模式的缺点:</p><ul><li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用桥接模式：</p><ul><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li><li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li><li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ul><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>一个 Java 桌面软件总是带有所在操作系统的视感(<code>LookAndFeel</code>)，如果一个 Java 软件是在 Unix 系统上开发的，那么开发人员看到的是<code>Motif</code>用户界面的视感；在 Windows 上面使用这个系统的用户看到的是 Windows 用户界面的视感；而一个在<code>Macintosh</code>上面使用的用户看到的则是<code>Macintosh</code>用户界面的视感，Java 语言是通过所谓的 Peer 架构做到这一点的。Java 为 AWT 中的每一个 GUI 构件都提供了一个 Peer 构件，在 AWT 中的 Peer 架构就使用了桥接模式。</p><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>适配器模式与桥接模式的联用:</p><p>桥接模式和适配器模式用于设计的不同阶段，<strong>桥接模式用于系统的初步设计</strong>，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式</strong>。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。</li><li>桥接模式包含如下四个角色：抽象类中定义了一个实现类接口类型的对象并可以维护该对象；扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</li><li>在桥接模式中，抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，它们可以沿着各自的维度独立变化。</li><li>桥接模式的主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节；其主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情。</li><li>桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。</li></ul><p>参考自：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html" target="_blank" rel="noopener">桥接模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式（Adapter Pattern）</title>
      <link href="/2018/12121265.html"/>
      <url>/2018/12121265.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><ul><li>在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。</li><li>通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li><li>在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</li><li>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(<code>Adapter</code>)，它所包装的对象就是适配者(<code>Adaptee</code>)，即被适配的类。</li><li>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>适配器模式</strong>(<code>Adapter Pattern</code>) ：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(<code>Wrapper</code>)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。适配器模式是一种<strong>结构型模式</strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><p>适配器模式包含如下角色：</p><ul><li><code>Target</code>：目标抽象类</li><li><code>Adapter</code>：适配器类</li><li><code>Adaptee</code>：适配者类</li><li><code>Client</code>：客户类</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p><img src="https://pic.lixl.cn/java-design-adapter.jpg" alt="适配器模式UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，是目标角色接口和具体目标实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Target 目标角色类. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 目标角色自己的方法.     */</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的目标角色实现类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteTarget</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 目标角色自己的方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, I'm concrete target method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其次，是适配者类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配者类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这是原有的业务逻辑方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, I'm Adaptee method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是适配器角色类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配器类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token keyword">extends</span> <span class="token class-name">Adaptee</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 适配了目标角色自己的方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配器适配了目标角色方法."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 客户端场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 原有业务逻辑.</span>        Target target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 增加了适配器角色后的业务逻辑.</span>        Target adaptTarget <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        adaptTarget<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用适配器模式：</p><ul><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>Sun 公司在 1996 年公开了 Java 语言的数据库连接工具 JDBC，JDBC 使得 Java 语言程序能够与数据库连接，并使用 SQL 语言来查询和操作数据。JDBC 给出一个客户端通用的抽象接口，每一个具体数据库引擎（如 SQL Server、Oracle、MySQL 等）的 JDBC 驱动软件都是一个介于 JDBC 接口和数据库引擎接口之间的适配器软件。抽象的 JDBC 接口和各个数据库引擎 API 之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</li><li>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li><li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li><li>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。</li><li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li></ul><p>参考自：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html" target="_blank" rel="noopener">适配器模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则</title>
      <link href="/2018/112425424.html"/>
      <url>/2018/112425424.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据 <code>Robert Martin</code> 的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、面向对象设计原则"><a href="#二、面向对象设计原则" class="headerlink" title="二、面向对象设计原则"></a>二、面向对象设计原则</h2><h3 id="1-单一职责原则（SRP）"><a href="#1-单一职责原则（SRP）" class="headerlink" title="1. 单一职责原则（SRP）"></a>1. 单一职责原则（SRP）</h3><p>所谓<code>SRP</code>原则，即：<code>Single Responsibility Principle</code>，<strong>单一职责原则</strong>。原始定义如下：</p><blockquote><p>There should never be more than one reason for a class to change.(<strong>只有一个引起类改变的原因</strong>)</p></blockquote><p>在面向对象编程领域中，单一职责原则（<code>Single responsibility principle</code>）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是 <strong>解耦</strong> 和 <strong>增强内聚性</strong>。</p><h4 id="单一职责的好处"><a href="#单一职责的好处" class="headerlink" title="单一职责的好处"></a>单一职责的好处</h4><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义;</li><li>可读性提高，复杂性降低，可维护性提高;</li><li>变更引起的风险降低。</li></ul><h4 id="单一职责原则的注意点"><a href="#单一职责原则的注意点" class="headerlink" title="单一职责原则的注意点"></a>单一职责原则的注意点</h4><ul><li>单一职责最难划分的是<strong>职责</strong>。</li><li>单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。</li><li>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。</li></ul><h3 id="2-里氏替换原则（LSP）"><a href="#2-里氏替换原则（LSP）" class="headerlink" title="2. 里氏替换原则（LSP）"></a>2. 里氏替换原则（LSP）</h3><p>所谓<code>LSP</code>原则，即：<code>Liskov Substitution principle</code>，<strong>里氏替换原则</strong>。原始定义如下：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>）</p></blockquote><p>更通俗的定义即为：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。里氏替换原则包含了一下 4 层含义：</p><ul><li>子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了<code>LSP</code>原则。</li><li>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。</li><li>覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li><li>覆盖或实现父类的方法时输出结果可以被缩小。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提高代码的重用性，子类拥有父类的方法和属性；</li><li>提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；</li><li>增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。</li></ul><h3 id="3-接口隔离原则（ISP）"><a href="#3-接口隔离原则（ISP）" class="headerlink" title="3. 接口隔离原则（ISP）"></a>3. 接口隔离原则（ISP）</h3><p>所谓<code>ISP</code>原则，即：<code>Interface Segregation Principle</code>，<strong>接口隔离原则</strong>。原始定义如下：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)<br>The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)</p></blockquote><p>即，<strong>接口尽量细化，接口中的方法尽量少</strong>。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="4-开闭原则（OCP）"><a href="#4-开闭原则（OCP）" class="headerlink" title="4. 开闭原则（OCP）"></a>4. 开闭原则（OCP）</h3><p>所谓<code>OCP</code>原则，即：<code>Open Closed Principle</code>，<strong>开闭原则</strong>。原始定义如下：</p><blockquote><p>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭)</p></blockquote><p>开闭原则（<code>OCP</code>）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：<strong>对扩展开放，对修改关闭</strong>。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。</p><p>软件系统中包含的各种组件，例如模块（<code>Module</code>）、类（<code>Class</code>）以及功能（<code>Function</code>）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。</p><p>实现开闭原则的关键就在于“<strong>抽象</strong>”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。</p><p>开闭原则的好处：</p><ul><li>可复用性好;</li><li>可维护性好。</li></ul><h3 id="5-依赖倒置原则（DIP）"><a href="#5-依赖倒置原则（DIP）" class="headerlink" title="5. 依赖倒置原则（DIP）"></a>5. 依赖倒置原则（DIP）</h3><p>所谓 <code>DIP</code> 原则，即：<code>Dependency Inversion Principle</code>，<strong>依赖倒置原则</strong>。原始定义如下：</p><blockquote><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.(<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong>)<br>Abstractions should not depend on details. Details should depend on abstractions.(<strong>抽象不应该依赖细节；细节应该依赖抽象</strong>)</p></blockquote><p>面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><p>依赖倒置原则主要有以下三层含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）；</li><li>抽象不应该依赖细节（具体实现）；</li><li>细节（具体实现）应该依赖抽象。</li></ul><p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<strong>依赖倒置原则的核心思想就是面向接口编程</strong>。</p><h3 id="6-迪米特法则（LOD-LKP）"><a href="#6-迪米特法则（LOD-LKP）" class="headerlink" title="6. 迪米特法则（LOD | LKP）"></a>6. 迪米特法则（LOD | LKP）</h3><p>所谓 <code>LOD</code> 原则，即：<code>Law of Demeter</code>，<strong>迪米特法则</strong>，又叫<strong>最少知识原则</strong>（<code>Least Knowledge Principle</code>，简写<code>LKP</code>），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下：</p><blockquote><p>talk only to your immediate friends.(<strong>只与直接的朋友通信</strong>)</p></blockquote><p><strong>迪米特法则的初衷在于降低类之间的耦合</strong>。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。</p><h3 id="7-组合复用原则（CRP）"><a href="#7-组合复用原则（CRP）" class="headerlink" title="7. 组合复用原则（CRP）"></a>7. 组合复用原则（CRP）</h3><p>所谓<code>CRP</code>原则，即：<code>Composite Reuse Principle</code>，<strong>组合复用原则</strong>。</p><p>组合复用原则的核心思想是：<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p><p>继承的缺点主要有以下几点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的<code>getter/setter</code>方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。</p><p>组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><p>使用继承时必须满足<code>Is-A</code>的关系是才能使用继承，而组合却是一种<code>Has-A</code>的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把<code>Has-A</code>当成了<code>Is-A</code>。</p><h2 id="三、通用设计原则"><a href="#三、通用设计原则" class="headerlink" title="三、通用设计原则"></a>三、通用设计原则</h2><h3 id="1-保持简单（KISS）"><a href="#1-保持简单（KISS）" class="headerlink" title="1. 保持简单（KISS）"></a>1. 保持简单（KISS）</h3><p>所谓<code>KISS</code>原则，即：<code>Keep It Simple,Stupid</code>，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><blockquote><p>Everything should be made as simple as possible, but not simpler. - Albert Einstein</p></blockquote><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><blockquote><p><strong>我的理解</strong>：保持简单但不能掩盖软件丰富的内涵。即<strong>简约而不简单</strong>！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</p></blockquote><h3 id="2-不要重复（-DRY）"><a href="#2-不要重复（-DRY）" class="headerlink" title="2. 不要重复（ DRY）"></a>2. 不要重复（ DRY）</h3><p>所谓<code>DRY</code>原则，即：<code>Don&#39;t Repeat Yourself</code>，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。<code>DRY</code>并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三</strong>法则。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><blockquote><p><strong>我的理解</strong>：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是<strong>立即行动</strong>去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</p></blockquote><h3 id="3-高内聚低耦合"><a href="#3-高内聚低耦合" class="headerlink" title="3. 高内聚低耦合"></a>3. 高内聚低耦合</h3><p>所谓<code>Maximize Cohesion,Minimize Coupling</code>原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低。</strong></p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java 中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用<code>public</code>，多用<code>private</code>关键字，</li><li>多用设计模式，比如采用<code>MVC</code>的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-关注点分离（SOC）"><a href="#4-关注点分离（SOC）" class="headerlink" title="4. 关注点分离（SOC）"></a>4. 关注点分离（SOC）</h3><p>所谓<code>SOC</code>原则，即：<strong>关注点分离</strong>（<code>Separation of Concerns</code>）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成。</strong>关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p><code>MVC</code>就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。<code>MVC</code>的基本结构：</p><ul><li><code>Model</code>层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li><code>View</code>是应用程序的显示层，通常是依据模型的数据而建立。</li><li><code>Controller</code>是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（<code>Model</code>层）发送数据。</li></ul><p><code>MVC</code>的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><blockquote><p>好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD 中文版》)</p></blockquote><h4 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h4><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块 1、模块 2、模块 3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（<code>log</code>），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联<code>customer</code>类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做<code>CreateNewCustomer()</code>，那么<code>CreateNewCustomer()</code>的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如<code>Spring</code>、<code>Guice</code>等等，这些帮助我们做依赖反转，从而倒置依赖关系。</li></ul><h3 id="5-你不需要它（YAGNI）"><a href="#5-你不需要它（YAGNI）" class="headerlink" title="5. 你不需要它（YAGNI）"></a>5. 你不需要它（YAGNI）</h3><p>所谓<code>YAGNI</code>原则，即：<code>You Ain’t Gonna Need It</code>，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。<code>YAGNI</code>很像<code>KISS</code>原则，因为它也是致力于构建简单的方案。然而，<code>KISS</code>是通过尽可能容易的完成某件事情来实现精简方案；但<code>YAGNI</code>是通过根本就不实现它来达到精简。<code>YAGNI</code>的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><blockquote><p>只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP 的联合创始人 Ron Jeffries</p></blockquote><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><blockquote><p><strong>我的理解</strong>：YAGNI 原则，本质上是告诫我们<strong>写代码不要画蛇添足，否则就会弄巧成拙了</strong>。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</p></blockquote><h3 id="6-童子军规则（Boy-Scout-Rule）"><a href="#6-童子军规则（Boy-Scout-Rule）" class="headerlink" title="6. 童子军规则（Boy-Scout Rule）"></a>6. 童子军规则（Boy-Scout Rule）</h3><p><code>Boy-Scout Rule</code>，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(<code>Always leave the campground cleaner than you found it</code>)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要<strong>始终保持代码整洁</strong>。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><blockquote><p>所以，请记住童子军规则对我们的启示：<strong>始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治</strong>。</p></blockquote><h3 id="7-其他原则"><a href="#7-其他原则" class="headerlink" title="7.其他原则"></a>7.其他原则</h3><ul><li><strong>避免过早优化</strong>（<code>Avoid Premature Optimization</code>）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“<strong>过早的优化是一切罪恶之源</strong>。”——Donald Knuth</li><li><strong>最小惊讶原则</strong>(<code>Principle of least astonishment</code>): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li><strong>代码重用原则</strong>（<code>Code Reuse is Good</code>）: 重用代码能提高代码的可读性，缩短开发时间。</li><li><strong>别让我思考</strong>(<code>Don’t Make Me Think</code>): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li><strong>为维护者写代码</strong>(<code>Write Code for the Maintainer</code>): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li><strong>正交原则(Orthogonality)</strong>: 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：<code>CSS</code>)。</li><li><strong>做最简单的事儿就让代码可运行</strong>（<code>Do the simplest thing that could possibly work</code>）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li><strong>隐藏实现细节</strong>（<code>Hide Implementation Details</code>）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li><strong>科里定律</strong>(<code>Curly&#39;s Law</code>): 是为任何特定的代码选择一个明确定义的目标：<strong>只做一件事</strong>。</li><li><strong>墨菲定律</strong>（<code>Murphy&#39;s Law</code>）:根本内容是：<strong>如果事情有变坏的可能，不管这种可能性有多小，它总会发生</strong>。主要内容如下：<ul><li>任何事都没有表面看起来那么简单；</li><li>所有的事都会比你预计的时间长；</li><li>会出错的事总会出错；</li><li>如果你担心某种情况发生，那么它就更有可能发生。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计原则 </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式（Chain of Responsibility Pattern）</title>
      <link href="/2018/110429724.html"/>
      <url>/2018/110429724.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>定义</strong>：责任链模式(<code>Chain of Responsibility Pattern</code>)是使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。</p></blockquote><p><strong>实质</strong>：责任链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Handler</code>（抽象处理者）：处理请求的接口，一般设计为具有抽象请求处理方法的抽象类，以便于不同的具体处理者进行继承，从而实现具体的请求处理方法。此外，由于每一个请求处理者的下家还是一个处理者，因此抽象处理者本身还包含了一个本身的引用(<code>nextHandler</code>)作为其对下家的引用，以便将处理者链成一条链；</li><li><code>ConcreteHandler</code>（具体处理者）：抽象处理者的子类，可以处理用户请求，其实现了抽象处理者中定义的请求处理方法。在具体处理请求时需要进行判断，若其具有相应的处理权限，那么就处理它；否则，其将请求转发给后继者，以便让后面的处理者进行处理。</li></ul><p>在责任链模式里，由每一个请求处理者对象对其下家的引用而连接起来形成一条请求处理链。请求将在这条链上一直传递，直到链上的某一个请求处理者能够处理此请求。<strong>发出这个请求的客户端并不知道链上的哪一个请求处理者将处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任</strong>。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://pic.lixl.cn/chain_of_responsibility.png" alt="责任链模式UML类图"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，责任链模式的核心在于对请求处理者的抽象。在实现过程中，抽象处理者一般会被设定为<strong>抽象类</strong>，其典型实现代码如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的抽象处理者角色. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 后继处理者角色. */</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 处理请求的抽象方法.     *     * @param condition 条件     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * nextHandler的Setter方法.     *     * @param nextHandler 后继处理器     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler nextHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> nextHandler<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其次，是若干个具体的处理角色类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色1的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色2的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色n. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerN</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这里假设n是链的最后一个节点必须处理掉.     * 在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点.     *     * @param condition 参数条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色n的处理方法 结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景类，代码调用示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的客户端场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler handler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handlern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler1<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handler2<span class="token punctuation">)</span><span class="token punctuation">;</span>        handler2<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handlern<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//假设这个请求是ConcreteHandler2的责任</span>        handler1<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：责任链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般由使用该责任链的客户端创建。职责链模式降低了请求的发送者和请求处理者之间的耦合，从而使得多个请求处理者都有机会处理这个请求。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际软件开发中，如果遇到有多个对象可以处理同一请求时可以考虑使用职责链模式，最常见的例子包括在 Java Web 应用开发中创建一个过滤器（Filter）链来对请求数据进行过滤（中文字符乱码的处理）、在工作流系统中实现公文的分级审批、在Struts应用中添加不同的拦截器(常用的有类型转化、异常处理，数据校验…)以增强Struts2的功能等。</p><h3 id="纯与不纯的责任链模式"><a href="#纯与不纯的责任链模式" class="headerlink" title="纯与不纯的责任链模式"></a>纯与不纯的责任链模式</h3><ul><li><strong>纯的责任链模式</strong>要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况；</li><li>在纯责任链模式里面，一个请求必须被某一个处理者对象所接收；</li><li>在不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</li></ul><p>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>降低耦合度，使请求的发送者和接收者解耦，便于灵活的、可插拔的定义请求处理过程；</li><li>简化、封装了请求的处理过程，并且这个过程对客户端而言是透明的，以便于动态地重新组织链以及分配责任，增强请求处理的灵活性；</li><li>可以从职责链任何一个节点开始，也可以随时改变内部的请求处理规则，每个请求处理者都可以去动态地指定他的继任者；</li><li>职责链可简化对象间的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用；</li><li>增加新的请求处理类很方便。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理；</li><li>该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理；</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li><li>职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式（Singleton Pattern）</title>
      <link href="/2018/102929438.html"/>
      <url>/2018/102929438.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或 ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>单例模式(<code>Singleton Pattern</code>)</strong>：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种 <strong>对象创建型模式</strong>。单例模式又名单件模式或单态模式。</p></blockquote><p>单例模式的要点有三个：</p><ul><li>一是某个类只能有一个实例；</li><li>二是它必须自行创建这个实例；</li><li>三是它必须自行向整个系统提供这个实例。</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Singleton</code>: 单例</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p><img src="https://pic.lixl.cn/Java_design_singleton_uml.jpg" alt="单例模式UML类图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://pic.lixl.cn/Java_design_singleton_seq.jpg" alt="单例模式时序图"></p><h2 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h2><h3 id="1-饿汉式（推荐使用）"><a href="#1-饿汉式（推荐使用）" class="headerlink" title="1. 饿汉式（推荐使用）"></a>1. 饿汉式（推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 饿汉式单例模式. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 全局唯一实例. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。</p></blockquote><h3 id="2-非线程安全懒汉式（不推荐使用）"><a href="#2-非线程安全懒汉式（不推荐使用）" class="headerlink" title="2. 非线程安全懒汉式（不推荐使用）"></a>2. 非线程安全懒汉式（不推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非线程安全的懒汉式. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取实例，但是非线程安全.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，但非线程安全。不推荐使用。</p></blockquote><h3 id="3-低效的线程安全懒汉式（不推荐使用）"><a href="#3-低效的线程安全懒汉式（不推荐使用）" class="headerlink" title="3. 低效的线程安全懒汉式（不推荐使用）"></a>3. 低效的线程安全懒汉式（不推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 低效的线程安全的懒汉式. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，但是效率很低。因为 99%的情况下是不需要去同步的。不推荐使用。</p></blockquote><h3 id="4-双重校验锁线程安全懒汉式（不推荐使用）"><a href="#4-双重校验锁线程安全懒汉式（不推荐使用）" class="headerlink" title="4. 双重校验锁线程安全懒汉式（不推荐使用）"></a>4. 双重校验锁线程安全懒汉式（不推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 双重校验锁线程安全懒汉式. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，效率也不错。但受限于 Jdk5 以前的 Java 内存模型，仍然会有 bug，Java5 及之后才能正常达到单例效果。</p></blockquote><h3 id="5-枚举式（强烈推荐使用）"><a href="#5-枚举式（强烈推荐使用）" class="headerlink" title="5. 枚举式（强烈推荐使用）"></a>5. 枚举式（强烈推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 枚举方式的单例. */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：在<code>《Effective Java》</code>一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。</p></blockquote><h3 id="6-静态内部类（推荐使用）"><a href="#6-静态内部类（推荐使用）" class="headerlink" title="6. 静态内部类（推荐使用）"></a>6. 静态内部类（推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">SingletonHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton4 instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取Singleton唯一实例的方法.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：这种方式利用了<code>ClassLoader</code>的机制保证初始化<code>instance</code>时只有一个线程，其只有显示通过调用<code>getInstance</code>方法时，才会显示装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——<code>Singleton</code>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如<code>Java</code>、<code>C#</code>)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式（Builder Pattern）</title>
      <link href="/2018/102060028.html"/>
      <url>/2018/102060028.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>造者模式(<code>Builder Pattern</code>)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于<strong>对象创建型模式</strong>。建造者模式又可以称为<strong>生成器模式</strong>。</p></blockquote><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>建造者模式包含如下角色：</p><ul><li><code>Builder</code>：抽象建造者</li><li><code>ConcreteBuilder</code>：具体建造者</li><li><code>Director</code>：导演者</li><li><code>Product</code>：产品角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/Builder.jpg" alt="建造者模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是产品类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 产品类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String part1<span class="token punctuation">;</span>    <span class="token keyword">private</span> String part2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter方法. */</span>    <span class="token keyword">public</span> String <span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart1</span><span class="token punctuation">(</span>String part1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part1 <span class="token operator">=</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart2</span><span class="token punctuation">(</span>String part2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part2 <span class="token operator">=</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，是抽象的建造者<code>Builder</code>接口和具体的建造者<code>ConcreteBuilder</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的建造者. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的建造者实现类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 产品. */</span>    <span class="token keyword">private</span> Product product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart1</span><span class="token punctuation">(</span><span class="token string">"编号：95757"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart2</span><span class="token punctuation">(</span><span class="token string">"名称：小机器人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，导演者<code>Director</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 导演者类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 当前需要的建造者对象. */</span>    <span class="token keyword">private</span> Builder builder<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param builder     */</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品构造方法，负责调用各个零件建造方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是建造者模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 建造者模式的客户端场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuilderClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Director director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>抽象建造者类中定义了产品的创建方法和返回方法;</p><p>建造者模式的结构中还引入了一个导演者类<code>Director</code>，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>建造者模式的优点：</p><ul><li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>建造者模式的缺点：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h3 id="4-建造者模式与抽象工厂模式的比较"><a href="#4-建造者模式与抽象工厂模式的比较" class="headerlink" title="4. 建造者模式与抽象工厂模式的比较"></a>4. 建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。</li><li>建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</li><li>在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li><li>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式（Facade Pattern）</title>
      <link href="/2018/101818310.html"/>
      <url>/2018/101818310.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><blockquote><p><strong>外观模式</strong>(<code>Facade Pattern</code>)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为<strong>门面模式</strong>，它是一种对象结构型模式。</p></blockquote><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>外观模式包含如下角色：</p><ul><li><code>Facade</code>: 外观角色</li><li><code>SubSystem</code>: 子系统角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/Facade.jpg" alt="命令模式结构图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是各个子系统角色类，分别如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类A. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法A..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类B. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassB</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法B..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类C. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassC</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法C..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是外观模式的外观类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 外观门面类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Facade</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ClassA a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassB b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassC c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以下是提供给外部访问的方法.</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“<strong>迪米特法则</strong>”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p><ul><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式的目的在于降低系统的复杂程度。</li><li>外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>外观模式的优点 k：</p><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>外观模式的缺点：</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“<strong>开闭原则</strong>”。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="五、模式总结"><a href="#五、模式总结" class="headerlink" title="五、模式总结"></a>五、模式总结</h2><ul><li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li><li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式（Mediator Pattern）</title>
      <link href="/2018/101718124.html"/>
      <url>/2018/101718124.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</p><ul><li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</li></ul><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>中介者模式(<code>Mediator Pattern</code>)</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为<strong>调停者模式</strong>，它是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>中介者模式包含如下角色：</p><ul><li><code>Mediator</code>: 抽象中介者</li><li><code>ConcreteMediator</code>: 具体中介者</li><li><code>Colleague</code>: 抽象同事类</li><li><code>ConcreteColleague</code>: 具体同事类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/Mediator.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Mediator</code>类和具体的<code>ConcreteMediator</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用抽象中介者类. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义同事类1. */</span>    <span class="token keyword">protected</span> ConcreteColleague1 colleague1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 定义同事类2. */</span>    <span class="token keyword">protected</span> ConcreteColleague2 colleague2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter 方法 */</span>    <span class="token keyword">public</span> ConcreteColleague1 <span class="token function">getColleague1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague1</span><span class="token punctuation">(</span>ConcreteColleague1 colleague1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague1 <span class="token operator">=</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ConcreteColleague2 <span class="token function">getColleague2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague2</span><span class="token punctuation">(</span>ConcreteColleague2 colleague2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague2 <span class="token operator">=</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑1.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的通用中介者类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">extends</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，是抽象的<code>Colleague</code>类和具体的<code>ConcreteColleague</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的同事类. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 中介者. */</span>    <span class="token keyword">protected</span> Mediator mediator<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Colleague</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mediator <span class="token operator">=</span> mediator<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague1</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague1</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-处理自己的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-委托给中介者的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague2</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague2</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-处理自己的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-委托给中介者的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是中介者模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 中介者模式的场景类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediatorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mediator mediator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague1 colleague1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague1</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague2 colleague2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague2</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague1</span><span class="token punctuation">(</span>colleague1<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague2</span><span class="token punctuation">(</span>colleague2<span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague1<span class="token punctuation">.</span><span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague2<span class="token punctuation">.</span><span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>中介者模式可以使对象之间的关系数量急剧减少。</p><p>中介者承担两方面的职责：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>中介者模式的优点：</p><ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>中介者模式的缺点：</p><ul><li>在具体中介者类中包含了同事之间的交互细节，<strong>可能会导致具体中介者类非常复杂，使得系统难以维护</strong>。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用中介者模式：</p><ul><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li><li>中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li><li>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li><li>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式（Command Pattern）</title>
      <link href="/2018/101640715.html"/>
      <url>/2018/101640715.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>命令模式(<code>Command Pattern</code>)</strong>：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(<code>Action</code>)模式或事务(<code>Transaction</code>)模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>命令模式包含如下角色：</p><ul><li><code>Command</code>: 抽象命令类</li><li><code>ConcreteCommand</code>: 具体命令类</li><li><code>Invoker</code>: 调用者</li><li><code>Receiver</code>: 接收者</li><li><code>Client</code>: 客户类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/Command.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Receiver</code>类和具体的<code>Receiver</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用的抽象 Receiver 接收者. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义每个接收者都必须完成的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver1</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver1 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver2</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver2 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，是抽象的<code>Command</code>类和具体的<code>Command</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的 Command 类. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 命令的抽象执行命令的方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand1</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand1</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的一个命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand2</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand2</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，调用者<code>Invoker</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 调用者 Invoker 类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Command command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>Command command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 执行命令.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是命令模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 命令模式的场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Invoker invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Receiver receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteReceiver1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Command command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCommand1</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把命令交给调用者执行</span>        invoker<span class="token punctuation">.</span><span class="token function">setCommand</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p><strong>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开</strong>。</p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>命令模式的优点：</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的<code>Undo</code>和<code>Redo</code>。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>命令模式的缺点：</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用命令模式：</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</li><li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li><li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式（Observer Pattern）</title>
      <link href="/2018/101432841.html"/>
      <url>/2018/101432841.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>观察者模式(<code>Observer Pattern</code>)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（<code>Publish</code>/<code>Subscribe</code>）模式、模型-视图（<code>Model</code>/<code>View</code>）模式、源-监听器（<code>Source</code>/<code>Listener</code>）模式或从属者（<code>Dependents</code>）模式。</p></blockquote><p>观察者模式是一种<strong>对象行为型模式</strong>。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>观察者模式包含如下角色：</p><ul><li><code>Subject</code>: 目标（抽象的被观察着）</li><li><code>ConcreteSubject</code>: 具体目标（具体的被观察者）</li><li><code>Observer</code>: 观察者</li><li><code>ConcreteObserver</code>: 具体观察者</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/Obeserver.jpg" alt="观察者模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="https://pic.lixl.cn/seq_Obeserver.jpg" alt="观察者模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是观察者接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者接口 * */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 更新的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，是具体的观察者类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的观察者. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现更新方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到信息,并进行处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是被观察者的抽象类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被观察者的抽象类. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义一个观察者的集合. */</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 增加一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通知所有观察者.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer o<span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            o<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的被观察者：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的被观察者. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是用于测试观察者模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者模式客户端场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个被观察者和观察者.</span>        ConcreteSubject sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Observer obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者观察被观察者.</span>        sub<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>obs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者开始活动了.</span>        sub<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅</strong>(<code>publish-subscribe</code>)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>观察者模式的优点：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>观察者模式的缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><blockquote><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li><li>在 JDK 的<code>java.util</code>包中，提供了<code>Observable</code>类以及<code>Observer</code>接口，它们构成了 Java 语言对观察者模式的支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Java编程风格指南</title>
      <link href="/2018/10056920.html"/>
      <url>/2018/10056920.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>这份文档是<code>Google Java</code>编程风格规范的完整定义。当且仅当一个<code>Java</code>源文件符合此文档中的规则，我们才认为它符合<code>Google</code>的<code>Java</code>编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>本文档中除非特殊说明，否则：</p><ul><li>术语<code>class</code>可表示一个普通类、枚举类、接口或者注解。</li><li>术语<code>comment</code>只用来指代实现的注释(<code>implementation comments</code>)，我们不使用文档注释(<code>documentation comments</code>)一词，而是用<code>Javadoc</code>。</li></ul><p>其他术语说明，将在文档中需要说明的地方单独说明。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2 源文件基础"></a>2 源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式使用<code>UTF-8</code>。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空格字符"><a href="#2-3-1-空格字符" class="headerlink" title="2.3.1 空格字符"></a>2.3.1 空格字符</h4><p>除了换行符外，<code>ASCII</code>水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着：</p><ul><li>所有其他空白字符将被转义。</li><li><code>Tab</code>字符不被用作缩进控制。</li></ul><h4 id="2-3-2-特殊转义字符串"><a href="#2-3-2-特殊转义字符串" class="headerlink" title="2.3.2 特殊转义字符串"></a>2.3.2 特殊转义字符串</h4><p>任何需要转义字符串表示的字符（例如：<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>\&#39;</code>, <code>\\</code>等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 <code>\012</code>）或<code>Unicode</code>码（例如：<code>\u000a</code>）表示。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于其余非<code>ASCII</code>字符，直接使用<code>Unicode</code>字符（例如 <code>∞</code>），或者使用对应的<code>Unicode</code>码（例如：<code>\u221e</code>）转义，都是允许的。<strong>唯一需要考虑的是，何种方式更能使代码容易阅读和理解</strong>。</p><blockquote><p><strong>注意</strong>：在使用<code>Unicode</code>码转义，或者甚至是有时直接使用<code>Unicode</code>字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。</p></blockquote><p>例子：</p><table><thead><tr><th>示例</th><th>结论</th></tr></thead><tbody><tr><td>String unitAbbrev = “μs”;</td><td>赞：即使没有注释也非常清晰。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // “μs”</td><td>允许，但没有理由要这样做。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td><td>允许，但这样做显得笨拙还容易出错。</td></tr><tr><td>String unitAbbrev = “\u03bcs”;</td><td>很糟：读者根本看不出这是什么。</td></tr><tr><td>return ‘\ufeff’ + content; // byte order mark</td><td>很好：对于非打印字符，使用转义，并在必要时写上注释。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：永远不要由于害怕某些程序可能无法正确处理非<code>ASCII</code>字符而让你的代码可读性变差。当程序无法正确处理非<code>ASCII</code>字符时，它自然无法正确运行，你就会去<code>fix</code>这些问题的了。(言下之意就是大胆去用非<code>ASCII</code>字符，如果真的有需要的话)</p></blockquote><h2 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3 源文件结构"></a>3 源文件结构</h2><p>源文件按照先后顺序，由以下几部分组成：</p><ul><li>许可证(<code>License</code>)或版权信息(<code>copyright</code>)（如果需要）</li><li><code>package</code>语句</li><li><code>import</code>语句</li><li><code>class</code>类声明（每个源码文件只能有唯一一个顶级<code>class</code>）。</li></ul><blockquote><p><strong>注意</strong>：以上每个部分之间应该只有<strong>一个空行</strong>作为间隔。</p></blockquote><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p><code>package</code>语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不使用通配符"><a href="#3-3-1-import不使用通配符" class="headerlink" title="3.3.1 import不使用通配符"></a>3.3.1 import不使用通配符</h4><p><code>import</code>语句中不应该使用通配符，不管是否是静态导入。</p><h4 id="3-3-2-import不换行"><a href="#3-3-2-import不换行" class="headerlink" title="3.3.2 import不换行"></a>3.3.2 import不换行</h4><p><code>import</code>语句不换行，列限制(4.4节)并不适用于<code>import</code>语句。(每个<code>import</code>语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p><code>import</code>语句可分为以下几组，按照顺序，每组由<strong>一个空行</strong>分隔：</p><ul><li>所有的静态导入(static import)归为一组</li><li><code>com.google</code>包的<code>import</code>归为一组</li><li>使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：<code>android</code>, <code>com</code>, <code>junit</code>, <code>org</code>, <code>sun</code></li><li><code>java</code>包归为一组</li><li><code>javax</code>包归为一组</li></ul><blockquote><p><strong>注意</strong>：同一组内的<code>import</code>语句之间不应用空行隔开，同一组中的<code>import</code>语句按字典序排列。</p></blockquote><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只声明唯一一个顶级class"><a href="#3-4-1-只声明唯一一个顶级class" class="headerlink" title="3.4.1 只声明唯一一个顶级class"></a>3.4.1 只声明唯一一个顶级class</h4><p>每个源文件中只能有一个顶级class。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。</p><p>最重要的一点，<strong>每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑</strong>。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。</p><h2 id="4-格式"><a href="#4-格式" class="headerlink" title="4 格式"></a>4 格式</h2><blockquote><p><strong>术语说明</strong>：块状结构(<code>block-­like construct</code>)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p></blockquote><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号一般用在<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>等语句，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空语句块采用K-amp-R风格"><a href="#4-1-2-非空语句块采用K-amp-R风格" class="headerlink" title="4.1.2 非空语句块采用K&amp;R风格"></a>4.1.2 非空语句块采用<code>K&amp;R</code>风格</h4><p>对于非空语句块，大括号遵循<code>Kernighan</code>和<code>Ritchie</code>风格 (<a href="https://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号结束是一个<code>语句块</code>或者<code>方法体</code>、<code>构造函数体</code>或者<code>有命名的类体</code>，则需要换行。当右括号后面接<code>else</code>或者<code>逗号</code>时，不应该换行。</li></ul><p>示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ProblemException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">otherCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">somethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">lastThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些例外的情况，将在<code>4.8.1</code>节讲<code>枚举类型</code>的时候讲到。</p><h4 id="4-1-3-空语句块：使代码更简洁"><a href="#4-1-3-空语句块：使代码更简洁" class="headerlink" title="4.1.3 空语句块：使代码更简洁"></a>4.1.3 空语句块：使代码更简洁</h4><p>一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：<code>if/else</code> 或者<code>try/catch/finally</code>）.</p><p>示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是可接受的</span><span class="token keyword">void</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这同样是可接受的</span><span class="token keyword">void</span> <span class="token function">doNothingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是不可接受的：多块语句中没有简洁的空语句块</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2块缩进：2个空格"><a href="#4-2块缩进：2个空格" class="headerlink" title="4.2块缩进：2个空格"></a>4.2块缩进：2个空格</h3><p>每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。</p><blockquote><p><strong>注意</strong>：根据实际的编程经验，<code>2</code>个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码<code>臃肿</code>不够美观。所以，我这里建议使用<code>4</code>个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。</p></blockquote><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每条语句结束都需要换行。</p><h3 id="4-4-列长度限制：100"><a href="#4-4-列长度限制：100" class="headerlink" title="4.4 列长度限制：100"></a>4.4 列长度限制：100</h3><p>Java代码的列长度限制为<code>100个</code>字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。</p><p>例外：</p><ul><li>不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)</li><li>注释中那些可能被剪切并粘贴到shell中的命令行</li></ul><blockquote><p><strong>注意</strong>：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，<code>100</code>个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用<code>120</code>个字符的宽度更为合适。</p></blockquote><h3 id="4-5-换行"><a href="#4-5-换行" class="headerlink" title="4.5 换行"></a>4.5 换行</h3><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(<code>100</code>个字符)而被分为多行，我们称之为断行(<code>line­-wrapping</code>)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。</p><blockquote><p><strong>注意</strong>: 提取<code>方法</code>或<code>局部变量</code>可以解决问题，而不不需要进行断行。</p></blockquote><h4 id="4-5-1-在何处断行"><a href="#4-5-1-在何处断行" class="headerlink" title="4.5.1 在何处断行"></a>4.5.1 在何处断行</h4><p>断行的主要原则是：<strong>选择在更高级的语法逻辑处断行</strong>。其他一些原则如下：</p><ul><li>当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。</li><li>如果要在非赋值运算符处断行，那么在该符号前断开(比如<code>+</code>操作符，它将位于下一行)。以下的<code>类运算符</code>也可作为参考：<ul><li>点操作符<code>.</code></li><li>类型界限中的<code>&amp;</code>、<code>||</code>等（例如：<code>&lt;T extends Foo &amp; Bar&gt;</code>)</li></ul></li><li>当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：<code>=</code>，它与前面的内容留在同一行)。<ul><li>这条规则也适用于<code>foreach</code>语句中的冒号。</li></ul></li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(<code>,</code>)与其前面的内容留在同一行。也就是在逗号之后断行。</li><li><code>Lambda</code>表达式在箭头符号(<code>-&gt;</code>)后断行。</li></ul><p>示例：</p><pre class="line-numbers language-java"><code class="language-java">MyLambda<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token punctuation">,</span> Object<span class="token operator">></span> lambda <span class="token operator">=</span>    <span class="token punctuation">(</span>String label<span class="token punctuation">,</span> Long value<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> str <span class="token operator">-</span><span class="token operator">></span>    <span class="token function">longExpressionInvolving</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：换行的主要目标是使代码更清晰易读。</p></blockquote><h4 id="4-5-2-断行的缩进：至少-4个空格"><a href="#4-5-2-断行的缩进：至少-4个空格" class="headerlink" title="4.5.2 断行的缩进：至少+4个空格"></a>4.5.2 断行的缩进：至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进<code>4</code>个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只<code>4</code>个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用单行空行：</p><ul><li>类成员之间需要单个空行隔开：例如：<code>字段</code>，<code>构造函数</code>，<code>方法</code>，<code>嵌套类</code>，<code>静态初始化块</code>，<code>实例初始化块</code>。但也有以下两种例外情况：<ul><li>两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。</li><li>枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。</li></ul></li><li>在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。</li><li>类的第一个成员之前或最后一个成员之后，使用空行(可选)。</li><li>本文档所介绍的其他章节的空行要求(比如3.3节：<code>import</code>语句)。</li></ul><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现：</p><ul><li>所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：<code>if</code>, <code>for</code> <code>catch</code>等)</li><li>所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：<code>else</code>、<code>catch</code>）</li><li>在左大括号之前都需要空格隔开。只有两种例外：<ul><li><code>@SomeAnnotation({a, b})</code></li><li><code>String[][] x = foo;</code></li></ul></li><li>所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：<code>a + b</code>、<code>b = a &lt; 0 ? 0 : a</code>)</li><li>逗号(<code>,</code>)、冒号(<code>:</code>)、分号(<code>;</code>)和右小括号(<code>)</code>)、Lambda箭头符号(<code>-&gt;</code>)之后，需要空格隔开。</li><li><code>//</code>双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：<code>a = 0; // 赋值为0</code>）</li><li>变量声明时，变量类型和变量名之间需要用空格隔开。（例如：<code>List&lt;String&gt; list</code>）</li><li>初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>）</li></ul><blockquote><p><strong>注意</strong>：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><blockquote><p><strong>术语说明</strong>：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。</p></blockquote><p>这种对齐是被允许的，但是不会做强制要求。</p><p>以下是没有水平对齐和水平对齐的例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 这种挺好</span><span class="token keyword">private</span> Color color<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 同上</span><span class="token keyword">private</span> <span class="token keyword">int</span>   x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 允许，但是未来会继续编辑</span><span class="token keyword">private</span> Color color<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可能会使它对不齐</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为<strong>爆炸半径</strong>。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码<code>review</code>的速度，引起更多<code>merge</code>代码冲突的情况。</p></blockquote><h3 id="4-7-分组小括号：推荐使用"><a href="#4-7-分组小括号：推荐使用" class="headerlink" title="4.7 分组小括号：推荐使用"></a>4.7 分组小括号：推荐使用</h3><p>除非作者和<code>reviewer</code>都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-特殊结构"><a href="#4-8-特殊结构" class="headerlink" title="4.8 特殊结构"></a>4.8 特殊结构</h3><h4 id="4-8-1-枚举类型"><a href="#4-8-1-枚举类型" class="headerlink" title="4.8.1 枚举类型"></a>4.8.1 枚举类型</h4><p>枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Answer <span class="token punctuation">{</span>    YES <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"yes"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    NO<span class="token punctuation">,</span>    MAYBE<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有方法和Javadoc的枚举类可写成数组初始化的格式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Suit <span class="token punctuation">{</span> CLUBS<span class="token punctuation">,</span> HEARTS<span class="token punctuation">,</span> SPADES<span class="token punctuation">,</span> DIAMONDS <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次声明一个变量"><a href="#4-8-2-1-每次声明一个变量" class="headerlink" title="4.8.2.1 每次声明一个变量"></a>4.8.2.1 每次声明一个变量</h5><p>不要使用组合声明。例如：<code>int a, b;</code>是不允许的。</p><h5 id="4-8-2-2-需要时才声明，尽快进行初始化"><a href="#4-8-2-2-需要时才声明，尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，尽快进行初始化"></a>4.8.2.2 需要时才声明，尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，例如以下格式的写法都是允许的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>           <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>            <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span>                       <span class="token number">1</span><span class="token punctuation">,</span>                        <span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>             <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>               <span class="token punctuation">}</span>  <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>                     <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                          <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p><strong>术语说明</strong>：<code>switch</code>块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>和其他语句块一样，<code>switch</code>大括号之后缩进两个字符。每个<code>switch</code>标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。</p><h5 id="4-8-4-2-继续向下执行的注释"><a href="#4-8-4-2-继续向下执行的注释" class="headerlink" title="4.8.4.2 继续向下执行的注释"></a>4.8.4.2 继续向下执行的注释</h5><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>抛出异常</code>来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token function">prepareOneOrTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// fall through</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>        <span class="token function">handleOneTwoOrThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token function">handleLargeNumber</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：在<code>case 1</code>之后不需要该注释，仅在语句组的末尾。</p></blockquote><h5 id="4-8-4-3-default标签需要显式声明"><a href="#4-8-4-3-default标签需要显式声明" class="headerlink" title="4.8.4.3 default标签需要显式声明"></a>4.8.4.3 default标签需要显式声明</h5><p>每个<code>switch</code>语句中，都需要显式声明<code>default</code>标签。即使没有任何代码也需要显示声明。</p><blockquote><p><strong>注意</strong>：枚举类型的<code>switch</code>语句可以省略<code>default</code>语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。</p></blockquote><h4 id="4-8-5-注解"><a href="#4-8-5-注解" class="headerlink" title="4.8.5 注解"></a>4.8.5 注解</h4><p>注解应用到类、方法或者构造方法时，应紧接<code>Javadoc</code>之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> String <span class="token function">getNameIfPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>例外</strong>：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注解应用到成员变量时，也是紧接<code>Javadoc</code>之后。不同的是，多个注解可以放在同一行。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Partial</span> <span class="token annotation punctuation">@Mock</span> DataLoader loader<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于参数或者局部变量使用注解的情况，没有特定的规范。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>注释的缩进与它所注释的代码缩进相同。可以采用<code>/* */</code>进行注释，也可以用<code>//</code>进行注释。当使用<code>/* */</code>进行多行注释时，每一行都应该以<code>*</code>开始，并且<code>*</code>应该上下对齐。</p><p>例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* * This is * okay. */</span><span class="token comment" spellcheck="true">// And so</span><span class="token comment" spellcheck="true">// is this.</span><span class="token comment" spellcheck="true">/* Or you can * even do this. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用<code>/* */</code>，<code>//</code>一般不会自动对齐。</p></blockquote><h4 id="4-8-7-修饰符"><a href="#4-8-7-修饰符" class="headerlink" title="4.8.7 修饰符"></a>4.8.7 修饰符</h4><p>类和成员变量的修饰符，按<code>Java Lauguage Specification</code>中介绍的先后顺序排序。具体是：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">protected</span> <span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">default</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">synchronized</span> <span class="token keyword">native</span> <span class="token keyword">strictfp</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-8-8-数字字面量"><a href="#4-8-8-数字字面量" class="headerlink" title="4.8.8 数字字面量"></a>4.8.8 数字字面量</h4><p>长整型的数字字面量使用大写的<code>L</code>作为后缀，不得使用小写（以免与数字1混淆）。例如：使用<code>3000000000L</code>，而不是<code>3000000000l</code>。</p><h2 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5 命名约定"></a>5 命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用<code>ASCII</code>字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用<code>com.example.deepspace</code>，而不是<code>com.example.deepSpace</code>或者<code>com.example.deep_space</code>。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语。例如：<code>Character</code>或者<code>ImmutableList</code>。接口名称也可以是名词或名词短语（例如：<code>List</code>），但有时可能是形容词或形容词短语（例如：<code>Readable</code>）。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如：<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。例如：<code>sendMessage</code>或者<code>stop</code>。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如：<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？</p><p>每个常量都是一个静态<code>final</code>字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 常量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableList<span class="token operator">&lt;</span>String<span class="token operator">></span> NAMES <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> AGES <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Joiner COMMA_JOINER <span class="token operator">=</span> Joiner<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为Joiner是不可变的</span><span class="token keyword">static</span> <span class="token keyword">final</span> SomeMutableType<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> SomeEnum <span class="token punctuation">{</span> ENUM_CONSTANT <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 非常量</span><span class="token keyword">static</span> String nonFinal <span class="token operator">=</span> <span class="token string">"non-final"</span><span class="token punctuation">;</span><span class="token keyword">final</span> String nonStatic <span class="token operator">=</span> <span class="token string">"non-static"</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> mutableCollection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableSet<span class="token operator">&lt;</span>SomeMutableType<span class="token operator">></span> mutableElements <span class="token operator">=</span> ImmutableSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>mutable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> SomeMutableType<span class="token operator">></span> mutableValues <span class="token operator">=</span>    ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> mutableInstance<span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> mutableInstance2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> nonEmptyArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"these"</span><span class="token punctuation">,</span> <span class="token string">"can"</span><span class="token punctuation">,</span> <span class="token string">"change"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些常量的名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。例如：<code>computedValues</code>或者<code>index</code>。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以<code>lowerCamelCase</code>风格编写。</p><p>即使局部变量是<code>final</code>和<code>不可改变</code>的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以视具体情况跟一个数字(如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：<code>RequestT</code>, <code>FooBarT</code>)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p><strong>驼峰式命名法</strong>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：<code>IPv6</code>或<code>iOS</code>)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ul><li>把短语转换为纯<code>ASCII</code>码，并且移除任何单引号。例如：<code>Müller’s algorithm</code>将变成<code>Muellers algorithm</code>。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li><strong>推荐</strong>：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如<code>AdWords</code>将分割成<code>ad words</code>)。</li><li>需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ul><p>示例：</p><table><thead><tr><th>散文形式</th><th>正确</th><th>不正确</th></tr></thead><tbody><tr><td>“XML HTTP request”</td><td>XmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>“new customer ID”</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>“inner stopwatch”</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>“supports IPv6 on iOS?”</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>“YouTube importer”</td><td>YouTubeImporter YoutubeImporter^</td><td>无</td></tr></tbody></table><p>加<code>^</code>号处表示可以，但不推荐。</p><blockquote><p><strong>注意</strong>：在英语中，某些带有连字符的单词形式不唯一。例如：<code>nonempty</code>和<code>non-empty</code>都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h2 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6 编程实践"></a>6 编程实践</h2><h3 id="6-1-Override：总是使用"><a href="#6-1-Override：总是使用" class="headerlink" title="6.1 @Override：总是使用"></a>6.1 <code>@Override</code>：总是使用</h3><p>只要是合法的方法，就把<code>@Override</code>注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。</p><p><strong>例外</strong>：当父方法为<code>@Deprecated</code>时，可以省略<code>@Override</code>。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">handleNumericResponse</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 它不是一个数字，不过没关系，继续</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">handleTextResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    emptyStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchElementException</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6.3 静态成员：使用类来调用</p><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><pre class="line-numbers language-java"><code class="language-java">Foo aFoo <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>Foo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 好</span>aFoo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 糟</span><span class="token function">somethingThatYieldsAFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 很糟</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>6.4 <code>Finalizers</code>: 禁用</p><p>极少会去重载<code>Object.finalize</code>。</p><blockquote><p><strong>注意</strong>：不要使用<code>finalize</code>。如果你非要使用它，请先仔细阅读和理解<code>Effective Java第7条款</code>：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h2 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7 Javadoc"></a>7 Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p><code>Javadoc</code>块的基本格式如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Multiple lines of Javadoc text are written here, * wrapped normally... */</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span>String p1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者是以下单行形式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** An especially short bit of Javadoc. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基本格式总是可以接受的。当整个<code>Javadoc</code>块能容纳于一行时(且没有标记<code>@XXX</code>)，就可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(只包含最左侧星号的行)会出现在段落之间和<code>Javadoc</code>标记(<code>@XXX</code>)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的<code>Javadoc</code>标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进<code>4</code>个空格(<strong>注</strong>：如果你的缩进统一采用采用<code>4</code>个空格，那么这里就应该是<code>8</code>个空格)。</p><h4 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h4><p>每个类或成员的<code>Javadoc</code>以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或者<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record.</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p><strong>注意</strong>：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h3 id="7-3-在哪里使用Javadoc"><a href="#7-3-在哪里使用Javadoc" class="headerlink" title="7.3 在哪里使用Javadoc"></a>7.3 在哪里使用Javadoc</h3><p>至少在每个<code>public</code>类及它的每个<code>public</code>和<code>protected</code>成员处使用<code>Javadoc</code>，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，<code>Javadoc</code>是可选的(可以不写)。这种情况下除了写<code>Returns the foo</code>，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p><strong>注意</strong>：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么<code>Javadoc</code>并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用<code>Javadoc</code>的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成<code>Javadoc</code>，这样更统一更友好。</p><p>原文地址: <a href="http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html" target="_blank" rel="noopener">Google Java Style Guide</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git知识点整理</title>
      <link href="/2018/092433617.html"/>
      <url>/2018/092433617.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git基本概念"><a href="#1-Git基本概念" class="headerlink" title="1. Git基本概念"></a>1. Git基本概念</h2><ul><li><code>repository</code></li><li><code>config</code></li><li><code>init</code></li><li><code>clone</code></li><li><code>fetch</code></li><li><code>pull</code></li><li><code>commit</code></li><li><code>push</code></li><li><code>branch</code></li><li><code>head</code></li><li><code>tag</code></li><li><code>merge</code></li><li><code>conflict</code></li><li><code>diff</code></li><li><code>log</code></li><li><code>show</code></li><li><code>status</code></li></ul><h2 id="2-Git工作空间和文件状态"><a href="#2-Git工作空间和文件状态" class="headerlink" title="2. Git工作空间和文件状态"></a>2. Git工作空间和文件状态</h2><h3 id="1-工作空间"><a href="#1-工作空间" class="headerlink" title="(1).工作空间"></a>(1).工作空间</h3><p><img src="http://blog.chinaunix.net/attachment/201402/19/10415985_139279770639pM.jpg" alt="Git工作空间"></p><p>左侧为工作区，右侧为版本库。</p><ul><li>工作区（<code>Working Directory</code>） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。</li><li>版本库（<code>Repository</code>）工作区有一个隐藏目录<code>.git</code>，是Git的版本库。</li></ul><p>在版本库中标记为<code>index</code>的区域为暂存区，标记为<code>master</code>的是Git为我们自动创建的第一个分支，代表的是目录树。此时<code>HEAD</code>实际是指向<code>master</code>分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用<code>master</code>来替换。图中的objects标识的区域为git的对象库，实际位于<code>.git/objects</code>目录下。</p><ul><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行<code>git rm --cached</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行<code>git checkout .</code>或<code>git checkout --</code> 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。</li><li>当执行<code>git checkout HEAD .</code>或<code>git checkout HEAD</code>命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</li></ul><h3 id="1-文件状态"><a href="#1-文件状态" class="headerlink" title="(1).文件状态"></a>(1).文件状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交(<code>committed</code>)</strong>、<strong>已修改(<code>modified</code>)</strong>和<strong>已暂存(<code>staged</code>)</strong>。</p><h2 id="3-Git配置系统级、全局、当前仓库用户名、邮箱的命令"><a href="#3-Git配置系统级、全局、当前仓库用户名、邮箱的命令" class="headerlink" title="3. Git配置系统级、全局、当前仓库用户名、邮箱的命令"></a>3. Git配置系统级、全局、当前仓库用户名、邮箱的命令</h2><p>系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填)</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"Jerry Mouse"</span><span class="token function">git</span> config --global user.email <span class="token string">"jerry@yiibai.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出Git设置</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span class="token function">git</span> config -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-Git-fetch和pull的区别"><a href="#4-Git-fetch和pull的区别" class="headerlink" title="4. Git fetch和pull的区别"></a>4. Git fetch和pull的区别</h2><ul><li><code>git fetch</code>：相当于是从远程获取最新版本到本地，不会自动merge.</li><li><code>git pull</code>：相当于是从远程获取最新版本并merge到本地.</li></ul><h3 id="1-git-fetch示例："><a href="#1-git-fetch示例：" class="headerlink" title="(1). git fetch示例："></a>(1). git fetch示例：</h3><pre class="line-numbers language-bash"><code class="language-bash">Git fetch origin master<span class="token function">git</span> log -p master<span class="token punctuation">..</span>origin/master<span class="token function">git</span> merge origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li><li>上述过程其实可以用以下更清晰的方式来进行：</li></ul><h3 id="1-git-pull示例"><a href="#1-git-pull示例" class="headerlink" title="(1). git pull示例"></a>(1). git pull示例</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令其实相当于<code>git fetch</code>和<code>git merge</code>。在实际使用中，<code>git fetch</code>更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p><h2 id="5-Git-reset和revert的却别"><a href="#5-Git-reset和revert的却别" class="headerlink" title="5. Git reset和revert的却别"></a>5. Git reset和revert的却别</h2><ul><li><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。 </li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li><code>git reset</code>是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li><li>git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。</li></ul><p>另外，说一下<code>git revert</code>， <code>git reset –hard</code>和 <code>–soft</code>的区别</p><ul><li><code>git reset –mixed id</code>: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。</li><li><code>git reset –soft id</code>: 实际上，是<code>git reset –mixed id</code>后，又做了一次<code>git add</code>。</li><li><code>git reset –herd id</code>: 是将git的HEAD变了，文件也变了。</li></ul><h2 id="6-Git-merge和reabse的相同点和不同点"><a href="#6-Git-merge和reabse的相同点和不同点" class="headerlink" title="6. Git merge和reabse的相同点和不同点"></a>6. Git merge和reabse的相同点和不同点</h2><p><code>merge</code>是合并的意思，<code>rebase</code>是复位基底的意思，相同点都是用来合并分支的。</p><p><img src="http://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png" alt="merge和rebase"></p><p>不同点:</p><ul><li><code>merge</code>操作会生成一个新的节点，之前的提交分开显示。而<code>rebase</code>操作不会生成新的节点，是将两个分支融合成一个线性的提交。</li><li>解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而<code>rebase</code>操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li><li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是”获取”和”合并”。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</li></ul><p><strong>总结</strong>：选择 merge 还是 rebase？</p><ul><li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li><li>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面</li><li>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面</li><li>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面</li><li>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定</li><li>merge 和 rebase 还有很多强大的选项，可以使用 git help <command> 查看</li></ul><h2 id="7-Git-stash是什么？它的相关使用方式命令"><a href="#7-Git-stash是什么？它的相关使用方式命令" class="headerlink" title="7. Git stash是什么？它的相关使用方式命令"></a>7. Git stash是什么？它的相关使用方式命令</h2><ul><li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li><li>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li><li>git stash pop –index stash@{0}: 恢复编号为0的进度的工作区和暂存区。</li><li>git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来</li><li>git stash drop[<stash>] 删除某一个进度，默认删除最新进度</li><li>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li><li>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复工作进度</span><span class="token function">git</span> stash pop <span class="token punctuation">[</span>--index<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>stash<span class="token operator">></span><span class="token punctuation">]</span>--index 参数：不仅恢复工作区，还恢复暂存区<span class="token operator">&lt;</span>stash<span class="token operator">></span> 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度<span class="token comment" spellcheck="true"># 这是git stash保存进度的完整命令形式</span><span class="token function">git</span> stash <span class="token punctuation">[</span>save message<span class="token punctuation">]</span> <span class="token punctuation">[</span>-k<span class="token operator">|</span>--no-keep-index<span class="token punctuation">]</span> <span class="token punctuation">[</span>--patch<span class="token punctuation">]</span>-k和--no-keep-index指定保存进度后，是否重置暂存区--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似使用save可以对进度添加备注<span class="token comment" spellcheck="true"># git stash save "这是保存的进度"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-Git只从暂存区删除，从工作空间删除的命令分别是什么"><a href="#8-Git只从暂存区删除，从工作空间删除的命令分别是什么" class="headerlink" title="8. Git只从暂存区删除，从工作空间删除的命令分别是什么"></a>8. Git只从暂存区删除，从工作空间删除的命令分别是什么</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> --cached<span class="token function">git</span> <span class="token function">rm</span><span class="token function">git</span> commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-Git标签的使用"><a href="#9-Git标签的使用" class="headerlink" title="9. Git标签的使用"></a>9. Git标签的使用</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出现有的标签</span><span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 打标签</span><span class="token function">git</span> tag -a v1.01 -m <span class="token string">"Relase version 1.01"</span><span class="token comment" spellcheck="true"># 查看相应标签的版本信息</span><span class="token function">git</span> show v1.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>-a 选项,创建一个含附注类型的标签</li><li>-m 选项,指定了对应的标签说明</li></ul><h2 id="9-Git分支的使用"><a href="#9-Git分支的使用" class="headerlink" title="9. Git分支的使用"></a>9. Git分支的使用</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看本地分支</span><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 查看远程分支</span><span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 创建本地分支(注意新分支创建后不会自动切换为当前分支)</span><span class="token function">git</span> branch <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换分支</span><span class="token function">git</span> checkout <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 创建新分支并立即切换到新分支</span><span class="token function">git</span> checkout -b <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强制删除一个分支</span><span class="token function">git</span> branch -D <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并分支(将名称为[name]的分支与当前分支合并)</span><span class="token function">git</span> merge <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看各个分支最后提交信息</span><span class="token function">git</span> br -v<span class="token comment" spellcheck="true"># 查看已经被合并到当前分支的分支</span><span class="token function">git</span> br --merged<span class="token comment" spellcheck="true"># 查看尚未被合并到当前分支的分支</span><span class="token function">git</span> br --no-merged<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别"><a href="#10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别" class="headerlink" title="10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别"></a>10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别</h2><p>merge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个<code>git checkout upstream</code>的过程，将<code>HEAD</code>从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。</p><h2 id="11-Git远程操作相关"><a href="#11-Git远程操作相关" class="headerlink" title="11. Git远程操作相关"></a>11. Git远程操作相关</h2><h3 id="1-clone"><a href="#1-clone" class="headerlink" title="(1). clone"></a>(1). clone</h3><blockquote><p>git clone &lt;版本库的网址&gt;<br>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆jQuery的版本库</span> <span class="token function">git</span> clone https://github.com/jquery/jquery.git <span class="token function">git</span> clone -o jQuery https://github.com/jquery/jquery.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-remote"><a href="#2-remote" class="headerlink" title="(2). remote"></a>(2). remote</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有远程主机</span><span class="token function">git</span> remote<span class="token comment" spellcheck="true"># 使用-v选项，可以参看远程主机的网址</span><span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 可以查看该主机的详细信息</span><span class="token function">git</span> remote show <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 添加远程主机</span><span class="token function">git</span> remote add <span class="token operator">&lt;</span>主机名<span class="token operator">></span> <span class="token operator">&lt;</span>网址<span class="token operator">></span><span class="token comment" spellcheck="true"># 删除远程主机</span><span class="token function">git</span> remote <span class="token function">rm</span> <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 修改远程主机名称</span><span class="token function">git</span> remote <span class="token function">rename</span> <span class="token operator">&lt;</span>原主机名<span class="token operator">></span> <span class="token operator">&lt;</span>新主机名<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-fetch"><a href="#3-fetch" class="headerlink" title="(3). fetch"></a>(3). fetch</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回所有分支(branch)的更新到本地</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回某的特定分支的更新</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回origin主机的master分支的更新</span><span class="token function">git</span> fetch origin master<span class="token comment" spellcheck="true"># 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支</span><span class="token function">git</span> merge origin/master<span class="token function">git</span> rebase origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-pull"><a href="#4-pull" class="headerlink" title="(4). pull"></a>(4). pull</h3><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回origin主机的next分支，与本地的master分支合并</span><span class="token function">git</span> pull origin next:master<span class="token comment" spellcheck="true"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><span class="token function">git</span> pull origin next<span class="token comment" spellcheck="true"># 上面的命令实质上等同于先做git fetch，再做git merge。</span><span class="token function">git</span> fetch origin<span class="token function">git</span> merge origin/next<span class="token comment" spellcheck="true"># 合并需要采用rebase模式</span><span class="token function">git</span> pull --rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">></span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-push"><a href="#5-push" class="headerlink" title="(5). push"></a>(5). push</h3><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><p><strong>注意</strong>:分支推送顺序的写法是”&lt;来源地&gt;:&lt;目的地&gt;”，所以git pull是”&lt;远程分支&gt;:&lt;本地分支&gt;”，而git push是”&lt;本地分支&gt;:&lt;远程分支&gt;”。</p><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建</span><span class="token function">git</span> push origin master<span class="token comment" spellcheck="true"># 省略了本地分支，以下等同，删除origin主机的master分支</span><span class="token function">git</span> push origin :master<span class="token function">git</span> push origin --delete master<span class="token comment" spellcheck="true"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略</span><span class="token function">git</span> push origin<span class="token comment" spellcheck="true"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><span class="token function">git</span> push<span class="token comment" spellcheck="true"># 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push</span><span class="token function">git</span> push -u origin master<span class="token comment" spellcheck="true"># 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机</span><span class="token function">git</span> push --all origin<span class="token comment" spellcheck="true"># 强制推送</span><span class="token function">git</span> push --force origin<span class="token comment" spellcheck="true"># git push不会推送标签(tag)，除非使用–tags选项</span><span class="token function">git</span> push origin --tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-Git-Flow使用简介"><a href="#12-Git-Flow使用简介" class="headerlink" title="12. Git Flow使用简介"></a>12. Git Flow使用简介</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><p>三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">Git flow</a>。</p><p>它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。</p><h3 id="1-Git-Flow流程图"><a href="#1-Git-Flow流程图" class="headerlink" title="(1). Git Flow流程图"></a>(1). Git Flow流程图</h3><p><img src="https://pic.lixl.cn/ghost/imagegit_flow.png" alt="Git Flow流程图"></p><h3 id="2-Git-Flow常用的分支"><a href="#2-Git-Flow常用的分支" class="headerlink" title="(2). Git Flow常用的分支"></a>(2). Git Flow常用的分支</h3><ul><li><code>Production</code>分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。</li><li><code>Develop</code>分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。</li><li><code>Feature</code>分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li><li><code>Release</code>分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li><li><code>Hotfix</code>分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li></ul><h3 id="3-Git-Flow代码示例"><a href="#3-Git-Flow代码示例" class="headerlink" title="(3). Git Flow代码示例"></a>(3). Git Flow代码示例</h3><h4 id="a-创建develop分支"><a href="#a-创建develop分支" class="headerlink" title="a. 创建develop分支"></a>a. 创建develop分支</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> branch develop<span class="token function">git</span> push -u origin develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="b-开始新Feature开发"><a href="#b-开始新Feature开发" class="headerlink" title="b. 开始新Feature开发"></a>b. 开始新Feature开发</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b some-feature develop<span class="token comment" spellcheck="true"># Optionally, push branch to origin:</span><span class="token function">git</span> push -u origin some-feature<span class="token comment" spellcheck="true"># 做一些改动</span><span class="token function">git</span> status<span class="token function">git</span> add some-file<span class="token function">git</span> commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="c-完成Feature"><a href="#c-完成Feature" class="headerlink" title="c. 完成Feature"></a>c. 完成Feature</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> pull origin develop<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff some-feature<span class="token function">git</span> push origin develop<span class="token function">git</span> branch -d some-feature<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete some-feature<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="d-开始Relase"><a href="#d-开始Relase" class="headerlink" title="d. 开始Relase"></a>d. 开始Relase</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b release-0.1.0 develop<span class="token comment" spellcheck="true"># Optional: Bump version number, commit</span><span class="token comment" spellcheck="true"># Prepare release, commit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="e-完成Release"><a href="#e-完成Release" class="headerlink" title="e. 完成Release"></a>e. 完成Release</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> branch -d release-0.1.0<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete release-0.1.0<span class="token function">git</span> tag -a v0.1.0 master<span class="token function">git</span> push --tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="f-开始Hotfix"><a href="#f-开始Hotfix" class="headerlink" title="f. 开始Hotfix"></a>f. 开始Hotfix</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b hotfix-0.1.1 master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="g-完成Hotfix"><a href="#g-完成Hotfix" class="headerlink" title="g. 完成Hotfix"></a>g. 完成Hotfix</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> branch -d hotfix-0.1.1<span class="token function">git</span> tag -a v0.1.1 master<span class="token function">git</span> push --tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-gitignore-设置失效的解决方法"><a href="#12-gitignore-设置失效的解决方法" class="headerlink" title="12. gitignore 设置失效的解决方法"></a>12. gitignore 设置失效的解决方法</h2><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。对应在解决方法：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> -r --cached <span class="token keyword">.</span><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">'update .gitignore'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样设置git的配置后再执行add操作就没有问题了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式（State Pattern）</title>
      <link href="/2018/092123773.html"/>
      <url>/2018/092123773.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(<code>stateful</code>)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>状态模式(<code>State Pattern</code>)</strong>：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(<code>Objects for States</code>)，状态模式是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>状态模式包含如下角色：</p><ul><li><code>Context</code>: 环境类</li><li><code>State</code>: 抽象状态角色</li><li><code>ConcreteState</code>: 具体状态角色类</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="https://pic.lixl.cn/State.jpg" alt="状态模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="https://pic.lixl.cn/seq_State.jpg" alt="状态模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的状态角色接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象状态角色 * */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法1     */</span>    <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法2     */</span>    <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，是多个具体的状态角色类，分别如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类1 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState1</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类2 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState2</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是环境类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 环境角色类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前状态</span>    <span class="token keyword">private</span> IState state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法     * @param state     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IState state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法1     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法2     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是用于测试状态模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 状态模式的客户端场景累 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StateClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteState1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li></ul><p>在状态模式结构中需要理解环境类与抽象状态类的作用：</p><ul><li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。</li><li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>状态模式的优点：</p><ul><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>状态模式的缺点：</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用状态模式：</p><ul><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li></ul><blockquote><p>状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。</li><li>状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</li><li>状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式（Proxy Pattern）</title>
      <link href="/2018/092032073.html"/>
      <url>/2018/092032073.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>代理模式(<code>Proxy Pattern</code>)</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做<code>Proxy</code>或<code>Surrogate</code>，它是一种对象结构型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>代理模式包含如下角色：</p><ul><li><code>Subject</code>: 抽象主题角色</li><li><code>RealSubject</code>: 真实主题角色</li><li><code>Proxy</code>: 代理主题角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg" alt="代理模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的主题接口和真实主题类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象主题类 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义一个方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 真实主题类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"真实主题类请求方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是代理类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ISubject subject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Proxy</span><span class="token punctuation">(</span>ISubject subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 预处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行前(before)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 善后处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行后(after)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景测试类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理模式客户端场景类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ISubject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Proxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>代理模式的优点：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li><li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对真实对象的使用权限。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>代理模式的缺点：</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write 代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write 代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li><li><strong>同步化(Synchronization)代理</strong>：使几个用户能够同时使用一个对象而没有冲突。</li><li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做 Proxy 或 Surrogate，它是一种对象结构型模式。</li><li>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li><li>代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式（Factory Pattern）</title>
      <link href="/2018/091449719.html"/>
      <url>/2018/091449719.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><p>工厂方法模式(<code>Factory Method Pattern</code>)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>工厂方法模式包含如下角色：</p><ul><li><code>Product</code>：抽象产品</li><li><code>ConcreteProduct</code>：具体产品</li><li><code>Factory</code>：抽象工厂</li><li><code>ConcreteFactory</code>：具体工厂</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/FactoryMethod.jpg" alt="工厂方法模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="https://pic.lixl.cn/seq_FactoryMethod.jpg" alt="工厂方法模式时序图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是抽象的产品类和具体的产品类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象产品类 * */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品类的公共方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是产品类的公共方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类1 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct1的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类2 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct2的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是抽象的工厂类和具体的工厂类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体生产产品的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Factory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>工厂方法模式的优点：</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>工厂方法模式的缺点：</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到 DOM、反射等技术，增加了系统的实现难度。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="五、模式扩展"><a href="#五、模式扩展" class="headerlink" title="五、模式扩展"></a>五、模式扩展</h2><p>工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍 4 种常用扩展。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式中的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。</p><h3 id="2-多工厂类工厂方法模式"><a href="#2-多工厂类工厂方法模式" class="headerlink" title="2. 多工厂类工厂方法模式"></a>2. 多工厂类工厂方法模式</h3><p>当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下：</p><p>多工厂模式的抽象工厂类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成多个产品的抽象工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成某种产品的方法     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种产品的创建工厂实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品1的具体工厂类1 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品1的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种产品的创建工厂实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品2的具体工厂类2 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品2的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多工厂模式的客户端场景类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 多工厂方法模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product concreteProduct1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product concreteProduct2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-工厂方法的单例模式"><a href="#3-工厂方法的单例模式" class="headerlink" title="3. 工厂方法的单例模式"></a>3. 工厂方法的单例模式</h3><p>单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。</p><p>下面是单例类，其中定义了一个 private 的无参构造函数，目的是不允许通过 new 的方式创建对象，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式中的单例类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 私有化构造方法，不允许new产生一个对象     */</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 工厂方法模式中的单例模式业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工厂方法模式中的单例模式方法。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成单例的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Class <span class="token class-name">c</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获得无参构造</span>            Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置无参构造是可访问的</span>            constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 产生一个实例对象</span>            singleton <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生成单例的工厂类方法中生成单例出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>zuihou        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后是工厂方法单例模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法单例模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Singleton singleton <span class="token operator">=</span> SingletonFactory<span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        singleton<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-工厂方法的延迟初始化"><a href="#4-工厂方法的延迟初始化" class="headerlink" title="4. 工厂方法的延迟初始化"></a>4. 工厂方法的延迟初始化</h3><p>何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> lazyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> lazyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 根据类型创建具体的产品对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 同时把对象放到缓存容器中</span>        lazyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面即为延迟加载的工厂类。代码比较简单，通过定义一个<code>map</code>容器来容纳所有产生的对象，如果在<code>map</code>容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到<code>map</code>容器中，以便下次调用。</p><p>延迟加载的工厂模式客户端场景类代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product11 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li><li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式（Decorator Pattern）</title>
      <link href="/2018/091461471.html"/>
      <url>/2018/091461471.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li></ul><p><strong>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。<strong>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)</strong>，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p></blockquote><p>策略模式是一种<strong>对象结构型</strong>模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>装饰模式包含如下角色：</p><ul><li><code>Component</code>: 抽象构件</li><li><code>ConcreteComponent</code>: 具体构件</li><li><code>Decorator</code>: 抽象装饰类</li><li><code>ConcreteDecorator</code>: 具体装饰类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://pic.lixl.cn/Decorator.jpg" alt="装饰模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://pic.lixl.cn/seq_Decorator.jpg" alt="装饰模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个抽象构件接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象构件 * */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 接口方法</span>    <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是具体构件实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体构件 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do Something..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是装饰角色：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰角色 * 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Component component<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 委托给被修饰者执行     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是具体的装饰类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类1 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator1</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator1</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法1     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method1修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类2 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator2</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator2</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法2     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method2修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后是客户端的场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰模式的客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第一修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator1</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第二修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator2</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 修饰后运行</span>        component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li><strong>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，<em>关联关系的缺点是比继承关系要创建更多的对象</em>。</li><li><strong>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>装饰模式的优点：</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰模式的缺点：</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>装饰模式的简化-需要注意的问题:</p><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。</li><li>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li><li>装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。</li><li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。</li><li>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li><li>装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。</li><li>装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式（Strategy Pattern）</title>
      <link href="/2018/09149157.html"/>
      <url>/2018/09149157.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(<code>Hard Coding</code>)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过 if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</p><p>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><p>为了解决这些问题，可以<strong>定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</strong>。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)</strong>。</p></blockquote><p>策略模式是一种对象行为型模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>策略模式包含如下角色：</p><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://pic.lixl.cn/Strategy1.jpg" alt="策略模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://pic.lixl.cn/strategy2.jpg" alt="策略模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个策略接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 策略模式的运算法则     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是具体的策略实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy1</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy2</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是封装角色的类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 抽象策略</span>    <span class="token keyword">private</span> IStrategy strategy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数设置具体策略     * @param strategy     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IStrategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 封装后的策略方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后是客户端的调用策略类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 声明一个具体的策略</span>        IStrategy strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteStrategy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明上下文对象</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行封装后的方法</span>        context<span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“<strong>准备一组算法，并将每一个算法封装起来，使得它们可以互换</strong>”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>策略模式的优点：</p><ul><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>策略模式的缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>策略模式与状态模式：</p><ul><li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</li><li>策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。</li><li>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</li><li>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</li><li>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
