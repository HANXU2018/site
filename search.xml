<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>idea常用快捷键Mac版</title>
      <link href="/2020/020459974.html"/>
      <url>/2020/020459974.html</url>
      
        <content type="html"><![CDATA[<h3 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h3><ul><li><code>⌘</code> Command</li><li><code>⇧</code> Shift</li><li><code>⌥</code> Option</li><li><code>⌃</code> Control</li><li><code>↩︎</code> Return/Enter</li><li><code>⌫</code> Delete</li><li><code>⌦</code> 向前删除键（Fn+Delete）</li><li><code>↑</code> 上箭头</li><li><code>↓</code> 下箭头</li><li><code>←</code> 左箭头</li><li><code>→</code> 右箭头</li><li><code>⇞</code> Page Up（Fn+↑）</li><li><code>⇟</code> Page Down（Fn+↓）</li><li><code>Home</code> Fn + ←</li><li><code>End</code> Fn + →</li><li><code>⇥</code> 右制表符（Tab键）</li><li><code>⇤</code> 左制表符（Shift+Tab）</li><li><code>⎋</code> Escape (Esc)</li></ul><h3 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a>Editing（编辑）</h3><ul><li><code>⌃ Space</code> 基本的代码补全（补全任何类、方法、变量）</li><li><code>⌃ ⇧ Space</code> 智能代码补全（过滤器方法列表和变量的预期类型）</li><li><code>⌘ ⇧ ↩</code> 自动结束代码，行末自动添加分号</li><li><code>⌘ P</code> 显示方法的参数信息</li><li><code>⌃ J, Mid. button click</code> 快速查看文档</li><li><code>⇧ F1</code> 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li><li><code>⌘ 鼠标放在代码上</code> 显示代码简要信息</li><li><code>⌘ F1</code> 在错误或警告处显示具体描述信息</li><li><code>⌘ N, ⌃↩, ⌃N</code> 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li><code>⌃ O</code> 覆盖方法（重写父类方法）</li><li><code>⌃ I</code> 实现方法（实现接口中的方法）</li><li><code>⌘ ⌥ T</code> 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）</li><li><code>⌘ /</code> 注释/取消注释与行注释</li><li><code>⌘ ⌥ /</code> 注释/取消注释与块注释</li><li><code>⌥ ↑</code> 连续选中代码块</li><li><code>⌥ ↓</code> 减少当前选中的代码块</li><li><code>⌃ ⇧ Q</code> 显示上下文信息</li><li><code>⌥ ↩</code> 显示意向动作和快速修复代码</li><li><code>⌘ ⌥ L</code> 格式化代码</li><li><code>⌃ ⌥ O</code> 优化import</li><li><code>⌃ ⌥ I</code> 自动缩进线</li><li><code>⇥ / ⇧⇥</code> 缩进代码 / 反缩进代码</li><li><code>⌘ X</code> 剪切当前行或选定的块到剪贴板</li><li><code>⌘ C</code> 复制当前行或选定的块到剪贴板</li><li><code>⌘ V</code> 从剪贴板粘贴</li><li><code>⌘ ⇧ V</code> 从最近的缓冲区粘贴</li><li><code>⌘ D</code> 复制当前行或选定的块</li><li><code>⌘ ⌫</code> 删除当前行或选定的块的行</li><li><code>⌃ ⇧ J</code> 智能的将代码拼接成一行</li><li><code>⌘ ↩</code> 智能的拆分拼接的行</li><li><code>⇧ ↩</code> 开始新的一行</li><li><code>⌘ ⇧ U</code> 大小写切换</li><li><code>⌘ ⇧ ] / ⌘ ⇧ [</code> 选择直到代码块结束/开始</li><li><code>⌥ ⌦</code> 删除到单词的末尾（⌦键为Fn+Delete）</li><li><code>⌥ ⌫</code> 删除到单词的开头</li><li><code>⌘ + / ⌘ -</code> 展开 / 折叠代码块</li><li><code>⌘ ⇧ +</code> 展开所以代码块</li><li><code>⌘ ⇧ -</code> 折叠所有代码块</li><li><code>⌘ W</code> 关闭活动的编辑器选项卡</li></ul><h3 id="Search-Replace（查询-替换）"><a href="#Search-Replace（查询-替换）" class="headerlink" title="Search/Replace（查询/替换）"></a>Search/Replace（查询/替换）</h3><ul><li><code>Double ⇧</code> 查询任何东西</li><li><code>⌘ F</code> 文件内查找</li><li><code>⌘ G</code> 查找模式下，向下查找</li><li><code>⌘ ⇧ G</code> 查找模式下，向上查找</li><li><code>⌘ R</code> 文件内替换</li><li><code>⌘ ⇧ F</code> 全局查找（根据路径）</li><li><code>⌘ ⇧ R</code> 全局替换（根据路径）</li><li><code>⌘ ⇧ S</code> 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</li><li><code>⌘ ⇧ M</code> 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</li></ul><h3 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h3><ul><li><code>⌥ F7 / ⌘ F7</code> 在文件中查找用法 / 在类中查找用法</li><li><code>⌘ ⇧ F7</code> 在文件中突出显示的用法</li><li><code>⌘ ⌥ F7</code> 显示用法</li></ul><h3 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h3><ul><li><code>⌘ F9</code> 编译Project</li><li><code>⌘ ⇧ F9</code> 编译选择的文件、包或模块</li><li><code>⌃ ⌥ R</code> 弹出 Run 的可选择菜单</li><li><code>⌃ ⌥ D</code> 弹出 Debug 的可选择菜单</li><li><code>⌃ R</code> 运行</li><li><code>⌃ D</code> 调试</li><li><code>⌃ ⇧ R, ⌃ ⇧ D</code> 从编辑器运行上下文环境配置</li></ul><h3 id="Debugging（调试）"><a href="#Debugging（调试）" class="headerlink" title="Debugging（调试）"></a>Debugging（调试）</h3><ul><li><code>F8</code> 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li><code>F7</code> 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</li><li><code>⇧ F7</code> 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</li><li><code>⇧ F8</code> 跳出</li><li><code>⌥ F9</code> 运行到光标处，如果光标前有其他断点会进入到该断点</li><li><code>⌥ F8</code> 计算表达式（可以更改变量值使其生效）</li><li><code>⌘ ⌥ R</code> 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</li><li><code>⌘ F8</code> 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</li><li><code>⌘ ⇧ F8</code> 查看断点信息</li></ul><h3 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h3><ul><li><code>⌘ O</code> 查找类文件</li><li><code>⌘ ⇧ O</code> 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠<code>/</code></li><li><code>⌘ ⌥ O</code> 前往指定的变量 / 方法</li><li><code>⌃ ← / ⌃ →</code> 左右切换打开的编辑tab页</li><li><code>F12</code> 返回到前一个工具窗口</li><li><code>⎋</code> 从工具窗口进入代码文件窗口</li><li><code>⇧ ⎋</code> 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li><code>⌘ ⇧ F4</code> 关闭活动run/messages/find/… tab</li><li><code>⌘ L</code> 在当前文件跳转到某一行的指定处</li><li><code>⌘ E</code> 显示最近打开的文件记录列表</li><li><code>⌘ ⌥ ← / ⌘ ⌥ →</code> 退回 / 前进到上一个操作的地方</li><li><code>⌘ ⇧ ⌫</code> 跳转到最后一个编辑的地方</li><li><code>⌥ F1</code> 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li><code>⌘ B / ⌘ 鼠标点击</code> 进入光标所在的方法/变量的接口或是定义处</li><li><code>⌘ ⌥ B</code> 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li><li><code>⌥ Space, ⌘ Y</code> 快速打开光标所在方法、类的定义</li><li><code>⌃ ⇧ B</code> 跳转到类型声明处</li><li><code>⌘ U</code> 前往当前光标所在方法的父类的方法 / 接口定义</li><li><code>⌃ ↓ / ⌃ ↑</code> 当前光标跳转到当前文件的前一个/后一个方法名位置</li><li><code>⌘ ] / ⌘ [</code> 移动光标到当前所在代码的花括号开始/结束位置</li><li><code>⌘ F12</code> 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li><li><code>⌃ H</code> 显示当前类的层次结构</li><li><code>⌘ ⇧ H</code> 显示方法层次结构</li><li><code>⌃ ⌥ H</code> 显示调用层次结构</li><li><code>F2 / ⇧ F2</code> 跳转到下一个/上一个突出错误或警告的位置</li><li><code>F4 / ⌘ ↓</code> 编辑/查看代码源</li><li><code>⌥ Home</code> 显示到当前文件的导航条</li><li><code>F3</code>选中文件/文件夹/代码行，添加/取消书签</li><li><code>⌥ F3</code> 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li><code>⌃0...⌃9</code> 定位到对应数值的书签位置</li><li><code>⌘ F3</code> 显示所有书签</li></ul><h3 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h3><ul><li><code>F5</code> 复制文件到指定目录</li><li><code>F6</code> 移动文件到指定目录</li><li><code>⌘ ⌫</code> 在文件上为安全删除文件，弹出确认框</li><li><code>⇧ F6</code> 重命名文件</li><li><code>⌘ F6</code> 更改签名</li><li><code>⌘ ⌥ N</code> 一致性</li><li><code>⌘ ⌥ M</code> 将选中的代码提取为方法</li><li><code>⌘ ⌥ V</code> 提取变量</li><li><code>⌘ ⌥ F</code> 提取字段</li><li><code>⌘ ⌥ C</code> 提取常量</li><li><code>⌘ ⌥ P</code> 提取参数</li></ul><h3 id="VCS-Local-History（版本控制-本地历史记录）"><a href="#VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="VCS/Local History（版本控制/本地历史记录）"></a>VCS/Local History（版本控制/本地历史记录）</h3><ul><li><code>⌘ K</code> 提交代码到版本控制器</li><li><code>⌘ T</code> 从版本控制器更新代码</li><li><code>⌥ ⇧ C</code> 查看最近的变更记录</li><li><code>⌃ C</code> 快速弹出版本控制器操作面板</li></ul><h3 id="Live-Templates（动态代码模板）"><a href="#Live-Templates（动态代码模板）" class="headerlink" title="Live Templates（动态代码模板）"></a>Live Templates（动态代码模板）</h3><ul><li><code>⌘ ⌥ J</code> 弹出模板选择窗口，将选定的代码使用动态模板包住</li><li><code>⌘ J</code> 插入自定义动态代码模板</li></ul><h3 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h3><ul><li><code>⌘1...⌘9</code> 打开相应编号的工具窗口</li><li><code>⌘ S</code> 保存所有</li><li><code>⌘ ⌥ Y</code> 同步、刷新</li><li><code>⌃ ⌘ F</code> 切换全屏模式</li><li><code>⌘ ⇧ F12</code> 切换最大化编辑器</li><li><code>⌥ ⇧ F</code> 添加到收藏夹</li><li><code>⌥ ⇧ I</code> 检查当前文件与当前的配置文件</li><li><code>⌘ ,</code> 打开IDEA系统设置</li><li><code>⌘ ;</code> 打开项目结构对话框</li><li><code>⌘ ⇧ A</code> 查找动作（可设置相关选项）</li><li><code>⌃ ⇥</code> 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）</li></ul><h3 id="Other（其它）"><a href="#Other（其它）" class="headerlink" title="Other（其它）"></a>Other（其它）</h3><ul><li><code>⌘ ⇧ 8</code> 竖编辑模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode常用快捷键Mac版</title>
      <link href="/2020/020253487.html"/>
      <url>/2020/020253487.html</url>
      
        <content type="html"><![CDATA[<h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>Command + K + Command + S 打开快捷键查找/编辑页<br>Command + Shift + P / F1 显示命令面板<br>Command + P 快速打开文件<br>Command + Shift + N 打开新窗口<br>Command + W 关闭窗口</p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>Command + X 剪切（未选中文本的情况下，剪切光标所在行）<br>Command + C 复制（未选中文本的情况下，复制光标所在行）<br>Option + Up 向上移动行<br>Option + Down 向下移动行<br>Option + Shift + Up 向上复制行<br>Option + Shift + Down 向下复制行<br>Command + Shift + K 删除行<br>Command + Enter 下一行插入<br>Command + Shift + Enter 上一行插入<br>Command + Shift +  跳转到匹配的括号<br>Command + [ 减少缩进<br>Command + ] 增加缩进<br>Home 跳转至行首<br>End 跳转到行尾<br>Command + Up 跳转至文件开头<br>Command + Down 跳转至文件结尾<br>Ctrl + PgUp 按行向上滚动<br>Ctrl + PgDown 按行向下滚动<br>Command + PgUp 按屏向上滚动<br>Command + PgDown 按屏向下滚动<br>Command + Shift + [ 折叠代码块<br>Command + Shift + ] 展开代码块<br>Command + K Command + [ 折叠全部子代码块<br>Command + K Command + ] 展开全部子代码块<br>Command + K Command + 0 折叠全部代码块<br>Command + K Command + J 展开全部代码块<br>Command + K Command + C 添加行注释<br>Command + K Command + U 移除行注释<br>Command + / 添加、移除行注释<br>Option + Shift + A 添加、移除块注释<br>Option + Z 自动换行、取消自动换行</p><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><p>Option + 点击 插入多个光标<br>Command + Option + Up 向上插入光标<br>Command + Option + Down 向下插入光标<br>Command + U 撤销上一个光标操作<br>Option + Shift + I 在所选行的行尾插入光标<br>Command + I 选中当前行<br>Command + Shift + L 选中所有与当前选中内容相同部分<br>Command + F2 选中所有与当前选中单词相同的单词<br>Command + Ctrl + Shift + Left 折叠选中<br>Command + Ctrl + Shift + Right 展开选中<br>Alt + Shift + 拖动鼠标 选中代码块<br>Command + Shift + Option + Up 列选择 向上<br>Command + Shift + Option + Down 列选择 向下<br>Command + Shift + Option + Left 列选择 向左<br>Command + Shift + Option + Right 列选择 向右<br>Command + Shift + Option + PgUp 列选择 向上翻页<br>Command + Shift + Option + PgDown 列选择 向下翻页</p><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><p>Command + F 查找<br>Command + Option + F 替换<br>Command + G 查找下一个<br>Command + Shift + G 查找上一个<br>Option + Enter 选中所有匹配项<br>Command + D 向下选中相同内容<br>Command + K Command + D 移除前一个向下选中相同内容</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>Ctrl + Space 打开建议<br>Command + Shift + Space 参数提示<br>Tab Emmet插件缩写补全<br>Option + Shift + F 格式化<br>Command + K Command + F 格式化选中内容<br>F12 跳转到声明位置<br>Option + F12 查看具体声明内容<br>Command + K F12 分屏查看具体声明内容<br>Command + . 快速修复<br>Shift + F12 显示引用<br>F2 重命名符号<br>Command + Shift + . 替换为上一个值<br>Command + Shift + , 替换为下一个值<br>Command + K Command + X 删除行尾多余空格<br>Command + K M 更改文件语言</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>Command + T 显示所有符号<br>Ctrl + G 跳转至某行<br>Command + P 跳转到某个文件<br>Command + Shift + O 跳转到某个符号<br>Command + Shift + M 打开问题面板<br>F8 下一个错误或警告位置<br>Shift + F8 上一个错误或警告位置<br>Ctrl + Shift + Tab 编辑器历史记录<br>Ctrl + - 后退<br>Ctrl + Shift + - 前进<br>Ctrl + Shift + M Tab 切换焦点</p><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><p>Shift + Alt + 鼠标左键 列编辑模式<br>Command + W 关闭编辑器<br>Command + K F 关闭文件夹<br>Command +  编辑器分屏<br>Command + 1 切换到第一分组<br>Command + 2 切换到第二分组<br>Command + 3 切换到第三分组<br>Command + K Command + Left 切换到上一分组<br>Command + K Command + Right 切换到下一分组<br>Command + K Command + Shift + Left 左移编辑器<br>Command + K Command + Shift + Right 右移编辑器<br>Command + K Left 激活左侧编辑组<br>Command + K Right 激活右侧编辑组</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>Command + N 新建文件<br>Command + O 打开文件<br>Command + S 保存文件<br>Command + Shift + S 另存为<br>Command + Option + S 全部保存<br>Command + W 关闭<br>Command + K Command + W 全部关闭<br>Command + Shift + T 重新打开被关闭的编辑器<br>Command + K Enter 保持打开<br>Ctrl + Tab 打开下一个<br>Ctrl + Shift + Tab 打开上一个<br>Command + K P 复制当前文件路径<br>Command + K R 在资源管理器中查看当前文件<br>Command + K O 新窗口打开当前文件</p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>Command + Ctrl + F 全屏、退出全屏<br>Command + Option + 1 切换编辑器分屏方式（横、竖）<br>Command + + 放大<br>Command + - 缩小<br>Command + B 显示、隐藏侧边栏<br>Command + Shift + E 显示资源管理器 或 切换焦点<br>Command + Shift + F 显示搜索框<br>Ctrl + Shift + G 显示Git面板<br>Command + Shift + D 显示调试面板<br>Command + Shift + X 显示插件面板<br>Command + Shift + H 全局搜索替换<br>Command + Shift + J 显示、隐藏高级搜索<br>Command + Shift + C 打开新终端<br>Command + Shift + U 显示输出面板<br>Command + Shift + V Markdown预览窗口<br>Command + K V 分屏显示 Markdown预览窗口</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>F9 设置 或 取消断点<br>F5 开始 或 继续<br>F11 进入<br>Shift + F11 跳出<br>F10 跳过<br>Command + K Command + I 显示悬停信息</p><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><p>Ctrl + ` 显示/关闭终端<br>Command + Up 向上滚动<br>Command + Down 向下滚动<br>PgUp 向上翻页<br>PgDown 向下翻页<br>Command + Home 滚动到顶部<br>Command + End 滚动到底部</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地测试</title>
      <link href="/2020/011231581.html"/>
      <url>/2020/011231581.html</url>
      
        <content type="html"><![CDATA[<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p><p><img src="https://pic.lixl.cn/2019/20200113000457.png/w1280" alt="Node.js架构"></p><p>Node使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。<br>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。<br>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）。在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li>Node.js官网：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></li><li>版本管理工具nvm：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a></li><li>包管理工具npm：<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></li><li>npm中文文档：<a href="https://www.npmjs.cn/" target="_blank" rel="noopener">https://www.npmjs.cn/</a></li><li>国内的 npm 镜像源：<a href="http://cnpmjs.org/" target="_blank" rel="noopener">http://cnpmjs.org/</a></li><li>中文社区：<a href="https://cnodejs.org/" target="_blank" rel="noopener">https://cnodejs.org/</a></li></ul><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h4 id="安装nvm及Node-js"><a href="#安装nvm及Node-js" class="headerlink" title="安装nvm及Node.js"></a>安装nvm及Node.js</h4><p>nvm全名node.js version management，顾名思义是一个nodejs的版本管理工具。通过它可以安装和切换不同版本的nodejs。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装nvm:</span>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh <span class="token operator">|</span> <span class="token function">bash</span><span class="token comment" spellcheck="true"># 列出所有可以安装的node版本号</span>nvm ls-remote<span class="token comment" spellcheck="true"># 安装指定版本号的node</span>nvm <span class="token function">install</span> v12.4.1<span class="token comment" spellcheck="true"># 切换node的版本，这个是全局的</span>nvm use v10.15.3<span class="token comment" spellcheck="true"># 当前node版本</span>nvm current：node -v<span class="token comment" spellcheck="true"># 列出所有已经安装的node版本</span>nvm <span class="token function">ls</span></code></pre><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p>npm 是世界上最大的软件注册中心，随同NodeJS一起安装，来自全球各地的开源开发人员使用 npm 来共享和复用软件包。npm 由三个独立的部分组成：</p><ul><li>网站： <a href="https://npmjs.com" target="_blank" rel="noopener">https://npmjs.com</a> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。<ul><li>注册表（registry）：是一个巨大的数据库，保存了每个包（package）的信息。</li><li>命令行工具 (CLI)：通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。</li></ul></li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 npm 版本</span><span class="token function">npm</span> -v<span class="token comment" spellcheck="true"># 更新npm版本</span><span class="token function">npm</span> <span class="token function">install</span> npm@latest -g<span class="token comment" spellcheck="true"># 搜索模块</span><span class="token function">npm</span> search hexo<span class="token comment" spellcheck="true"># 安装依赖包</span><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&lt;</span>Module Name<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span> hexo      <span class="token comment" spellcheck="true"># 本地安装 hexo</span><span class="token function">npm</span> <span class="token function">install</span> hexo -g   <span class="token comment" spellcheck="true"># 全局安装 hexo</span><span class="token comment" spellcheck="true"># 查看所有全局安装的模块</span><span class="token function">npm</span> list -g<span class="token comment" spellcheck="true"># 查看某个模块</span><span class="token function">npm</span> list hexo<span class="token comment" spellcheck="true"># 卸载模块</span><span class="token function">npm</span> uninstall hexo<span class="token comment" spellcheck="true"># 卸载后，查看包是否还存在</span><span class="token function">npm</span> <span class="token function">ls</span><span class="token comment" spellcheck="true"># 更新某个模块</span><span class="token function">npm</span> update hexo<span class="token comment" spellcheck="true"># 创建模块</span><span class="token function">npm</span> init</code></pre><h3 id="Node特点"><a href="#Node特点" class="headerlink" title="Node特点"></a>Node特点</h3><h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h4><p>在Node中，绝大多数的操作都以异步的方式进行调用。在底层构建了很多异步I/O的API，从文件读取到网络请求等，均是如此。这样的意义在于，在Node中，我们可以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。在编程模型上可以极大提升效率。<br>下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时：</p><pre class=" language-js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件1完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path2'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件2完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>而对于同步I/O而言，它们的耗时是两个任务的耗时之和。这里异步带来的优势是显而易见的。</p><h4 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h4><p>在JavaScript中，函数被作为第一等公民来对待，可以将函数作为对象传递给方法作为实参进行调用。Node将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。</p><p>下面的例子展示的是Ajax异步提交的服务器端处理过程。Node创建一个Web服务器，并侦听8080端口。对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> quertstring <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> postData <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>  req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听请求的data事件</span>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">{</span>    postData <span class="token operator">+</span><span class="token operator">=</span> chunk<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听请求的end事件</span>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器启动完成，监听端口：8080'</span><span class="token punctuation">)</span></code></pre><p>相应地，我们在前端为Ajax请求绑定了success事件，在发出请求后，只需关心请求成功时执行相应的业务逻辑即可，相关代码如下：</p><pre class=" language-js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token string">'url'</span><span class="token punctuation">:</span> <span class="token string">'/url'</span><span class="token punctuation">,</span>  <span class="token string">'method'</span><span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>  <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">'success'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// success事件</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>与其他的Web后端编程语言相比，Node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的。代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍。</p><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。<br>同样，单线程也有它自身的弱点。Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：<code>child_process</code>。子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。</p><h4 id="擅长I-O密集型的应用"><a href="#擅长I-O密集型的应用" class="headerlink" title="擅长I/O密集型的应用"></a>擅长I/O密集型的应用</h4><p>通常，说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p><h4 id="性能不俗"><a href="#性能不俗" class="headerlink" title="性能不俗"></a>性能不俗</h4><p>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU，I/O阻塞造成的性能浪费远比CPU的影响小。</p><p><img src="https://pic.lixl.cn/2019/20200113165953.png/w1280" alt="计算斐波那契数列的耗时排行"></p><h3 id="创建Node应用"><a href="#创建Node应用" class="headerlink" title="创建Node应用"></a>创建Node应用</h3><h4 id="使用Node创建http服务器"><a href="#使用Node创建http服务器" class="headerlink" title="使用Node创建http服务器"></a>使用Node创建http服务器</h4><p>使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> hostname <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">;</span><span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 终端打印如下信息</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Server running at http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hostname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>port<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。使用 <strong>node</strong> 命令执行以上的代码：</p><pre class=" language-js"><code class="language-js">node server<span class="token punctuation">.</span>jsServer running at http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span></code></pre><p>打开浏览器访问 <code>http://127.0.0.1:8080/</code>，会看到一个写着 “Hello World”的网页。</p><h4 id="web框架express简单使用"><a href="#web框架express简单使用" class="headerlink" title="web框架express简单使用"></a>web框架express简单使用</h4><p>express 是 Node应用最广泛的快速、开放、极简主义 web 框架，现在是 4.x 版本。官方提供了应用程序生成器工具 express-generator 可以快速创建应用程序骨架。安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> express --save<span class="token function">npm</span> <span class="token function">install</span> express-generator -g</code></pre><p>创建名称为 <em>ExpressDemo</em> 的 Express 应用。此应用将在当前目录下的 <em>ExpressDemo</em> 目录中创建，并且设置为使用 <a href="https://pugjs.org/" target="_blank" rel="noopener">Pug</a> 模板引擎：</p><pre class=" language-bash"><code class="language-bash">express --view<span class="token operator">=</span>pug ExpressDemo   create <span class="token keyword">:</span> ExpressDemo/   create <span class="token keyword">:</span> ExpressDemo/public/   create <span class="token keyword">:</span> ExpressDemo/public/javascripts/   create <span class="token keyword">:</span> ExpressDemo/public/images/   create <span class="token keyword">:</span> ExpressDemo/public/stylesheets/   create <span class="token keyword">:</span> ExpressDemo/public/stylesheets/style.css   create <span class="token keyword">:</span> ExpressDemo/routes/   create <span class="token keyword">:</span> ExpressDemo/routes/index.js   create <span class="token keyword">:</span> ExpressDemo/routes/users.js   create <span class="token keyword">:</span> ExpressDemo/views/   create <span class="token keyword">:</span> ExpressDemo/views/error.pug   create <span class="token keyword">:</span> ExpressDemo/views/index.pug   create <span class="token keyword">:</span> ExpressDemo/views/layout.pug   create <span class="token keyword">:</span> ExpressDemo/app.js   create <span class="token keyword">:</span> ExpressDemo/package.json   create <span class="token keyword">:</span> ExpressDemo/bin/   create <span class="token keyword">:</span> ExpressDemo/bin/www   change directory:     $ <span class="token function">cd</span> ExpressDemo   <span class="token function">install</span> dependencies:     $ <span class="token function">npm</span> <span class="token function">install</span>   run the app:     $ DEBUG<span class="token operator">=</span>expressdemo:* <span class="token function">npm</span> start</code></pre><p>按提示安装依赖并启动。  </p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> ExpressDemo<span class="token function">npm</span> <span class="token function">install</span>DEBUG<span class="token operator">=</span>expressdemo:* <span class="token function">npm</span> start  <span class="token comment" spellcheck="true"># MacOS</span></code></pre><p>在浏览器中打开 <code>http://localhost:3000/</code> 就可以看到这个应用了。</p><p>通过生成器创建的应用一般都有如下目录结构：</p><pre class=" language-bash"><code class="language-bash">tree -I <span class="token string">"node_modules"</span><span class="token keyword">.</span>├── app.js├── bin│   └── www├── package-lock.json├── package.json├── public│   ├── images│   ├── javascripts│   └── stylesheets│       └── style.css├── routes│   ├── index.js│   └── users.js└── views    ├── error.pug    ├── index.pug    └── layout.pug7 directories, 10 files</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>官方文档：<a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/docs/</a></li><li>express官网：<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a></li><li>深入浅出Node.js：<a href="https://book.douban.com/subject/25768396/" target="_blank" rel="noopener">https://book.douban.com/subject/25768396/</a></li><li>Node.js 教程：<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></li><li>需要关注的Web 框架：<a href="https://www.infoq.cn/article/mB9uCHIgsE*mWI4vhITq" target="_blank" rel="noopener">https://www.infoq.cn/article/mB9uCHIgsE*mWI4vhITq</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> npm </tag>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js必知必会（安装配置、应用实例及同步控制）</title>
      <link href="/2020/011231581.html"/>
      <url>/2020/011231581.html</url>
      
        <content type="html"><![CDATA[<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p><p><img src="https://pic.lixl.cn/2019/20200113000457.png/w1280" alt=" "></p><p>Node使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。<br>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。<br>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）。在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>Node.js官网：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></li><li>版本管理工具nvm：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a></li><li>包管理工具npm：<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></li><li>npm中文文档：<a href="https://www.npmjs.cn/" target="_blank" rel="noopener">https://www.npmjs.cn/</a></li><li>国内的 npm 镜像源：<a href="http://cnpmjs.org/" target="_blank" rel="noopener">http://cnpmjs.org/</a></li><li>中文社区：<a href="https://cnodejs.org/" target="_blank" rel="noopener">https://cnodejs.org/</a></li></ul><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="安装nvm及Node-js"><a href="#安装nvm及Node-js" class="headerlink" title="安装nvm及Node.js"></a>安装nvm及Node.js</h3><p>nvm全名node.js version management，顾名思义是一个nodejs的版本管理工具。通过它可以安装和切换不同版本的nodejs。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装nvm:</span>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh <span class="token operator">|</span> <span class="token function">bash</span><span class="token comment" spellcheck="true"># 列出所有可以安装的node版本号</span>nvm ls-remote<span class="token comment" spellcheck="true"># 安装指定版本号的node</span>nvm <span class="token function">install</span> v12.4.1<span class="token comment" spellcheck="true"># 切换node的版本，这个是全局的</span>nvm use v10.15.3<span class="token comment" spellcheck="true"># 当前node版本</span>nvm current：node -v<span class="token comment" spellcheck="true"># 列出所有已经安装的node版本</span>nvm <span class="token function">ls</span></code></pre><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm 是世界上最大的软件注册中心，随同NodeJS一起安装，来自全球各地的开源开发人员使用 npm 来共享和复用软件包。npm 由三个独立的部分组成：</p><ul><li>网站： <a href="https://npmjs.com" target="_blank" rel="noopener">https://npmjs.com</a> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</li><li>注册表（registry）：是一个巨大的数据库，保存了每个包（package）的信息。</li><li>命令行工具 (CLI)：通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 npm 版本</span><span class="token function">npm</span> -v<span class="token comment" spellcheck="true"># 更新npm版本</span><span class="token function">npm</span> <span class="token function">install</span> npm@latest -g<span class="token comment" spellcheck="true"># 搜索模块</span><span class="token function">npm</span> search hexo<span class="token comment" spellcheck="true"># 安装依赖包</span><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&lt;</span>Module Name<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span> hexo      <span class="token comment" spellcheck="true"># 本地安装 hexo</span><span class="token function">npm</span> <span class="token function">install</span> hexo -g   <span class="token comment" spellcheck="true"># 全局安装 hexo</span><span class="token comment" spellcheck="true"># 查看所有全局安装的模块</span><span class="token function">npm</span> list -g<span class="token comment" spellcheck="true"># 查看某个模块</span><span class="token function">npm</span> list hexo<span class="token comment" spellcheck="true"># 卸载模块</span><span class="token function">npm</span> uninstall hexo<span class="token comment" spellcheck="true"># 卸载后，查看包是否还存在</span><span class="token function">npm</span> <span class="token function">ls</span><span class="token comment" spellcheck="true"># 更新某个模块</span><span class="token function">npm</span> update hexo<span class="token comment" spellcheck="true"># 创建模块</span><span class="token function">npm</span> init</code></pre><h2 id="Node特点"><a href="#Node特点" class="headerlink" title="Node特点"></a>Node特点</h2><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>在Node中，绝大多数的操作都以异步的方式进行调用。在底层构建了很多异步I/O的API，从文件读取到网络请求等，均是如此。这样的意义在于，在Node中，我们可以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。在编程模型上可以极大提升效率。<br>下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时：</p><pre class=" language-js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件1完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path2'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件2完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>而对于同步I/O而言，它们的耗时是两个任务的耗时之和。这里异步带来的优势是显而易见的。</p><h3 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h3><p>在JavaScript中，函数被作为第一等公民来对待，可以将函数作为对象传递给方法作为实参进行调用。Node将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。</p><p>下面的例子展示的是Ajax异步提交的服务器端处理过程。Node创建一个Web服务器，并侦听8080端口。对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> quertstring <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> postData <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>  req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听请求的data事件</span>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">{</span>    postData <span class="token operator">+</span><span class="token operator">=</span> chunk<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听请求的end事件</span>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器启动完成，监听端口：8080'</span><span class="token punctuation">)</span></code></pre><p>相应地，我们在前端为Ajax请求绑定了success事件，在发出请求后，只需关心请求成功时执行相应的业务逻辑即可，相关代码如下：</p><pre class=" language-js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token string">'url'</span><span class="token punctuation">:</span> <span class="token string">'/url'</span><span class="token punctuation">,</span>  <span class="token string">'method'</span><span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>  <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">'success'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// success事件</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>与其他的Web后端编程语言相比，Node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的。代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍。</p><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。<br>同样，单线程也有它自身的弱点。Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：<code>child_process</code>。子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。</p><h3 id="擅长I-O密集型的应用"><a href="#擅长I-O密集型的应用" class="headerlink" title="擅长I/O密集型的应用"></a>擅长I/O密集型的应用</h3><p>通常，说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p><h3 id="性能不俗"><a href="#性能不俗" class="headerlink" title="性能不俗"></a>性能不俗</h3><p>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU，I/O阻塞造成的性能浪费远比CPU的影响小。</p><p><img src="https://pic.lixl.cn/2019/20200113165953.png/w1280" alt="计算斐波那契数列的耗时排行"></p><h2 id="创建Node应用"><a href="#创建Node应用" class="headerlink" title="创建Node应用"></a>创建Node应用</h2><h3 id="使用Node创建http服务器"><a href="#使用Node创建http服务器" class="headerlink" title="使用Node创建http服务器"></a>使用Node创建http服务器</h3><p>使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> hostname <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">;</span><span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 终端打印如下信息</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Server running at http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hostname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>port<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。使用 <strong>node</strong> 命令执行以上的代码：</p><pre class=" language-js"><code class="language-js">node server<span class="token punctuation">.</span>jsServer running at http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span></code></pre><p>打开浏览器访问 <code>http://127.0.0.1:8080/</code>，会看到一个写着 “Hello World”的网页。</p><h3 id="web框架express简单使用"><a href="#web框架express简单使用" class="headerlink" title="web框架express简单使用"></a>web框架express简单使用</h3><p>express 是 Node应用最广泛的快速、开放、极简主义 web 框架，现在是 4.x 版本。官方提供了应用程序生成器工具 express-generator 可以快速创建应用程序骨架。安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> express --save<span class="token function">npm</span> <span class="token function">install</span> express-generator -g</code></pre><p>创建名称为 <em>ExpressDemo</em> 的 Express 应用。此应用将在当前目录下的 <em>ExpressDemo</em> 目录中创建，并且设置为使用 <a href="https://pugjs.org/" target="_blank" rel="noopener">Pug</a> 模板引擎：</p><pre class=" language-bash"><code class="language-bash">express --view<span class="token operator">=</span>pug ExpressDemo   create <span class="token keyword">:</span> ExpressDemo/   create <span class="token keyword">:</span> ExpressDemo/public/   create <span class="token keyword">:</span> ExpressDemo/public/javascripts/   create <span class="token keyword">:</span> ExpressDemo/public/images/   create <span class="token keyword">:</span> ExpressDemo/public/stylesheets/   create <span class="token keyword">:</span> ExpressDemo/public/stylesheets/style.css   create <span class="token keyword">:</span> ExpressDemo/routes/   create <span class="token keyword">:</span> ExpressDemo/routes/index.js   create <span class="token keyword">:</span> ExpressDemo/routes/users.js   create <span class="token keyword">:</span> ExpressDemo/views/   create <span class="token keyword">:</span> ExpressDemo/views/error.pug   create <span class="token keyword">:</span> ExpressDemo/views/index.pug   create <span class="token keyword">:</span> ExpressDemo/views/layout.pug   create <span class="token keyword">:</span> ExpressDemo/app.js   create <span class="token keyword">:</span> ExpressDemo/package.json   create <span class="token keyword">:</span> ExpressDemo/bin/   create <span class="token keyword">:</span> ExpressDemo/bin/www   change directory:     $ <span class="token function">cd</span> ExpressDemo   <span class="token function">install</span> dependencies:     $ <span class="token function">npm</span> <span class="token function">install</span>   run the app:     $ DEBUG<span class="token operator">=</span>expressdemo:* <span class="token function">npm</span> start</code></pre><p>按提示安装依赖并启动。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> ExpressDemo<span class="token function">npm</span> <span class="token function">install</span>DEBUG<span class="token operator">=</span>expressdemo:* <span class="token function">npm</span> start  <span class="token comment" spellcheck="true"># MacOS</span></code></pre><p>在浏览器中打开 <code>http://localhost:3000/</code> 就可以看到这个应用了。</p><p>通过生成器创建的应用一般都有如下目录结构：</p><pre class=" language-bash"><code class="language-bash">tree -I <span class="token string">"node_modules"</span><span class="token keyword">.</span>├── app.js├── bin│   └── www├── package-lock.json├── package.json├── public│   ├── images│   ├── javascripts│   └── stylesheets│       └── style.css├── routes│   ├── index.js│   └── users.js└── views    ├── error.pug    ├── index.pug    └── layout.pug7 directories, 10 files</code></pre><h2 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h2><p>异步是Node得天独厚的特点和优势，但我们经常还是会需要解决同步执行的场景。如方法A执行完才可以执行方法B。如下面这个例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行结果为:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>BA<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.12 seconds</code></pre><p>如果想要输出结果为 <code>A B</code>，可以采取 <code>Promise</code> 或 <code>Async</code> 来实现。</p><h3 id="基于Promise实现同步控制"><a href="#基于Promise实现同步控制" class="headerlink" title="基于Promise实现同步控制"></a>基于Promise实现同步控制</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。ES6 原生提供了<code>Promise</code>对象，提供统一的 API，各种异步操作都可以用同样的方法进行处理。示例如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Err'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>AB<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.123 seconds</code></pre><p>可以把 <code>Promise</code> 对象比喻为一个容器，里面有一个异步操作，<code>Promise</code> 容器只有在收到信号（resolve或者reject）时才会调用then方法。</p><blockquote><p>补充：<code>Promise</code> 构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供。<code>resolve</code> 函数在异步操作成功时调用，其作用是将<code>Promise</code>对象的状态从“pending”变为“resolved”，并将异步操作的结果作为参数传递出去；<code>reject</code>函数在异步操作失败时调用，其作用是将<code>Promise</code>对象的状态从“pending”变为“rejected”，并将异步操作报出的错误作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。<code>then</code>方法可以接受两个回调函数作为参数，第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数（可选提供）是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p><p>下面是一个<code>Promise</code>对象的简单例子。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">'done.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//会立即执行</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`resolve result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`reject error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>上面代码中，<code>f1</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（3000毫秒）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。执行结果如下:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>Aresolve result: done.<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.175 seconds</code></pre><p>另外，<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例。<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p></blockquote><p><code>Promise</code>对象有以下两个特点。</p><ul><li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就会一直保持不再改变,称为 resolved。</li></ul><blockquote><p>Promise也有一些缺点。首先是无法取消，一旦新建它就会立即执行，无法中途取消；其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段。</p></blockquote><h3 id="基于Async实现同步控制"><a href="#基于Async实现同步控制" class="headerlink" title="基于Async实现同步控制"></a>基于Async实现同步控制</h3><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。随着Node.js 8的发布，期待已久的async函数也在其中默认实现了。async 函数的实现原理，是将 Generator 函数和自动执行器，包装在一个函数里。</p><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变（除非遇到<code>return</code>语句或者抛出错误），再接着执行函数体内后面的语句。看下面这个例子:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncF</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//前面的 `async` 关键字，表明该函数内部有异步操作。</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// return语句的返回值，会成为`then`方法回调函数的参数。</span><span class="token punctuation">}</span><span class="token function">asyncF</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行结果如下:</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>B      <span class="token comment" spellcheck="true">#立即输出</span>A      <span class="token comment" spellcheck="true">#立即输出</span>Hello  <span class="token comment" spellcheck="true">#3秒后输出</span>Cworld<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.165 seconds</code></pre><blockquote><p>补充： <code>async</code> 函数的<code>await</code>命令后面，可以是 Promise 对象或原始类型的值（数值、字符串和布尔值，但会自动转成立即 resolved 的 Promise 对象）。</p><p><code>sync</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。如下面这个例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'发生异常'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`resolve result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行结果：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>Error: 发生异常 at f <span class="token punctuation">(</span>/Users/lixl.cn/nodework/blog/test.js:4:9<span class="token punctuation">)</span> at Object.<span class="token operator">&lt;</span>anonymous<span class="token operator">></span> <span class="token punctuation">(</span>/Users/lixl.cn/nodework/blog/test.js:7:1<span class="token punctuation">)</span> at Module._compile <span class="token punctuation">(</span>internal/modules/cjs/loader.js:701:30<span class="token punctuation">)</span> at Object.Module._extensions<span class="token punctuation">..</span>js <span class="token punctuation">(</span>internal/modules/cjs/loader.js:712:10<span class="token punctuation">)</span> at Module.load <span class="token punctuation">(</span>internal/modules/cjs/loader.js:600:32<span class="token punctuation">)</span> at tryModuleLoad <span class="token punctuation">(</span>internal/modules/cjs/loader.js:539:12<span class="token punctuation">)</span> at Function.Module._load <span class="token punctuation">(</span>internal/modules/cjs/loader.js:531:3<span class="token punctuation">)</span> at Function.Module.runMain <span class="token punctuation">(</span>internal/modules/cjs/loader.js:754:12<span class="token punctuation">)</span> at startup <span class="token punctuation">(</span>internal/bootstrap/node.js:283:19<span class="token punctuation">)</span> at bootstrapNodeJSCore <span class="token punctuation">(</span>internal/bootstrap/node.js:622:3<span class="token punctuation">)</span><span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 0.153 seconds</code></pre></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>官方文档：<a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/docs/</a></li><li>express官网：<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a></li><li>深入浅出Node.js：<a href="https://book.douban.com/subject/25768396/" target="_blank" rel="noopener">https://book.douban.com/subject/25768396/</a></li><li>Node.js 教程：<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></li><li>ECMAScript 6 入门：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li><li>需要关注的Web 框架：<a href="https://www.infoq.cn/article/mB9uCHIgsE*mWI4vhITq" target="_blank" rel="noopener">https://www.infoq.cn/article/mB9uCHIgsE*mWI4vhITq</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> npm </tag>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用AutoSSH建立SSH隧道，实现内网穿透</title>
      <link href="/2020/010618877.html"/>
      <url>/2020/010618877.html</url>
      
        <content type="html"><![CDATA[<p>当我们使用公司或家中电脑搭建了Web服务时，一般不能直接从外网访问，为了实现从外网直接访问到内网的服务，一般会需要用到 <strong>内网穿透</strong> 技术。常用的内网穿透工具有NAT转发、DMZ主机、AutoSSH、ngrok、frp、花生壳等。下面将会介绍如何通过SSH端口转发，使内网主机A的服务转发至公网主机B上。</p><h3 id="需要条件："><a href="#需要条件：" class="headerlink" title="需要条件："></a>需要条件：</h3><p>​        一台内网主机A，一台Linux公网主机B。下文以CentOS7系统为例。</p><h3 id="第一步：公网服务器配置"><a href="#第一步：公网服务器配置" class="headerlink" title="第一步：公网服务器配置"></a>第一步：公网服务器配置</h3><p>​        修改公网主机B的SSH配置文件<code>/etc/ssh/sshd_config</code></p><pre><code>GatewayPorts yes</code></pre><p>​        这样可以把监听的端口绑定到任意IP 0.0.0.0上，否则只有本机127.0.0.1可以访问。</p><p>​        重启sshd服务</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> sshd restart</code></pre><h3 id="第二步：安装AutoSSH服务"><a href="#第二步：安装AutoSSH服务" class="headerlink" title="第二步：安装AutoSSH服务"></a>第二步：安装AutoSSH服务</h3><p>  在内网主机A上，执行以下命令安装AutoSSH</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> autossh</code></pre><h3 id="第三步：断线免密登录自动重连"><a href="#第三步：断线免密登录自动重连" class="headerlink" title="第三步：断线免密登录自动重连"></a>第三步：断线免密登录自动重连</h3><p>​        ssh反向链接会因为超时而关闭，如果关闭了那从外网连通内网的通道就无法维持，为此我们需要结合免密码登录及AutoSSH来提供稳定的ssh反向代理隧道。</p><p>​        1、在内网主机A上产生公钥和私钥</p><pre class=" language-bash"><code class="language-bash">ssh-keygen </code></pre><p>  然后按三次回车执行默认选项生成公钥和私钥。会生成密钥文件和私钥文件 id_rsa,id_rsa.pub或id_dsa,id_dsa.pub</p><p>​        2、拷贝秘钥<br>  在内网主机A上继续执行如下命令，将内网主机A上的秘钥文件copy到公网主机B中。</p><pre class=" language-bash"><code class="language-bash">ssh-copy-id  username@ip</code></pre><p>  其中“username”是公网主机B的用户名，ip为公网主机B的ip，然后按照提示输入公网主机B的密码就完成了。</p><h3 id="第四步：利用AutoSSH实现端口转发"><a href="#第四步：利用AutoSSH实现端口转发" class="headerlink" title="第四步：利用AutoSSH实现端口转发"></a>第四步：利用AutoSSH实现端口转发</h3><p>  在内网主机A上，利用AutoSSH建立一条SSH隧道</p><pre class=" language-bash"><code class="language-bash"> autossh -M 4010 -NR 80:localhost:4000 username@xxx.xxx.xxx.xxx <span class="token punctuation">(</span>-p xxxx<span class="token punctuation">)</span></code></pre><p>​    <strong>参数解释：</strong></p><ul><li>“-M 4010”意思是使用内网主机A的4010 端口监视SSH连接状态，连接出问题了会自动重连</li><li>“ -N”意思是不执行远程命令</li><li>“-R”意思是将远程主机（公网主机B）的某个端口转发到本地指定机器的指定端口</li></ul><p>​    <strong>代码解释：</strong></p><ul><li><p>“80:localhost:4000”意思是将内网主机A的 4000 号端口转发至公网主机B的 80 号端口上</p></li><li><p>“<a href="mailto:username@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">username@xxx.xxx.xxx.xxx</a>”意思是公网主机B的用户名和IP</p></li><li><p>“-p xxxx”意思是公网主机B的SSH端口，如果是默认的22号端口，则可以不输入.</p></li></ul><h3 id="第五步：监听端口检查"><a href="#第五步：监听端口检查" class="headerlink" title="第五步：监听端口检查"></a>第五步：监听端口检查</h3><p>​        分别检查本地主机A及公网主机B的端口监听情况，出现如下进程则为正常。</p><p>​        本地主机A：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># lsof -i:4010</span>COMMAND   PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME<span class="token function">ssh</span>      6710 lixl    5u  IPv6 0x15699cecfe8a4995      0t0  TCP localhost:altserviceboot <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>autossh 46984 lixl    3u  IPv4 0x15699cece41d5e95      0t0  TCP localhost:altserviceboot <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span></code></pre><p>​        远程主机B：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># lsof -i:8080</span>COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEsshd    9762 root   10u  IPv4 473994      0t0  TCP *:webcache <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>sshd    9762 root   11u  IPv6 473995      0t0  TCP *:webcache <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span></code></pre><h3 id="第六步：开启自启动"><a href="#第六步：开启自启动" class="headerlink" title="第六步：开启自启动"></a>第六步：开启自启动</h3><p>​        配置AutoSSH开机自启动，输入：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/rc.d/rc.local</code></pre><p>​        添加内容:</p><pre class=" language-bash"><code class="language-bash">autossh -M 4010 -fCNR 80:localhost:4000 username@xxx.xxx.xxx.xxx <span class="token punctuation">(</span>-p xxxx<span class="token punctuation">)</span><span class="token function">chmod</span> +x /etc/rc.d/rc.local</code></pre><p>​        centos7之后，修改/etc/rc.d/rc.local启动脚本需要重新赋予可执行权限。</p><p>​        至此完成了端口转发，在相应的应用（如浏览器）中输入公网服务器B的IP+端口即相当于直接访问内网主机A的相应服务，大功告成！</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>配置完通过外网IP加端口无法访问： 请检查公网服务器防火墙是否开放响应端口。</li><li>本地服务重启后，通过外部端口无法访问：这种情况是由于没有检测到通道之前已经断开，AutoSSH应该有类似的机制，还没有仔细研究。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.jianshu.com/p/7accc1e485d3" target="_blank" rel="noopener">https://www.jianshu.com/p/7accc1e485d3</a></li><li><a href="https://blog.csdn.net/weixin_36394852/article/details/72725505" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36394852/article/details/72725505</a></li><li><a href="https://blog.csdn.net/zll_0405/article/details/81208606" target="_blank" rel="noopener">https://blog.csdn.net/zll_0405/article/details/81208606</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD领域驱动设计</title>
      <link href="/2019/122036340.html"/>
      <url>/2019/122036340.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://s.geekbang.org/search/c=2/k=DDD/t=" target="_blank" rel="noopener">DDD </a>和 DSL、DCI 的关系是什么？开发团队为何需要 DDD？它与微服务与中台又有着怎样的联系？目前业界实践 DDD 最大的问题是什么？11 月 30 日，在由 ThoughtWorks 举办的领域驱动设计峰会 <a href="http://www.ddd-china.com/speaker-info.html" target="_blank" rel="noopener">DDD-China 2019 </a>上，InfoQ 记者带着这些问题对中兴通讯资深软件架构师张晓龙进行了采访。</p><h2 id="DDD、DSL-和-DCI"><a href="#DDD、DSL-和-DCI" class="headerlink" title="DDD、DSL 和 DCI"></a>DDD、DSL 和 DCI</h2><p>DDD 概念最早提出于 2004 年，作为一种软件开发的指导思想，DDD 对软件开发带来了诸多可能与方向，张晓龙认为 DDD 为软件开发带来的好处主要有以下几点：</p><ul><li>首先，最大好处就是所有参与者围绕一个统一一致的领域模型工作，传统的分析模型和设计模型不再割裂，不管是做设计、做分析还是写代码、写文档，脑海中所构建的画面都是一致的。</li><li>第二，DDD 是一个软件开发过程，它显式地把领域和设计放到了软件开发的核心，软件人员和业务人员被受到同样的重视，他们合作来构建领域模型，使得软件的交付质量更高且维护成本更低；</li><li>第三，DDD 提出的分层架构，有效分离了业务复杂度和技术复杂度，凸显了领域模型，使得领域层的代码和领域模型保持高度一致；</li><li>第四，统一语言非常重要，每个概念在各自的上下文中是清晰的无歧义的，同时要控制领域模型的复杂度，于是 DDD 在战略上提出了分离子域（问题域空间）和拆分 BC（解决方案空间）的模式，BC 间通过 Context Mapping 来集成；</li><li>第五，DDD 在战术层面提出了很多模式（聚合，实体，值对象，服务，工厂，仓储），对领域模型中的元素进行了分类，并给出了每类元素在领域模型中的职责和特征，降低了领域模型的构建成本。</li></ul><p>张晓龙此前曾在 DDD-China 峰会和<a href="https://archsummit.infoq.cn/2019/beijing/" target="_blank" rel="noopener"> ArchSummit 全球架构师峰会</a>上分别做过《当 DDD 遇上 DSL（Domain-Specific Language）》、《当 DDD 遇上 DCI（Data，Context， Interactive）》的演讲，在他看来，DDD 和 DSL、DCI 之间存在极强的关联性。</p><p>DDD 和 DSL 的融合有三点：</p><ol><li>面向领域；</li><li>模型的组装方式；</li><li>分层架构演进。</li></ol><p>DSL 可以看作是在领域模型之上的一层外壳，可以显著增强领域模型的能力。它的价值主要有两个，一是提升了开发人员的生产力，二是增进了开发人员与领域专家的沟通。举个例子：想让 BA 负责流程契约的设计，该流程契约是一个活文档，可以跑测试，而 BA 不熟悉宿主语言。于是，我们设计了一种外部 DSL 来专门描述流程契约，对 BA 非常友好，学习成本也很低（不超过 5 分钟就可以学会），最后发现 BA 很快就广泛使用了起来。外部 DSL 并不一定要定义新文法，我们直接复用了 plantUML 文法，安装该插件可以自动生成序列图，非常棒！对于外部 DSL，需要自己实现一个解析器将 DSL 文法解析成语法树，再根据语法树生成语义模型。语义模型可以看作领域模型（严格的讲语义模型是领域模型的子集），外部 DSL 就是对领域模型的一种组装方式。</p><p>DCI 的作用主要体现在两方面：</p><p>首先，DCI 助力 DDD 战术设计：</p><ol><li>显式地对 ROLE 建模，解决了贫血模型与充血模型之争；</li><li>一个聚合可以支持哪些 ROLE，一个 ROLE 可以由哪些聚合扮演，一个场景下哪些聚合要扮演哪些角色；</li><li>当 Aggregate 内部实体行为比较多时可以嵌套使用 DCI 来拆分和组合；</li></ol><p>其次，DCI 助力 DDD 代码落地：</p><ol><li>对象就是 Data，Client 为 Context，对象在 Client 中的行为就是 ROLE。</li><li>根据正交设计原则得到小类（素材库），根据多重继承（only C++）或依赖注入来组合素材，不管是行为类还是数据类，都按 Role 的方式来组合，对像仅仅组合 Role 并注入依赖；</li><li>小类大对象：类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域；领域对象需要真正意义上的生命周期管理。</li></ol><p>张晓龙认为，DCI 对一些开发人员的影响可能比 DDD 和 DSL 还大，因为开发人员每天都在不断倒腾代码，想让代码的组合性更强，以便快速应对需求的变化。</p><h2 id="开发团队真的需要-DDD"><a href="#开发团队真的需要-DDD" class="headerlink" title="开发团队真的需要 DDD"></a>开发团队真的需要 DDD</h2><p>DDD 思想贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，和最终的代码实现，甚至对代码的测试与重构。代码是业务的核心资产，不管是否特性团队，开发团队肯定是代码的编写者和守护者。</p><p>对于开发团队而言，需要关注以下几点：</p><ul><li>首先是统一语言，让团队成员可以做到无障碍的沟通，不管是什么角色都能基于同样的画面进行讨论；</li><li>其次是团队中各个角色都围绕领域模型开展工作；</li><li>第三是代码物理设计容易标准化，比如说在分层设计时，基础设施层怎么设计，应用层怎么设计，DTO 应该放在哪儿，领域层中各个建模元素如何组织？</li></ul><p>更进一步，在分层架构里，应用层更加关注横切面的东西，比如说要上报一个告警，要给用户发送一个 Email，这些最好都集中放到应用层里面。但触发是在领域层发生的，应用层怎么知道？通过领域事件来实现依赖反转，即应用层订阅领域事件，领域层发布领域事件。</p><p>在中兴通讯，核心业务属于通信行业，DDD 的应用场景跟互联网企业有着很大差别：</p><ol><li>嵌入式软件；</li><li>兼业务复杂性和技术复杂性；</li><li>软件规模大，功能复杂，特性交叉；</li><li>高质量，高性能，高可靠等要求。</li></ol><p>张晓龙举例提到，中兴通讯在开发团队中实践 DDD 的经验具体而言有以下几点：</p><ol><li>领域专家下团队，和团队一起交流和协作；</li><li>教练指导，开展战训营，定期 review；</li><li>架构、设计、编码和工程实践：（1）DCI，DSL，正交设计，组合式设计；（2）编码规范和纪律；（3）嵌入式 C/C++ 最佳实践；（4）软件工程能力：开发者测试，小步安全流畅的重构，持续交付流水线，每日 Code Review。</li></ol><h2 id="DDD-与微服务"><a href="#DDD-与微服务" class="headerlink" title="DDD 与微服务"></a>DDD 与微服务</h2><p>DDD 概念提出距今已经有 15 年的历史，前十年时间都一直处于不温不火的状态，而在最近几年才开始大行其道。张晓龙表示，中兴通讯在 2012-2015 年期间也有过一些成功的案例，但对于整个业界来说了解的人并不多。他拿 DDD-China 峰会举例解释：这次峰会的参会者有 500 人的规模，而我们假设峰会在 2015 年之前举办的话，估计参会者不会超过 100 人。因此，我们可以断定是<a href="https://s.geekbang.org/search/c=2/k=微服务/t=" target="_blank" rel="noopener">微服务</a>的热风让人们重新发现了领域驱动设计的价值。</p><p>微服务架构从提出以来一直没有很好的理论支撑如何合理地划分服务边界，人们常常为服务要划分多大而争吵不休。而 DDD 被发现恰好可以弥补微服务的营养不良：（1）服务最大不要大过一个 BC，否则服务内可能会存在有歧义的领域概念；（2）服务最小不要小过一个聚合，否则会引入分布式事务的复杂度；（3）服务间最好通过 Domain Event 来进行交互，这样可以让服务保持松耦合。微服务和 DDD 的结合，让微服务架构看起来似乎更加稳健了。</p><p>“微服务就像是 DDD 的心上人，使得 DDD 真正焕发起了青春。”张晓龙这样解释。</p><p>对于业界目前流行的<a href="https://s.geekbang.org/search/c=2/k=中台/t=" target="_blank" rel="noopener">中台</a>概念，张晓龙同样也有自己的看法：</p><p>中台和 DDD 不是同一个层面的东西，不能为了把它们联系在一起，而强行找相似点。中台实际上就是多条业务线的共同需求，比如对于滴滴公司来说，快车、专车和出租车等业务都是微服务架构，这些业务的很多服务是相似的，考虑将这些服务从各个前台下沉到统一的平台，这个平台就是中台。中台要考虑各个前台的需求，所以复杂性变高了。</p><p>中台是一种企业级的架构模式，从企业全局整体视角来看架构全貌，而 DDD 是一种主流的软件开发方法，用来应对软件的核心复杂性。中台架构可以看作是微服务架构的延伸和发展，服务复杂性很高，所以更需要用 DDD 的方式去设计和建模，但二者之间并不是相同层面的概念。</p><h2 id="DDD-的困局"><a href="#DDD-的困局" class="headerlink" title="DDD 的困局"></a>DDD 的困局</h2><p>最近几年 DDD 的火爆也给业界开发团队带来了一些迷思，为什么我的 DDD 推行不下去？为什么我的 DDD 做起来总是跟敏捷一样，最后都变了味？</p><p>张晓龙总结了 DDD 目前面临的几大困局：</p><ul><li>首先是领域案例面比较窄。目前业界的 DDD 实践案例并不多，而且很多案例是偏向互联网领域的，对于工业领域、嵌入式领域和操作系统领域基本没有涉及；</li><li>第二，DDD 书籍非常少，而且大多数书籍是以 Java 或 C#写的。如果开发团队用的是 C、C++、Python 或 Go 语言，基本没有可参考的书籍，难度也就更大一些（尤其是 C 和 C++）；</li><li>第三，各个巨头公司，比如 Google，微软，BAT 等，很少组织、参与或赞助 DDD 峰会，没有形成引导作用，业界自然也就少有跟随效应；</li><li>第四，开发团队要么找不到领域专家，要么领域专家无法与开发团队长时间保持沟通，导致实践中出现偏差；</li><li>第五，DDD 落地有一定的门槛，对开发者的技能和素质都有较高的要求。</li></ul><p>针对以上几大困局，张晓龙也给出了自己的解决方案：</p><ol><li>培训 OOA、OOD 和 OOP 的基本知识，并实战演练，不断弥补与高手的 gap ；</li><li>领域专家和团队一起工作，确保大家头脑中的画面是一致的；</li><li>DDD 建模要有文档交付物，并和代码同步演进，以便对代码不熟悉的人员也能看到并理解领域驱动设计成果的全貌。</li></ol><p>软件开发没有银弹，DDD 也不是万能的。如果开发团队真的决定用 DDD 的思想指导软件开发，就一定要跟随时代的脚步，吃透 DDD 这个旧瓶里装的新酒。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计方法论 </tag>
            
            <tag> 领域驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物流、商流、资金流、信息流之间的关系</title>
      <link href="/2019/121252656.html"/>
      <url>/2019/121252656.html</url>
      
        <content type="html"><![CDATA[<p>物流、商流、资金流和信息流是流通过程的四大组成部分，这四者构成了一个流通过程。几者的关系“互为存在、相互作用、密不可分”，既相互独立，又是一个综合体。将物流、商流、资金流和信息流有机结合起来，会产生更大的能量，创造更大的经济效益。</p><p>所谓商流，就是一种买卖或者说是一种交易活动过程，通过商流活动发生商品所有权的转移。</p><p>商流是物流、资金流和信息流的起点，也可以说是后”三流”的前提，没有商流一般不可能发生物流、资金流和信息流。反过来，没有物流、资金流和信息流的匹配和支撑，商流也不可能达到目的。”四流”之间有时是互为因果关系。</p><p>比如，A企业与B企业经过商谈，达成了一笔供货协议，确定了商品价格、品种、数量、供货时间、交货地点、运输方式等，并签订了合同，也可以说商流活动开始了。要认真履行这份合同，自然要进入物流过程，将货物进行包装、装卸、保管和运输。同时伴随着信息传递活动。如果商流和物流都顺利进行了，接下来是付款和结算，即进入资金流的过程。无论是买卖交易，还是物流和资金流，这三大过程中都离不开信息的传递和交换，没有及时的信息流，就没有顺畅的商流、物流和资金流。没有资金支付，商流不会成立，物流也不会发生。</p><p>可以讲。商流是动机和目的，资金流是条件，信息流是手段，物流是终结和归缩。</p><p>就是说由于需要或产生购买欲望，才决定购买，购买的原因和理由就是商流的动机和目的；因为想购买或决定购买某种商品，才考虑购买资金的来源或筹措资金问题。不付款商品的所有权就不归你，这就是条件；又因为决定购买，也有了资金，然后才付之行动，这就是买主要向卖主传递一个信息，或去商店向售货员传递购买信息，或电话购物、网上购物，这些都是信息传递的过程，但这种过程只是一种手段；然而，商流、资金流和信息流产生后，必须有一个物流的过程，否则商流、资金流和信息流都没有意义。</p><p>举个例子，一个单位搬进新办公地点后要购买几台空调，这个单位可能直接去商店选购，也可能打电话或网上采购，就产生了商流活动。由此也伴生出资金流(如现金支付，支票付款或银行走账)和信息流。可是只完成这”三流”，并不是事物的完结，还必须将空调送至买主，最终还是少不了运输、装卸等物流过程。</p><p>那么。怎样才能保证将卖出去的空调按买主要求的时间、地点和数量，准确、完全地送货上门呢？</p><p>首先，出售空调的商店里有库存，或者商店给厂家打电话，让厂家从仓库取货。无论从商店取货，还是从仓库取货，都需要有车将空调送过去，如果销售量过于集中，车子跑不过来，或者司机调整不过来怎么办？如果仓库里缺这种型号的空调又怎么办？看来，这都属于物流的问题。</p><p>再往复杂一些说，假如空调厂家对空调的销售量预测的不准确，预测的销售大干实际需要，就产生库存积压，浪费仓库保管费，多占压生产资金。假如预测的销售量小于实际需要，则不仅少赚利润，失去市场，而且还可能影响企业声望。怎样才能既不浪费保管费和占压资金，又能保证供货呢？除了准确的市场需求预测，及时掌握各种信息外，还要构筑一个先进、合理的物流系统。首先要进行商品的需求、购买力、市场容量、销售时点、销售数量等基础性调查研究。然后，再制定一个与商流相配套的物流规划。根据市场情况，决定建几个配适中心，建多大规模，如何构筑配送网络等等。</p><p>因为物流是受商流制约，随商流变化而变化，往往为了占领市场、扩大销售而牺牲物流利益的，所以，在竞争激烈的商品经济社会要加强对物流问题的研究，加强对信息技术等现代科学手段的充分利用。</p><p>商流和资金流是传统性的经济活动，规则性强，已经比较成熟和定型，进一步的科学化管理受时代和经济发展水平限制。信息流主要依赖互联网，由计算机支持，是电子化传输和软件开发问题。这方面的竞争会不断加剧和复杂化，各企业的技术水平将来也会彼此接近。</p><p>前几年兴起的电子商务热，之所以急剧降温，是因 “物流瓶颈”造成的，而不是信息技术自身的问题。而且，商流、资金流和信息流将来都可能由计算机和网络通信部分替代，只有物流难以做到这一点。而旦物流又最落后，物流发展的空间比商流、资金流和信息流要大，合理化、科学化管理的余地要大，节约费用的潜力要大。这是因为：</p><ul><li><p>第一，物流是一门新兴科学，很多人对物流基本知识、物流理论、物流的重要作用、重视物流的必要性和必然性还了解不多，还需要一个认识过程。物流与商流、资金流以及信息流相比，发展滞后。进度缓慢，如不及时超上，要拖其他”三流”的后腿。同时也说明，物流的发展因过去是一流空白，是”黑暗的大陆”。因此它的发展空间也就更大。</p></li><li><p>第二，物流在商品总成本中的费用比例大，过去不受重视，这块庞大的成本，只要我们稍加努力，就会有利可图。这块”第三利润源泉”，是新经济时代最有前景的领域，是节约费用最大的空间。</p></li><li><p>第三，物流发展时间尚短，成熟程度差，物流管理科学化较低。只要我们认识到这一点，认真对待，大力加强对物流的管理，就能大大提高物流生产效率，大幅度增加经济效益。</p></li><li><p>第四，过去还很少有人将物流与商流、资金流、信息流联系起来考虑。也没有将”四流”做为一个大系统对待。今后如果真正把”四流”统一起来、协调起来，那将产生不可估量的效益。目前的主要矛盾表现在物流和信息流两个方面。</p></li></ul><p>在此我们有必要强调，商流、物流、资金演、信息流，虽然各有独立存在的意义，并各有自身的运行规律，但是，”四流”是一个相互联系、互为伴随、共同支撑流通活动的整体。在认识和研究流通经济，或者在进行物流管理过程中一定要把握这一点，以使我们认识问题全面化、科学化，把物流工作做得更有成效。</p>]]></content>
      
      
      <categories>
          
          <category> 供应链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四流合一 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Typora+iPic/PicGo图床+CDN实现高效Markdown创作</title>
      <link href="/2019/120114500.html"/>
      <url>/2019/120114500.html</url>
      
        <content type="html"><![CDATA[<p>本文提到两种插件组合方式，iPic及PicGo，支持Github、SM.MS、阿里OSS、腾讯COS、微博等主流图床。通过工具的搭配使用，我们能轻松地完成在 Markdown 中插图的工作，发布到多个内容平台。</p><p>对于Typora + iPic方式，是Typora默认支持的。尤其在一次性粘贴带有多个图片的图文混合内容时，超级方便。不过iPic是收费软件，可以使用PicGo来替代，只是这样就无法实现一次性粘贴多个图片的图文混合内容了。</p><h2 id="iPic方式"><a href="#iPic方式" class="headerlink" title="iPic方式"></a>iPic方式</h2><p>目前，Markdown 编辑器 <a href="https://sspai.com/tag/Typora" target="_blank" rel="noopener">Typora</a> 已经接入 iPicUploader，通过两款工具的搭配，我们能轻松地完成在 Markdown 中插图的工作。</p><h3 id="自动上传图片至图床"><a href="#自动上传图片至图床" class="headerlink" title="自动上传图片至图床"></a>自动上传图片至图床</h3><p>打开 Typora 中的「系统偏好设置 - 图像 - 通过iPic上传图片」选项，在 Typora 中插入本地图片时，i会自动将图片上传图床并使用 Markdown 语法替换文内地址。</p><p><img src="https://pic.lixl.cn/2020/20200114223815.png/w1280" alt></p><h3 id="使用快捷键"><a href="#使用快捷键" class="headerlink" title="使用快捷键"></a>使用快捷键</h3><p>如果你的主力 Markdown 工具不是 Typora，在选中图片或截图之后，使用 ⌘ + U 快捷键上传，然后直接在编辑器中粘贴也是一个不错的选择。</p><h2 id="PicGo方式"><a href="#PicGo方式" class="headerlink" title="PicGo方式"></a>PicGo方式</h2><p>PicGo是一款开源的图床软件，该软件与iPic的不分伯仲，文档支持中文，支持插件开发。</p><h3 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h3><p>下载地址 <a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a> ，选择下载与系统匹配的安装包，正常安装即可。</p><h3 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h3><p><img src="https://pic.lixl.cn/2020/20200114213053.png/w1280" alt></p><p>Github图床配置如上图，参数说明：</p><ul><li>仓库名：按照 <code>账户名/仓库名的格式填写</code></li><li>分支名：一般填写 <code>master</code> 即可</li><li>Token：到 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a> 去生成，然后黏贴在这里</li><li>存储路径：如图配置，会在仓库根目录创建 <code>images/2019</code> 的文件夹</li><li>自定义域名：图片成功上传后，PicGo会将 <code>自定义域名+上传的图片名</code> 生成的访问链接，放到剪切板中。</li></ul><blockquote><p>使用GitHub仓库作为图床，存在的问题是国内访问github的速度很慢，可以利用 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr CDN</a> 来加速访问。jsDelivr 是一个免费开源的 CDN 解决方案，该平台是首个打通中国大陆与海外的免费CDN服务，拥有中国政府颁发的 ICP 许可证，无须担心中国防火墙问题而影响使用。使用jsDelivr加速访问，需要将自定义域名设置为<code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/</code>。</p><p>这里有一个图片的两个链接地址，可以体验一下速度差异：<a href="https://raw.githubusercontent.com/lxl80/blog/master/images/2019/20200114202526.png" target="_blank" rel="noopener">Github原始地址</a>   <a href="https://cdn.jsdelivr.net/gh/lxl80/blog/images/2019/20200114202526.png" target="_blank" rel="noopener">jsDelivr加速地址</a></p></blockquote><p><img src="https://pic.lixl.cn/2020/20200114203447.png/w1280" alt></p><p>阿里云OSS图床配置如上图，参数说明：</p><ul><li><p>Keyii及KeySecret：到 <a href="https://usercenter.console.aliyun.com/#/manage/ak" target="_blank" rel="noopener">阿里云控制台AccessKey管理</a> 申请并输入</p></li><li><p>仓库空间名：在对象存储中创建的Bucket的名称</p></li><li><p>存储区域：创建Bucket时所选区域的英文标识，查询地址：<a href="https://help.aliyun.com/document_detail/31837.html#concept-zt4-cvy-5db" target="_blank" rel="noopener">OSS开通Region</a></p></li><li><p>存储路径：如图配置，会自动在OSS存储空间根目录创建 <code>2020</code> 文件夹</p></li><li><p>网址后缀：这是阿里云OSS的一个很好用的功能，用于图片处理（如缩略图）。需要去OSS的 <a href="https://help.aliyun.com/document_detail/48884.html" target="_blank" rel="noopener">图片处理规则</a> 中创建样式。以下是我设置的规则，后缀 <code>w1280</code>代表将图片等比缩放到宽度&lt;=1280</p><p><img src="https://pic.lixl.cn/2020/20200114220140.png/w1280" alt></p></li><li><p>自定义域名：图片成功上传后，PicGo会将 <code>自定义域名+上传的图片名</code> 生成的访问链接，放到剪切板中。</p></li></ul><h3 id="快捷键及相关配置"><a href="#快捷键及相关配置" class="headerlink" title="快捷键及相关配置"></a>快捷键及相关配置</h3><p><img src="https://pic.lixl.cn/2020/20200114221441.png/w1280" alt></p><p>支持快捷键<code>command+shift+p</code>（macOS）或者<code>control+shift+p</code>（Windows\Linux）用以支持快捷上传剪贴板里的图片（第一张）。 PicGo 支持自定义快捷键，使用方法见 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html" target="_blank" rel="noopener">配置手册</a>。</p><p>通过自定义链接格式，可以直接生成符合需要的Markdown代码，方便粘贴。如我喜欢通过OSS将原始图片等比缩放到宽度&lt;=1280px，并将图片缩放50%来优化显示效果及速度，配置如下：</p><p><img src="https://pic.lixl.cn/2020/20200114222126.png/w1280" alt></p><p>复制或截图后，通过快捷键上传，然后直接粘贴，即可获得如下可直接粘贴到Markdown文档中的代码：</p><pre class=" language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://pic.lixl.cn/2020/20200114222126.png/w1280<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">zoom</span><span class="token punctuation">:</span><span class="token number">50%</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><blockquote><p>补充：自动生成的代码包括了图片缩放设置，您也可以通过设置自定义链接格式为 <code>![]($url)</code> ，生成标准的Markdown代码:<code>![](https://pic.lixl.cn/2020/20200114222126.png/w1280)</code></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/d1dac86fbe04" target="_blank" rel="noopener">iPic + Typora，方便快捷地在 Markdown 中插图</a></li><li><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">Molunerfinn/PicGo</a></li><li><a href="https://www.jianshu.com/p/a36e9c64361d" target="_blank" rel="noopener">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象检测算法之YOLO-V3</title>
      <link href="/2019/10029099.html"/>
      <url>/2019/10029099.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>​        Yolo是一种使用卷积神经网络进行目标检测的算法。目标检测是指计算机和软件系统对图像或场景中的目标进行定位和识别的任务。与识别算法相比，检测算法不仅可以预测类别标签，还可以检测对象的位置。目标检测已广泛应用于人脸检测、车辆检测、人流量统计、网络图像、安防系统和无人驾驶等多个领域。</p><p><img src="https://pic.lixl.cn/2019/20200106230653.png/w1280" alt></p><p>​        2012年深度学习的突破性进展和迅速普及，使得R-CNN、Fast-RCNN、Faster-RCNN、RetinaNet以及快速、高度准确的SSD、YOLO等目标检测算法应运而生。YOLO v3非常快速和准确。在mAP值为0.5 IOU时，YOLO v3与Focal Loss相当，但速度约快4倍。此外，只需更改模型的大小即可轻松在速度和精度之间进行权衡，无需重新训练！</p><p>​        2012年深度学习的突破性进展和迅速普及，使得 R-CNN、Fast-RCNN、Faster-RCNN、RetinaNet以及快速、高度准确的 SSD、YOLO 等目标检测算法应运而生。YOLO v3非常快速和准确。在 mAP 值为 0.5IOU 时，YOLO v3 与 Focal Loss 相当，但速度约快 4 倍。此外，只需更改模型的大小即可轻松在速度和精度之间进行权衡，无需重新训练！</p><p><img src="https://pic.lixl.cn/2019/20200106230722.png/w1280" alt></p><h3 id="Yolo-V3架构"><a href="#Yolo-V3架构" class="headerlink" title="Yolo-V3架构"></a>Yolo-V3架构</h3><p><img src="https://pic.lixl.cn/2019/20200106230801.png/w1280" alt></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1418308" target="_blank" rel="noopener">目标检测第5步-keras版YOLOv3训练</a></li><li><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO: Real-Time Object Detection</a></li><li><a href="https://github.com/wizyoung/YOLOv3_TensorFlow" target="_blank" rel="noopener"> 支持在自己的数据集上进行训练的YOLO v3 TensorFlow 实现</a></li><li><a href="https://github.com/YunYang1994/tensorflow-yolov3" target="_blank" rel="noopener">YunYang1994/tensorflow-yolov3 含自主训练</a></li><li><a href="https://blog.csdn.net/Patrick_Lxc/article/details/80615433" target="_blank" rel="noopener">Keras/Tensorflow+python+yolo3训练自己的数据集</a></li><li><a href="https://cloud.tencent.com/developer/article/1418306" target="_blank" rel="noopener">目标检测第6步-keras版RetinaNet训练</a></li><li><a href="https://github.com/OlafenwaMoses/ImageAI/blob/master/imageai/Detection/README.md" target="_blank" rel="noopener"></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象监测 </tag>
            
            <tag> YOLO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达神经网络与深度学习笔记</title>
      <link href="/2019/10029178.html"/>
      <url>/2019/10029178.html</url>
      
        <content type="html"><![CDATA[<p>​        吴恩达是人工智能领域的大牛，著作颇丰，其推出的机器学习课程在学生之中反响强烈，深受中国学生的推崇。<strong>Deep Learning Specialization</strong>对卷积神经网络 (<strong>CNN</strong>)、递归神经网络 (<strong>RNN</strong>)、长短期记忆 (<strong>LSTM</strong>) 等深度学习常用的网络结构、工具和知识都有涉及。</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="模型适用性"><a href="#模型适用性" class="headerlink" title="模型适用性"></a>模型适用性</h3><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/33a613e0dc2642d87288b66c026e97538052f630daa29a48faa4acb539b00f6ef521c398a55f1495ff85d58bd5844ea8?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20191002-211009%402x.png&amp;size=750" alt></p><p> 标准神经网络   ——&gt;  房产价格预测及在线广告点击预测<br>​        卷积神经网络    CNN    ——&gt;    图像领域<br>​        循环神经网络    RNNs    ——&gt;    序列数据，语言处理<br>​        混合神经网络        ——&gt;    无人驾驶</p><p>数据积累 + 计算能力提升 + 算法改进  使得深度学习能够发挥作用，受欢迎。</p><h2 id="物体监测"><a href="#物体监测" class="headerlink" title="物体监测"></a>物体监测</h2><p>​    目标是输出bx，by，bh，bw及1～4个分类标签，目标标签定义如下：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/4aeca6af50f7cfd6bf9d879a56905ea45e1ad517e10c2d2bd2ee71d42d4b68bcaefc2e8c5ed421a8cff54c1e558c46f3?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20191003-130947%402x.png&amp;size=750" alt="定义目标标签"></p><ul><li>基于滑动窗口的目标监测算法：可以监测到图片中是否有目标（如汽车），缺点是计算成本高。如果加大滑动窗口的步长可能会影响性能。</li><li>YOLO对象监测算法：如把图片划分成3x3个区域，通过增加N个anchor box，分别监测9个区域，得到 3x3x2x8 个Y值。过滤掉无效数据（Pc=0），得到N个预测的边界框。针对每个anchor运行非最大值抑制。获得交并比最大边框，如图：<br>  <img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/d3ae98cff57c4d885146e216e71400758f45676f632931f0c277ee33973fec27245bc43db38f8f31f85f5c1a93e66125?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20191004-092921%402x.png&amp;size=750" alt="YOLO对象监测算法"></li><li>R-CNN：运行图像分割算法，只在候选框（识别到汽车）运行卷积网络分类器。 缺点还是太慢了。</li><li>Fast R-CNN：用滑动窗口的一个卷积实现。问题是得到<strong>候选区域</strong>的聚类步骤仍然很慢。 </li><li>Faster R-CNN：使用卷积神经网络（而且传统分割算法）来获取候选色块，速度比R-CNN快，但事实比YOLO慢很多。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的matery主题搭建博客并优化</title>
      <link href="/2019/092856736.html"/>
      <url>/2019/092856736.html</url>
      
        <content type="html"><![CDATA[<p>对于有一定技术背景的同学，自己动手搭建博客网站是一个很不错的选择。选择喜欢的主题，按需进行个性化配置，随时在本地用自己喜欢的工具写文章，一键发布到多个博客托管平台，使用自己喜欢的图床/CDN来加速…</p><blockquote><p><a href="https://www.lixl.cn">演示站点（悟尘记）</a> 基于 Hexo 的 hexo-theme-matery 主题构建，部署在腾讯云COS中并使用CDN进行内容加速，通过 PicGo + 阿里云OSS 作为图床进行静态资源加速。如果不想付费，可以托管在 Github 的 Pages 服务中，采用 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr</a> CDN来加速。</p></blockquote><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><p><code>npx hexo</code></p></li><li><p>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo</code>：</p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'PATH="<span class="token variable">$PATH</span>:./node_modules/.bin"'</span> <span class="token operator">>></span> ~/.profile</code></pre><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre class=" language-bash"><code class="language-bash">hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token function">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span></code></pre><p>新建完成后，指定文件夹的目录如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">.</span>├── _config.yml├── package.json├── scaffolds├── <span class="token function">source</span><span class="token operator">|</span>   ├── _drafts<span class="token operator">|</span>   └── _posts└── themes</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>此时，通过 <code>hexo s</code> 命令即可在本地启动您的博客站点了。</p><pre class=" language-bash"><code class="language-bash">~ hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 <span class="token keyword">.</span> Press Ctrl+C to stop.</code></pre><p>接下来将安装主题，配置博客托管平台，实现一键发布并刷新CDN缓存。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a> 是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题，点击 <a href="https://www.lixl.cn">这里</a>  可以查看示例效果。点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到 Hexo 的 <code>themes</code> 文件夹中即可。</p><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议"></a><code>_config.yml</code> 文件的其它修改建议</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span></code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span></code></pre><p>同时，在 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://www.lixl.cn/medias/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"悟尘记"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"人生就是一场修行，上善若水，厚德载物。"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.lixl.cn/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去参观"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&amp;modificationDate=1540928132000&amp;api=v2"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Fabric"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"A Blockchain Platform for the Enterprise"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://hyperledger-fabric.readthedocs.io/en/master/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://www.bootcdn.cn/assets/img/maoyun.svg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"BootCDN"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"稳定、快速、免费的前端开源项目 CDN 加速服务。"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.bootcdn.cn/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去加速"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  <span class="token key atrule">custom_css</span><span class="token punctuation">:</span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>通过 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> 插件可以实现一键将博客同时部署到多个git仓库中。如同时发布到github及gitee提供的pages服务。安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save</code></pre><p>修改 Hexo 根目录下的 <code>_config.yml</code> 文件中的如下内容:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">## Docs: https://hexo.io/docs/deployment.html</span><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/lxl80/blog.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//gitee.com/lxl80/lxl80.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> master    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></code></pre><blockquote><p>也可以如本站一样，采用 <a href="https://github.com/75k/hexo-deployer-cos-enhanced" target="_blank" rel="noopener">hexo-deployer-cos-enhanced</a> 插件将静态内容部署到腾讯云对象存储服务中，在DNS配置中将境内线路解析到腾讯云CDN地址，实现加速。部署完成后会自动刷新被更新文件的CDN缓存。</p></blockquote><p>安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-cos-enhanced --save</code></pre><p> <code>_config.yml</code> 配置如下:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/lxl80/blog.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> cos    <span class="token key atrule">bucket</span><span class="token punctuation">:</span> lxl80<span class="token punctuation">-</span>130****    <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>beijing    <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDh9***<span class="token important">*F8FvL</span>    <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> Z3IGiur***<span class="token important">*QZR3PgjXmlVg</span>    <span class="token key atrule">cdnConfig</span><span class="token punctuation">:</span>      <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">cdnUrl</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//static.lixl.cn      <span class="token key atrule">bucket</span><span class="token punctuation">:</span> static<span class="token punctuation">-</span>130****      <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>beijing      <span class="token key atrule">folder</span><span class="token punctuation">:</span> static      <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDh9***<span class="token important">*F8FvL</span>      <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> Z3IGiur***<span class="token important">*QZR3PgjXmlVg</span></code></pre><p>然后通过 <code>hexo g -d</code> 即可实现一键发布，并更新CDN缓存。</p><h3 id="文章链接转静态短地址（建议安装）"><a href="#文章链接转静态短地址（建议安装）" class="headerlink" title="文章链接转静态短地址（建议安装）"></a>文章链接转静态短地址（建议安装）</h3><p>如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件生成文章时生成中文拼音的永久链接，或者用<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 生成静态文章链接。以下结合hexo-abbrlink生成类似 <code>/yyyy/mmdd+随机数.html</code> 的文章链接地址。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，修改 <code>permalink:</code> ，并在文件末尾新增 <code>abbrlink:</code>配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink</span><span class="token punctuation">:</span> <span class="token punctuation">:</span>year/<span class="token punctuation">:</span>month<span class="token punctuation">:</span>day<span class="token punctuation">:</span>abbrlink.html<span class="token key atrule">abbrlink</span><span class="token punctuation">:</span>  <span class="token key atrule">alg</span><span class="token punctuation">:</span> crc16 <span class="token comment" spellcheck="true">#算法选项：crc16丨crc32</span>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> dec <span class="token comment" spellcheck="true">#输出进制：dec为十进制，hex为十六进制</span></code></pre><h3 id="CND加速（建议启用）"><a href="#CND加速（建议启用）" class="headerlink" title="CND加速（建议启用）"></a>CND加速（建议启用）</h3><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr</a> + Github便是免费且好用的CDN，非常适合博客网站使用。也可以选择主流云服务商提供的对象存储+CDN来获得更快速及稳定的访问效果，费用低到几乎可忽略。</p><p><strong>用法：</strong></p><pre class=" language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code></pre><p><strong>例如：</strong></p><pre class=" language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg</code></pre><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源。</p><blockquote><p>还可以配合 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>图床上传工具的<strong>自定义域名前缀</strong>来上传图片，使用极其方便。具体使用方法可参见我的另一篇文章:  <a href="/2019/120114500.html">使用Typora+iPic/PicGo图床+CDN实现高效Markdown创作</a></p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明已经安装成功了。</p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p>如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#4cbf30</span> <span class="token number">0%</span>, <span class="token hexcode">#0f9d58</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>可以直接在 <code>/source/medias/banner</code> 文件夹中更换喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果会 <code>JavaScript</code> 代码，可以修改成自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图</td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td>表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td>表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 基于Hexo的hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>matery主题搭建博客并优化<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-10-03 14:25:00</span><span class="token punctuation">---</span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 基于Hexo的hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>matery主题搭建博客并优化<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-10-03 14:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 悟尘<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> 工具<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> blog  <span class="token punctuation">-</span> hexo<span class="token punctuation">---</span></code></pre><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google自动收录效果还不错，百度就差得远了（<code>GitHub</code>不允许百度的<code>Spider</code>爬取<code>GitHub</code>上的内容）。</p><p>安装sitemap插件生成站点地图文件:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-sitemap --save<span class="token function">npm</span> <span class="token function">install</span> hexo-generator-baidu-sitemap --save  <span class="token comment" spellcheck="true">#百度专用</span></code></pre><p>安装后直接执行 <code>hexo cl&amp;&amp;hexo g -d</code> 命令，就会在网站根目录生成 <code>sitemap.xml</code> 及 <code>baidusitemap.xml</code> 文件。</p><h3 id="百度优化"><a href="#百度优化" class="headerlink" title="百度优化"></a>百度优化</h3><p>登录<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度搜索资源平台</a>， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击<a href="https://ziyuan.baidu.com/site/siteadd" target="_blank" rel="noopener">添加网站</a>，按提示操作。</p><p><img src="https://pic.lixl.cn/2020/20200129213302.png/w1280" alt="添加网站"></p><blockquote><p>提示：由于百度的spider是爬取不到GitHub的内容的，所以在第三步验证网站的时候，建议选择<code>CNAME验证</code>的方式。</p></blockquote><p>经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。点击 网站支持 –&gt; 数据引入 –&gt; 链接提交菜单，提交站点地图：<br><img src="https://pic.lixl.cn/2020/20200130153759.png/w1280" alt="提交站点地图"></p><p>另外，<code>hexo-theme-matery</code>主题已经内置了 <code>自动推送</code> 的功能， 检查 <code>themes/hexo-theme-matery/_config.yml</code> 文件中如下配置:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 百度搜索资源平台提交链接</span><span class="token key atrule">baiduPush</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>自动推送的JS代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。</p><h3 id="谷歌优化"><a href="#谷歌优化" class="headerlink" title="谷歌优化"></a>谷歌优化</h3><p>登录 <a href="https://search.google.com/search-console?hl=zh-CN" target="_blank" rel="noopener">Google Search Console</a>，点击添加资源，输入自己的域名，按提示操作。</p><p><img src="https://pic.lixl.cn/2020/20200129214720.png/w1280" alt="添加资源"></p><blockquote><p>提示：需要进行DNS验证，进入DNS域名解析设置页面，按提示增加TXT记录，如下图:<br><img src="https://pic.lixl.cn/2020/20200129215358.png/w1280" alt="DNS验证内容填写示例"></p></blockquote><p>验证成功后，需要提交站点地图。参照下图提交，然后等待收录。<br>  <img src="https://pic.lixl.cn/2020/20200129223124.png/w1280" alt="提交站点地图"></p><blockquote><p>注意：hexo配置文件中的url一定要输入正确的域名，插件是根据url生成站点地图的。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h3><p><code>hexo server</code> #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><p><code>hexo server -s</code> #以静态模式启动</p><p><code>hexo server -p 5000</code> #更改访问端口   (默认端口为4000，’ctrl + c’关闭server)</p><p><code>hexo server -i IP地址</code> #自定义 IP</p><p><code>hexo clean</code> #清除缓存  ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</p><p><code>hexo g</code> #生成静态网页  (执行 $ <code>hexo g</code>后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“   下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “   路径下)</p><p><code>hexo d</code> #自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)</p><p><code>hexo init</code> 文件夹名称 #初始化XX文件夹名称</p><p><code>npm update hexo -g</code>#升级</p><p><code>npm install hexo -g</code> #安装</p><p><code>node-v</code>          #查看node.js版本号</p><p><code>npm -v</code>        #查看npm版本号</p><p><code>git --version</code>  #查看git版本号</p><p><code>hexo -v</code>      #查看hexo版本号</p><h3 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令"></a>简写指令</h3><p><code>hexo n &quot;我的第一篇文章&quot;</code>       等价于        <code>hexo new &quot;我的第一篇文章&quot;</code>  还等价于       <code>hexo new post &quot;我的第一篇文章&quot;</code></p><p><code>hexo p</code> 等价于 <code>hexo publish</code></p><p><code>hexo g</code> 等价于 <code>hexo generate</code></p><p><code>hexo s</code>等价于 <code>hexo server</code></p><p><code>hexo d</code> 等价于 <code>hexo deploy</code></p><p><code>hexo g -d</code>等价于<code>hexo generate --deploy</code></p><p>注: <code>hexo  clean</code> 没有 简写,  <code>git --version</code> 没有简写</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>1. 通过<code>hexo g -d</code>部署时报<code>Error: Spawn failed</code>错误:</strong></p><blockquote><p>这是由于git本地记录的提交版本号与github上不一致导致的，通过<code>git reset --hard commitCode</code>即可解决。</p></blockquote><ul><li>检查本地最近提交记录，获取最后一次提交记录的更新时间及标识，如<code>280a7fdd46fcfd7d34e652aec15523dcd247fac8</code></li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> .deploy_git<span class="token function">cat</span> .git/logs/HEAD</code></pre><ul><li>获取github pages服务所关联分支的最近一次提交记录，获取更新时间及标识。地址一般为：<code>https://github.com/用户名/仓库名/commits/分支名</code>，如<code>https://github.com/lxl80/blog/commits/gh-pages</code></li><li>如果发现提交最新的提交时间/标识不一致，通过以下命令即可解决:</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard f085038efdf79546c09641d37b2a2429c1ae8e60 <span class="token comment" spellcheck="true">#github上最新的提交标识</span></code></pre><h2 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h2><ul><li><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></p></li><li><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">闪烁之狐</a></p></li><li><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">hexo-theme-matery</a></p></li><li><p><a href="https://blog.sky03.cn/posts/42790.html#toc-heading-1" target="_blank" rel="noopener">Hexo进阶之各种优化</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow2.0入门实战</title>
      <link href="/2019/090963177.html"/>
      <url>/2019/090963177.html</url>
      
        <content type="html"><![CDATA[<p>TensorFlow是2015年年底开源的一套深度学习框架，是目前最活跃的深度学习框架。本文基于2.0版本，首先介绍它的安装和基本用法，然后讨论了深度学习的基本概念，包括神经网络前向计算、损失函数、反向传播计算和优化函数等，接着介绍了卷积神经网络和循环神经网络，最后介绍了在大规模应用的场景下，如何实现分布式的深度学习训练。</p><h3 id="安装Tensorflow环境："><a href="#安装Tensorflow环境：" class="headerlink" title="安装Tensorflow环境："></a>安装Tensorflow环境：</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装python3,pip </span><span class="token function">sudo</span> yum -y <span class="token function">install</span> epel-release<span class="token function">sudo</span> yum -y <span class="token function">install</span> gcc gcc-c++ python3-pip python-devel atlas atlas-devel gcc-gfortran openssl-devel libffi-devel<span class="token comment" spellcheck="true">#更新python国内源</span>    <span class="token function">mkdir</span> ~/.pip    vim ~/.pip/pip.conf        <span class="token punctuation">[</span>global<span class="token punctuation">]</span>        index-url <span class="token operator">=</span> https://pypi.mirrors.ustc.edu.cn/simple/        <span class="token punctuation">[</span>install<span class="token punctuation">]</span>        trusted-host <span class="token operator">=</span> mirrors.ustc.edu.cn<span class="token comment" spellcheck="true"># 安装virtualenv</span>pip3 <span class="token function">install</span> --upgrade virtualenvvirtualenv --system-site-packages ~/venvs/tensorflowcurl <span class="token function">sudo</span> python get-pip.pypip --version<span class="token function">sudo</span> pip <span class="token function">install</span> virtualenvvirtualevn --version<span class="token comment" spellcheck="true"># 创建python虚拟环境</span>virtualenv --system-site-packages -p python2.7 ./venv<span class="token comment" spellcheck="true"># 激活虚拟环境</span><span class="token function">source</span> venv/bin/activate<span class="token comment" spellcheck="true"># 安装Tensorflow</span>pip <span class="token function">install</span>  -i http://mirrors.aliyun.com/pypi/simple/ tensorflow<span class="token comment" spellcheck="true"># 查看安装的软件</span>pip list installed<span class="token comment" spellcheck="true">#通过python交互式环境验证安装是否成功</span>python<span class="token function">import</span> tensorflow as tfexit<span class="token punctuation">(</span><span class="token punctuation">)</span>  //退出python交互环境deactivate  //退出python虚拟环境</code></pre><h3 id="Helloworld示例验证"><a href="#Helloworld示例验证" class="headerlink" title="Helloworld示例验证"></a>Helloworld示例验证</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">source</span> venv/bin/activatepython //进入python交互式环境<span class="token function">import</span> tensorflow as tfhello <span class="token operator">=</span> tf.constant<span class="token punctuation">(</span>"hello tensorflow.<span class="token punctuation">)</span>sess <span class="token operator">=</span> tf.Session<span class="token punctuation">(</span><span class="token punctuation">)</span>sess.run<span class="token punctuation">(</span>hello<span class="token punctuation">)</span></code></pre><h3 id="在Jupyter交互式环境中使用Tensorflow"><a href="#在Jupyter交互式环境中使用Tensorflow" class="headerlink" title="在Jupyter交互式环境中使用Tensorflow"></a>在Jupyter交互式环境中使用Tensorflow</h3><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> jupyterpython -m ipykernel <span class="token function">install</span> --user --name<span class="token operator">=</span>venvjupyter kernelspec listjupyter notebook //自动打开浏览器</code></pre><h3 id="在Docker中使用Tensorflow"><a href="#在Docker中使用Tensorflow" class="headerlink" title="在Docker中使用Tensorflow"></a>在Docker中使用Tensorflow</h3><pre class=" language-bash"><code class="language-bash">docker pull tensorflow/tensorflow:nightly-jupytervim docker-compose.yml <span class="token comment" spellcheck="true">#制作配置文件</span>docker-compose up -d <span class="token comment" spellcheck="true">#初次启动，以后用start/stop</span>docker <span class="token function">exec</span> -it xxxx <span class="token function">bash</span> <span class="token comment" spellcheck="true">#进入docker,然后执行如下命令升级安装Python3</span>    <span class="token function">apt-get</span> update    <span class="token function">apt-get</span> <span class="token function">install</span> python-software-properties    <span class="token function">apt-get</span> <span class="token function">install</span> python3.6    apt <span class="token function">install</span> python3-pip    <span class="token comment" spellcheck="true">#更新python国内源</span>    <span class="token function">mkdir</span> ~/.pip    vim ~/.pip/pip.conf        <span class="token punctuation">[</span>global<span class="token punctuation">]</span>        index-url <span class="token operator">=</span> https://pypi.mirrors.ustc.edu.cn/simple/        <span class="token punctuation">[</span>install<span class="token punctuation">]</span>        trusted-host <span class="token operator">=</span> mirrors.ustc.edu.cn    <span class="token comment" spellcheck="true">#在jupyter中启用python3</span>    jupyter kernelspec list <span class="token comment" spellcheck="true"># 查看激活的kernel</span>    python3 -m pip <span class="token function">install</span> ipykernel      python3 -m ipykernel <span class="token function">install</span> --user    <span class="token function">rm</span> /usr/local/bin/python    <span class="token function">ln</span> -s /usr/bin/python3.6 /usr/local/bin/python    python --version  <span class="token comment" spellcheck="true">#显示Python 3.6.x，则安装成功</span>    pip <span class="token function">install</span> --upgrade tensorflow jupyter matplotlib pandas seaborn numpy tensorflow-hub tensorflow-datasets pillow    pip list installed</code></pre><ul><li>使用docker-compose管理容器<pre class=" language-ymal"><code class="language-ymal">version:  '3'services:tensorflow-jupyter:  image: tensorflow/tensorflow:nightly-jupyter  ports:    - "8888:8888"    - "6006:6006"  volumes:    - .:/tf/notebooks</code></pre>启动： docker-compose up</li></ul><h3 id="Tensorflow架构介绍"><a href="#Tensorflow架构介绍" class="headerlink" title="Tensorflow架构介绍"></a>Tensorflow架构介绍</h3><p><img src="https://pic4.zhimg.com/80/v2-14f1196030f7bd2db1ceff96bc9b0ddb_hd.jpg" alt="Tensorflow架构图一"><br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/3b16e5b406f603289fdeb140ee76e14190f57f14a72d49c11aea6fbd116b59234c971528be44e40cf6d42d638a2c3b14?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;size=750=" alt="Tensorflow架构图二"><br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/4250deb81e391cffa189c9d95f4a4e1c74c1fbb43c6a60b0ddd5efea4acd47ba090e0f3c42b5146ddfe7d7edf6bc8686?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;size=750=" alt></p><h3 id="实战：使用CNN识别彩色尺寸各异的猫狗图片"><a href="#实战：使用CNN识别彩色尺寸各异的猫狗图片" class="headerlink" title="实战：使用CNN识别彩色尺寸各异的猫狗图片"></a>实战：使用CNN识别彩色尺寸各异的猫狗图片</h3><p>​    参考 <a href="https://colab.research.google.com/drive/1WerlZnNfh7N4RqO26gbctQ6NINkMxPkO" target="_blank" rel="noopener">Colab</a></p><h4 id="扁平化处理"><a href="#扁平化处理" class="headerlink" title="扁平化处理"></a>扁平化处理</h4><pre><code> 调整尺寸为一致的150 * 150，以便可以生成相同大小的一位数组</code></pre><h4 id="彩色图像处理"><a href="#彩色图像处理" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h4><pre><code> 使用三维数组建模，增加RGB作为3维数组的深度值，如图：![](https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0479c21b4302a6c26eb97984094a43864ca895cb1e33bb3f41de3f5a7d408d9d7a723f11ff403adc1ea9749c252ae77e?pictype=scale&amp;amp;from=30113&amp;amp;version=3.3.3.3&amp;amp;size=750=)</code></pre><h4 id="对彩色图像执行卷积运算："><a href="#对彩色图像执行卷积运算：" class="headerlink" title="对彩色图像执行卷积运算："></a>对彩色图像执行卷积运算：</h4><ul><li>将彩色图像分解为3维数组<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c50a4ac38c7ce1aba88acd8610c03e76ca95fe46cdd25a11313bf9f5626602d00af10dc4b8cbab30601f6c19eb1a30ae?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=111.png&amp;size=750" alt></li><li>利用三个过滤核进行卷积运算示例<br>  <img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/d5867af3457e0692e7d8e33c54aa169ac453c7e75c4a9a9e634b195027b320c708e3aa95b9f8c2c048096570fffb3f4e?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=112.png&amp;size=450" alt></li><li>示例中使用三个三维过滤器进行卷积运算<br>  <img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c059b5c447235ce967e6a6624cc566aa1905b7e2ab7754c0c23b38b32dd9059dc59fc3c7eae44bdb951220dcbbc79e53?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-163837%402x.png&amp;size=750" alt="使用三个过滤核进行卷积运算获得的三维结果"></li><li><p>代码说明</p><pre><code>tf.keras.layers.Conv2D(filters, kernel_size, ...)  #  参数：过滤器数量, 卷积核形状, ...#本例中使用：tf.keras.layers.Conv2D(3, (3,3), ...)</code></pre><p>​    在训练CNN时，将通过损失函数更新三维核中的值，从而最小化损失。</p><h4 id="执行最大池化运算"><a href="#执行最大池化运算" class="headerlink" title="执行最大池化运算"></a>执行最大池化运算</h4><pre><code>![](https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/9f7687a18e5b38514ae2a90d6fc13fdbeec4ce39957fb08f465afbf43f16b912d982cdb72fb9f3d24e7cd455d1ffec8f?pictype=scale&amp;amp;from=30113&amp;amp;version=3.3.3.3&amp;amp;uin=369888789&amp;amp;fname=WX20190913-175829%402x.png&amp;amp;size=750=)</code></pre><p> 最大池化处理后，获得的三维数组宽度和高度减半，但深度不变。</p><h4 id="使用验证集解决过拟合问题（早停法）"><a href="#使用验证集解决过拟合问题（早停法）" class="headerlink" title="使用验证集解决过拟合问题（早停法）"></a>使用验证集解决过拟合问题（早停法）</h4></li></ul><p>​    通常在完成训练后，在测试集上进行验证才能发现过拟合问题。可以通过增加验证集，在每轮训练过程中基于验证集检查效果，分析训练损失和验证损失与周期的函数图，可判断出模型泛化效果。</p><p>   <img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/e8f7b98ddbbc9f117c5d1bf110d76ef3b414866b0b6e3539338b3216fe451f8aa59c6ffa5601e4c59d970ba8ecffb2db?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-201908%402x.png&amp;size=750" alt></p><pre><code>   可以看出，验证集有助于我们判断CNN应该训练多少个周期，即可以达到较好的训练效果又不会出现过拟合，提前结束训练一遍获取最优模型。对于有多个潜在模型可选择时（如为模型选择合适的参数/结构），也可以用这种方法对比选择最优模型。</code></pre><blockquote><p>如果训练集足够广泛（如各种各样可能的图片都有，如大小，位置，猫狗完整性等），将有助于训练出泛化能力强的模型。</p></blockquote><h4 id="使用图像增加技术避免过拟合"><a href="#使用图像增加技术避免过拟合" class="headerlink" title="使用图像增加技术避免过拟合"></a>使用图像增加技术避免过拟合</h4><p>​    通过应用各种图片变换，可以增加样本数量，提高泛化能力避免过拟合的效果。</p><p>   <img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0d8bfb44efdffc9b668a4823a975c2cf71f25fa4d821352a1d1ca753744267a8df99e53f85482386e6a262712cfef8dc?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-204934%402x.png&amp;size=750" alt></p><h3 id="使用随机丢弃避免过拟合（仅限深度神经网络）"><a href="#使用随机丢弃避免过拟合（仅限深度神经网络）" class="headerlink" title="使用随机丢弃避免过拟合（仅限深度神经网络）"></a>使用随机丢弃避免过拟合（仅限深度神经网络）</h3><p>​     丢弃是指在训练过程中，随机关闭网络中的某些神经元。可以强制其它神经元产生更大的影响，在训练中扮演积极角色，如图：</p><p>   <img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/2c5a2132d7102530a3931a7105d7a8072be268a23bce15834b5e7535b6980e861cd49cbe5491ab8a854259885654f033?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-211219%402x.png&amp;size=750" alt></p><p>   在实践中，会指定每个训练周期每个神经元被丢弃的概率。</p><h3 id="实战：-图片增强的狗与猫图片分类"><a href="#实战：-图片增强的狗与猫图片分类" class="headerlink" title="实战： 图片增强的狗与猫图片分类"></a>实战： 图片增强的狗与猫图片分类</h3><p>参考<a href="https://colab.research.google.com/drive/1d3BmTUhMi4zFL9p4PMrKObJvfwj1zvFL#scrollTo=LZPYT-EmVrWo" target="_blank" rel="noopener">Colab</a>，我们将遵循一般的机器学习流程:</p><ul><li>Examine and understand data 检查和理解数据</li><li>Build an input pipeline 构建输入管道</li><li>Build our model 建立我们的模型</li><li>Train our model 训练我们的模型</li><li>Test our model 测试我们的模型</li><li>Improve our model/Repeat the process 改进我们的模型 / 重复这个过程</li></ul><h3 id="其它避免过拟合的技巧"><a href="#其它避免过拟合的技巧" class="headerlink" title="其它避免过拟合的技巧"></a>其它避免过拟合的技巧</h3><ul><li><p>收集更多数据及添加噪音：这和数据增强的目的是一样的，但是也会使模型对于自然界中可能遇到的干扰更加稳定。</p></li><li><p>简化模型：通过逐步降低模型的复杂性ーー随机森林中估计值的数目、神经网络中参数的数目等ーー你可以使模型足够简单，不会过度拟合，但也足够复杂，可以从你的数据中学习。 要做到这一点，根据模型的复杂性来查看两个数据集上的错误是很方便的。</p></li><li><p>改变训练方式：包括改变损失函数，或者模型在训练期间的工作方式。</p></li><li><p>正则化：正则化是一个约束模型学习以减少过拟合的过程。 其中一个最强大的和众所周知的技术正则化是增加一个惩罚的损失函数。 最常见的是 L1和 L2。L1惩罚的目的是最小化权重的绝对值，这有助于识别数据集中最相关的特性。L2惩罚的目的是使权重的平方最小化，效率高于L1。通过惩罚，该模型被迫在权重上做出妥协，因为它不能再将权重任意增加。 这使得模型更加通用，有助于防止过拟合。</p><p>参考文章： <a href="https://hackernoon.com/memorizing-is-not-learning-6-tricks-to-prevent-overfitting-in-machine-learning-820b091dc42" target="_blank" rel="noopener">6 tricks to prevent overfitting in machine learning.</a></p></li></ul><h3 id="练习：增加版花朵图像分类"><a href="#练习：增加版花朵图像分类" class="headerlink" title="练习：增加版花朵图像分类"></a>练习：增加版花朵图像分类</h3><p>​    参考：<a href="https://colab.research.google.com/drive/1uURGgGNTeeyJ4Zfeoz81ggmUARxuNhfK#scrollTo=tk5NT1PW3j_P" target="_blank" rel="noopener">自行练习版Colab</a>，<a href>官方版Colab</a></p><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>迁移学习的原理是通过使用由机器学习专家创建的经过大型数据训练过的模型，将模型已经学习到的知识迁移到新的数据集上，可以显著提高预测准确率。如上面猫狗识别的实战可以将准确率从80%提高到95%</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/8ec95bbbf4a17ab91b71cffaca9dca22f2f4020cd3b621c387f2972b0678f4ae35aec76d835f9c464c5a5f9edfed187b?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-130000%402x.png&amp;size=750=" alt></p><p>​        在迁移学习中，预训练的模型中的参数将被冻结（避免随机初始化权重），只训练最后分类层级的变量，可以显著提高训练速度。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/695902034ea19e36c9a7169926b7872bebc6f2c9f4aa53fa4aa88cc556012da1cb029e18d4688174459ef489ca77d718?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-130849%402x.png&amp;size=750" alt><br>​    示例代码：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/58b0e59034ade88fb41c26a1c7c918efc3eccfae6995ec8fb908883b250ea2273c2653bb2cfc96dbe6a6cb144570c40d?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-132906%402x.png&amp;size=750" alt></p><p>​    参考Colab：<a href="https://colab.research.google.com/drive/1aGtbtCl2wSrcIMk9aadlJz2LtCHZ601R#scrollTo=3n0Wb9ylKd8R" target="_blank" rel="noopener">对猫狗数据集应用迁移学习</a> , <a href="https://colab.research.google.com/drive/177BHQe1KCLdzMvMW7TvSRfblPsG30fJV#scrollTo=oXiJjX0jfx1o" target="_blank" rel="noopener">通过迁移学习分类花朵图像</a></p><h3 id="实战：房价预测（线性回归）"><a href="#实战：房价预测（线性回归）" class="headerlink" title="实战：房价预测（线性回归）"></a>实战：房价预测（线性回归）</h3><h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/9a5c4539cd94381da65ed1936112134e2b4a12ee162954ca027e4b288fe87ba83dcf95a32a54eaa18a52be096bb2d439?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-151749%402x.png&amp;size=750" alt></p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/08aa206814b71996987241fb6f0cfaad6b870417d5ab71ee80d9795d49a33764f92bf4e4aacf94824ecb83a82f88ed63?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-153950%402x.png&amp;size=750" alt></p><ul><li><p>matplotlib 是一个 Python 2D 绘图库，可以生成出版物质量级别的图像和各种硬拷贝格式，并广泛支持多种平台，如:Python 脚本，Python，IPython Shell 和 Jupyter Notebook。</p></li><li><p>seaborn 是一个基于 matplotlib的 Python 数据可视化库。它提供了更易用的高级接口，用于绘制精美且信息丰富的统计图形。</p></li><li><p>mpl_toolkits.mplot3d 是一个基础 3D绘图(散点图、平面图、折线图等)工具集，也是matplotlib 库的一部分。同时，它也支持轻量级的独立安装模式。</p></li><li><p>NumPy 是一个 BSD 开源协议许可的，面向 Python 用户的基础科学计算库，在多 维数组上实现了线性代数、傅立叶变换和其他丰富的函数运算。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/f602ee77363996f0a1d8eae20742ca797fbdf93f868417b1733f05ed5dae75508b1bc5c10925984456133eb0f56014b9?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190914-171026%402x.png&amp;size=750" alt></p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://classroom.udacity.com/courses/ud187" target="_blank" rel="noopener">Tensorflow free course</a></li><li><a href="https://medium.com/tensorflow/introducing-tensorflow-hub-a-library-for-reusable-machine-learning-modules-in-tensorflow-cdee41fa18f9" target="_blank" rel="noopener">Introducing TensorFlow Hub: A Library for Reusable Machine Learning Modules in TensorFlow</a></li><li><a href="https://towardsdatascience.com/understanding-your-convolution-network-with-visualizations-a4883441533b" target="_blank" rel="noopener">Understanding your Convolution network with Visualizations</a></li><li><a href="https://time.geekbang.org/course/detail/153-78981" target="_blank" rel="noopener">TensorFlow快速入门与实战</a></li><li><a href="https://www.cnblogs.com/guoyaohua/p/9265268.html" target="_blank" rel="noopener">Win10安装Tensorflow</a></li><li><a href="https://blog.csdn.net/xiaohuihui1994/article/details/83589701" target="_blank" rel="noopener">超详细：win10安装tensorflow-gpu1.8.0完整步骤</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习常用术语</title>
      <link href="/2019/090864521.html"/>
      <url>/2019/090864521.html</url>
      
        <content type="html"><![CDATA[<p>机器学习领域有着许多非常基本的术语，这些术语听来可能相当高深莫测、它们事实上也可能拥有非常复杂的数学背景，本文会对这些常用的基本术语进行说明与解释。</p><ul><li>人工智能：一种计算机科学分支，旨在让计算机达到人类的智慧。实现这一目标有很多方式，包括机器学习和深度学习。</li><li>机器学习：一系列相关技术，用于训练计算机执行特定的任务。</li><li>神经网络：一种机器学习结构，灵感来自人类大脑的神经元网络。神经网络是深度学习的基本概念。</li><li>深度学习：机器学习的一个分支，利用多层神经网络实现目标。通常“机器学习”和“深度学习”可以相互指代。</li><li>监督式学习：</li><li>非监督式学习：</li><li>训练流程：是指将网络的内部变量调整为最佳可能值，使它们能够将输入映射到输出。为了实现这个目标，我们将采用梯度下降法这一优化流程，它会使用数值分析找到模- 型内部变量的最佳可能值。</li><li>梯度下降法：梯度下降法会以迭代方式调整参数，每次朝着正确的方向小幅更改参数，直到达到最佳值。“最佳值”是指再调整的话，会降低模型的效果。在每次迭代过程中- 衡量模型好坏的函数称为“损失函数”，每次调整的目标是“最小化损失函数”。</li><li>特征：模型的输入</li><li>样本：用于训练流程的输入/输出对</li><li>标签：模型的输出</li><li>层级：神经网络中相互连接的节点集合。</li><li>模型：神经网络的表示法</li><li>密集全连接层 (FC)：一个层级中的每个节点都与上个层级中的每个节点相连。</li><li>权重和偏差：模型的内部变量</li><li>损失：期望输出和真实输出之间的差值</li><li>MSE：均方误差，一种损失函数，它会将一小部分很大的差值视作比大量很小的差值更糟糕。</li><li>梯度下降法：每次小幅调整内部变量，从而逐渐降低损失函数的算法。</li><li>优化器：梯度下降法的一种具体实现方法。（有很多算法。在这门课程中，我们将仅使用“Adam”优化器，它是 - ADAptive with Momentum 的简称，并且被视为最佳优化器。）</li><li>学习速率：梯度下降过程中的损失改进“步长”。</li><li>批次：在训练神经网络的过程中使用的一组样本。</li><li>周期：完全经过整个训练数据集一轮</li><li>前向传播：根据输入计算输出值</li><li>反向传播：根据优化器算法计算内部变量的调整幅度，从输出层级开始，并往回计算每个层级，直到抵达输入层。</li><li>扁平化：将二维图像转换为一维向量的过程</li><li>ReLU：一种激活函数，使模型能够解决非线性问题。如果它接收到任何负输入，则该函数返回0，但对于任何正值x，它返回该值。参考：<a href="https://www.kaggle.com/dansbecker/rectified-linear-units-relu-in-deep-learning" target="_blank" rel="noopener">深度学习中的 ReLU</a></li><li>Softmax：一种函数，能够为每个潜在输出类别生成概率</li><li>分类：一种机器学习模型，用于区分两个或多个输出类别</li><li>训练集：用于训练神经网络的数据。</li><li>测试集：用于测试神经网络最终效果的数据。</li><li>验证集：训练完毕时，使用验证集衡量模型的最终准确率。</li><li>递归：输出一个值的模型。例如，估算房屋价值。</li><li>分类：一种模型，能够输出多个类别的概率分布。</li><li>CNN：卷积神经网络。即至少有一个卷积层的网络。典型的 CNN 还包括其他类型的层级，例如池化层和密集层。</li><li>卷积：向图像应用核（滤波器）的过程</li><li>核/滤波器：小于输入的矩阵，用于将输入变成多个小区域</li><li>填充：在输入图像周围添加像素，像素值通常为 0</li><li>池化：通过下采样降低图像大小的过程。池化层有多种类型。例如，平均池化通过求平均值将多个值变成一个值。但是最大池化是最常见- 的池化类型。</li><li>最大池化：一种池化过程，通过获取多个值中的最大值，将多个值变成一个值。</li><li>步长：在图像上滑动核（滤波器）的间隔像素数量。</li><li>下采样：降低图像大小的操作</li></ul><h2 id="其它基础知识常用术语："><a href="#其它基础知识常用术语：" class="headerlink" title="其它基础知识常用术语："></a>其它基础知识常用术语：</h2><ul><li>线性与非线性：</li><li>一维向量：</li><li>方差：是指一组数据中的各个数减这组数据的平均数的平方和的平均数，如（1，2，3,4,5）这组数据的方差，就先求出这组数据的平均数（1+2+3+4+5）÷5＝3，然后再求各个数与平均数的差的平方和，用（1-3）²+（2-3）²+（3-3）²+（4-3）²+（5-3）²＝10，再求平均数10÷5＝2，即这组数据的方差为2. 意义：当数据分布比较分散（即数据在平均数附近波动较大）时，各个数据与平均数的差的平方和较大，方差就较大；当数据分布比较集中时，各个数据与平均数的差的平方和较小。因此方差越大，数据的波动越大；方差越小，数据的波动就越小。方差不仅仅表达了样本偏离均值的程度，更是揭示了样本内部彼此波动的程度，也可以理解为方差代表了样本彼此波动的期望。</li></ul><h2 id="常用算法模型"><a href="#常用算法模型" class="headerlink" title="常用算法模型"></a>常用算法模型</h2><ul><li><p>OpenPose：OpenPose人体姿态识别项目是美国卡耐基梅隆大学（CMU）基于卷积神经网络和监督学习并以caffe为框架开发的开源库。可以实现人体动作、面部表情、手指运动等姿态估计。适用于单人和多人，具有极好的鲁棒性。是世界上首个基于深度学习的实时多人二维姿态估计应用。其成功的一部分原因是它在 GitHub 上开源了其实现代码（ <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose" target="_blank" rel="noopener">https://github.com/CMU-Perceptual-Computing-Lab/openpose</a> ），并配有详细的说明文档。</p></li><li><p>DeepCut：DeepCut（ <a href="https://arxiv.org/abs/1511.06645" target="_blank" rel="noopener">https://arxiv.org/abs/1511.06645</a> ）是一个自底向上的多人人体姿态估计方法。</p></li><li><p>RMPE（AlphaPose）：是一个流行的自顶向下姿态估计算法。该论文的作者认为，自顶向下方法的性能通常依赖于人体检测器的精度，毕竟人体姿态估计是在检测器检出的框的区域内进行的。因此，错误的定位和重复的候选框会使姿态检测算法的性能降低。为解决这一问题，作者提出了使用对称空间变换网络（Symmetric Spatial Transformer Network，SSTN）来从不准确的候选框中抽取高质量的单人区域。然后，作者使用了一个单人的姿态估计器（Single Person Pose Estimator，SPPE）来从抽取到的区域中估计此人的姿态骨架。接着，作者用一个空间逆变换网络（Spatial De-Transformer Network，SDTN），将估计出的姿态重新映射到图像坐标系下。最后，用一个参数化的姿态非极大抑制（Non-Maximum Suppression，NMS）方法来处理重复预测的问题。另外，作者还引入了一种姿态候选生成器（Pose Guided Proposals Generator），来增广训练样本，以便更好地训练 SPPE 和 SSTN 网络。RMPE 的显著特征是，该方法可以推广到任意的人体检测算法和 SSPE 的组合。</p></li><li><p>Mask RCNN：Mask RCNN（ <a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">https://arxiv.org/abs/1703.06870</a> ）是一个非常流行的语义和实例分割架构。该模型可以同时预测图像中多个物体的候选框位置及分割其语义信息的 mask。该模型的基础架构很容易被扩展到人体姿态估计上来。</p></li><li><p>DensePose：这是Mask-RCNN的一种变体，可以以每秒多帧的速度在每个人体区域内密集地回归特定部位的UV坐标。它基于一种能将图像像素通过卷积网络映射到密集网格的系统——DenseReg。模型的目标是决定每个像素在表面的位置以及它所在部分相对应的2D参数。DensePose借用了Mask-RCNN的架构，同时带有Feature Pyramid Network（FPN）的特征，以及ROI-Align池化。除此之外，他们在ROI池化的顶层搭建了一个全卷积网络。想了解DensePose更多的技术细节，请阅读原论文。</p></li><li><p>Realtime Multi-Person Pose Estimation： 这一模型和上面的OpenPose高度相关，同时特征模型能与多种框架相关联。论文的作者提供了一种自下而上的方法，对多人的姿态进行实时估计，不需要用任何人物探测器。这种方法运用了一种非参数表示，我们称为Part Affinity Fields（PAFs），用它可以学习将图中人物和其身体部位联系到一起。有关该技术的具体细节和理论，可以阅读原文。另外，这一方法最棒的特征之一就是它可以在多种不同的框架中实现，针对不同框架，已经公开了相关代码和模型。</p></li><li><p>AlphaPose：lphaPose是一款精准的多人姿态评估工具，并声称是第一款开源系统。AlphaPose既可以在图片、视频或多图中进行姿态估计，也能在画面中对动作进行追踪。它的输出形式非常广泛，包括PNG、JPG和AVI等具有关键点的图片形式，也有JSON格式的输出，这一特点也使其成为众多应用受欢迎的工具。目前，这一工具支持TensorFlow和PyTorch两种实现。AlphaPose利用一种区域性的多人动作估计框架将不精准的人类边界框该进程精确的动作估计。这里有三种元素：对称空间转换网络（SSTN）、参数化姿态非极大抑制（NMS）以及姿态导向的生成器（PGPG）。</p></li><li><p>DeepPose： DeepPose算是比较“古老”的了，论文发布与2014年，提出了一种基于深度神经网络的姿态估计方法，是基于DNN向身体关节回归的问题。它以一种整体的方式估计姿态，并且表述起来非常简洁强大。DeepPose是第一个将深度学习应用到人类姿态估计上的应用，并且取得了当时顶尖的结果，成为了其他方法的baseline。</p></li><li><p>MTCNN人脸检测：是2016年的论文提出来的，MTCNN的“MT”是指多任务学习(Multi-Task)，在同一个任务中同时学习”识别人脸“、”边框回归“、”人脸关键点识别“。相比2015年的CVPR(边框调整和识别人脸分开做)的结构，MTCNN是有创新的。</p></li><li><p>FaceNet：是 Google 研究人员于 2015 年开发的人脸识别系统，一个通用的系统，可以用于人脸验证（是否是同一人？），识别（这个人是谁？）和聚类（寻找类似的人？）。与其他的深度学习方法在人脸上的应用不同，FaceNet并没有用传统的softmax的方式去进行分类学习，然后抽取其中某一层作为特征，而是直接进行端对端学习一个从图像到欧式空间的编码方法，然后基于这个编码再做人脸识别、人脸验证和人脸聚类等。通过卷积神经网络学习将图像映射到欧几里得空间。空间距离直接和图片相似度相关：同一个人的不同图像在空间距离很小，不同人的图像在空间中有较大的距离。</p></li><li><p>CTPN：是在ECCV 2016提出的一种文字检测算法。CTPN结合CNN与LSTM深度网络，能有效的检测出复杂场景的横向分布的文字，是目前比较好的文字检测算法。 <a href="https://zhuanlan.zhihu.com/p/34757009" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34757009</a></p></li><li><p>Faster RCNN：经过R-CNN和Fast RCNN的积淀，Ross B. Girshick在2016年提出了新的Faster RCNN，在结构上，Faster RCNN已经将特征抽取(feature extraction)，proposal提取，bounding box regression(rect refine)，classification都整合在了一个网络中，使得综合性能有较大提高，在检测速度方面尤为明显。</p></li><li><p>SLAM： Simultaneous Localization And Mapping的 英文首字母组合，一般翻译为：同时定位与建图、同时定位与地图构建。SLAM是指当某种移动设备（如机器人、无人机、手机等）从一个未知环境里的未知地点出发，在运动过程中通过传感器（如激光雷达、摄像头等）观测定位自身位置、姿态、运动轨迹，再根据自身位置进行增量式的地图构建，从而达到同时定位和地图构建的目的。定位和建图是两个相辅相成的过程，地图可以提供更好的定位，而定位也可以进一步扩建地图。需要说明的是，上述扫地机器人例子中，定位和建图是SLAM的基本要求，而路径规划是在此基础上的高级功能，不属于SLAM的讨论范畴。</p></li><li><p>SFM：Structure From Motion，通过相机的移动来确定目标的空间和几何关系，是三维重建的一种常见方法。<br>它与Kinect这种3D摄像头最大的不同在于，它只需要普通的RGB摄像头即可，因此成本更低廉，且受环境约束较小，<br>在室内和室外均能使用。</p></li><li><p>ResNet：ResNet是由微软研究院的Kaiming He等四名华人提出，他们通过自己提出的ResNet Unit成功训练出来152层的神经网络并在ILSVRC2015比赛中斩获冠军。ResNet语义分割领域最受欢迎且最广泛运用的神经网络.ResNet的核心思想就是在网络中引入恒等映射，允许原始输入信息直接传到后面的层中，在学习过程中可以只学习上一个网络输出的残差（F(x)），因此ResNet又叫做残差网络。、</p></li><li><p>R-CNN：伯克利大学的Girshick教授等人共同提出了首个在目标检测方向应用的深度学习模型：Region-based Convolutional Neural Network（R-CNN）。该网络模型如下图所示，其主要流程为：先使用selective search算法提取2000个候选框，然后通过卷积网络对候选框进行串行的特征提取，再根据提取的特征使用SVM对候选框进行分类预测，最后使用回归方法对区域框进行修正。</p><p><img src="https://pic2.zhimg.com/80/v2-bd5baff7669ca7ddce811c7149c11799_hd.jpg" alt></p></li><li><p>Fast R-CNN：由于R-CNN的效率太低，2015年由Ross等学者提出了它的改进版本：Fast R-CNN。其网络结构图如下图所示（从提取特征开始，略掉了region的选择）Fast R-CNN在传统的R-CNN模型上有所改进的地方是它是直接使用一个神经网络对整个图像进行特征提取，就省去了串行提取特征的时间；接着使用一个RoI Pooling Layer在全图的特征图上摘取每一个RoI对应的特征，再通过FC进行分类和包围框的修正。</p><p><img src="https://pic2.zhimg.com/80/v2-ae08e5aa35c2e8bfd65491e3c39888cd_hd.jpg" alt></p></li><li><p>Faster R-CNN：2016年提出的Faster R-CNN可以说有了突破性的进展（虽然还是目标检测哈哈哈），因为它改变了它的前辈们最耗时最致命的部位：selective search算法。它将selective search算法替换成为RPN，使用RPN网络进行region的选取，将2s的时间降低到10ms，其网络结构如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-d7b27123e9e95200303959aeaf8816e2_hd.jpg" alt></p><p>​    Faster R-CNN优缺点：</p><ul><li>使用RPN替换了耗时的selective search算法，对整个网络结构有了突破性的优化；</li><li>Faster R-CNN中使用的RPN和selective search比起来虽然速度更快，但是精度和selective search相比稍有不及，如果更注重速度而不是精度的话完全可以只使用RPN；</li></ul></li><li><p>Mask R-CNN：Mask R-CNN（终于到分割了！）是何恺明大神团队提出的一个基于Faster R-CNN模型的一种新型的分割模型，此论文斩获ICCV 2017的最佳论文，在Mask R-CNN的工作中，它主要完成了三件事情：目标检测，目标分类，像素级分割。恺明大神是在Faster R-CNN的结构基础上加上了Mask预测分支，并且改良了ROI Pooling，提出了ROI Align。其网络结构真容就如下图所示啦：</p><p><img src="https://pic4.zhimg.com/80/v2-8123af16197c5b6b486808fafe2246d7_hd.jpg" alt></p><p>​    MS R-CNN的优缺点：</p><ul><li>优化了Mask R-CNN中的信息传播，提高了生成预测模板的质量；</li><li>未经大批量训练的情况下，就拿下了COCO 2017挑战赛实例分割任务冠军；</li><li>要说缺点的话。。应该就是整个网络有些庞大，一方面需要ResNet当作主干网络，另一方面需要其它各种Head共同承担各种任务。</li></ul></li><li><p>SetNet：SegNet是剑桥提出的旨在解决自动驾驶或者智能机器人的图像语义分割深度网络，SegNet基于FCN，与FCN的思路十分相似，只是其编码-解码器和FCN的稍有不同，其解码器中使用去池化对特征图进行上采样，并在分各种保持高频细节的完整性；而编码器不使用全连接层，因此是拥有较少参数的轻量级网络：</p><p><img src="https://pic4.zhimg.com/80/v2-f6a18a6bad1cbfd8c359a45656604fe3_hd.jpg" alt></p><p>​    SetNet的优缺点：</p><ul><li>保存了高频部分的完整性；</li><li>网络不笨重，参数少，较为轻便；</li><li>对于分类的边界位置置信度较低；</li><li>对于难以分辨的类别，例如人与自行车，两者如果有相互重叠，不确定性会增加。</li></ul></li><li><p>LSTM:长短时记忆（LSTM，Long Short Term Memory）模型在时间信息处理中很受欢迎，关键思想是单元（cell）状态，如图水平线贯穿的顶部。LSTM将信息移除或添加到单元状态（cell state），称为门（gates）：输入门（𝑖𝑡），忘记门（𝑓𝑡）和输出门（𝑜𝑡）可以定义为如下公式：</p><p><img src="https://pic2.zhimg.com/80/v2-3f99658ef0bee863c16c243cf5de9279_hd.jpg" alt></p></li><li><p>GRU：Gated Recurrent Unit ，也来自LSTMs。GRU受欢迎的主要原因是计算成本和模型的简单性，如图所示。在拓扑、计算成本和复杂性方面，GRU是比标准LSTM更轻的RNN版。 该技术将遗忘门（forget gates）和输入门（input gates）组合成单个“更新门（update gate）”，并将单元状态、隐藏状态以及一些其他变化合并。更简单的GRU模型越来越受欢迎。数学上GRU可以用表示如下公式：</p><p><img src="https://pic4.zhimg.com/80/v2-15ac0386cacc6f89cd9b4bbe07806ebf_hd.jpg" alt></p></li><li><p>RNN： 递归神经网络（Recurrent Neural Network，RNN），不同于CNN，是用来处理序列数据的模型。有一点共同的是，RNN在几个时间点也具有共享权重的特点。RNN是唯一的，它允许随时间推移在一系列向量上进行操作。在Elman架构中，使用隐层的输出和隐层的正常输入一起作为输入。 另一方面，Jordan网络中输出单元的输出作为隐藏层的输入。相反地Jordan使用输出单元的输出同时作为自身和隐藏层的输入。RNN方法的主要问题是梯度消失/下降。如图示意所示。</p><p><img src="https://pic4.zhimg.com/80/v2-4359eedb6d8821257dae8988614b7d23_hd.jpg" alt></p></li><li><p>迁移学习：迁移学习是一种机器学习的方法，指的是一个预训练的模型被重新用在另一个任务中。迁移学习是一种优化，是一种节省时间或者得到更好性能的捷径。</p></li><li><p>ArchiGAN: 基于GAN实现公寓户型及家具自动划分，参考地址: <a href="https://devblogs.nvidia.com/archigan-generative-stack-apartment-building-design/?linkId=70968833" target="_blank" rel="noopener">https://devblogs.nvidia.com/archigan-generative-stack-apartment-building-design/?linkId=70968833</a></p></li><li><p>SLAM：同时定位与建图（simultaneous localization and mapping，SLAM）是自动驾驶与增强现实领域中常用的技术。主要研究装置通过各种传感器在未知环境中的感知与定位问题。可以描述为: 机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置估计和地图进行自身定位,同时在自身定位的基础上建造增量式地图，实现机器人的自主定位和导航。使用的基于机器人操作系统（ROS）框架工作的SLAM算法。 在ROS中提供的五种基于2D激光的SLAM算法分别是：HectorSLAM，Gmapping，KartoSLAM，CoreSLAM和LagoSLAM。当然最后还有比较经典的google开源的cartographer，虽然不是基于ROS的但是大牛们已经将它修改为基于ＲＯＳ的版本的cartographer_ros</p></li><li><p>U-Net：在图像分割任务特别是医学图像分割中，U-Net[1]无疑是最成功的方法之一，该方法在2015年MICCAI会议上提出，目前已达到四千多次引用。其采用的编码器（下采样）-解码器（上采样）结构和跳跃连接是一种非常经典的设计方法。目前已有许多新的卷积神经网络设计方式，但很多仍延续了U-Net的核心思想，加入了新的模块或者融入其他设计理念。</p><p><img src="https://pic3.zhimg.com/v2-63be140aee258bc15cfc1541f0a60d22_1200x500.jpg" alt="图像分割的U-Net系列方法"></p></li><li></li></ul><p>参考文章</p><ul><li><a href="https://developers.google.com/machine-learning/glossary/" target="_blank" rel="noopener">Google机器学习和TensorFlow专用术语表</a></li><li><a href="https://zhuanlan.zhihu.com/p/70758906" target="_blank" rel="noopener">最全综述 | 图像分割算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Bash命令收集</title>
      <link href="/2019/081342868.html"/>
      <url>/2019/081342868.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><h3 id="1-hostname-查看主机名"><a href="#1-hostname-查看主机名" class="headerlink" title="1. hostname - 查看主机名"></a>1. hostname - 查看主机名</h3><p><code>hostname</code>命令用于查看系统的主机名，或是修改系统的主机名。</p><p><code>hostname</code>的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示系统的当前主机名</span><span class="token function">hostname</span><span class="token comment" spellcheck="true"># 修改你系统的主机名</span><span class="token function">hostname</span> blinkfox-system<span class="token comment" spellcheck="true"># 使用 -F 选项，从指定的文件中读取主机名</span><span class="token function">hostname</span> -F /root/hostname.txt</code></pre><h3 id="2-uptime-查看系统运行时间"><a href="#2-uptime-查看系统运行时间" class="headerlink" title="2. uptime - 查看系统运行时间"></a>2. uptime - 查看系统运行时间</h3><p><code>uptime</code>命令用于打印系统的运行时间等信息。使用如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uptime</span></code></pre><h3 id="3-w、who-列出登录的用户"><a href="#3-w、who-列出登录的用户" class="headerlink" title="3. w、who - 列出登录的用户"></a>3. w、who - 列出登录的用户</h3><p><code>w</code>命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下：</p><pre class=" language-bash"><code class="language-bash">w<span class="token comment" spellcheck="true"># 打印如下</span>22:42  up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75USER     TTY      FROM              LOGIN@  IDLE WHATblinkfox console  -                日19   6days -blinkfox s000     -                五23       - w</code></pre><p><code>who</code>命令有与<code>w</code>命令类似的用途，但它的功能比<code>w</code>命令更强大一些。语法格式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">who</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>FILE <span class="token operator">|</span> ARG1 ARG2<span class="token punctuation">]</span></code></pre><p><code>who</code>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示当前登录的所有用户信息</span><span class="token function">who</span><span class="token comment" spellcheck="true"># 显示系统的启动时间</span><span class="token function">who</span> -b<span class="token comment" spellcheck="true"># 显示系统登录进程</span><span class="token function">who</span> -l<span class="token comment" spellcheck="true"># 显示与当前标准输入关联的用户信息</span><span class="token function">who</span> -m<span class="token comment" spellcheck="true"># 显示系统的运行级别</span><span class="token function">who</span> -r<span class="token comment" spellcheck="true"># 显示所有登录用户的用户名和登录用户数</span><span class="token function">who</span> -q</code></pre><h3 id="4-uname-查看系统信息"><a href="#4-uname-查看系统信息" class="headerlink" title="4. uname - 查看系统信息"></a>4. uname - 查看系统信息</h3><p><code>uname</code>命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">uname</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><p>常用使用方式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 只打印内核的名称</span><span class="token function">uname</span><span class="token comment" spellcheck="true"># 使用 -n 选项，只打印系统的主机名</span><span class="token function">uname</span> -n<span class="token comment" spellcheck="true"># 使用 -r 选项，打印内核版本信息</span><span class="token function">uname</span> -r<span class="token comment" spellcheck="true"># 使用 -m 选项，打印系统的硬件名称</span><span class="token function">uname</span> -m<span class="token comment" spellcheck="true"># 使用 -p 选项，打印系统的处理器类型信息</span><span class="token function">uname</span> -p<span class="token comment" spellcheck="true"># 使用 -i 选项，打印系统的硬件平台信息</span><span class="token function">uname</span> -i<span class="token comment" spellcheck="true"># 使用 -a 选项，打印上述所有示例中的信息</span><span class="token function">uname</span> -a</code></pre><h3 id="5-date-显示和设置系统日期和时间"><a href="#5-date-显示和设置系统日期和时间" class="headerlink" title="5. date - 显示和设置系统日期和时间"></a>5. date - 显示和设置系统日期和时间</h3><p><code>date</code>命令用于以多种格式显示日期和时间，或设置系统的日期和时间。<code>date</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">date</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>+FORMAT<span class="token punctuation">]</span><span class="token function">date</span> <span class="token punctuation">[</span>-u<span class="token operator">|</span>--utc<span class="token operator">|</span>--universal<span class="token punctuation">]</span> <span class="token punctuation">[</span>MMDDhhmm<span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span><span class="token punctuation">[</span>.ss<span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>常用使用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以默认格式显示系统的当前日期时间</span><span class="token function">date</span><span class="token comment" spellcheck="true"># 格式化当前日期</span><span class="token function">date</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 格式化输出昨天的日期</span><span class="token function">date</span> -d <span class="token string">"1 day ago"</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 2秒后格式化输出</span><span class="token function">date</span> -d <span class="token string">"2 second"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 普通格式化转出</span><span class="token function">date</span> -d <span class="token string">"2009-12-12"</span> +<span class="token string">"%Y/%m/%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># apache格式转换</span><span class="token function">date</span> -d <span class="token string">"Dec 5, 2009 12:00:37 AM"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 日期加减操作</span><span class="token function">date</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前天年月日</span><span class="token function">date</span> -d <span class="token string">"+1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示后一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示上一月的日期</span><span class="token function">date</span> -d <span class="token string">"+1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一月的日期</span><span class="token function">date</span> -d <span class="token string">"-1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一年的日期</span><span class="token function">date</span> -d <span class="token string">"+1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一年的日期</span><span class="token comment" spellcheck="true"># 设定时间</span><span class="token function">date</span> -s <span class="token comment" spellcheck="true"># 设置当前时间，只有root权限才能设置，其他只能查看</span><span class="token function">date</span> -s 20160816 <span class="token comment" spellcheck="true"># 设置成20160816，这样会把具体时间设置成空00:00:00</span><span class="token function">date</span> -s 01:01:01 <span class="token comment" spellcheck="true"># 设置具体时间，不会对日期做更改</span><span class="token function">date</span> -s <span class="token string">"01:01:01 2012-05-23"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间 </span><span class="token function">date</span> -s <span class="token string">"01:01:01 20120523"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"2012-05-23 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间 </span><span class="token function">date</span> -s <span class="token string">"20120523 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span></code></pre><h3 id="6-id-显示用户属性"><a href="#6-id-显示用户属性" class="headerlink" title="6. id - 显示用户属性"></a>6. id - 显示用户属性</h3><p><code>id</code>命令用于打印输出用户<code>uid</code>、<code>gid</code>、用户名和组名等用户身份信息。<code>id</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">id</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>USERNAME<span class="token punctuation">]</span></code></pre><p>常见使用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息</span><span class="token function">id</span><span class="token comment" spellcheck="true"># 使用 -u 选项，输出用户的 uid</span><span class="token function">id</span> -u<span class="token comment" spellcheck="true">#-u 选项和 -n 选项结合使用，输出账户的用户名</span><span class="token function">id</span> -un<span class="token comment" spellcheck="true"># 使用 -g 选项，输出帐号当前起作用的gid</span><span class="token function">id</span> -g<span class="token comment" spellcheck="true"># -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名</span><span class="token function">id</span> -gn<span class="token comment" spellcheck="true"># 使用 -G 选项，输出帐号所属的所有群组id</span><span class="token function">id</span> -G root<span class="token comment" spellcheck="true"># -G 与 -n 选项结合使用，输出账号所属的所有群组的名称</span><span class="token function">id</span> -Gn root</code></pre><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><h3 id="1-touch-创建文件"><a href="#1-touch-创建文件" class="headerlink" title="1. touch - 创建文件"></a>1. touch - 创建文件</h3><p><code>touch</code>命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。<code>touch</code>命令又如下选项：</p><pre class=" language-bash"><code class="language-bash">-a: 只改变访问时间 -c: 不创建任何文件-m: 只改变修改时间-r: 使用指定文件的时间替代当前时间-t: 使用 <span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span>MMDDhhmm<span class="token punctuation">[</span>.ss<span class="token punctuation">]</span> 替代当前时间</code></pre><p>touch 命令的常见用法如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个名为 effyl 的新空文件</span><span class="token function">touch</span> effyl<span class="token comment" spellcheck="true"># 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件</span><span class="token function">touch</span> effyl myeffyl lueffyl<span class="token comment" spellcheck="true"># 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个</span><span class="token function">touch</span> -a effyl<span class="token comment" spellcheck="true"># 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳</span><span class="token function">touch</span> -c effyl<span class="token comment" spellcheck="true"># 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变</span><span class="token function">touch</span> -m effyl<span class="token comment" spellcheck="true"># 使用 -c 和 -t 选项，来明确设置文件的时间</span><span class="token function">touch</span> -c -t YYMMDDHHMM filename<span class="token comment" spellcheck="true"># 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项</span><span class="token function">touch</span> -r myeffyl effyl</code></pre><h3 id="2-mkdir-创建目录"><a href="#2-mkdir-创建目录" class="headerlink" title="2.mkdir - 创建目录"></a>2.mkdir - 创建目录</h3><p><code>mkdir</code>命令用于创建一个新目录。最基本的<code>mkdir</code>命令的使用方法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下创建一个给定的目录名</span><span class="token function">mkdir</span> <span class="token operator">&lt;</span>dirname<span class="token operator">></span><span class="token comment" spellcheck="true"># 在 backup 中的相对路径创建一个名为 old 的目录</span><span class="token function">mkdir</span> backup/old<span class="token comment" spellcheck="true"># 在 backup 中的绝对路径中创建一个名为 old 的目录</span><span class="token function">mkdir</span> /home/blinkfox/backup/old<span class="token comment" spellcheck="true"># 使用 -p 选项，会自动创建所有还不存在的父目录</span><span class="token function">mkdir</span> -p backup/old<span class="token comment" spellcheck="true"># 使用 -m 选项，可以设置将要创建目录的权限</span><span class="token comment" spellcheck="true"># 如：创建一个任何人都有读写访问权限的目录</span><span class="token function">mkdir</span> -p -m 777 backup/old</code></pre><h3 id="3-cp-复制文件或目录"><a href="#3-cp-复制文件或目录" class="headerlink" title="3.cp - 复制文件或目录"></a>3.cp - 复制文件或目录</h3><p><code>cp</code>命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。</p><p>使用 cp 命令复制文件和目录的语法有以下几种：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制源文件到目标文件</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE DEST<span class="token comment" spellcheck="true"># 复制一个或多个源文件到一个目录</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY<span class="token comment" spellcheck="true"># 同上</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> -t DIRECTORY SOURCE<span class="token punctuation">..</span>. </code></pre><p>常用使用示例如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txt</span><span class="token function">cp</span> file.txt newfile.txt<span class="token comment" spellcheck="true"># 复制当前目录下的 file.txt 文件到 /tmp 目录下</span><span class="token function">cp</span> file.txt /tmp<span class="token comment" spellcheck="true"># 复制当前目录下的所有文件到 /tmp 目录下</span><span class="token function">cp</span> * /tmp<span class="token comment" spellcheck="true"># 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息</span><span class="token function">cp</span> -p filename /path/to/new/location/myfile<span class="token comment" spellcheck="true"># 使用 -R 或 -r 选项，恶意递归地复制一个目录</span><span class="token comment" spellcheck="true"># 即将一个目录及其下的所有文件和子目录都复制到另一个目录</span><span class="token function">cp</span> -R * /home/blinkfox/backup</code></pre><h3 id="4-ln-链接文件或目录"><a href="#4-ln-链接文件或目录" class="headerlink" title="4.ln - 链接文件或目录"></a>4.ln - 链接文件或目录</h3><p><code>ln</code>命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在目录 lib 下创建一个软链接 library.so，链接到 /home/blinkfox/src/library.so</span><span class="token function">ln</span> -s /home/blinkfox/src/library.so /home/blinkfox/lib<span class="token comment" spellcheck="true"># 创建目录的软链接</span><span class="token function">ln</span> -s /home/blinkfox/src <span class="token function">source</span></code></pre><h3 id="5-mv-移动文件或目录"><a href="#5-mv-移动文件或目录" class="headerlink" title="5. mv - 移动文件或目录"></a>5. mv - 移动文件或目录</h3><p><code>mv</code>命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，<code>mv</code>命令还可用于修改文件或目录的名字。</p><p>mv 命令的基本语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mv</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY</code></pre><p>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将当前目录下的文件 source.txt 移到目录 /tmp 下</span><span class="token function">mv</span> source.txt /tmp<span class="token comment" spellcheck="true"># 将目录 dir1、dir2 移到目录 dir_dist 下</span><span class="token function">mv</span> dir1 dir2 dir_dist<span class="token comment" spellcheck="true"># 将当前目录下的 old.txt 文件更名为 new.txt</span><span class="token function">mv</span> old.txt new.txt<span class="token comment" spellcheck="true"># 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息</span><span class="token function">mv</span> -i old.txt new.txt<span class="token comment" spellcheck="true"># 将当前目录下的所有文件移动到目录 /tmp 下</span><span class="token function">mv</span> * /tmp/<span class="token comment" spellcheck="true"># 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录</span><span class="token function">mv</span> -u dir1/* dir2/</code></pre><h3 id="6-rm-删除文件或目录"><a href="#6-rm-删除文件或目录" class="headerlink" title="6.rm - 删除文件或目录"></a>6.rm - 删除文件或目录</h3><p><code>rm</code>命令用于删除指定的文件和目录。其语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span><span class="token punctuation">..</span>. FILE<span class="token punctuation">..</span>.</code></pre><p><code>rm</code>的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除当前目录下的文件 file1.txt、file2.txt、file3.txt</span><span class="token function">rm</span> file1.txt file2.txt file3.txt<span class="token comment" spellcheck="true"># 删除当前目录下的所有文件</span><span class="token function">rm</span> *<span class="token comment" spellcheck="true"># 删除你当前帐号主目录下的 temp 目录中的所有文件</span><span class="token function">rm</span> ~/temp/*<span class="token comment" spellcheck="true"># 使用 -i 选项，可以在删除每个文件或目录前提示用户确认</span><span class="token function">rm</span> -i *<span class="token comment" spellcheck="true"># 删除当前目录下所有以".doc"结尾的文件</span><span class="token function">rm</span> *.doc<span class="token comment" spellcheck="true"># 删除当前目录下所有文件名中包含"movie"字符串的文件</span><span class="token function">rm</span> *movie*<span class="token comment" spellcheck="true"># 删除当前目录下所有以"a"开头的文件</span><span class="token function">rm</span> a*<span class="token comment" spellcheck="true"># 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件</span><span class="token function">rm</span> ???<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名有两个字符的所有文件</span><span class="token function">rm</span> *.??<span class="token comment" spellcheck="true"># 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>abc<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件名中包含 0~9 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名是字母 c 或 h 的所有文件</span><span class="token function">rm</span> *.<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除 /tmp 目录下的所有文件及其子目录</span><span class="token function">rm</span> -rf /tmp/*</code></pre><blockquote><p>-f 删除前不提示用户确认，并忽略不存在的文件<br>-r 递归地删除目录及其下的内容</p></blockquote><h3 id="7-ls-列出文件名和目录"><a href="#7-ls-列出文件名和目录" class="headerlink" title="7. ls - 列出文件名和目录"></a>7. ls - 列出文件名和目录</h3><p><code>ls</code>命令是<code>Linux</code>中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入<code>ls</code>命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。</p><p>以下便是<code>ls</code>命令及其选项的作用说明：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 仅列出当前目录下所有文件和目录</span><span class="token function">ls</span><span class="token comment" spellcheck="true"># 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等</span><span class="token function">ls</span> -l<span class="token comment" spellcheck="true"># 将文件大小显示符合人类阅读习惯的格式</span><span class="token function">ls</span> -lh<span class="token comment" spellcheck="true"># 将使用不同的特殊字符归类不同的文件类型</span><span class="token function">ls</span> -F<span class="token comment" spellcheck="true"># 以长列表格式列出某个目录的信息</span><span class="token function">ls</span> -ld /var/log<span class="token comment" spellcheck="true"># 将递归地列出子目录的内容</span><span class="token function">ls</span> -R /etc/sysconfig/<span class="token comment" spellcheck="true"># 以长列表格式按文件或目录的修改时间倒序地列出文件和目录</span><span class="token function">ls</span> -ltr<span class="token comment" spellcheck="true"># 以长列表格式按文件大小顺序列出文件和目录</span><span class="token function">ls</span> -ls<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -a<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -A输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组<span class="token function">ls</span> -n</code></pre><h3 id="8-cat-连接显示文件内容"><a href="#8-cat-连接显示文件内容" class="headerlink" title="8. cat - 连接显示文件内容"></a>8. cat - 连接显示文件内容</h3><p><code>cat</code> 命令也是Linux系统中最常用的命令之一。<code>cat</code>命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。</p><p><code>cat</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><p><code>cat</code>常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 cat 命令查看文件 /etc/group 的内容</span><span class="token function">cat</span> /etc/group<span class="token comment" spellcheck="true"># 显示多个文件的内容</span><span class="token function">cat</span> /etc/redhat-release /etc/issue<span class="token comment" spellcheck="true"># -n 选项，可以显示文件内容的行号</span><span class="token function">cat</span> -n /etc/fstab<span class="token comment" spellcheck="true"># -b 选项和 -n 选项类似，但只标识非空白行的行号</span><span class="token function">cat</span> -b /etc/fstab<span class="token comment" spellcheck="true"># -e 选项，将在每一行的结尾显示“$”字符</span><span class="token function">cat</span> -e /etc/fstab</code></pre><blockquote><p>当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。</p></blockquote><h3 id="9-less、more-分屏显示文件"><a href="#9-less、more-分屏显示文件" class="headerlink" title="9.less、more - 分屏显示文件"></a>9.less、more - 分屏显示文件</h3><p><code>more</code>命令在你使用小的xterm窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more命令是一个用于一次翻阅一整屏文件的过滤器。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看一个文件，自动清空屏幕并显示文件开头部分</span><span class="token function">more</span> /etc/inittab<span class="token comment" spellcheck="true"># 指定一次显示num行</span><span class="token function">more</span> -num /etc/inittab</code></pre><p>与<code>more</code>命令相比，我个人更喜欢<code>less</code>命令来查看文件。<code>less</code>命令与<code>more</code>命令类似，但<code>less</code>命令向前和向后翻页都支持，而且<code>less</code>命令不需要在查看前加载整个文件，即<code>less</code>命令查看文件更快速。</p><p><code>less</code>常用命令参数如下：</p><pre class=" language-bash"><code class="language-bash">-b  <span class="token operator">&lt;</span>缓冲区大小<span class="token operator">></span> 设置缓冲区的大小-e  当文件显示结束后，自动离开-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g  只标志最后搜索的关键词-i  忽略搜索时的大小写-m  显示类似more命令的百分比-N  显示每行的行号-o  <span class="token operator">&lt;</span>文件名<span class="token operator">></span> 将less 输出的内容在指定文件中保存起来-Q  不使用警告音-s  显示连续空行为一行-S  行过长时间将超出部分舍弃-x  <span class="token operator">&lt;</span>数字<span class="token operator">></span> 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n： 重复前一个搜索（与 / 或 ? 有关）N： 反向重复前一个搜索（与 / 或 ? 有关）b  向后翻一页d  向后翻半页h  显示帮助界面Q  退出less 命令u  向前滚动半页y  向前滚动一行空格键 滚动一行回车键 滚动一页<span class="token punctuation">[</span>pagedown<span class="token punctuation">]</span>： 向下翻动一页<span class="token punctuation">[</span>pageup<span class="token punctuation">]</span>：   向上翻动一页</code></pre><h3 id="10-head-显示文件头部"><a href="#10-head-显示文件头部" class="headerlink" title="10.head - 显示文件头部"></a>10.head - 显示文件头部</h3><p><code>head</code>命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前10行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的前N行：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的前5行</span><span class="token function">head</span> -n 5 /etc/inittab（或）head -5 /etc/inittab<span class="token comment" spellcheck="true"># 打印文件的前N个字节的数据</span><span class="token function">head</span> -c 10 /etc/inittab</code></pre><h3 id="11-tail-显示文件尾部"><a href="#11-tail-显示文件尾部" class="headerlink" title="11.tail - 显示文件尾部"></a>11.tail - 显示文件尾部</h3><p><code>tail</code>命令和<code>head</code>命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后10行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的最后N行：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的后10行</span><span class="token function">tail</span> -n 10 /etc/inittab<span class="token function">tail</span> -10 /etc/inittab<span class="token comment" spellcheck="true"># 即时打印文件中新写入的行</span><span class="token function">tail</span> -f /var/log/messages<span class="token comment" spellcheck="true"># --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件</span><span class="token function">tail</span> -f /tmp/debug.log --retry</code></pre><h3 id="12-file-查看文件类型"><a href="#12-file-查看文件类型" class="headerlink" title="12.file - 查看文件类型"></a>12.file - 查看文件类型</h3><p><code>file</code>命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看文件类型</span><span class="token function">file</span> /etc/inittab<span class="token comment" spellcheck="true"># 可以MIME类型的格式显示文件类型的信息</span><span class="token function">file</span> -i  /etc/inittab<span class="token comment" spellcheck="true"># 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示</span><span class="token function">file</span> -N *</code></pre><h3 id="13-wc-查看文件统计信息"><a href="#13-wc-查看文件统计信息" class="headerlink" title="13.wc - 查看文件统计信息"></a>13.wc - 查看文件统计信息</h3><p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">wc</span> filenameX Y Z /etc/inittab</code></pre><p>其中X表示行数，Y表示单词数，Z表示字节数，filename表示文件名。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -l选项，可以只统计文件的行数信息</span><span class="token function">wc</span> -l /etc/inittab<span class="token comment" spellcheck="true"># -w选项，可以只统计文件的单词数信息</span><span class="token function">wc</span> -w /etc/inittab<span class="token comment" spellcheck="true"># -c选项，可以只统计文件的字节数信息</span><span class="token function">wc</span> -c /etc/inittab<span class="token comment" spellcheck="true"># -L选项，可以只统计文件中最长的行的长度</span><span class="token function">wc</span> -L /etc/inittab</code></pre><h3 id="14-find-查找文件或目录"><a href="#14-find-查找文件或目录" class="headerlink" title="14.find - 查找文件或目录"></a>14.find - 查找文件或目录</h3><p><code>find</code>命令用于根据你指定的参数搜索和定位文件和目录的列表。<code>find</code>命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。</p><p><code>find</code>命令常用使用和说明如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查找指定目录下的某个文件</span><span class="token function">find</span> /etc/ -name inittab<span class="token comment" spellcheck="true"># 在当前目录下查找名称为 inittab 的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -name inittab<span class="token comment" spellcheck="true"># 在当前目录下，文件不区分大小写是example的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -iname example<span class="token comment" spellcheck="true"># 找出当前目录下所有以 sh 结尾的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -name <span class="token string">"*.sh"</span><span class="token comment" spellcheck="true"># 找出当前目录下，文件权限是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下，文件权限不是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下所有只读文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm /a+w<span class="token comment" spellcheck="true"># 找出你帐号主目录下的所有可执行文件</span><span class="token function">find</span> ~ -type f -perm /a+w<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的.log文件并将其删除：</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">"*.log"</span> -exec <span class="token function">rm</span> -f <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 找出当前目录下的所有空文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -empty<span class="token comment" spellcheck="true"># 找出当前目录下的所有空目录</span><span class="token function">find</span> <span class="token keyword">.</span> -type d -empty<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的所有隐藏文件</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">".*"</span><span class="token comment" spellcheck="true"># 找出 /tmp 目录下，所有者是 root 的文件和目录</span><span class="token function">find</span> /tmp/ -user root<span class="token comment" spellcheck="true"># 找出 /tmp 目录下，用户组是 developer 的文件和目录</span><span class="token function">find</span> /tmp/ -group root<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天前修改的文件</span><span class="token function">find</span> ~ -type f -mtime 3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime -3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30 -mtime -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内变更过的文件</span><span class="token function">find</span> /etc -type f -cmin -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内访问过的文件</span><span class="token function">find</span> /etc -type f -amin -60<span class="token comment" spellcheck="true"># 找出你账号主目录下，大小是50MB的所有文件</span><span class="token function">find</span> ~ -type f -size 50MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于50MB小于100MB的所有文件</span><span class="token function">find</span> ~ -type f -size +50MB -size -100MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于100MB的文件并将其删除</span><span class="token function">find</span> ~ -type f -size +100MB -exec <span class="token function">rm</span> -rf <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span></code></pre><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="1-sort-文本排序"><a href="#1-sort-文本排序" class="headerlink" title="1. sort - 文本排序"></a>1. sort - 文本排序</h3><p><code>sort</code>命令用于将文本文件的行排序。默认情况下，<code>sort</code>命令是按照字符串的字母顺序排序。</p><p>sort 的常用命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将文本内容按字母顺序排序</span><span class="token function">sort</span> example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，移除所有重复行后排序</span><span class="token function">sort</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -n 选项，将令数字按数值的大小排序</span><span class="token function">sort</span> -n example.txt<span class="token comment" spellcheck="true"># 使用 -r 选项，以倒序方式排序</span><span class="token function">sort</span> -n -r example.txt<span class="token comment" spellcheck="true"># 同时将 file1、file2 的内容排序</span><span class="token function">sort</span> file1 file2</code></pre><h3 id="2-uniq-文本去重"><a href="#2-uniq-文本去重" class="headerlink" title="2.uniq - 文本去重"></a>2.uniq - 文本去重</h3><p><code>uniq</code>命令用于移除或发现文件中重复的条目。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 它将移除文件中重复的行并显示单一行</span><span class="token function">uniq</span> example.txt<span class="token comment" spellcheck="true"># 可以统计重复行出现的次数</span><span class="token function">uniq</span> -c example.txt<span class="token comment" spellcheck="true"># 使用 -d 选项，只显示文件中有重复的行并只显示一次</span><span class="token function">uniq</span> -d example.txt<span class="token comment" spellcheck="true"># 使用 -D 选项，显示文件中所有重复的行</span><span class="token function">uniq</span> -D example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，只显示文件中不重复的行</span><span class="token function">uniq</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复</span><span class="token function">uniq</span> -w 3 example.txt<span class="token comment" spellcheck="true"># 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复</span><span class="token function">uniq</span> -s 3 example.txt<span class="token comment" spellcheck="true"># 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复</span><span class="token function">uniq</span> -f 1 example.txt</code></pre><h3 id="3-tr-替换或删除字符"><a href="#3-tr-替换或删除字符" class="headerlink" title="3.tr - 替换或删除字符"></a>3.tr - 替换或删除字符</h3><p><code>tr</code>命令主要用于删除文件中控制字符或进行字符转换。使用<code>tr</code>时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。<code>tr</code>刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。</p><p><code>tr</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">tr</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. SET1 <span class="token punctuation">[</span>SET2<span class="token punctuation">]</span></code></pre><p>常用命令示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 若要将大括号转换为小括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'()'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将大括号转换成方括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'\[]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将小写字符转换成大写，请输入：</span><span class="token function">tr</span> <span class="token string">'a-z'</span> <span class="token string">'A-Z'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要创建一个文件中的单词列表</span><span class="token function">tr</span> -cs <span class="token string">'[:lower:][:upper:]'</span> <span class="token string">'[\n*]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要从某个文件中删除所有空字符</span><span class="token function">tr</span> -d <span class="token string">'\0'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要用单独的换行替换每一序列的一个或多个换行，请输入：</span><span class="token function">tr</span> -s <span class="token string">'\n'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 要以单个“#”字符替换 &lt;space> 字符类中的每个字符序列</span><span class="token function">tr</span> -s <span class="token string">'[:space:]'</span> <span class="token string">'[#*]'</span></code></pre><h3 id="4-grep-查找字符串"><a href="#4-grep-查找字符串" class="headerlink" title="4.grep - 查找字符串"></a>4.grep - 查找字符串</h3><p><code>grep</code>命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，<code>grep</code>命令只显示匹配的行。</p><p><code>grep</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. PATTERN <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>-e PATTERN <span class="token operator">|</span> -f FILE<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># `grep`命令查找文件/etc/passwd 中帐号 blinkfox 的信息</span><span class="token function">grep</span> blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写</span><span class="token function">grep</span> -i blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -r 选项，可以递归搜索指定目录下的所有文件</span><span class="token function">grep</span> -r blinkfox /etc/<span class="token comment" spellcheck="true"># 使用 -w 选项，只匹配包含指定单词的行</span><span class="token function">grep</span> -w blinkfox /etc/<span class="token comment" spellcheck="true"># 使用 -c 选项，报告文件或文本中模式被匹配的次数</span><span class="token function">grep</span> -c blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -n 选项，显示每一个匹配的行的行号</span><span class="token function">grep</span> -n blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行</span><span class="token function">grep</span> -v blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出</span><span class="token function">grep</span> --color blinkfox /etc/passwd</code></pre><h3 id="5-diff-比较两个文件"><a href="#5-diff-比较两个文件" class="headerlink" title="5.diff - 比较两个文件"></a>5.diff - 比较两个文件</h3><p><code>diff</code>命令用于比较两个文件，并找出它们之间的不同。<code>diff</code>命令的语法如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">diff</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. from-file to-file</code></pre><p>常用使用方式如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 比较两个文件</span><span class="token function">diff</span> nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -w 选项，比较时忽略空格</span><span class="token function">diff</span> -w nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -y 选项，以并排的格式输出两个文件的比较结果</span><span class="token function">diff</span> -y nsswitch.conf nsswitch.conf.org使用 -c 选项，以上下对比的格式输出两个文件的比较结果<span class="token function">diff</span> -c nsswitch.conf nsswitch.conf.org</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/</a></li><li>[2] <a href="https://blinkfox.github.io/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/</a></li><li>[3] <a href="https://blinkfox.github.io/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/</a></li><li><a href="https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Dubbo-Spring-Cloud构建微服务项目</title>
      <link href="/2019/062356747.html"/>
      <url>/2019/062356747.html</url>
      
        <content type="html"><![CDATA[<p>Dubbo 生态体系已发生巨大变化，Dubbo Spring Cloud 作为 Spring Cloud Alibaba3 的最核心组件，完全地拥抱 Spring Cloud 技术栈，不但无缝地整合 Spring Cloud 注册中心，包括 Nacos4、Eureka5、Zookeeper6 以及 Consul7，而且完全地兼容 Spring Cloud Open Feign8 以及 @LoadBalanced RestTemplate，本文将讨论 Dubbo Spring Cloud 对 Spring Cloud 技术栈所带来的革命性变化。</p><h2 id="Dubbo-Spring-Cloud-简介"><a href="#Dubbo-Spring-Cloud-简介" class="headerlink" title="Dubbo Spring Cloud 简介"></a>Dubbo Spring Cloud 简介</h2><p>Dubbo Spring Cloud 基于 Dubbo Spring Boot 2.7.19 和 Spring Cloud 2.x 开发，无论开发人员是 Dubbo 用户还是 Spring Cloud 用户，都能轻松地驾驭，并以接近“零”成本的代价使应用向上迁移。Dubbo Spring Cloud 致力于简化 Cloud Native 开发成本，提高研发效能以及提升应用性能等目的。</p><p>由于 Spring 官方宣布 Spring Cloud Edgware(下文简称为 “E” 版) 将在 2019 年 8 月 1 号后停止维护13，因此，目前 Dubbo Spring Cloud 发布版本并未对 “E” 版提供支持，仅为 “F” 版 和 “G” 版开发，同时也建议和鼓励 Spring Cloud 用户更新至 “F” 版 或 “G” 版。</p><p>同时，Dubbo Spring Cloud 基于 Apache Dubbo Spring Boot 2.7.1 开发（最低 Java 版本为 1.8），提供完整的 Dubbo 注解驱动、外部化配置以及 Production-Ready 的特性，详情请参考：<a href="https://github.com/apache/incubator-dubbo-spring-boot-project" target="_blank" rel="noopener">dubbo-spring-boot-project</a></p><h2 id="Spring-Cloud-Alibaba-简介"><a href="#Spring-Cloud-Alibaba-简介" class="headerlink" title="Spring Cloud Alibaba 简介"></a>Spring Cloud Alibaba 简介</h2><p><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/README-zh.md" target="_blank" rel="noopener">Spring Cloud Alibaba</a> 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>参考文档 请查看 WIKI 。</p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>开发 Dubbo Spring Cloud 应用的方法与传统 Dubbo 或 Spring Cloud 应用类似，按照以下步骤就能完整地实现Dubbo 服务提供方和消费方的应用，完整的示例代码请访问一下资源：</p><ul><li>Dubbo 服务提供方应用 - <a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/spring-cloud-dubbo-server-sample" target="_blank" rel="noopener">spring-cloud-dubbo-server-sample</a></li><li>Dubbo 服务消费方应用 - <a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/spring-cloud-dubbo-client-sample" target="_blank" rel="noopener">spring-cloud-dubbo-client-sample</a></li></ul><h3 id="构建Spring-Cloud-Alibaba"><a href="#构建Spring-Cloud-Alibaba" class="headerlink" title="构建Spring Cloud Alibaba"></a>构建Spring Cloud Alibaba</h3><p>Spring Cloud 使用 Maven 来构建，最快的使用方式是将本项目 clone 到本地，然后执行以下命令：</p><pre><code>./mvnw install</code></pre><p>执行完毕后，项目将被安装到本地 Maven 仓库。</p><h3 id="开发-Dubbo-Spring-Cloud-应用"><a href="#开发-Dubbo-Spring-Cloud-应用" class="headerlink" title="开发 Dubbo Spring Cloud 应用"></a>开发 Dubbo Spring Cloud 应用</h3><p>使用IDEA导入示例应用（服务提供方及服务消费方），参照<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/README_CN.md" target="_blank" rel="noopener">Dubbo Spring Cloud 示例工程</a>进行操作。</p><h2 id="高阶示例"><a href="#高阶示例" class="headerlink" title="高阶示例"></a>高阶示例</h2><p>进一步了解 Dubbo Spring Cloud 使用细节，可参考官方 Samples：<a href="https://github.com/spring-clo.." target="_blank" rel="noopener">https://github.com/spring-clo..</a>.</p><p>其子模块说明如下：</p><ul><li>spring-cloud-dubbo-sample-api：API 模块，存放 Dubbo 服务接口和模型定义</li><li>spring-cloud-dubbo-provider-web-sample：Dubbo Spring Cloud 服务提供方示例（Web 应用）</li><li>spring-cloud-dubbo-provider-sample：Dubbo Spring Cloud 服务提供方示例（非 Web 应用）<br>vspring-cloud-dubbo-consumer-sample：Dubbo Spring Cloud 服务消费方示例</li><li>spring-cloud-dubbo-servlet-gateway-sample：Dubbo Spring Cloud Servlet 网关简易实现示例</li></ul><h2 id="Spring-Cloud-Alibaba-演示-Demo"><a href="#Spring-Cloud-Alibaba-演示-Demo" class="headerlink" title="Spring Cloud Alibaba 演示 Demo"></a>Spring Cloud Alibaba 演示 Demo</h2><p>Spring Cloud Alibaba 项目包含了一个子模块<code>spring-cloud-alibaba-examples</code>。此模块中提供了演示用的 example ，您可以阅读对应的 example 工程下的 readme 文档，根据里面的步骤来体验。</p><p>Example 列表：</p><ul><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-examples/sentinel-example/sentinel-core-example/readme-zh.md" target="_blank" rel="noopener">Sentinel Example</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md" target="_blank" rel="noopener">Nacos Config Example</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/readme-zh.md" target="_blank" rel="noopener">Nacos Discovery Example</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/rocketmq-example/readme-zh.md" target="_blank" rel="noopener">RocketMQ Example</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/fescar-example/readme-zh.md" target="_blank" rel="noopener">Fescar Example</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/oss-example/readme-zh.md" target="_blank" rel="noopener">Alibaba Cloud OSS Example</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/ans-example/ans-provider-example/readme-zh.md" target="_blank" rel="noopener">Alibaba Cloud ANS Example</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/acm-example/acm-local-example/readme-zh.md" target="_blank" rel="noopener">Alibaba Cloud ACM Example</a></li><li><a href="https://github.com/xiaolongzuo/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/schedulerx-example/schedulerx-simple-task-example/readme-zh.md" target="_blank" rel="noopener">Alibaba Cloud SchedulerX Example</a></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://segmentfault.com/a/1190000018991721" target="_blank" rel="noopener">Dubbo Spring Cloud 重塑微服务治理</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/README-zh.md" target="_blank" rel="noopener">Spring Cloud Alibaba</a></li><li><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/spring-cloud-alibaba-dubbo-examples/README_CN.md" target="_blank" rel="noopener">Dubbo Spring Cloud 示例工程</a> </li><li><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo中文文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 技术框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Spring boot + Cloud构建微服务项目</title>
      <link href="/2019/06187172.html"/>
      <url>/2019/06187172.html</url>
      
        <content type="html"><![CDATA[<p>基于Spring boot + Cloud构建微服务项目….</p><h2 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/helloworld_in_java/article/details/81519267" target="_blank" rel="noopener">十分钟带你掌握springboot微服务架构的基本使用</a></li><li><a href="https://github.com/qqxx6661/springcloud_for_noob" target="_blank" rel="noopener">SpringCloud新手入门实战教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术框架 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Pages+Jekyll+Minimal-Mistakes搭建个人博客</title>
      <link href="/2019/061036412.html"/>
      <url>/2019/061036412.html</url>
      
        <content type="html"><![CDATA[<p>Github pages官方推荐使用Jekyll生成静态网页，jekyll支持各种不同的主题。Minimal Mistakes 是一个灵活的两栏 Jekyll 简约风格主题，非常适合建立个人网站、博客和作品集。除了外观设置外，还支持文章评论、文章搜索、文章标签、文章分类等增强和定制。</p><h2 id="安装Github-pages-Jekyll"><a href="#安装Github-pages-Jekyll" class="headerlink" title="安装Github pages + Jekyll"></a>安装Github pages + Jekyll</h2><ol><li>在github上Fork<a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">mmistakes/minimal-mistakes</a></li><li>参考<a href="https://pages.github.com/" target="_blank" rel="noopener">github pages主页</a>, 设置Fork来的仓库名为 {username}.github.io/blog，并启用GitHub Pages</li><li>clone <code>{username}.github.io/blog</code> 到本地 $Github/lxl80/blog目录</li><li>本地安装jekyll并建立博客</li></ol><pre class=" language-bash"><code class="language-bash">gem <span class="token function">install</span> jekyll bundler//建立myblog并复制内容到根目录后删除myblog//如果直接在根目录建立，github在编译时可能会软连接错误，暂不知原因<span class="token function">cd</span> <span class="token variable">$Github</span>/lxl80/blog<span class="token function">rm</span> Gemfilejekyll new blogtemp<span class="token function">cd</span> blogtemp<span class="token function">cp</span> -r * <span class="token punctuation">..</span>/<span class="token function">cd</span> <span class="token punctuation">..</span><span class="token function">rm</span> -rf blogtemp</code></pre><h2 id="使用Minimal-Mistakes主题"><a href="#使用Minimal-Mistakes主题" class="headerlink" title="使用Minimal-Mistakes主题"></a>使用Minimal-Mistakes主题</h2><ol><li><p>修改Gemfile:<br>替换<code>gem &quot;jekyll&quot;</code> 为 <code>gem &quot;github-pages&quot;, group: :jekyll_plugins</code></p></li><li><p>修改_config.yml:<br>替换<code>theme</code>为<code>remote_theme: &quot;mmistakes/minimal-mistakes&quot;</code></p></li><li>运行<code>bundle update</code>更新主题</li><li>更改about.md和 _posts/0000-00-00-welcome-to-jekyll.markdown 中 layout为single。</li><li>在根目录下删除<code>index.md</code>，添加<code>index.html</code>，内容如下：</li></ol><pre class=" language-bash"><code class="language-bash">---layout: homeauthor_profile: <span class="token boolean">true</span>---</code></pre><ol><li>运行<code>bundle exec jekyll serve</code><br>如果碰到No GitHub API authentication could be found.的问题，参考<a href="https://link.jianshu.com/?t=http%3A%2F%2Fidratherbewriting.com%2Fdocumentation-theme-jekyll%2Fmydoc_install_jekyll_on_mac.html%23githuberror" target="_blank" rel="noopener">Resolve ERRORS</a>。</li><li>访问<code>127.0.0.1:4000</code>查看页面</li><li>push到github，访问commits页面查看部署状态。</li><li>访问<code>{username}.github.io</code>查看博客主页。</li></ol><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="修改Markdown-高亮配色"><a href="#修改Markdown-高亮配色" class="headerlink" title="修改Markdown 高亮配色"></a>修改Markdown 高亮配色</h3><p>Jekyll使用rough作为代码高亮工具，不同的皮肤设置(minimal_mistakes_skin)有不同的高亮配色，这里我使用contrast皮肤，但代码高亮希望将背景从深色改为白色。</p><ol><li>在gems目录/usr/local/lib/ruby/gems/2.4.0/gems/minimal-mistakes-jekyll-{version}下复制 _sass 到博客根目录。</li><li>修改_sass/minimal-mistakes/skins/_contrast.scss，替换 syntax highlighting (base16) 设置，参考<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmmistakes.github.io%2Fminimal-mistakes%2Fdocs%2Fstylesheets%2F%23colors" target="_blank" rel="noopener">Sylesheet/Color</a>。</li></ol><pre class=" language-bash"><code class="language-bash">/* solarized light syntax highlighting <span class="token punctuation">(</span>base16<span class="token punctuation">)</span> */<span class="token variable">$base00</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#fafafa !default;</span><span class="token variable">$base01</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#073642 !default;</span><span class="token variable">$base02</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#586e75 !default;</span><span class="token variable">$base03</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#657b83 !default;</span><span class="token variable">$base04</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#839496 !default;</span><span class="token variable">$base05</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#586e75 !default;</span><span class="token variable">$base06</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#eee8d5 !default;</span><span class="token variable">$base07</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#fdf6e3 !default;</span><span class="token variable">$base08</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#dc322f !default;</span><span class="token variable">$base09</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#cb4b16 !default;</span><span class="token variable">$base0a</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#b58900 !default;</span><span class="token variable">$base0b</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#859900 !default;</span><span class="token variable">$base0c</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#2aa198 !default;</span><span class="token variable">$base0d</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#268bd2 !default;</span><span class="token variable">$base0e</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#6c71c4 !default;</span><span class="token variable">$base0f</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#d33682 !default;</span></code></pre><ol><li>运行bundle update<h3 id="设置文字大小"><a href="#设置文字大小" class="headerlink" title="设置文字大小"></a>设置文字大小</h3>修改 _sass/minimal-mistakes/_variables.scss 对应font-size。</li></ol><h2 id="添加Disqus评论支持"><a href="#添加Disqus评论支持" class="headerlink" title="添加Disqus评论支持"></a>添加Disqus评论支持</h2><ol><li>参考I want to install disqus on my site注册，添加网站并得到shortname。</li><li>设置_config.yml</li></ol><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">comments</span><span class="token punctuation">:</span><span class="token key atrule">provider</span><span class="token punctuation">:</span> <span class="token string">"disqus"</span><span class="token key atrule">disqus</span><span class="token punctuation">:</span>    <span class="token key atrule">shortname</span><span class="token punctuation">:</span> <span class="token string">"your-disqus-shortname"</span>//<span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token key atrule">default</span><span class="token punctuation">:</span>    <span class="token key atrule">comments</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">Minimal Mistakes Jekyll theme</a></li><li><a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">Minimal Mistakes Quick-Start Guide</a></li><li><a href="https://jekyllrb.com/docs/" target="_blank" rel="noopener">Jekyll docs</a></li><li><a href="https://www.jianshu.com/p/d19eede28520" target="_blank" rel="noopener">Github pages + Minimal-Mistakes + Disqus建立个人博客记录</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Jekyll </tag>
            
            <tag> Minimal-Mistakes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric生产网络动态添加新组织</title>
      <link href="/2019/060423381.html"/>
      <url>/2019/060423381.html</url>
      
        <content type="html"><![CDATA[<p>一个商用的区块链网络，随着业务的发展变化，经常需要动态的新增/移除组织，以满足业务/安全等管理需要。本文在既有组织/节点的基础上，新增一个组织两个节点。</p><p>Fabric 是联盟链，一个 Channel 就好比一个子链，如果有新的机构需要加入，则必须得到联盟内的成员的认可。基于这样的场景，Fabric 在为 channel 新增 org 时，会涉及诸多的权限和证书操作。</p><h2 id="为-Channel-动态新增-Org-有以下几步："><a href="#为-Channel-动态新增-Org-有以下几步：" class="headerlink" title="为 Channel 动态新增 Org 有以下几步："></a>为 Channel 动态新增 Org 有以下几步：</h2><ol><li>为新 org 生成证书</li><li>为新 org 生成配置文件</li><li>生成和提交新 org 的配置<ol><li>peer channel fetch config 创建添加新 org 的配置交易，为网络新增 org</li><li>peer channel signconfigtx 为配置交易签名，需网络中 MAJORITY 的 org 都签名</li><li>peer channel update 提交签名后的配置交易至 orderer</li></ol></li><li>将新 org 添加入 channel<ol><li>启动新 org 集群，一般会有一个 cli 和多个 peer</li><li>peer channel fetch 于 cli 中从 orderer 中获取 channel 创世块</li><li>peer channel join 将新 org 下的 peer 加入 channel</li></ol></li><li>升级chaincode和背书策略<ol><li>peer chaincode install 为新 org 的 peer 安装 chaincode，于新 org 的 cli 中完成</li><li>peer chaincode install, 为其他 org 升级 chaincode，于原 org 的 cli 中完成</li><li>peer chaincode upgrade 升级背书策略，于原 org 的 cli 中完成<br>此文通过 fabric-samples 下的 first-network 样例为基础，在其区块链网络上，为通道 cfichannel 新增一个组织Cfec，CfecOrg 包含个 peer。</li></ol></li></ol><h2 id="一、新组织基础环境安装"><a href="#一、新组织基础环境安装" class="headerlink" title="一、新组织基础环境安装"></a>一、新组织基础环境安装</h2><h3 id="1、安装epel源"><a href="#1、安装epel源" class="headerlink" title="1、安装epel源"></a>1、安装epel源</h3><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> epel-release</code></pre><h3 id="2、安装依赖包"><a href="#2、安装依赖包" class="headerlink" title="2、安装依赖包"></a>2、安装依赖包</h3><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> snappy-devel.x86_64 zlib-devel.x86_64 bzip2-devel.x86_64 libtool-ltdl-devel.x86_64 libtool <span class="token function">git</span></code></pre><h3 id="3、安装docker"><a href="#3、安装docker" class="headerlink" title="3、安装docker"></a>3、安装docker</h3><pre class=" language-bash"><code class="language-bash">yum localinstall docker-ce-18.05.0.ce-3.el7.centos.x86_64.rpm <span class="token punctuation">(</span>安装包见附件<span class="token punctuation">)</span></code></pre><h3 id="4、安装docker-compose"><a href="#4、安装docker-compose" class="headerlink" title="4、安装docker-compose"></a>4、安装docker-compose</h3><pre class=" language-bash"><code class="language-bash">curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">></span> /usr/local/bin/docker-compose<span class="token function">chmod</span> +x /usr/local/bin/docker-compose</code></pre><h3 id="5、配置docker源（如果不配置拉取的是国外的镜像源）"><a href="#5、配置docker源（如果不配置拉取的是国外的镜像源）" class="headerlink" title="5、配置docker源（如果不配置拉取的是国外的镜像源）"></a>5、配置docker源（如果不配置拉取的是国外的镜像源）</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span> -d /etc/docker <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"docker dir Already exist"</span> <span class="token operator">||</span> <span class="token function">mkdir</span> /etc/docker<span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;</span>-<span class="token string">'EOF'</span><span class="token punctuation">{</span>  <span class="token string">"registry-mirrors"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"https://k03hynjl.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>EOF</code></pre><h3 id="6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下："><a href="#6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下：" class="headerlink" title="6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下："></a>6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下：</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">scp</span> -r cfichain@xxx.xxx.xxx.xxx:/home/cfichain/cfi_network <span class="token keyword">.</span><span class="token function">sudo</span> <span class="token function">scp</span> -r cfichain@xxx.xxx.xxx.xxx:/home/cfichain/bin <span class="token keyword">.</span></code></pre><h3 id="7、清理数据"><a href="#7、清理数据" class="headerlink" title="7、清理数据"></a>7、清理数据</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">rm</span> -fr /data/fabric/bin/channel-artifacts/*<span class="token function">rm</span> -fr /data/fabric/bin/crypto-config/*<span class="token function">rm</span> -fr /data/fabric/bin/chaindata/*/*/*<span class="token function">rm</span> -fr /data/fabric/bin/chainData/*/*/*</code></pre><h2 id="二、在联盟管理节点创建新channel"><a href="#二、在联盟管理节点创建新channel" class="headerlink" title="二、在联盟管理节点创建新channel"></a>二、在联盟管理节点创建新channel</h2><p>（MBFA组织任意节点上执行）</p><h3 id="1、创建交易文件"><a href="#1、创建交易文件" class="headerlink" title="1、创建交易文件"></a>1、创建交易文件</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span>:/data/fabric/bin<span class="token function">export</span> ORDERER_GENERAL_GENESISPROFILE<span class="token operator">=</span>MbfaGenesisconfigtxgen -profile MbfaChannel -outputCreateChannelTx ./channel-artifacts/sycfinchannel.tx -channelID syfinchannel</code></pre><h3 id="2、为新组织创建channel"><a href="#2、为新组织创建channel" class="headerlink" title="2、为新组织创建channel"></a>2、为新组织创建channel</h3><p>登录docker cli</p><pre><code>docker exec -it cli bash</code></pre><h3 id="3、发起创建channel交易"><a href="#3、发起创建channel交易" class="headerlink" title="3、发起创建channel交易"></a>3、发起创建channel交易</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> CORE_PEER_ADDRESS<span class="token operator">=</span>am.mbfa.fabric.mbfa.cn:7051<span class="token function">export</span> CORE_PEER_LOCALMSPID<span class="token operator">=</span>MbfaMSP<span class="token function">export</span> CORE_PEER_TLS_ENABLED<span class="token operator">=</span>false<span class="token function">export</span> CORE_PEER_TLS_CERT_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/server.crt<span class="token function">export</span> CORE_PEER_TLS_KEY_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/server.key<span class="token function">export</span> CORE_PEER_TLS_ROOTCERT_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/ca.crt<span class="token function">export</span> CORE_PEER_MSPCONFIGPATH<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/users/Admin@mbfa.fabric.mbfa.cn/msppeer channel create -o orderer0.fabric.mbfa.cn:7050 -c syfinchannel -f ./channel-artifacts/syfinchannel.tx</code></pre><h2 id="三、在新组织节点（ORG）生成证书"><a href="#三、在新组织节点（ORG）生成证书" class="headerlink" title="三、在新组织节点（ORG）生成证书"></a>三、在新组织节点（ORG）生成证书</h2><h3 id="1、生成证书命令"><a href="#1、生成证书命令" class="headerlink" title="1、生成证书命令"></a>1、生成证书命令</h3><p>(依据 crypto-config.yaml 生成，生成后的文件位于 org3-artifacts/crypto-config/ 下)：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> org3-artifacts./cryptogen generate --config<span class="token operator">=</span>./crypto-config.yaml --output ./crypto-config</code></pre><h3 id="2、crypto-config-yamll-文件如下："><a href="#2、crypto-config-yamll-文件如下：" class="headerlink" title="2、crypto-config.yamll 文件如下："></a>2、crypto-config.yamll 文件如下：</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">PeerOrgs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">Name</span><span class="token punctuation">:</span> SyOrg    <span class="token key atrule">Domain</span><span class="token punctuation">:</span> sy.fabric.mbfa.cn    <span class="token key atrule">CA</span><span class="token punctuation">:</span>        <span class="token key atrule">Country</span><span class="token punctuation">:</span> CN        <span class="token key atrule">Province</span><span class="token punctuation">:</span> Beijing        <span class="token key atrule">Locality</span><span class="token punctuation">:</span> Beijing    <span class="token key atrule">Specs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">Hostname</span><span class="token punctuation">:</span> peer    <span class="token key atrule">Users</span><span class="token punctuation">:</span>      <span class="token key atrule">Count</span><span class="token punctuation">:</span> <span class="token number">1</span></code></pre><h2 id="四、在新组织节点使用configtxgen生成SyOrg配置JSON文件"><a href="#四、在新组织节点使用configtxgen生成SyOrg配置JSON文件" class="headerlink" title="四、在新组织节点使用configtxgen生成SyOrg配置JSON文件"></a>四、在新组织节点使用configtxgen生成SyOrg配置JSON文件</h2><h3 id="1、生成组织配置文件"><a href="#1、生成组织配置文件" class="headerlink" title="1、生成组织配置文件"></a>1、生成组织配置文件</h3><p>configtx会在当前目录中寻找configtx.yaml配置文件并从中读取SyOrg相关配置。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> org3-artifacts./configtxgen -printOrg SyOrg -profile ./configtx.yaml <span class="token operator">></span> <span class="token punctuation">..</span>/channel-artifacts/syorg.json</code></pre><h3 id="2、configtx-yaml配置文件如下："><a href="#2、configtx-yaml配置文件如下：" class="headerlink" title="2、configtx.yaml配置文件如下："></a>2、configtx.yaml配置文件如下：</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">Organizations</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token important">&amp;SyOrg</span>        <span class="token key atrule">Name</span><span class="token punctuation">:</span> SyOrg        <span class="token key atrule">ID</span><span class="token punctuation">:</span> SyMSP        <span class="token key atrule">MSPDir</span><span class="token punctuation">:</span> crypto<span class="token punctuation">-</span>config/peerOrganizations/sy.fabric.mbfa.cn/msp        <span class="token key atrule">Policies</span><span class="token punctuation">:</span> <span class="token important">&amp;SyOrgPolicies</span>            <span class="token key atrule">Readers</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.member')"</span>            <span class="token key atrule">Writers</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.member')"</span>            <span class="token key atrule">Admins</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.admin')"</span>        <span class="token key atrule">AnchorPeers</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">Host</span><span class="token punctuation">:</span> peer.sy.fabric.mbfa.cn              <span class="token key atrule">Port</span><span class="token punctuation">:</span> <span class="token number">7051</span></code></pre><h2 id="五、配置新组织节点"><a href="#五、配置新组织节点" class="headerlink" title="五、配置新组织节点"></a>五、配置新组织节点</h2><p>修改cfi.yaml配置文件，需要检查环境差异。需要注意docker配置文件中对应的fabric链镜像版本号。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mv</span> org3-artifacts/crypto-config <span class="token keyword">.</span><span class="token function">cat</span> /etc/resolv.conf //此为正常配置     nameserver 127.0.0.11    options ndots:0//如果输出结果如下，需要在docker compose yaml模板增加环境变量，GODEBUG<span class="token operator">=</span>netdns<span class="token operator">=</span>go以强制使用pure Go resolver    nameserver 127.0.0.11    options timeout:2 attempts:3 rotate single-request-reopen ndots:0</code></pre><h2 id="六、既有联盟组织生成和提交新-org-的配置"><a href="#六、既有联盟组织生成和提交新-org-的配置" class="headerlink" title="六、既有联盟组织生成和提交新 org 的配置"></a>六、既有联盟组织生成和提交新 org 的配置</h2><p>通过 step 3~4，已经生成了 Sy 的证书和配置，但这仅仅是在本地文件系统，还未于区块链网络产生关联。为 channel 新加 Org，对 Fabric而言，是以一笔交易的形式提交的。因此要使得这笔交易能顺利完成，需要提交Sy的配置，到channel中，获得权限认证；然后于网络中发起更新的交易。</p><h3 id="1、登录联盟管理组织的cli"><a href="#1、登录联盟管理组织的cli" class="headerlink" title="1、登录联盟管理组织的cli"></a>1、登录联盟管理组织的cli</h3><pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span></code></pre><h3 id="2、安装-jq-工具"><a href="#2、安装-jq-工具" class="headerlink" title="2、安装 jq 工具"></a>2、安装 jq 工具</h3><p>jq 是 Linux 下命令行处理 JSON 的工具，可以对 JSON 进行过滤、格式化、修改等等操作。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> -y update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> jq</code></pre><h3 id="3、设置orderer-TLS-CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）"><a href="#3、设置orderer-TLS-CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）" class="headerlink" title="3、设置orderer TLS CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）"></a>3、设置orderer TLS CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem</code></pre><h3 id="4、获取准备加入channel的配置"><a href="#4、获取准备加入channel的配置" class="headerlink" title="4、获取准备加入channel的配置"></a>4、获取准备加入channel的配置</h3><pre class=" language-bash"><code class="language-bash">peer channel fetch config vtm_config_block.pb -o orderer0.fabric.mbfa.cn:7050 -c cfitestchannel --cafile <span class="token variable">$ORDERER_CA</span></code></pre><h3 id="5、联盟管理组织修改原channel配置文件-增加新组织"><a href="#5、联盟管理组织修改原channel配置文件-增加新组织" class="headerlink" title="5、联盟管理组织修改原channel配置文件, 增加新组织"></a>5、联盟管理组织修改原channel配置文件, 增加新组织</h3><h4 id="5-1、解码原有网络的配置文件"><a href="#5-1、解码原有网络的配置文件" class="headerlink" title="5.1、解码原有网络的配置文件"></a>5.1、解码原有网络的配置文件</h4><pre class=" language-bash"><code class="language-bash">将准备加入channel的pb格式配置信息转换成json格式configtxlator proto_decode --input vtm_config_block.pb --type common.Block <span class="token operator">|</span> jq .data.data<span class="token punctuation">[</span>0<span class="token punctuation">]</span>.payload.data.config <span class="token operator">></span> vtm_config.json</code></pre><p>生成文件内容类似set2中syorg.json内容</p><h4 id="5-2、使用jq工具，合并cfiorg-json与cfi-config-json-形成增加新组织后的完整json格式的配置更新文件。"><a href="#5-2、使用jq工具，合并cfiorg-json与cfi-config-json-形成增加新组织后的完整json格式的配置更新文件。" class="headerlink" title="5.2、使用jq工具，合并cfiorg.json与cfi_config.json, 形成增加新组织后的完整json格式的配置更新文件。"></a>5.2、使用jq工具，合并cfiorg.json与cfi_config.json, 形成增加新组织后的完整json格式的配置更新文件。</h4><pre class=" language-bash"><code class="language-bash">jq -s <span class="token string">'.[0] * {"channel_group":{"groups":{"Application":{"groups": {"VtmMSP":.[1]}}}}}'</span> vtm_config.json ./channel-artifacts/vtmorg.json <span class="token operator">></span> vtm_modified_config.json</code></pre><h4 id="5-3、将-config-json-和-modified-config-json-转为-protobuf-格式"><a href="#5-3、将-config-json-和-modified-config-json-转为-protobuf-格式" class="headerlink" title="5.3、将 config.json 和 modified_config.json 转为 protobuf 格式"></a>5.3、将 config.json 和 modified_config.json 转为 protobuf 格式</h4><pre class=" language-bash"><code class="language-bash">configtxlator proto_encode --input vtm_config.json --type common.Config <span class="token operator">></span> vtm_config.pbconfigtxlator proto_encode --input vtm_modified_config.json --type common.Config <span class="token operator">></span> vtm_modified_config.pb</code></pre><h4 id="5-4、根据-config-pb-和-modified-config-pb-计算出-org3-update-pb-，计算出增量更新内容。-类似于-diff-操作，但是针对-protobuf-格式，因此会多出好多操作。"><a href="#5-4、根据-config-pb-和-modified-config-pb-计算出-org3-update-pb-，计算出增量更新内容。-类似于-diff-操作，但是针对-protobuf-格式，因此会多出好多操作。" class="headerlink" title="5.4、根据 config.pb 和 modified_config.pb 计算出 org3_update.pb ，计算出增量更新内容。 (类似于 diff 操作，但是针对 protobuf 格式，因此会多出好多操作。)"></a>5.4、根据 config.pb 和 modified_config.pb 计算出 org3_update.pb ，计算出增量更新内容。 (类似于 diff 操作，但是针对 protobuf 格式，因此会多出好多操作。)</h4><pre class=" language-bash"><code class="language-bash">configtxlator compute_update --channel_id cfitestchannel --original vtm_config.pb --updated vtm_modified_config.pb <span class="token operator">></span> vtm_config_update.pb</code></pre><h4 id="5-5、解码-config-update-pb-为-json，然后用-jq-修改，然后在编码为-protobuf-格式，最终输出-syorg-update-in-envelope-pb"><a href="#5-5、解码-config-update-pb-为-json，然后用-jq-修改，然后在编码为-protobuf-格式，最终输出-syorg-update-in-envelope-pb" class="headerlink" title="5.5、解码 config_update.pb 为 json，然后用 jq 修改，然后在编码为 protobuf 格式，最终输出 syorg_update_in_envelope.pb"></a>5.5、解码 config_update.pb 为 json，然后用 jq 修改，然后在编码为 protobuf 格式，最终输出 syorg_update_in_envelope.pb</h4><pre class=" language-bash"><code class="language-bash">configtxlator proto_decode --input cfi_config_update.pb  --type common.ConfigUpdate <span class="token operator">></span> cfi_config_update.json<span class="token keyword">echo</span> <span class="token string">'{"payload":{"header":{"channel_header":{"channel_id":"cfitestchannel", "type":2}},"data":{"config_update":'</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> cfi_config_update.json<span class="token variable">)</span></span><span class="token string">'}}}'</span> <span class="token operator">|</span> jq <span class="token keyword">.</span> <span class="token operator">></span> cfi_config_update_in_envelope.jsonconfigtxlator proto_encode --input cfi_config_update_in_envelope.json --type common.Envelope <span class="token operator">></span> cfiorg_update_in_envelope.pb</code></pre><h3 id="6、为新组织配置签名"><a href="#6、为新组织配置签名" class="headerlink" title="6、为新组织配置签名"></a>6、为新组织配置签名</h3><p>为配置交易签名，需要 channel 中的大多数 Org 对其进行签名。<br>对于 mychannel 而言，已有了 org1，org2，因此新增 org3 时需要 org1、org2 都签名。<br>签名操作于 cli 中完成，需采用 Anchor Peer，可通过更改环境变量，改变签名者的身份。</p><h4 id="6-1、MBFA组织签名"><a href="#6-1、MBFA组织签名" class="headerlink" title="6.1、MBFA组织签名"></a>6.1、MBFA组织签名</h4><pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span>组织签名peer channel signconfigtx -f cfiorg_update_in_envelope.pb</code></pre><h4 id="6-2、登录MSC组织CLI继续签名"><a href="#6-2、登录MSC组织CLI继续签名" class="headerlink" title="6.2、登录MSC组织CLI继续签名"></a>6.2、登录MSC组织CLI继续签名</h4><p>（下载MBFA签名后的syorg_update_in_envelope.pb上传到msc组织CLI中，参照MBFA将syorg_update_in_envelope.pb进行签名。）</p><h3 id="7、提交签名后的配置交易至orderer"><a href="#7、提交签名后的配置交易至orderer" class="headerlink" title="7、提交签名后的配置交易至orderer"></a>7、提交签名后的配置交易至orderer</h3><p>注意：需要将syorg_update_in_envelope.pb注意上传到老组织，并逐一叠加签名。然后由生产此pb文件的组织提交更新。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pempeer channel update -f cfiorg_update_in_envelope.pb -c cfitestchannel -o orderer0.fabric.mbfa.cn:7050 --cafile <span class="token variable">$ORDERER_CA</span></code></pre><p>若成功入链，可以看到以下输出：</p><pre class=" language-bash"><code class="language-bash">2018-11-01 13:45:17.982 UTC <span class="token punctuation">[</span>kvledger<span class="token punctuation">]</span> CommitWithPvtData -<span class="token operator">></span> INFO 066 <span class="token punctuation">[</span>mbfastorechannel<span class="token punctuation">]</span> Committed block <span class="token punctuation">[</span>2<span class="token punctuation">]</span> with 1 transaction<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> 19ms <span class="token punctuation">(</span>state_validation<span class="token operator">=</span>0ms block_commit<span class="token operator">=</span>13ms state_commit<span class="token operator">=</span>3ms<span class="token punctuation">)</span></code></pre><p>输出显示，当前提交的块号是 6。块 0 是创世块；1~2 是一些初始化；3~4 是实例化与调用 chaincode ，更新配置。</p><h2 id="七、新组织申请添加到channel中"><a href="#七、新组织申请添加到channel中" class="headerlink" title="七、新组织申请添加到channel中"></a>七、新组织申请添加到channel中</h2><p>启动新组织节点，登录cli，加入到新channel：</p><pre class=" language-bash"><code class="language-bash">docker-compose -f cfi.yaml updocker <span class="token function">exec</span> -it cli <span class="token function">bash</span><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem<span class="token function">export</span> CHANNEL_NAME<span class="token operator">=</span>cfitestchannel//从 orderer 中获取 channel 创世块配置peer channel fetch 0 cfitestchannel.block -o orderer0.fabric.mbfa.cn:7050 -c <span class="token variable">$CHANNEL_NAME</span> --cafile <span class="token variable">$ORDERER_CA</span>peer channel <span class="token function">join</span> -b cfitestchannel.block</code></pre><h2 id="八、升级chaincode和背书策略"><a href="#八、升级chaincode和背书策略" class="headerlink" title="八、升级chaincode和背书策略"></a>八、升级chaincode和背书策略</h2><h3 id="1、为新组织安装-2-0-版本的-chaincode"><a href="#1、为新组织安装-2-0-版本的-chaincode" class="headerlink" title="1、为新组织安装 2.0 版本的 chaincode"></a>1、为新组织安装 2.0 版本的 chaincode</h3><p>其他组织的 chaincode 版本号是 1，新组织需要更新此版本的 chaincode，因此为新组织直接安装版本为 2 的 chaincode，省得先安装再升级。</p><pre class=" language-bash"><code class="language-bash">peer chaincode <span class="token function">install</span> -n cfistore -v 2 -p github.com/hyperledger/fabric/chaincode/go/cfistore</code></pre><h3 id="2、为其他组织安装-2-0-版本-chaincode"><a href="#2、为其他组织安装-2-0-版本-chaincode" class="headerlink" title="2、为其他组织安装 2.0 版本 chaincode"></a>2、为其他组织安装 2.0 版本 chaincode</h3><p>登录每个联盟原有组织 cli，逐一进行更新。</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span>peer chaincode <span class="token function">install</span> -n cfistore -v 2 -p github.com/hyperledger/fabric/chaincode/go/cfistorepeer chaincode upgrade -n cfistore -v 7 -c <span class="token string">'{"Args":["init"]}'</span> -o orderer0.fabric.mbfa.cn:7050 -C cfichannel -P <span class="token string">"OR ('MbfaMSP.member','MscMSP.member','CfecMSP.member','VteamMSP.member')"</span>// 查看channel中已经实例化的链码peer chaincode list --instantiated -C cfichannel</code></pre><h3 id="3、升级背书策略"><a href="#3、升级背书策略" class="headerlink" title="3、升级背书策略"></a>3、升级背书策略</h3><p>升级背书策略，-v 2 指明版本号，-P “AND (‘MbfaMSP.peer’,’CfecMSP.peer’)”指明新的背书策略（添加了 CfecOrg）。</p><pre class=" language-bash"><code class="language-bash"> peer chaincode upgrade -n cfistore -v 2 -c <span class="token string">'{"Args":["init"]}'</span> -o orderer0.fabric.mbfa.cn:7050 -C cfichannel -P <span class="token string">"AND ('MbfaMSP.peer','CfecMSP.peer')"</span></code></pre><p>peer chaincode upgrade 命令将为区块链新增一个块，可以在其他的 peer 的输出中查看。</p><p>查询链码</p><pre class=" language-bash"><code class="language-bash">peer chaincode query -C cfichannel -n cfistore -c <span class="token string">'{"Args":["query","a"]}'</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之桥接模式</title>
      <link href="/2018/121928602.html"/>
      <url>/2018/121928602.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>桥接模式</strong>(<code>Bridge Pattern</code>)：将抽象和实现解耦，使得两者可以独立地变化。它是一种对象结构型模式，又称为桥梁模式。</p></blockquote><h3 id="模式角色"><a href="#模式角色" class="headerlink" title="模式角色"></a>模式角色</h3><p>桥接模式包含如下角色：</p><ul><li><code>Abstraction</code>：抽象类角色</li><li><code>RefinedAbstraction</code>：扩充抽象类</li><li><code>Implementor</code>：实现化角色</li><li><code>ConcreteImplementor</code>：具体实现化角色的实现类</li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/java-design-bridge.jpg" alt="桥接模式UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，是实现化角色<code>Abstraction</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 实现化角色 Implementor. * * @author blinkfox on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后，是各个具体的实现化角色类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ConcreteImplementor1. * * @author blinkfox on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementor1</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor1 的业务逻辑 doSomething."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor1 的业务逻辑 doAnything."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ConcreteImplementor2. * * @author blinkfox on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementor2</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor2 的业务逻辑 doSomething."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor2 的业务逻辑 doAnything."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接下来，是抽象类角色<code>Abstraction</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>bridge<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象化角色 Abstraction. * * @author blinkfox on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义对实现化角色的引用. */</span>    <span class="token keyword">private</span> Implementor impl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param impl 实现类的实例     */</span>    <span class="token keyword">public</span> <span class="token function">Abstraction</span><span class="token punctuation">(</span>Implementor impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl <span class="token operator">=</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * impl 的 getter方法.     *     * @return impl     */</span>    <span class="token keyword">public</span> Implementor <span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自身的请求处理方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再次，是扩展的具体抽象化角色类<code>RefinedAbstraction</code>：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * RefinedAbstraction. * * @author blinkfox on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefinedAbstraction</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param impl 实现类的实例     */</span>    <span class="token keyword">public</span> <span class="token function">RefinedAbstraction</span><span class="token punctuation">(</span>Implementor impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 覆盖后的请求处理方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RefinedAbstraction 开始做业务处理."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Client. * * @author blinkfox on 2018-12-17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定义一个实现化角色和抽象化角色,并执行请求方法.</span>        Implementor impl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementor1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Abstraction abs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefinedAbstraction</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>        abs<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>理解桥接模式，重点需要理解如何将抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，使得二者可以独立地变化。</p><ul><li><strong>抽象化</strong>：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li><li><strong>实现化</strong>：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li><li><strong>脱耦</strong>：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。<strong>桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</strong></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>桥接模式的优点:</p><ul><li>分离抽象接口及其实现部分。</li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li><li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li><li>实现细节对客户透明，可以对用户隐藏实现细节。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>桥接模式的缺点:</p><ul><li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 </li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用桥接模式：</p><ul><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li><li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li><li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ul><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>一个Java桌面软件总是带有所在操作系统的视感(<code>LookAndFeel</code>)，如果一个Java软件是在Unix系统上开发的，那么开发人员看到的是<code>Motif</code>用户界面的视感；在Windows上面使用这个系统的用户看到的是Windows用户界面的视感；而一个在<code>Macintosh</code>上面使用的用户看到的则是<code>Macintosh</code>用户界面的视感，Java语言是通过所谓的Peer架构做到这一点的。Java为AWT中的每一个GUI构件都提供了一个Peer构件，在AWT中的Peer架构就使用了桥接模式。</p><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>适配器模式与桥接模式的联用:</p><p>桥接模式和适配器模式用于设计的不同阶段，<strong>桥接模式用于系统的初步设计</strong>，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式</strong>。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。</li><li>桥接模式包含如下四个角色：抽象类中定义了一个实现类接口类型的对象并可以维护该对象；扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</li><li>在桥接模式中，抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，它们可以沿着各自的维度独立变化。</li><li>桥接模式的主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节；其主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情。</li><li>桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。</li></ul><p>参考自：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html" target="_blank" rel="noopener">桥接模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之适配器模式</title>
      <link href="/2018/12121265.html"/>
      <url>/2018/12121265.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><ul><li>在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。</li><li>通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li><li>在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</li><li>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(<code>Adapter</code>)，它所包装的对象就是适配者(<code>Adaptee</code>)，即被适配的类。</li><li>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>适配器模式</strong>(<code>Adapter Pattern</code>) ：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(<code>Wrapper</code>)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。适配器模式是一种<strong>结构型模式</strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><p>适配器模式包含如下角色：</p><ul><li><code>Target</code>：目标抽象类</li><li><code>Adapter</code>：适配器类</li><li><code>Adaptee</code>：适配者类</li><li><code>Client</code>：客户类</li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/java-design-adapter.jpg" alt="适配器模式UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，是目标角色接口和具体目标实现类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Target 目标角色类. * * @author blinkfox on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 目标角色自己的方法.     */</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的目标角色实现类. * * @author blinkfox on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteTarget</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 目标角色自己的方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, I'm concrete target method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其次，是适配者类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配者类. * * @author blinkfox on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这是原有的业务逻辑方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, I'm Adaptee method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是适配器角色类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配器类. * * @author blinkfox on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token keyword">extends</span> <span class="token class-name">Adaptee</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 适配了目标角色自己的方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配器适配了目标角色方法."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 客户端场景类. * * @author blinkfox on 2018-12-11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 原有业务逻辑.</span>        Target target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 增加了适配器角色后的业务逻辑.</span>        Target adaptTarget <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        adaptTarget<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用适配器模式：</p><ul><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</li><li>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li><li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li><li>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。</li><li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li></ul><p>参考自：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html" target="_blank" rel="noopener">适配器模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则</title>
      <link href="/2018/112425424.html"/>
      <url>/2018/112425424.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据<code>Robert Martin</code>的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、通用设计原则"><a href="#二、通用设计原则" class="headerlink" title="二、通用设计原则"></a>二、通用设计原则</h2><h3 id="1-KISS"><a href="#1-KISS" class="headerlink" title="1. KISS"></a>1. KISS</h3><p>所谓<code>KISS</code>原则，即：<code>Keep It Simple,Stupid</code>，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><blockquote><p>Everything should be made as simple as possible, but not simpler. - Albert Einstein</p></blockquote><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><blockquote><p><strong>我的理解</strong>：保持简单但不能掩盖软件丰富的内涵。即<strong>简约而不简单</strong>！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</p></blockquote><h3 id="2-DRY"><a href="#2-DRY" class="headerlink" title="2. DRY"></a>2. DRY</h3><p>所谓<code>DRY</code>原则，即：<code>Don&#39;t Repeat Yourself</code>，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。<code>DRY</code>并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三</strong>法则。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><blockquote><p><strong>我的理解</strong>：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是<strong>立即行动</strong>去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</p></blockquote><h3 id="3-Maximize-Cohesion，-Minimize-Coupling"><a href="#3-Maximize-Cohesion，-Minimize-Coupling" class="headerlink" title="3. Maximize Cohesion， Minimize Coupling"></a>3. Maximize Cohesion， Minimize Coupling</h3><p>所谓<code>Maximize Cohesion,Minimize Coupling</code>原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低。</strong></p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用<code>public</code>，多用<code>private</code>关键字，</li><li>多用设计模式，比如采用<code>MVC</code>的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-SOC"><a href="#4-SOC" class="headerlink" title="4. SOC"></a>4. SOC</h3><p>所谓<code>SOC</code>原则，即：<strong>关注点分离</strong>（<code>Separation of Concerns</code>）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成。</strong>关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p><code>MVC</code>就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。<code>MVC</code>的基本结构：</p><ul><li><code>Model</code>层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li><code>View</code>是应用程序的显示层，通常是依据模型的数据而建立。</li><li><code>Controller</code>是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（<code>Model</code>层）发送数据。</li></ul><p><code>MVC</code>的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><blockquote><p>好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD中文版》)</p></blockquote><h4 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h4><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块1、模块2、模块3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（<code>log</code>），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联<code>customer</code>类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做<code>CreateNewCustomer()</code>，那么<code>CreateNewCustomer()</code>的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如<code>Spring</code>、<code>Guice</code>等等，这些帮助我们做依赖反转，从而倒置依赖关系。</li></ul><h3 id="5-YAGNI"><a href="#5-YAGNI" class="headerlink" title="5. YAGNI"></a>5. YAGNI</h3><p>所谓<code>YAGNI</code>原则，即：<code>You Ain’t Gonna Need It</code>，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。<code>YAGNI</code>很像<code>KISS</code>原则，因为它也是致力于构建简单的方案。然而，<code>KISS</code>是通过尽可能容易的完成某件事情来实现精简方案；但<code>YAGNI</code>是通过根本就不实现它来达到精简。<code>YAGNI</code>的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><blockquote><p>只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries</p></blockquote><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><blockquote><p><strong>我的理解</strong>：YAGNI 原则，本质上是告诫我们<strong>写代码不要画蛇添足，否则就会弄巧成拙了</strong>。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</p></blockquote><h3 id="6-Boy-Scout-Rule"><a href="#6-Boy-Scout-Rule" class="headerlink" title="6. Boy-Scout Rule"></a>6. Boy-Scout Rule</h3><p><code>Boy-Scout Rule</code>，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(<code>Always leave the campground cleaner than you found it</code>)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要<strong>始终保持代码整洁</strong>。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>关于童子军规则中所提倡的<strong>对代码坏味道的尽早修复</strong>，我也想起来了我们所熟知的“<strong>破窗效应</strong>”和“<strong>讳疾忌医</strong>”的典故：</p><h4 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h4><blockquote><p>如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗。——政治学家威尔逊和犯罪学家凯琳提出的“破窗效应”理论</p></blockquote><ul><li>“环境早就脏了，我扔的这点儿垃圾根本起不到关键性作用。”</li><li>“这个代码以前的其他人也都是这样写的。”</li><li>“反正也不是只有我才这么写代码的。”</li></ul><p>不少人会像上面这样辩解自己的过错。其实，这些说法根本站不住脚，错了就是错了，影响的大小并不能改变行为错误的本质，别人的错误更不会是证明你无错的理由。任何一种不良现象的存在，都有可能传递一种错误信息。进而导致更坏的后果，正所谓“<strong>千里之堤，溃于蚁穴</strong>”、<strong>勿以善小而不为，勿以恶小而为之</strong>。</p><h4 id="讳疾忌医的典故"><a href="#讳疾忌医的典故" class="headerlink" title="讳疾忌医的典故"></a>讳疾忌医的典故</h4><p><img src="https://pic.lixl.cn/2019/20200113171614.png/w1280" alt></p><p>《扁鹊见蔡桓公》的故事，我们从小就学习了，告诉我们不能盲目相信自己，不能讳疾忌医。但想想我们自己代码的坏味道和bug，也是如出一辙。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><blockquote><p>所以，请记住童子军规则对我们的启示：<strong>始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治</strong>。</p></blockquote><h3 id="其他原则："><a href="#其他原则：" class="headerlink" title="其他原则："></a>其他原则：</h3><ul><li><strong>避免过早优化</strong>（<code>Avoid Premature Optimization</code>）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“<strong>过早的优化是一切罪恶之源</strong>。”——Donald Knuth</li><li><strong>最小惊讶原则</strong>(<code>Principle of least astonishment</code>): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li><strong>代码重用原则</strong>（<code>Code Reuse is Good</code>）: 重用代码能提高代码的可读性，缩短开发时间。</li><li><strong>别让我思考</strong>(<code>Don’t Make Me Think</code>): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li><strong>为维护者写代码</strong>(<code>Write Code for the Maintainer</code>): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li><strong>正交原则(Orthogonality)</strong>: 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：<code>CSS</code>)。</li><li><strong>做最简单的事儿就让代码可运行</strong>（<code>Do the simplest thing that could possibly work</code>）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li><strong>隐藏实现细节</strong>（<code>Hide Implementation Details</code>）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li><strong>科里定律</strong>(<code>Curly&#39;s Law</code>): 是为任何特定的代码选择一个明确定义的目标：<strong>只做一件事</strong>。</li><li><strong>墨菲定律</strong>（<code>Murphy&#39;s Law</code>）:根本内容是：<strong>如果事情有变坏的可能，不管这种可能性有多小，它总会发生</strong>。主要内容如下：<ul><li>任何事都没有表面看起来那么简单；</li><li>所有的事都会比你预计的时间长；</li><li>会出错的事总会出错；</li><li>如果你担心某种情况发生，那么它就更有可能发生。</li></ul></li></ul><h2 id="三、面向对象设计原则"><a href="#三、面向对象设计原则" class="headerlink" title="三、面向对象设计原则"></a>三、面向对象设计原则</h2><h3 id="1-SRP"><a href="#1-SRP" class="headerlink" title="1. SRP"></a>1. SRP</h3><p>所谓<code>SRP</code>原则，即：<code>Single Responsibility Principle</code>，<strong>单一职责原则</strong>。原始定义如下：</p><blockquote><p>There should never be more than one reason for a class to change.(<strong>只有一个引起类改变的原因</strong>)</p></blockquote><p>在面向对象编程领域中，单一职责原则（<code>Single responsibility principle</code>）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是<strong>解耦</strong>和<strong>增强内聚性</strong>。</p><h4 id="单一职责的好处："><a href="#单一职责的好处：" class="headerlink" title="单一职责的好处："></a>单一职责的好处：</h4><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义;</li><li>可读性提高，复杂性降低，可维护性提高;</li><li>变更引起的风险降低。</li></ul><h4 id="单一职责原则的注意点："><a href="#单一职责原则的注意点：" class="headerlink" title="单一职责原则的注意点："></a>单一职责原则的注意点：</h4><ul><li>单一职责最难划分的是<strong>职责</strong>。</li><li>单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。</li><li>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。</li></ul><h3 id="2-LSP"><a href="#2-LSP" class="headerlink" title="2. LSP"></a>2. LSP</h3><p>所谓<code>LSP</code>原则，即：<code>Liskov Substitution principle</code>，<strong>里氏替换原则</strong>。原始定义如下：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>）</p></blockquote><p>更通俗的定义即为：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。里氏替换原则包含了一下4层含义：</p><ul><li>子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了<code>LSP</code>原则。</li><li>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。</li><li>覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li><li>覆盖或实现父类的方法时输出结果可以被缩小。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>提高代码的重用性，子类拥有父类的方法和属性；</li><li>提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；</li><li>增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。</li></ul><h3 id="3-ISP"><a href="#3-ISP" class="headerlink" title="3. ISP"></a>3. ISP</h3><p>所谓<code>ISP</code>原则，即：<code>Interface Segregation Principle</code>，<strong>接口隔离原则</strong>。原始定义如下：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)</p></blockquote><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)</p></blockquote><p>即，<strong>接口尽量细化，接口中的方法尽量少</strong>。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="4-OCP"><a href="#4-OCP" class="headerlink" title="4. OCP"></a>4. OCP</h3><p>所谓<code>OCP</code>原则，即：<code>Open Closed Principle</code>，<strong>开闭原则</strong>。原始定义如下：</p><blockquote><p>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭)</p></blockquote><p>开闭原则（<code>OCP</code>）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：<strong>对扩展开放，对修改关闭</strong>。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。</p><p>软件系统中包含的各种组件，例如模块（<code>Module</code>）、类（<code>Class</code>）以及功能（<code>Function</code>）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。</p><p>实现开闭原则的关键就在于“<strong>抽象</strong>”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。</p><p>开闭原则的好处：</p><ul><li>可复用性好;</li><li>可维护性好。</li></ul><h3 id="5-DIP"><a href="#5-DIP" class="headerlink" title="5. DIP"></a>5. DIP</h3><p>所谓<code>DIP</code>原则，即：<code>Dependency Inversion Principle</code>，<strong>依赖倒置原则</strong>。原始定义如下：</p><blockquote><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.(<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong>)</p></blockquote><blockquote><p>Abstractions should not depend on details. Details should depend on abstractions.(<strong>抽象不应该依赖细节；细节应该依赖抽象</strong>)</p></blockquote><p>面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><p>依赖倒置原则主要有以下三层含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）；</li><li>抽象不应该依赖细节（具体实现）；  </li><li>细节（具体实现）应该依赖抽象。</li></ul><p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<strong>依赖倒置原则的核心思想就是面向接口编程</strong>。</p><h3 id="6-LOD-LKP"><a href="#6-LOD-LKP" class="headerlink" title="6. LOD | LKP"></a>6. LOD | LKP</h3><p>所谓<code>LOD</code>原则，即：<code>Law of Demeter</code>，<strong>迪米特法则</strong>，又叫<strong>最少知识原则</strong>（<code>Least Knowledge Principle</code>，简写<code>LKP</code>），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下：</p><blockquote><p>talk only to your immediate friends.(<strong>只与直接的朋友通信</strong>)</p></blockquote><p><strong>迪米特法则的初衷在于降低类之间的耦合</strong>。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。</p><h3 id="7-CRP"><a href="#7-CRP" class="headerlink" title="7. CRP"></a>7. CRP</h3><p>所谓<code>CRP</code>原则，即：<code>Composite Reuse Principle</code>，<strong>组合复用原则</strong>。</p><p>组合复用原则的核心思想是：<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p><p>继承的缺点主要有以下几点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的<code>getter/setter</code>方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。</p><p>组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><p>使用继承时必须满足<code>Is-A</code>的关系是才能使用继承，而组合却是一种<code>Has-A</code>的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把<code>Has-A</code>当成了<code>Is-A</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计原则 </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解的理解和应用</title>
      <link href="/2018/110822033.html"/>
      <url>/2018/110822033.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1. 什么是注解"></a>1. 什么是注解</h3><p>注解(<code>Annotation</code>)是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符，它是一种由JSR-175标准选择用来描述元数据的一种工具。Java从<code>Java5</code>开始引入了注解。在注解出现之前，程序的元数据只是通过java注释和javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。</p><p>比如，下面这段代码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"This is String."</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的代码中，我重写了<code>toString()</code>方法并使用了<code>@Override</code>注解。但是，即使我们不使用<code>@Override</code>注解标记代码，程序也能够正常执行。那么，该注解表示什么？这么写有什么好处吗？事实上，<code>@Override</code>告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。如果我不小心拼写错误，例如将<code>toString()</code>写成了<code>toStrring(){double r}</code>，而且我也没有使用<code>@Override</code>注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。</p><h3 id="2-为什么要引入注解"><a href="#2-为什么要引入注解" class="headerlink" title="2. 为什么要引入注解"></a>2. 为什么要引入注解</h3><p>使用注解之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。</p><p>假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用注解会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p><p>另一个很重要的因素是注解定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记接口，注释，<code>transient</code>关键字等等。每个程序员按照自己的方式定义元数据，而不像注解这种标准的方式。</p><p>目前，许多框架将<code>XML</code>和<code>Annotation</code>两种方式结合使用，平衡两者之间的利弊。</p><h2 id="Java基本注解"><a href="#Java基本注解" class="headerlink" title="Java基本注解"></a>Java基本注解</h2><p>在<code>java.lang</code>包下，JAVA提供了5个基本注解。</p><h3 id="1-Override"><a href="#1-Override" class="headerlink" title="1. @Override"></a>1. @Override</h3><p><code>@Override</code>用于标注重写了父类的方法。对于子类中被<code>@Override</code>修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。<code>@Override</code>只能作用于方法，不能作用于其他程序元素。</p><h3 id="2-Deprecated"><a href="#2-Deprecated" class="headerlink" title="2. @Deprecated"></a>2. @Deprecated</h3><p><code>@Deprecated</code>用于表示某个程序元素（类、方法等）已过时。如果使用了被<code>@Deprecated</code>修饰的类或方法等，编译器会发出警告。</p><h3 id="3-SuppressWarnings"><a href="#3-SuppressWarnings" class="headerlink" title="3. @SuppressWarnings"></a>3. @SuppressWarnings</h3><p><code>@SuppressWarnings</code>用于抑制编译器的警告。指示被<code>@SuppressWarnings</code>修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法）取消显示指定的编译器警告。例如，常见的<code>@SuppressWarnings（value=&quot;unchecked&quot;）</code>。</p><p><code>SuppressWarnings</code>注解的常见参数值主要有以下几种：</p><ul><li><code>deprecation</code>：使用了不赞成使用的类或方法时的警告(使用<code>@Deprecated</code>使得编译器产生的警告)；</li><li><code>unchecked</code>：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告</li><li><code>fallthrough</code>：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</li><li><code>path</code>：在类路径、源文件路径等中有不存在的路径时的警告;</li><li><code>serial</code>：当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li><li><code>finally</code>：任何 finally 子句不能正常完成时的警告;</li><li><code>all</code>：关于以上所有情况的警告。</li></ul><h3 id="4-SafeVarargs"><a href="#4-SafeVarargs" class="headerlink" title="4. @SafeVarargs"></a>4. @SafeVarargs</h3><p><code>@SafeVarargs</code>是JDK 7 专门为抑制<strong>堆污染</strong>警告提供的。</p><h3 id="5-FunctionalInterface"><a href="#5-FunctionalInterface" class="headerlink" title="5. @FunctionalInterface"></a>5. @FunctionalInterface</h3><p><code>@FunctionalInterface</code>是Java8中新增的函数式接口。Java8规定：如果接口中只有一个抽象方法（可以包含多个默认方法或多个<code>static</code>方法），该接口称为函数式接口。如以下代码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Fun</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"foo类方法"</span><span class="token punctuation">)</span>；    <span class="token punctuation">}</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"bar默认方法"</span><span class="token punctuation">)</span>；    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//只定义了一个抽象方法</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：如在上面的接口中再加一个抽象方法<code>abc()</code>，则会编译出错。</p></blockquote><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p><strong>元注解(<code>meta-annotation</code>)</strong>是指注解的注解。Java5定义了5个标准的元注解类型，它们被用来提供对其它注解的类型作说明。接下来介绍这五个元注解。</p><h3 id="1-Retention"><a href="#1-Retention" class="headerlink" title="1. @Retention"></a>1. @Retention</h3><p><code>@Retention</code>指明了该注解被保留的时间长短。包含一个名为<code>value</code>的成员变量，该value成员变量是<code>RetentionPolicy</code>枚举类型。使用<code>@Retention</code>时，必须为其value指定值。value成员变量的值只能是如下3个：</p><ul><li><code>SOURCE</code>：只保留在源代码中，编译器编译时，直接丢弃这种注解，不记录在<code>.class</code>文件中。</li><li><code>CLASS</code>：编译器把注解记录在<code>class</code>文件中。当运行Java程序时，JVM中不可获取该注解信息，这是默认值。</li><li><code>RUNTIME</code>：编译器把注解记录在<code>class</code>文件中。当运行Java程序时，JVM可获取该注解信息，程序可以通过反射获取该注解的信息。</li></ul><h3 id="2-Target"><a href="#2-Target" class="headerlink" title="2. @Target"></a>2. @Target</h3><p><code>@Target</code>指定注解用于修饰哪些程序元素。<code>@Target</code>也包含一个名为<code>value</code>的成员变量，该value成员变量类型为<code>ElementType[]</code>，<code>ElementType</code>也为枚举类型，值有如下几个：</p><ul><li><code>TYPE</code>：修饰类、接口或枚举类型</li><li><code>FIELD</code>：修饰成员变量（包括枚举常量）</li><li><code>METHOD</code>：修饰方法</li><li><code>PARAMETER</code>：修饰参数</li><li><code>CONSTRUCTOR</code>：修饰构造器</li><li><code>LOCAL_VARIABLE</code>：修饰局部变量</li><li><code>ANNOTATION_TYPE</code>：修饰注解</li><li><code>PACKAGE</code>：修饰包</li><li><code>TYPE_PARAMETER</code>：Java8新增，修饰类型参数。</li><li><code>TYPE_USE</code>：Java8新增，可以在任何类型上使用</li></ul><h4 id="类型注解（Java8新增）"><a href="#类型注解（Java8新增）" class="headerlink" title="类型注解（Java8新增）"></a>类型注解（Java8新增）</h4><p>在 Java8 之前的版本中，只能允许在声明式前使用注解。而在 Java8 版本中，注解可以被用在任何使用 Type 的地方，例如：初始化对象时 (new)，对象类型转化时，使用 implements 表达式时，或者使用 throws 表达式时。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始化对象时</span>String myString <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NotNull</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对象类型转化时</span>myString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> String<span class="token punctuation">)</span> str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用 implements 表达式时</span><span class="token keyword">class</span> <span class="token class-name">MyList</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token annotation punctuation">@ReadOnly</span> List<span class="token operator">&lt;</span><span class="token annotation punctuation">@ReadOnly</span> T<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//使用 throws 表达式时</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">validateValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@Critical</span> ValidationFailedException<span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>定义一个类型的方法与普通的注解类似，只需要指定<code>Target</code>为<code>ElementType.TYPE_PARAMETER</code>或者<code>ElementType.TYPE_USE</code>，或者同时指定这两个<code>Target</code>。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE_PARAMETER<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span>  @<span class="token keyword">interface</span> <span class="token class-name">MyAnnotation</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p><code>ElementType.TYPE_PARAMETER</code>表示这个注解可以用在 Type 的声明式前，而<code>ElementType.TYPE_USE</code>表示这个注解可以用在所有使用 Type 的地方（如：泛型，类型转换等）</p><p>与 Java 8 之前的注解类似的是，类型也可以通过设置 Retention 在编译后保留在 class 文件中（RetentionPolicy.CLASS）或者运行时可访问（RetentionPolicy.RUNTIME）。但是与之前不同的是，类型注解有两个新的特性：在本地变量上的注解可以保留在<code>class</code>文件中，以及泛型类型可以被保留甚至在运行时被访问。</p><p>虽然类型可以保留在 class 文件中，但是它并不会改变程序代码本身的行为。例如在一个方法前加上注解，调用此方法返回的结果和不加注解的时候一致。</p><p>Java8 通过引入类型，使得开发者可以在更多的地方使用注解，从而能够更全面地对代码进行分析以及进行更强的类型检查。</p><h3 id="3-Inherited"><a href="#3-Inherited" class="headerlink" title="3. @Inherited"></a>3. @Inherited</h3><p><code>@Inherited</code>指定注解具有继承性。如果某个类使用了<code>@xxx</code>注解（定义该注解时使用了<code>@Inherited</code>修饰）修饰，则其子类将自动被<code>@xxx</code>修饰。</p><h3 id="4-Documented"><a href="#4-Documented" class="headerlink" title="4. @Documented"></a>4. @Documented</h3><p>如果定义注解A时，使用了<code>@Documented</code>修饰定义，则在用Javadoc命令生成API文档后，所有使用注解A修饰的程序元素，将会包含注解A的说明。</p><h3 id="5-Repeatable（Java8新增）"><a href="#5-Repeatable（Java8新增）" class="headerlink" title="5. @Repeatable（Java8新增）"></a>5. @Repeatable（Java8新增）</h3><p><code>@Repeatable</code>表示可重复注解。在实际应用中，可能会出现需要对同一个声明式或者类型加上相同的注解（包含不同的属性值）的情况。例如系统中除了管理员之外，还添加了超级管理员这一权限，对于某些只能由这两种角色调用的特定方法，可以使用可重复注解。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Access</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"SuperAdministrator"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Access</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"Administrator"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>Java8之前版本的 JDK 并不允许开发者在同一个声明式前加注同样的注解，（即使属性值不同）这样的代码在编译过程中会提示错误。而 Java8 解除了这一限制，开发者可以根据各自系统中的实际需求在所有可以使用注解的地方使用可重复注解。</p><p>由于兼容性的缘故，可重复注解并不是所有新定义的注解的默认特性，需要开发者根据自己的需求决定新定义的注解是否可以重复注解。Java 编译器会自动把可重复注解储存到指定的注解容器中。而为了触发编译器进行这一操作，开发者需要进行以下的定义：</p><p>首先，在需要重复标注特性的注解前加上<code>@Repeatable</code>标签，示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>AccessContainer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Access</span> <span class="token punctuation">{</span>    String <span class="token function">role</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>@Repeatable</code>标签后括号中的值即为指定的注解容器的类型。在这个例子中，注解容器的类型是<code>AccessContainer</code>，Java 编译器会把重复的 Access 对象保存在 AccessContainer 中。</p><p>AccessContainer 中必须定义返回数组类型的 value 方法。数组中元素的类型必须为对应的可重复注解类型。具体示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">AccessContainer</span> <span class="token punctuation">{</span>    Access<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以通过 Java 的反射机制获取注解的 Annotation。一种方式是通过 AnnotatedElement 接口的<code>getAnnotationByType(Class&lt;T&gt;)</code>。首先获得 Container Annotation，然后再通过 Container Annotation 的 value 方法获得可重复注解。另一种方式是用过 AnnotatedElement 接口的<code>getAnnotations(Class&lt;T&gt;)</code>方法一次性返回可重复注解。</p><p>可重复注解使得开发者可以根据具体的需求对同一个声明式或者类型加上同一类型的注解，从而增加代码的灵活性和可读性。</p><h2 id="自定义注解及解析"><a href="#自定义注解及解析" class="headerlink" title="自定义注解及解析"></a>自定义注解及解析</h2><h3 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1. 自定义注解"></a>1. 自定义注解</h3><p>创建Java的自定义注解和创建一个接口相似，但是注解的<code>interface</code>关键字需要以<code>@</code>符号开头。我们可以为注解声明方法。我们先来看看一个自定义注解的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Inherited<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MethodInfo</span> <span class="token punctuation">{</span>    String <span class="token function">author</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">'blinkfox'</span><span class="token punctuation">;</span>    String <span class="token function">date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">revision</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span>    String <span class="token function">comments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>自定义注解就需要用到上面所介绍到的几种元注解，可以看出元注解就是用来注解其它注解。自定义注解和接口类似，只能定义<strong>方法</strong>，注解中的<strong>方法</strong>需要遵循以下几种规则：</p><ul><li>注解方法不能带有参数；</li><li>注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组；</li><li>注解方法可以有默认值。</li></ul><h3 id="2-注解的解析"><a href="#2-注解的解析" class="headerlink" title="2. 注解的解析"></a>2. 注解的解析</h3><p>要解析Java中的注解需要使用Java反射技术。那么注解的<code>RetentionPolicy</code>应该设置为<code>RUNTIME</code>，否则Java类的注解信息在执行过程中将不可用，我们也就不能从中得到任何和注解有关的数据。以下是解析注解常用的几种方法的示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Annotation<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationParsing</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>AnnotationParsing<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> AnnotationParsing<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'com.journaldev.annotations.AnnotationExample'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// checks if MethodInfo annotation is present for the method</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>journaldev<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>MethodInfo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// iterates all the annotations available in the method</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>Annotation anno <span class="token operator">:</span> method<span class="token punctuation">.</span><span class="token function">getDeclaredAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'Annotation in Method '</span><span class="token string">'+ method + '</span><span class="token string">' : '</span> <span class="token operator">+</span> anno<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    MethodInfo methodAnno <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>MethodInfo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>methodAnno<span class="token punctuation">.</span><span class="token function">revision</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'Method with revision no 1 = '</span><span class="token operator">+</span> method<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"解析Java注解出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="注解的应用之监控方法执行耗时"><a href="#注解的应用之监控方法执行耗时" class="headerlink" title="注解的应用之监控方法执行耗时"></a>注解的应用之监控方法执行耗时</h2><p>通过前面对元注解的介绍，我们就可以自定义我们需要的注解了。假如，我们需要监控某些方法的执行，最原始的办法就是在方法执行的开头和结尾分别记录时间，最后计算前后的时间差即可，但是这些代码与核心业务无关，且大量重复、分散在各处，维护起来也困难。这时我们可以<a href="http://blinkfox.com/shi-yong-spring-aoplai-tong-ji-fang-fa-de-zhi-xing-shi-jian/" target="_blank" rel="noopener">使用Spring AOP来统计方法的执行耗时</a>，同时我们也可以使用注解的方式来实现，更自由灵活。</p><p>首先，定义我们的执行耗时的方法上的注解：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Documented<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 自定义'统计方法耗时'并打印日志的注解. * * @author blinkfox on 2017-01-04. */</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">CostTime</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 执行超过某毫秒数时数则打印'warn'级别的日志，默认 0ms，即默认都打印.     *     * @return 毫秒数     */</span>    <span class="token keyword">long</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后，书写监控所标注有<code>@CostTime</code>注解的方法代理类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 被标注为'@CostTime'注解的方法执行耗时的代理方法. * &lt;p>实现了cglib中的`MethodInterceptor`的方法拦截接口.&lt;/p> * * @author blinkfox on 2017-01-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CostTimeProxy</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>CostTimeProxy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取代理类.     *     * @param cls 代理类的class     * @return 代理类实例     */</span>    <span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span>Class <span class="token class-name">cls</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 拦截方法,判断是否有'@CostTime'的注解，如果有则拦截执行.     *     * @param o 对象     * @param method 方法     * @param args 参数     * @param methodProxy 代理方法     * @return 对象     * @throws Throwable 问题     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断该方法上是否有 CostTime 注解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>CostTime<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 获取注解信息</span>        CostTime costTime <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>CostTime<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> limitTime <span class="token operator">=</span> costTime<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 记录方法执行前后的耗时时间，并做差，判断是否需要打印方法执行耗时</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> diffTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>limitTime <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>diffTime <span class="token operator">>=</span> limitTime<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 打印耗时的信息</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"【CostTime监控】通过注解监控方法'{}'的执行耗时为:{}"</span><span class="token punctuation">,</span> methodName<span class="token punctuation">,</span> diffTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着，可以写一些业务类及方法，这里就以<code>A</code>类为例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * A类. * * @author blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 始终打印方法执行耗时的方法.     */</span>    <span class="token annotation punctuation">@CostTime</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"执行A类中doSomeThing()方法！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 当方法执行耗时大于等于'50ms'时打印出方法执行耗时.     */</span>    <span class="token annotation punctuation">@CostTime</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeThing2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"执行A类中doSomeThing2()方法！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是用来测试<code>A</code>类某些业务方法执行耗时的测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>test<span class="token punctuation">.</span>reflect<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 耗时注解使用测试示例 * Created by blinkfox on 2017-01-04. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CostTimeTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** A类的全局实例. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> A a<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        CostTimeProxy aproxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CostTimeProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> aproxy<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * main 方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">doSomeThing2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这就完成了对A类被标注了<code>@CostTime</code>注解的方法执行耗时的监控。当然你可以配置需要扫描的包(<code>package</code>)下的所有类中被标注为<code>@CostTime</code>注解的方法的执行耗时，这里就不介绍了。</p><hr><p>参考文档：</p><ul><li><a href="http://www.importnew.com/17413.html" target="_blank" rel="noopener">Java注解教程及自定义注解</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8annotation/" target="_blank" rel="noopener">Java 8 Annotation 新特性在软件质量和开发效率方面的提升</a></li><li><a href="http://blog.csdn.net/u014207606/article/details/52291951" target="_blank" rel="noopener">Java内置系统注解和元注解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射基础</title>
      <link href="/2018/110753.html"/>
      <url>/2018/110753.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Java反射(<code>Reflection</code>)机制就是在运行状态中，对于任意一个类，都能够知道这个类的属性和方法。对于任意一个对象能够调用它的任意一个属性和方法。这种动态获取的信息和动态调用对象的方法的功能称为Java语言的反射机制。Java程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是JVM在<strong>运行时</strong>才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。反射机制就是通过<code>java.lang.Class</code>类来实现的，在Java中，Object 类是所有类的根类，而Class类就是描述Java类的类。</p><blockquote><p><strong>注</strong>：因为Class类也是类，所以Object也包括Class类。</p></blockquote><h3 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h3><p>Java反射框架主要提供以下功能：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>在运行时调用任意一个对象的方法；</li><li>修改构造函数、方法、属性的可见性。</li></ul><h3 id="3-主要用途"><a href="#3-主要用途" class="headerlink" title="3. 主要用途"></a>3. 主要用途</h3><p><strong>反射最重要的用途就是开发各种通用框架</strong>。很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。</p><h2 id="二、反射的使用"><a href="#二、反射的使用" class="headerlink" title="二、反射的使用"></a>二、反射的使用</h2><h3 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1. 获取Class对象"></a>1. 获取Class对象</h3><p>反射的各种功能都需要通过Class对象来实现，因此，需要知道如何获取Class对象，主要有以下几种方式。</p><h4 id="使用-Class-forName-的静态方法"><a href="#使用-Class-forName-的静态方法" class="headerlink" title="使用 Class.forName() 的静态方法"></a>使用 Class.forName() 的静态方法</h4><p><code>Class.forName(String className)</code>方法可以通过类或接口的名称（一个字符串或完全限定名）来获取对应的Class对象。</p><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.blinkfox.Zealot"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="直接获取某个类的class-最安全-性能最好"><a href="#直接获取某个类的class-最安全-性能最好" class="headerlink" title="直接获取某个类的class(最安全/性能最好)"></a>直接获取某个类的class(最安全/性能最好)</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span>String<span class="token operator">></span> cls <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span></code></pre><h4 id="调用某个对象的-getClass-方法"><a href="#调用某个对象的-getClass-方法" class="headerlink" title="调用某个对象的 getClass() 方法"></a>调用某个对象的 getClass() 方法</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span>String<span class="token operator">></span> cls <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-判断是否为某个类的实例"><a href="#2-判断是否为某个类的实例" class="headerlink" title="2. 判断是否为某个类的实例"></a>2. 判断是否为某个类的实例</h3><p>一般地，我们用<code>instanceof</code>关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的<code>isInstance()</code>方法来判断是否为某个类的实例，它是一个Native方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-创建实例"><a href="#3-创建实例" class="headerlink" title="3. 创建实例"></a>3. 创建实例</h3><p>通过反射来生成对象主要有两种方式。</p><h4 id="使用Class对象的newInstance-方法"><a href="#使用Class对象的newInstance-方法" class="headerlink" title="使用Class对象的newInstance()方法"></a>使用Class对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>Object str <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法"><a href="#通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance-方法" class="headerlink" title="通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法"></a>通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取String所对应的Class对象</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取String类带一个String参数的构造器</span>Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 根据构造器创建实例</span>Object obj <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"23333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注</strong>：这种方法可以用指定的构造器构造类的实例。</p></blockquote><h3 id="4-获取方法"><a href="#4-获取方法" class="headerlink" title="4. 获取方法"></a>4. 获取方法</h3><p>获取某个Class对象的方法集合，主要有以下几个方法：</p><ul><li><code>getDeclaredMethods()</code>方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException</code></pre><ul><li><code>getMethods()</code>方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException</code></pre><ul><li><code>getMethod()</code>方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span></code></pre><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>            InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        Object object <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取MethodClass类的add方法</span>        Method method <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//getMethods()方法获取的所有方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//getDeclaredMethods()方法获取的所有方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getDeclaredMethods获取的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：通过<code>getMethods()</code>获取的方法可以获取到父类的方法,比如<code>java.lang.Object</code>下定义的各个方法。</p></blockquote><h3 id="5-获取构造方法"><a href="#5-获取构造方法" class="headerlink" title="5. 获取构造方法"></a>5. 获取构造方法</h3><p>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的<code>getConstructor</code>方法得到<code>Constructor</code>类的一个实例，而Constructor类有一个<code>newInstance</code>方法可以创建一个对象实例:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>Object <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initargs<span class="token punctuation">)</span></code></pre><blockquote><p><strong>注</strong>：此方法可以根据传入的参数来调用对应的Constructor创建对象实例。</p></blockquote><h3 id="6-获取类的成员变量信息"><a href="#6-获取类的成员变量信息" class="headerlink" title="6. 获取类的成员变量信息"></a>6. 获取类的成员变量信息</h3><p>获取的方法同Method相似，主要是这几个方法，在此不再赘述：</p><ul><li><code>Field getField(String name)</code>: 访问公有的成员变量。</li><li><code>Field[] getDeclaredFields()</code>：所有已声明的成员变量。但不能得到其父类的成员变量。</li><li><code>Field[] getFields()</code>和<code>Field[] getDeclaredFields()</code>用法同上。</li></ul><h3 id="7-调用方法"><a href="#7-调用方法" class="headerlink" title="7. 调用方法"></a>7. 调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span> InvocationTargetException</code></pre><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>            InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> klass <span class="token operator">=</span> MethodClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建 MethodClass 的实例</span>        Object obj <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取 MethodClass 类的add方法</span>        Method method <span class="token operator">=</span> klass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用 method 对应的方法 => add(1,4)</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MethodClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fuck <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="8-利用反射创建数组"><a href="#8-利用反射创建数组" class="headerlink" title="8. 利用反射创建数组"></a>8. 利用反射创建数组</h3><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个<code>Object Reference</code>。下面我们看一看利用反射创建数组的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用`java.lang.reflect.Array`反射创建长度为25的字符串数组.</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 往数组里添加内容</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Go"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Scala"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"Clojure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取某一项的内容</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="三、使用反射获取信息"><a href="#三、使用反射获取信息" class="headerlink" title="三、使用反射获取信息"></a>三、使用反射获取信息</h2><p>Class类提供了大量的实例方法来获取该Class对象所对应的详细信息，Class类大致包含如下方法，其中每个方法都包含多个重载版本，因此我们只是做简单的介绍，详细请参考<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">JDK文档</a>。</p><h3 id="1-获取类内信息"><a href="#1-获取类内信息" class="headerlink" title="1. 获取类内信息"></a>1. 获取类内信息</h3><ul><li>构造器: <code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></li><li>包含的方法: <code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></li><li>包含的属性: <code>Field getField(String name)</code></li><li>包含的Annotation: <code>&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)</code></li><li>内部类: <code>Class&lt;?&gt;[] getDeclaredClasses()</code></li><li>外部类: <code>Class&lt;?&gt; getDeclaringClass()</code></li><li>所实现的接口: <code>Class&lt;?&gt;[] getInterfaces()</code></li><li>修饰符: <code>int getModifiers()</code></li><li>所在包: <code>Package getPackage()</code></li><li>类名: <code>String getName()</code></li><li>简称: <code>String getSimpleName()</code></li></ul><h3 id="2-判断类本身信息的方法"><a href="#2-判断类本身信息的方法" class="headerlink" title="2. 判断类本身信息的方法"></a>2. 判断类本身信息的方法</h3><ul><li>是否注解类型: <code>boolean isAnnotation()</code></li><li>是否使用了该Annotation修饰: <code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></li><li>是否匿名类: <code>boolean isAnonymousClass()</code></li><li>是否数组: <code>boolean isArray()</code></li><li>是否枚举: <code>boolean isEnum()</code></li><li>是否原始类型: <code>boolean isPrimitive()</code></li><li>是否接口: <code>boolean isInterface()</code></li><li>obj是否是该Class的实例: <code>boolean isInstance(Object obj)</code></li></ul><h3 id="3-使用反射获取泛型信息"><a href="#3-使用反射获取泛型信息" class="headerlink" title="3. 使用反射获取泛型信息"></a>3. 使用反射获取泛型信息</h3><p>为了通过反射操作泛型以迎合实际开发的需要, Java新增了<code>java.lang.reflect.ParameterizedType</code>、<code>java.lang.reflect.GenericArrayType</code>、<code>java.lang.reflect.TypeVariable</code>、<code>java.lang.reflect.WildcardType</code>几种类型来代表不能归一到Class类型但是又和原始类型同样重要的类型。</p><ul><li><code>ParameterizedType</code>: 一种参数化类型, 比如Collection<string></string></li><li><code>GenericArrayType</code>: 一种元素类型是参数化类型或者类型变量的数组类型</li><li><code>TypeVariable</code>: 各种类型变量的公共接口</li><li><code>WildcardType</code>: 一种通配符类型表达式, 如<code>?</code>、<code>? extends Number</code>、<code>? super Integer</code></li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> objectMap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> map<span class="token punctuation">,</span> String string<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> Bean<span class="token operator">></span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试属性类型     *     * @throws NoSuchFieldException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFieldType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException <span class="token punctuation">{</span>        Field field <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"objectMap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type gType <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 打印type与generic type的区别</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gType<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ParameterizedType pType <span class="token operator">=</span> <span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> gType<span class="token punctuation">;</span>            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> pType<span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> types<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试参数类型     *     * @throws NoSuchMethodException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testParamType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>        Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> parameterTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"type -> "</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试返回值类型     *     * @throws NoSuchMethodException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>        Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type returnType <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"return type -> "</span> <span class="token operator">+</span> returnType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>returnType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> returnType<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>参考文档：<a href="http://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">Java反射基础</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之责任链模式</title>
      <link href="/2018/110429724.html"/>
      <url>/2018/110429724.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>定义</strong>：责任链模式(<code>Chain of Responsibility Pattern</code>)是使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。</p></blockquote><p><strong>实质</strong>：责任链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Handler</code>（抽象处理者）：处理请求的接口，一般设计为具有抽象请求处理方法的抽象类，以便于不同的具体处理者进行继承，从而实现具体的请求处理方法。此外，由于每一个请求处理者的下家还是一个处理者，因此抽象处理者本身还包含了一个本身的引用(<code>nextHandler</code>)作为其对下家的引用，以便将处理者链成一条链；</li><li><code>ConcreteHandler</code>（具体处理者）：抽象处理者的子类，可以处理用户请求，其实现了抽象处理者中定义的请求处理方法。在具体处理请求时需要进行判断，若其具有相应的处理权限，那么就处理它；否则，其将请求转发给后继者，以便让后面的处理者进行处理。</li></ul><p>在责任链模式里，由每一个请求处理者对象对其下家的引用而连接起来形成一条请求处理链。请求将在这条链上一直传递，直到链上的某一个请求处理者能够处理此请求。<strong>发出这个请求的客户端并不知道链上的哪一个请求处理者将处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任</strong>。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/chain_of_responsibility.png" alt="责任链模式UML类图"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，责任链模式的核心在于对请求处理者的抽象。在实现过程中，抽象处理者一般会被设定为<strong>抽象类</strong>，其典型实现代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的抽象处理者角色. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 后继处理者角色. */</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 处理请求的抽象方法.     *     * @param condition 条件     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * nextHandler的Setter方法.     *     * @param nextHandler 后继处理器     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler nextHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> nextHandler<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其次，是若干个具体的处理角色类。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色1. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色1的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色2. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色2的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色n. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerN</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这里假设n是链的最后一个节点必须处理掉.     * 在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点.     *     * @param condition 参数条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色n的处理方法 结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，代码调用示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的客户端场景类. * * Created by blinkfox on 16/7/11. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler handler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handlern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler1<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handler2<span class="token punctuation">)</span><span class="token punctuation">;</span>        handler2<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handlern<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//假设这个请求是ConcreteHandler2的责任</span>        handler1<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：责任链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般由使用该责任链的客户端创建。职责链模式降低了请求的发送者和请求处理者之间的耦合，从而使得多个请求处理者都有机会处理这个请求。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际软件开发中，如果遇到有多个对象可以处理同一请求时可以考虑使用职责链模式，最常见的例子包括在 Java Web 应用开发中创建一个过滤器（Filter）链来对请求数据进行过滤（中文字符乱码的处理）、在工作流系统中实现公文的分级审批、在Struts应用中添加不同的拦截器(常用的有类型转化、异常处理，数据校验…)以增强Struts2的功能等。</p><h3 id="纯与不纯的责任链模式"><a href="#纯与不纯的责任链模式" class="headerlink" title="纯与不纯的责任链模式"></a>纯与不纯的责任链模式</h3><ul><li><strong>纯的责任链模式</strong>要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况；</li><li>在纯责任链模式里面，一个请求必须被某一个处理者对象所接收；</li><li>在不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</li></ul><p>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>降低耦合度，使请求的发送者和接收者解耦，便于灵活的、可插拔的定义请求处理过程；</li><li>简化、封装了请求的处理过程，并且这个过程对客户端而言是透明的，以便于动态地重新组织链以及分配责任，增强请求处理的灵活性；</li><li>可以从职责链任何一个节点开始，也可以随时改变内部的请求处理规则，每个请求处理者都可以去动态地指定他的继任者；</li><li>职责链可简化对象间的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用；</li><li>增加新的请求处理类很方便。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理；</li><li>该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理；</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li><li>职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之单例模式</title>
      <link href="/2018/102929438.html"/>
      <url>/2018/102929438.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>单例模式(<code>Singleton Pattern</code>)</strong>：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种<strong>对象创建型模式</strong>。单例模式又名单件模式或单态模式。</p></blockquote><p>单例模式的要点有三个：</p><ul><li>一是某个类只能有一个实例；</li><li>二是它必须自行创建这个实例；</li><li>三是它必须自行向整个系统提供这个实例。</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Singleton</code>: 单例</li></ul><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="http://static.blinkfox.com/Java_design_singleton_uml.jpg" alt="单例模式UML类图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/Java_design_singleton_seq.jpg" alt="单例模式时序图"></p><h2 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h2><h3 id="1-饿汉式（推荐使用）"><a href="#1-饿汉式（推荐使用）" class="headerlink" title="1. 饿汉式（推荐使用）"></a>1. 饿汉式（推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 饿汉式单例模式. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 全局唯一实例. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。</p></blockquote><h3 id="2-非线程安全懒汉式（不推荐使用）"><a href="#2-非线程安全懒汉式（不推荐使用）" class="headerlink" title="2. 非线程安全懒汉式（不推荐使用）"></a>2. 非线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取实例，但是非线程安全.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，但非线程安全。不推荐使用。</p></blockquote><h3 id="3-低效的线程安全懒汉式（不推荐使用）"><a href="#3-低效的线程安全懒汉式（不推荐使用）" class="headerlink" title="3. 低效的线程安全懒汉式（不推荐使用）"></a>3. 低效的线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 低效的线程安全的懒汉式. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，但是效率很低。因为99%的情况下是不需要去同步的。不推荐使用。</p></blockquote><h3 id="4-双重校验锁线程安全懒汉式（不推荐使用）"><a href="#4-双重校验锁线程安全懒汉式（不推荐使用）" class="headerlink" title="4. 双重校验锁线程安全懒汉式（不推荐使用）"></a>4. 双重校验锁线程安全懒汉式（不推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 双重校验锁线程安全懒汉式. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，效率也不错。但受限于Jdk5以前的Java内存模型，仍然会有bug，Java5及之后才能正常达到单例效果。</p></blockquote><h3 id="5-枚举式（强烈推荐使用）"><a href="#5-枚举式（强烈推荐使用）" class="headerlink" title="5. 枚举式（强烈推荐使用）"></a>5. 枚举式（强烈推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 枚举方式的单例. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：在<code>《Effective Java》</code>一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。</p></blockquote><h3 id="6-静态内部类（推荐使用）"><a href="#6-静态内部类（推荐使用）" class="headerlink" title="6. 静态内部类（推荐使用）"></a>6. 静态内部类（推荐使用）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. * * @author blinkfox on 2017-10-23. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">SingletonHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton4 instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取Singleton唯一实例的方法.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：这种方式利用了<code>ClassLoader</code>的机制保证初始化<code>instance</code>时只有一个线程，其只有显示通过调用<code>getInstance</code>方法时，才会显示装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——<code>Singleton</code>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如<code>Java</code>、<code>C#</code>)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程的理解</title>
      <link href="/2018/102136438.html"/>
      <url>/2018/102136438.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><h3 id="面向过程思想概述"><a href="#面向过程思想概述" class="headerlink" title="面向过程思想概述"></a>面向过程思想概述</h3><p>面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。</p><h3 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h3><p>当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。面向对象是基于面向过程的编程思想。</p><h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><ul><li>抽象</li><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面：</p><ul><li>数据抽象：表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)</li><li>过程抽象：表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。隐藏之后，外部程序就不能接触和改变那些细节，所以不用担心自己的类会受到非法修改，可确保它们不会对其他程序造成影响。</p><h4 id="封装的原则"><a href="#封装的原则" class="headerlink" title="封装的原则"></a>封装的原则</h4><ul><li>将不需要对外提供的内容都隐藏起来</li><li>把属性都隐藏，提供公共方法对其访问</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一种联结类的层次模型，并且允许和鼓励类的重用，提供一种明确表达共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，原始类称为新类的基类(父类)。派生类可以从它的父类哪里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。因此可以说，继承为了重用父类代码，同时为实现多态性作准备。</p><h4 id="继承概念的实现方式"><a href="#继承概念的实现方式" class="headerlink" title="继承概念的实现方式"></a>继承概念的实现方式</h4><ul><li>类继承：类继承是指直接使用基类的属性和方法而无需额外编码。</li><li>接口继承：接口继承是指仅使用属性和方法的名称、但是子类必须提供实现。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><h4 id="实现多态的方式"><a href="#实现多态的方式" class="headerlink" title="实现多态的方式"></a>实现多态的方式</h4><ul><li>重载</li><li>重写</li><li>实现接口</li></ul><h2 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h2><p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了<strong>代码重用</strong>。而多态则是为了实现另一个目的：<strong>接口重用</strong>！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p><h3 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h3><p>就是不断的创建对象，使用对象，指挥对象做事情。</p><h3 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h3><p>更好的管理和维护对象之间的关系。</p><h3 id="面向对象优点"><a href="#面向对象优点" class="headerlink" title="面向对象优点"></a>面向对象优点</h3><ul><li>更符合我们思想习惯的思想</li><li>将复杂的事情简单化</li><li>将我们从执行者变成了指挥者</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之建造者模式</title>
      <link href="/2018/102060028.html"/>
      <url>/2018/102060028.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>造者模式(<code>Builder Pattern</code>)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于<strong>对象创建型模式</strong>。建造者模式又可以称为<strong>生成器模式</strong>。</p></blockquote><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>建造者模式包含如下角色：</p><ul><li><code>Builder</code>：抽象建造者</li><li><code>ConcreteBuilder</code>：具体建造者</li><li><code>Director</code>：导演者</li><li><code>Product</code>：产品角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Builder.jpg" alt="建造者模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是产品类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 产品类. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String part1<span class="token punctuation">;</span>    <span class="token keyword">private</span> String part2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter方法. */</span>    <span class="token keyword">public</span> String <span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart1</span><span class="token punctuation">(</span>String part1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part1 <span class="token operator">=</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart2</span><span class="token punctuation">(</span>String part2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part2 <span class="token operator">=</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的建造者<code>Builder</code>接口和具体的建造者<code>ConcreteBuilder</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的建造者. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的建造者实现类. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 产品. */</span>    <span class="token keyword">private</span> Product product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart1</span><span class="token punctuation">(</span><span class="token string">"编号：95757"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart2</span><span class="token punctuation">(</span><span class="token string">"名称：小机器人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，导演者<code>Director</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 导演者类. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 当前需要的建造者对象. */</span>    <span class="token keyword">private</span> Builder builder<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param builder     */</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品构造方法，负责调用各个零件建造方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是建造者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 建造者模式的客户端场景类. * * Created by blinkfox on 2016/10/8. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuilderClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Director director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>抽象建造者类中定义了产品的创建方法和返回方法;</p><p>建造者模式的结构中还引入了一个导演者类<code>Director</code>，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>建造者模式的优点：</p><ul><li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>建造者模式的缺点：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h3 id="4-建造者模式与抽象工厂模式的比较"><a href="#4-建造者模式与抽象工厂模式的比较" class="headerlink" title="4. 建造者模式与抽象工厂模式的比较"></a>4. 建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。</li><li>建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</li><li>在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li><li>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之外观模式</title>
      <link href="/2018/101818310.html"/>
      <url>/2018/101818310.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><blockquote><p><strong>外观模式</strong>(<code>Facade Pattern</code>)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为<strong>门面模式</strong>，它是一种对象结构型模式。</p></blockquote><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>外观模式包含如下角色：</p><ul><li><code>Facade</code>: 外观角色</li><li><code>SubSystem</code>: 子系统角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Facade.jpg" alt="命令模式结构图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是各个子系统角色类，分别如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类A. * * Created by blinkfox on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法A..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类B. * * Created by blinkfox on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassB</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法B..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类C. * * Created by blinkfox on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassC</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法C..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是外观模式的外观类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 外观门面类. * * Created by blinkfox on 16/8/25. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Facade</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ClassA a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassB b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassC c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以下是提供给外部访问的方法.</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“<strong>迪米特法则</strong>”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p><ul><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式的目的在于降低系统的复杂程度。</li><li>外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>外观模式的优点k：</p><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>外观模式的缺点：</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“<strong>开闭原则</strong>”。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="五、模式总结"><a href="#五、模式总结" class="headerlink" title="五、模式总结"></a>五、模式总结</h2><ul><li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li><li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之中介者模式</title>
      <link href="/2018/101718124.html"/>
      <url>/2018/101718124.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</p><ul><li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</li></ul><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>中介者模式(<code>Mediator Pattern</code>)</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为<strong>调停者模式</strong>，它是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>中介者模式包含如下角色：</p><ul><li><code>Mediator</code>: 抽象中介者</li><li><code>ConcreteMediator</code>: 具体中介者</li><li><code>Colleague</code>: 抽象同事类</li><li><code>ConcreteColleague</code>: 具体同事类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Mediator.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Mediator</code>类和具体的<code>ConcreteMediator</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用抽象中介者类. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义同事类1. */</span>    <span class="token keyword">protected</span> ConcreteColleague1 colleague1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 定义同事类2. */</span>    <span class="token keyword">protected</span> ConcreteColleague2 colleague2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter 方法 */</span>    <span class="token keyword">public</span> ConcreteColleague1 <span class="token function">getColleague1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague1</span><span class="token punctuation">(</span>ConcreteColleague1 colleague1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague1 <span class="token operator">=</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ConcreteColleague2 <span class="token function">getColleague2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague2</span><span class="token punctuation">(</span>ConcreteColleague2 colleague2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague2 <span class="token operator">=</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑1.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的通用中介者类. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">extends</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的<code>Colleague</code>类和具体的<code>ConcreteColleague</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的同事类. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 中介者. */</span>    <span class="token keyword">protected</span> Mediator mediator<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Colleague</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mediator <span class="token operator">=</span> mediator<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类1. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague1</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague1</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-处理自己的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-委托给中介者的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类2. * * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague2</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague2</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-处理自己的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-委托给中介者的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是中介者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 中介者模式的场景类 * Created by blinkfox on 16/8/21. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediatorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mediator mediator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague1 colleague1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague1</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague2 colleague2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague2</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague1</span><span class="token punctuation">(</span>colleague1<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague2</span><span class="token punctuation">(</span>colleague2<span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague1<span class="token punctuation">.</span><span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague2<span class="token punctuation">.</span><span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>中介者模式可以使对象之间的关系数量急剧减少。</p><p>中介者承担两方面的职责：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>中介者模式的优点：</p><ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>中介者模式的缺点：</p><ul><li>在具体中介者类中包含了同事之间的交互细节，<strong>可能会导致具体中介者类非常复杂，使得系统难以维护</strong>。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用中介者模式：</p><ul><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li><li>中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li><li>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li><li>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之命令模式</title>
      <link href="/2018/101640715.html"/>
      <url>/2018/101640715.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>命令模式(<code>Command Pattern</code>)</strong>：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(<code>Action</code>)模式或事务(<code>Transaction</code>)模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>命令模式包含如下角色：</p><ul><li><code>Command</code>: 抽象命令类</li><li><code>ConcreteCommand</code>: 具体命令类</li><li><code>Invoker</code>: 调用者</li><li><code>Receiver</code>: 接收者</li><li><code>Client</code>: 客户类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/Command.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Receiver</code>类和具体的<code>Receiver</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用的抽象 Receiver 接收者. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义每个接收者都必须完成的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类1. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver1</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver1 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类2. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver2</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver2 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的<code>Command</code>类和具体的<code>Command</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的 Command 类. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 命令的抽象执行命令的方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类1. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand1</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand1</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的一个命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类2. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand2</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand2</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，调用者<code>Invoker</code>类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 调用者 Invoker 类. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Command command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>Command command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 执行命令.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是命令模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 命令模式的场景类. * * Created by blinkfox on 16/8/17. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Invoker invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Receiver receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteReceiver1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Command command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCommand1</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把命令交给调用者执行</span>        invoker<span class="token punctuation">.</span><span class="token function">setCommand</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p><strong>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开</strong>。</p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>命令模式的优点：</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的<code>Undo</code>和<code>Redo</code>。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>命令模式的缺点：</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用命令模式：</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</li><li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li><li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码整洁之道内容概要</title>
      <link href="/2018/101560116.html"/>
      <url>/2018/101560116.html</url>
      
        <content type="html"><![CDATA[<p>读了代码整洁之道，觉得这本书写的很好，所以就将里面自己觉得很经典的内容记录下来，作为自己以后写代码的标准和准则。同时也为那些曾经困惑过的人一点参考吧！</p><h2 id="一、在正式开始之前，我们先思考几个几个问题："><a href="#一、在正式开始之前，我们先思考几个几个问题：" class="headerlink" title="一、在正式开始之前，我们先思考几个几个问题："></a>一、在正式开始之前，我们先思考几个几个问题：</h2><h3 id="1-需求与代码哪个重要？"><a href="#1-需求与代码哪个重要？" class="headerlink" title="1.需求与代码哪个重要？"></a>1.需求与代码哪个重要？</h3><p>答：并不是所有的产品都能提出合理的需求，当你面对一个提出不合理需求的产品的时候，你需要坚持自己的原则，不能妥协。</p><h3 id="2-易读和易懂是一回事吗？"><a href="#2-易读和易懂是一回事吗？" class="headerlink" title="2.易读和易懂是一回事吗？"></a>2.易读和易懂是一回事吗？</h3><p>答：易读的代码和易懂的代码是有区别的，不是易读的代码就是易懂的代码。</p><h3 id="3-什么是测试驱动代码？"><a href="#3-什么是测试驱动代码？" class="headerlink" title="3.什么是测试驱动代码？"></a>3.什么是测试驱动代码？</h3><p>答：测试驱动代码，你写的代码要可以执行单元测试。如果你发现你的代码很难写单元测试，那么你就要思考你的代码是不是已经不整洁了，或者说已经乱成一团了。</p><h3 id="4-什么是简单的代码？"><a href="#4-什么是简单的代码？" class="headerlink" title="4.什么是简单的代码？"></a>4.什么是简单的代码？</h3><p>答：<br>1.能通过所有测试<br>2.没有重复代码<br>3.体现系统中全部设计理念<br>4.包含尽量少的实体，包括，类，函数，方法等</p><p>如果某段代码在程序设计中反复出现，就证明想法在代码中没有很好的体现出来。总之，不要重复代码，只做一件事，表达力，小规模抽象。</p><h2 id="二、第二章-有意义的命名"><a href="#二、第二章-有意义的命名" class="headerlink" title="二、第二章 有意义的命名"></a>二、第二章 有意义的命名</h2><h3 id="1-名副其实"><a href="#1-名副其实" class="headerlink" title="1.名副其实"></a>1.名副其实</h3><p>变量，函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么会存在，它做什么事情，应该怎么用。如果名称需要注释来补充，那么就不算名副其实。</p><h3 id="2-避免误导"><a href="#2-避免误导" class="headerlink" title="2.避免误导"></a>2.避免误导</h3><p>必须避免留下掩藏代码本意的错误线索。</p><h3 id="3-做有意义的区分"><a href="#3-做有意义的区分" class="headerlink" title="3.做有意义的区分"></a>3.做有意义的区分</h3><p>只要体现出有意义的区分，使用a和the这样的前缀就没有错。废话就是冗余。</p><h3 id="4-使用读得出来的名称"><a href="#4-使用读得出来的名称" class="headerlink" title="4.使用读得出来的名称"></a>4.使用读得出来的名称</h3><p>不要用傻乎乎的自造词，而不是恰当的英语词。</p><h3 id="5-使用可搜索的名称"><a href="#5-使用可搜索的名称" class="headerlink" title="5.使用可搜索的名称"></a>5.使用可搜索的名称</h3><p>使用便于搜索的名字。</p><h3 id="6-避免使用编码"><a href="#6-避免使用编码" class="headerlink" title="6.避免使用编码"></a>6.避免使用编码</h3><p>把类型或者作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外，还要再搞懂另一种编码”语言”。</p><h3 id="7-避免思维映射"><a href="#7-避免思维映射" class="headerlink" title="7.避免思维映射"></a>7.避免思维映射</h3><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称，尤其是在经常出现在选择是使用问题领域术语还是解决方案领域术语的时候。</p><h3 id="8-类名或对象名最好使用名词或者名词短语"><a href="#8-类名或对象名最好使用名词或者名词短语" class="headerlink" title="8.类名或对象名最好使用名词或者名词短语"></a>8.类名或对象名最好使用名词或者名词短语</h3><h3 id="9-方法名最好使用动词或者动词短语"><a href="#9-方法名最好使用动词或者动词短语" class="headerlink" title="9.方法名最好使用动词或者动词短语"></a>9.方法名最好使用动词或者动词短语</h3><h3 id="10-别扮可爱"><a href="#10-别扮可爱" class="headerlink" title="10.别扮可爱"></a>10.别扮可爱</h3><p>命名一定要通俗易懂。</p><h3 id="11-每一个概念对应一个词"><a href="#11-每一个概念对应一个词" class="headerlink" title="11.每一个概念对应一个词"></a>11.每一个概念对应一个词</h3><p>给每个抽象概念选择一个词，并一以贯之</p><h3 id="12-别用双关语词"><a href="#12-别用双关语词" class="headerlink" title="12.别用双关语词"></a>12.别用双关语词</h3><p>避免将同一个词用于不同目的，遵循一词一义的原则</p><h3 id="13-使用解决方案领域名"><a href="#13-使用解决方案领域名" class="headerlink" title="13.使用解决方案领域名"></a>13.使用解决方案领域名</h3><h3 id="14-使用源自所涉领域名"><a href="#14-使用源自所涉领域名" class="headerlink" title="14.使用源自所涉领域名"></a>14.使用源自所涉领域名</h3><h3 id="15-添加有意义的语境"><a href="#15-添加有意义的语境" class="headerlink" title="15.添加有意义的语境"></a>15.添加有意义的语境</h3><p>在一个bean中定义变量名的时候，变量名一定是基于实际使用场景。</p><h3 id="16-不要添加没用的语境"><a href="#16-不要添加没用的语境" class="headerlink" title="16.不要添加没用的语境"></a>16.不要添加没用的语境</h3><h2 id="三、第三章-函数"><a href="#三、第三章-函数" class="headerlink" title="三、第三章 函数"></a>三、第三章 函数</h2><h3 id="1-短小"><a href="#1-短小" class="headerlink" title="1.短小"></a>1.短小</h3><p>函数第一规则是要短小。第二条规则是还要更短小。</p><h3 id="2-只做一件事"><a href="#2-只做一件事" class="headerlink" title="2.只做一件事"></a>2.只做一件事</h3><ul><li>函数应该做一件事。做好这件事。只做一件事。如果可以从你的函数中还能拆分出一个函数，该函数不仅只是单纯地重新诠释其实现，那么你设计的函数就不是一个好的函数。</li><li>函数中的区段，如果函数被切分了多个区段，这就证明该函数做的事情太多了。</li></ul><h3 id="3-每个函数一个抽象层级"><a href="#3-每个函数一个抽象层级" class="headerlink" title="3.每个函数一个抽象层级"></a>3.每个函数一个抽象层级</h3><h3 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h3><p>确保每个switch都埋藏在较低的抽象层级，而且永远不重复。</p><h3 id="5-使用描述性的名称"><a href="#5-使用描述性的名称" class="headerlink" title="5.使用描述性的名称"></a>5.使用描述性的名称</h3><p>命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如：includeSetupPages。</p><h3 id="6-函数参数"><a href="#6-函数参数" class="headerlink" title="6.函数参数"></a>6.函数参数</h3><ul><li>最理想的函数参数的数量是零个，其次是一，再次是二，应尽量避免三。有足够的理由才能用上三个以上的参数。</li><li>如果函数看来需要两个，三个或者三个以上参数，就说明其中一些参数应该封装为类了。</li><li>函数和函数的参数命名一般是动名词比较好。</li></ul><h3 id="7-无副作用"><a href="#7-无副作用" class="headerlink" title="7.无副作用"></a>7.无副作用</h3><h3 id="8-分割指令与查询"><a href="#8-分割指令与查询" class="headerlink" title="8.分割指令与查询"></a>8.分割指令与查询</h3><p>函数要么做什么事，要么回答什么事，但二者不可兼得</p><h3 id="9-使用异常替代返回错误码"><a href="#9-使用异常替代返回错误码" class="headerlink" title="9.使用异常替代返回错误码"></a>9.使用异常替代返回错误码</h3><ul><li>返回错误码的时候，就是在要求调用者立刻处理错误。</li><li>如果使用异常替代返回错误码，错误处理代码就能从住路径代码中分离出来，得到简化。</li><li>抽离try/catch代码块</li></ul><h3 id="10-别重复自己"><a href="#10-别重复自己" class="headerlink" title="10.别重复自己"></a>10.别重复自己</h3><h3 id="11-结构化编程"><a href="#11-结构化编程" class="headerlink" title="11.结构化编程"></a>11.结构化编程</h3><h2 id="四、第四章-注释"><a href="#四、第四章-注释" class="headerlink" title="四、第四章 注释"></a>四、第四章 注释</h2><h3 id="1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"><a href="#1-如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。" class="headerlink" title="1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。"></a>1.如果你代码写的足够好的话，可以让人一看就懂，那么你就不需要再写注释。如果你的代码需要注释，那么你就需要想想是不是你的表达水平有问题。</h3><h3 id="2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"><a href="#2-真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？" class="headerlink" title="2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？"></a>2.真正好的注释是想办法不用写注释，那么什么样的注释需要写呢？</h3><ul><li>法律信息</li><li>提供信息的注释</li><li>提供意图的解释</li><li>阐释</li><li>警告</li><li>TODO注释</li><li>TODO是一种程序要认为应该要做的，但是由于某种原因没有做的</li><li>放大,放大某些看似不合理的地方</li></ul><h2 id="五、第六章-对象和数据结构"><a href="#五、第六章-对象和数据结构" class="headerlink" title="五、第六章 对象和数据结构"></a>五、第六章 对象和数据结构</h2><h3 id="1-得墨忒定律"><a href="#1-得墨忒定律" class="headerlink" title="1.得墨忒定律"></a>1.得墨忒定律</h3><p>模块不应该了解他所操作对象的内部情形。对象隐藏数据曝露操作，这就意味着对象不应该通过存取器曝露其内部结构。</p><h2 id="六、第七章-错误处理"><a href="#六、第七章-错误处理" class="headerlink" title="六、第七章 错误处理"></a>六、第七章 错误处理</h2><h3 id="1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"><a href="#1-将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。" class="headerlink" title="1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。"></a>1.将业务逻辑和出错处理一定要隔离开，但是并不是所有的情况都试用，在不适用的情况下我们可以创建一个配置对象将特殊情况给予返回。</h3><h3 id="2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"><a href="#2-异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。" class="headerlink" title="2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。"></a>2.异常处理不能过多的曝露实现细节，主要提现在异常抛出的栈信息上。</h3><h2 id="七、第八章-边界"><a href="#七、第八章-边界" class="headerlink" title="七、第八章 边界"></a>七、第八章 边界</h2><h3 id="1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"><a href="#1-整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。" class="headerlink" title="1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。"></a>1.整洁的边界，边界上的代码要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。</h3><h2 id="八、第九章-单元测试"><a href="#八、第九章-单元测试" class="headerlink" title="八、第九章 单元测试"></a>八、第九章 单元测试</h2><h3 id="1-TDD三定律"><a href="#1-TDD三定律" class="headerlink" title="1.TDD三定律"></a>1.TDD三定律</h3><ul><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也算不通过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ul><h3 id="2-整洁测试三要素"><a href="#2-整洁测试三要素" class="headerlink" title="2.整洁测试三要素"></a>2.整洁测试三要素</h3><ul><li>可读性</li><li>可读性</li><li>可读性</li></ul><h3 id="3-整洁测试的五条原则："><a href="#3-整洁测试的五条原则：" class="headerlink" title="3.整洁测试的五条原则："></a>3.整洁测试的五条原则：</h3><ul><li>快速，测试应该够快</li><li>独立，测试应该相互独立</li><li>可重复，测试应当可在任何环境中重复通过。</li><li>自足验证，测试应该有布尔值输出，无论测试是成功还是失败，不应该人工通过log来确认测试是否成功或者失败。</li><li>及时，测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ul><h2 id="九、第十章-类"><a href="#九、第十章-类" class="headerlink" title="九、第十章 类"></a>九、第十章 类</h2><h3 id="1-单一权责原则，类或者模块应有且只有一条加以修改的理由。"><a href="#1-单一权责原则，类或者模块应有且只有一条加以修改的理由。" class="headerlink" title="1.单一权责原则，类或者模块应有且只有一条加以修改的理由。"></a>1.单一权责原则，类或者模块应有且只有一条加以修改的理由。</h3><h3 id="2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"><a href="#2-内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。" class="headerlink" title="2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。"></a>2.内聚，如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。</h3><h2 id="十、第十一章-系统"><a href="#十、第十一章-系统" class="headerlink" title="十、第十一章 系统"></a>十、第十一章 系统</h2><h3 id="1-将系统的构造与使用分开"><a href="#1-将系统的构造与使用分开" class="headerlink" title="1.将系统的构造与使用分开"></a>1.将系统的构造与使用分开</h3><p>软件系统应将起始过程和启始过程之后的运行时逻辑分离开，在起始过程中构建应用对象，也会存在相互缠结的依赖关系。（延迟初始化可以加快程序运行速度）</p><h4 id="1-1分解main"><a href="#1-1分解main" class="headerlink" title="1.1分解main"></a>1.1分解main</h4><p>将程序的构造放到main，并使其与运行时逻辑分开，main只管构造并将构造后的数据对象发送给各个应用，或者被各个应用使用。但是，不参与运行时的任何逻辑控制。</p><h4 id="1-2工厂模式"><a href="#1-2工厂模式" class="headerlink" title="1.2工厂模式"></a>1.2工厂模式</h4><p>使用该模式可以将系统构造和系统运行时逻辑分开。</p><h4 id="1-3依赖注入（需要强化理解）"><a href="#1-3依赖注入（需要强化理解）" class="headerlink" title="1.3依赖注入（需要强化理解）"></a>1.3依赖注入（需要强化理解）</h4><h4 id="1-4扩容"><a href="#1-4扩容" class="headerlink" title="1.4扩容"></a>1.4扩容</h4><p>“一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统，实现新用户的故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发，重构以及他们打造出的整洁的代码。</p><h4 id="1-5测试驱动系统架构"><a href="#1-5测试驱动系统架构" class="headerlink" title="1.5测试驱动系统架构"></a>1.5测试驱动系统架构</h4><p>最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯编程语言对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具结合起来。这种架构就能测试驱动，就像代码一样。(需要关注面向切片编程(POJO))</p><h4 id="1-6优化决策"><a href="#1-6优化决策" class="headerlink" title="1.6优化决策"></a>1.6优化决策</h4><p>模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或是一个软件项目，无人能做所有的决策。最好是授权给最有资格的人。拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的，时机刚好的决策。决策的复杂性降低了。</p><h2 id="十一、第十二章-迭进"><a href="#十一、第十二章-迭进" class="headerlink" title="十一、第十二章 迭进"></a>十一、第十二章 迭进</h2><h3 id="1-通过迭进设计达到代码整洁的目的："><a href="#1-通过迭进设计达到代码整洁的目的：" class="headerlink" title="1. 通过迭进设计达到代码整洁的目的："></a>1. 通过迭进设计达到代码整洁的目的：</h3><p>通过这几个原则可以让你的设计变简单（DIP，SRP）</p><ul><li>运行所有测试</li><li>不可重复，</li><li>表达了程序员的意图</li><li>尽可能减少类和方法的数量</li><li>以上规则按其重要程度排序</li></ul><h3 id="2-简单设计规则1-运行所有测试"><a href="#2-简单设计规则1-运行所有测试" class="headerlink" title="2. 简单设计规则1:运行所有测试"></a>2. 简单设计规则1:运行所有测试</h3><p>编写的测试越多就越能持续走向编写较易测试的代码，紧耦合的代码很难编写测试。遵循有关编写测试并持续运行测试的简单，明确的规则，系统就会更贴近OO低耦合度，高内聚度的目标。编写测试引致更好的设计。</p><h3 id="3-简单设计规则2-4：重构"><a href="#3-简单设计规则2-4：重构" class="headerlink" title="3. 简单设计规则2-4：重构"></a>3. 简单设计规则2-4：重构</h3><p>在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是简单设计原则后三条规则的地方:消除重复，保证表达力，尽可能减少类和方法的数量。</p><h3 id="4-不可重复"><a href="#4-不可重复" class="headerlink" title="4. 不可重复"></a>4. 不可重复</h3><h3 id="5-表达力"><a href="#5-表达力" class="headerlink" title="5. 表达力"></a>5. 表达力</h3><h3 id="6-尽可能少的类和方法"><a href="#6-尽可能少的类和方法" class="headerlink" title="6. 尽可能少的类和方法"></a>6. 尽可能少的类和方法</h3><h2 id="十二、第十三章-并发编程"><a href="#十二、第十三章-并发编程" class="headerlink" title="十二、第十三章 并发编程"></a>十二、第十三章 并发编程</h2><h3 id="1-为什么要并发"><a href="#1-为什么要并发" class="headerlink" title="1. 为什么要并发"></a>1. 为什么要并发</h3><p>并发是一种解耦策略。它帮我们把做什么和何时做分解开。</p><h3 id="2-并发的防御原则"><a href="#2-并发的防御原则" class="headerlink" title="2. 并发的防御原则"></a>2. 并发的防御原则</h3><h3 id="13-1-单一权责原则（SRP）"><a href="#13-1-单一权责原则（SRP）" class="headerlink" title="13.1 单一权责原则（SRP）"></a>13.1 单一权责原则（SRP）</h3><p>并发代码应该从其他代码中分离出来，因为，并发代码相比于其他的代码是很复杂的存在。但是，并发实现细节常常直接嵌入到其他生产代码中。那么下面几个问题需要考虑，</p><ul><li>并发相关代码由自己的开发，修改和调优生命周期</li><li>开发相关代码由自己要对付的挑战，和非并发相关代码不同，而且往往更为困难</li><li>即便没有周边应用程序增加负担，写得不好的并发代码可能的出错方式数量已经足具挑战性。</li></ul><blockquote><p>建议：分离并发相关代码与其他代码。</p></blockquote><h3 id="13-2-限制数据作用域"><a href="#13-2-限制数据作用域" class="headerlink" title="13.2 限制数据作用域"></a>13.2 限制数据作用域</h3><p>两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是采用<code>synchronized</code>关键字在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。更新共享数据的地方越多，就越可能出错。</p><blockquote><p>建议：谨记数据封装，严格限制对可能被共享的数据的访问。</p></blockquote><h3 id="13-3-使用数据副本"><a href="#13-3-使用数据副本" class="headerlink" title="13.3 使用数据副本"></a>13.3 使用数据副本</h3><p>避免共享数据的好方法之一就是一开始就避免共享数据。在某些情况下，有可能复制对象并以只读方式对待。在另外一种情况下，有可能复制对象，从多个线程收集所有副本的结果，并在单个线程中合并这些结果。</p><h3 id="13-4-线程尽可能地独立"><a href="#13-4-线程尽可能地独立" class="headerlink" title="13.4　线程尽可能地独立"></a>13.4　线程尽可能地独立</h3><p>让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。</p><p>建议：尝试将数据分解到可被独立线程操作的独立子集。</p><h3 id="13-5-了解执行模型"><a href="#13-5-了解执行模型" class="headerlink" title="13.5 了解执行模型"></a>13.5 了解执行模型</h3><h4 id="13-5-1-生产者－－－消费者模型"><a href="#13-5-1-生产者－－－消费者模型" class="headerlink" title="13.5.1 生产者－－－消费者模型"></a>13.5.1 生产者－－－消费者模型</h4><p>一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p><h4 id="13-5-2-读者－－－作者模型"><a href="#13-5-2-读者－－－作者模型" class="headerlink" title="13.5.2 读者－－－作者模型"></a>13.5.2 读者－－－作者模型</h4><p>当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的消息，这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。</p><p>挑战之处在于平衡读者线程和作者线程的需求，实现正确的操作，提供合理的吞吐量，避免线程饥饿。</p><h4 id="13-5-3哲学家问题（故事内容不在这里描述）"><a href="#13-5-3哲学家问题（故事内容不在这里描述）" class="headerlink" title="13.5.3哲学家问题（故事内容不在这里描述）"></a>13.5.3哲学家问题（故事内容不在这里描述）</h4><p>从哲学家问题可以反映出编写并发经常遇到的问题，死锁，活锁，吞吐量和效率降低等问题。那么学习这些基础问题的解决算法可以帮助你解决大多数的并发问题，因为大多的并发问题都是上述问题的变种。</p><h3 id="13-6-警惕同步方法之间的依赖"><a href="#13-6-警惕同步方法之间的依赖" class="headerlink" title="13.6 警惕同步方法之间的依赖"></a>13.6 警惕同步方法之间的依赖</h3><p>同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java语言有synchronized概念，可以用来保护单个方法。然而，如果在同一共享类中由多个同步方法，系统就可能写得不太正确了。</p><blockquote><p>建议：避免使用一个共享对象的多个方法。如果有时必须使用一个共享对象的多个方法。这种情况发生时，有３中写对代码的手段：</p></blockquote><ul><li>基于客户端的锁定－－客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码。</li><li>基于服务端的锁定－－在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新的方法。</li><li>适配服务端－－创建执行锁定的中间层。这是一种基于服务端的锁定例子，但不修改原始服务端代码。</li></ul><h3 id="13-7保持同步区域微小"><a href="#13-7保持同步区域微小" class="headerlink" title="13.7保持同步区域微小"></a>13.7保持同步区域微小</h3><p>应该尽可能少地设计临界区，如果有请尽可能减小同步区域。</p><h3 id="13-8-编写线程需要注意的几点："><a href="#13-8-编写线程需要注意的几点：" class="headerlink" title="13.8　编写线程需要注意的几点："></a>13.8　编写线程需要注意的几点：</h3><h4 id="1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"><a href="#1-将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。" class="headerlink" title="(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。"></a>(1). 将伪失败看作可能的线程问题。线程代码中的缺陷可能在一千或者一百万次执行中才会显现一次。所以，不要将系统错误归咎于偶发事件。</h4><h4 id="2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"><a href="#2-先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。" class="headerlink" title="(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。"></a>(2). 先使非线程代码可工作。确保线程之外的代码可以工作。不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可以工作。</h4><h4 id="3-编写可插拔的线程代码。编写在数个环境下运行的线程代码"><a href="#3-编写可插拔的线程代码。编写在数个环境下运行的线程代码" class="headerlink" title="(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码"></a>(3). 编写可插拔的线程代码。编写在数个环境下运行的线程代码</h4><ul><li>1.单线程与多线程在执行时不同的情况</li><li>2.线程代码与实物或测试替身互动</li><li>3.用运行速度,缓慢和有变动的测试替身执行</li><li>4.将测试配置为能运行一定数量的迭代</li></ul><blockquote><p>建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。</p></blockquote><h4 id="4-编写可调整的线程代码"><a href="#4-编写可调整的线程代码" class="headerlink" title="(4). 编写可调整的线程代码"></a>(4). 编写可调整的线程代码</h4><p>在系统运行时允许线程发生变动。允许线程依据吞吐量和使用率自我调整。</p><h4 id="5-运行多余处理器数量的线程"><a href="#5-运行多余处理器数量的线程" class="headerlink" title="(5). 运行多余处理器数量的线程"></a>(5). 运行多余处理器数量的线程</h4><p>任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。</p><h4 id="6-在不同平台上运行"><a href="#6-在不同平台上运行" class="headerlink" title="(6). 在不同平台上运行"></a>(6). 在不同平台上运行</h4><h4 id="7-调整代码并强迫错误发生"><a href="#7-调整代码并强迫错误发生" class="headerlink" title="(7). 调整代码并强迫错误发生"></a>(7). 调整代码并强迫错误发生</h4><h2 id="十三、第14章-逐步改进"><a href="#十三、第14章-逐步改进" class="headerlink" title="十三、第14章 逐步改进"></a>十三、第14章 逐步改进</h2><p>代码并不是一次就能写的很干净的，需要我们不断的迭代和优化。</p><h2 id="十四、第17章-味道与启发"><a href="#十四、第17章-味道与启发" class="headerlink" title="十四、第17章 味道与启发"></a>十四、第17章 味道与启发</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><h4 id="1-不恰当的注释信息"><a href="#1-不恰当的注释信息" class="headerlink" title="(1). 不恰当的注释信息"></a>(1). 不恰当的注释信息</h4><p>让注释传达本该更好地在源代码控制系统，问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。注释只应该描述有关代码和设计的技术性信息。</p><h4 id="2-废弃的注释"><a href="#2-废弃的注释" class="headerlink" title="(2). 废弃的注释"></a>(2). 废弃的注释</h4><p>过时，无关或不正确的注释就是废弃的注释。</p><h4 id="3-冗余注释"><a href="#3-冗余注释" class="headerlink" title="(3). 冗余注释"></a>(3). 冗余注释</h4><p>如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。注释应该谈及代码自身没有提到的东西。</p><h4 id="4-注释要写就要写最好的注释，别画蛇添足"><a href="#4-注释要写就要写最好的注释，别画蛇添足" class="headerlink" title="(4). 注释要写就要写最好的注释，别画蛇添足"></a>(4). 注释要写就要写最好的注释，别画蛇添足</h4><h4 id="5-注释掉的代码，看到注释掉的代码就删。"><a href="#5-注释掉的代码，看到注释掉的代码就删。" class="headerlink" title="(5). 注释掉的代码，看到注释掉的代码就删。"></a>(5). 注释掉的代码，看到注释掉的代码就删。</h4><h3 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h3><h4 id="1-需要多步才能实现的构建"><a href="#1-需要多步才能实现的构建" class="headerlink" title="(1). 需要多步才能实现的构建"></a>(1). 需要多步才能实现的构建</h4><p>构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四出寻找额外的小jar,xml文件和其他系统所需的杂物。你应该能够用单个命令签出系统，并单个指令构建它。</p><h4 id="2-需要多步才能做到测试"><a href="#2-需要多步才能做到测试" class="headerlink" title="(2). 需要多步才能做到测试"></a>(2). 需要多步才能做到测试</h4><p>你应该能够用单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速，轻易和直接了当地做到。</p><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h3><ul><li>函数的参数应该少。</li><li>输出参数违反直觉。如果非要修改，那就修改函数所在对象好了。</li><li>标示参数，布尔值参数宣告函数做了不止一件事，应该消灭掉，即函数只做一件事。</li><li>永不被调用的方法应该丢弃。</li></ul><h3 id="4-一般性问题"><a href="#4-一般性问题" class="headerlink" title="4. 一般性问题"></a>4. 一般性问题</h3><p>(1). 如果代码需要有多种语言，那么应该尽力减少源文件中额外语言的数量和范围。</p><p>(2). 明显的行为未被实现，如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。</p><p>(3). 不正确的边界行为，追索每种边界条件，编写测试。</p><p>(4). 忽视安全</p><p>(5). 重复，尽可能找到并消除重复。</p><p>(6). 在错误的抽象层级上的代码，创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。</p><p>(7). 基类不可多度依赖于派生类，基类应该对派生类一无所知。</p><p>(8). 信息过多，设计良好的模块有着非常小的接口，让你事半功倍。设计良好的接口并不提供许多需要依靠的函数，所以耦合度比较低。</p><p>优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。</p><p>(9). 死代码一定要删除。</p><p>(10). 垂直分隔，变量和函数应该在靠近被使用的地方定义。私有函数应该刚好在其首次被使用的位置下面定义。</p><p>(11). 前后不一致，从一而终即一旦选中，就小心持续遵循。如果在特定函数中用了response的变量来持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名。这样会让你的代码更易阅读。</p><p>(12). 混淆视听，没用的变量或者函数直接删掉，以免造成不必要的干扰。</p><p>(13). 人为耦合，不互相依赖的东西不该耦合。一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量，常量或函数不恰当地放在临时方便的位置。</p><p>(14). 特性依恋，类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。</p><p>(15). 选择算子参数，尽量不要把boolean作为函数参数</p><p>(16). 晦涩意图，代码要尽可能具有表达力。</p><p>(17). 位置错误的权责，我们可以采用最小惊异原则来帮助我们即代码应该放在读者自然而然期待它所在的地方。</p><p>(18). 不恰当的静态方法，对于没有机会打算让它有多态行为的函数可以作为动态函数，否则可选用静态函数。</p><p>(19). 使用解释性变量，命名要有意义。</p><p>(20). 函数名称应该表达其行为</p><p>(21). 理解算法</p><p>(22). 把逻辑依赖改为物理依赖：</p><ul><li>1.逻辑依赖：原始数据和业务逻辑之间的依赖关系。例如：定义的常量和业务逻辑存在着依赖关系或者说被捆绑在了一起，即当业务逻辑发生变化或者存在其他可能性的时候且定义的常量无法满足导致常量需要修改。</li><li>2.物理依赖：函数方法和业务逻辑之间的依赖关系。例如：为了解决逻辑依赖的问题，我们可以通过构造一个方法将数据和业务隔离。</li></ul><p>(23). 用多态替代<code>if/else</code> 或 <code>switch/case</code></p><p>(24). 遵循标准约定</p><p>(25). 用命名常量替代魔术数，魔术数不仅仅指的是数字，也泛指任何不能自我描述的符号。</p><p>(26). 准确，在可以用List的时候，非要把变量声明为ArrayList就过分拘束了。在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。代码中的含糊和不准确性要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。</p><p>(27). 结构甚于约定，坚守结构甚于约定的设计决策。</p><p>(28). 封装条件，如果没有if或while语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。</p><p>例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">shouldBeDeleted</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>要好于</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">.</span><span class="token function">hasExpired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer<span class="token punctuation">.</span><span class="token function">isRecurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>(29). 避免否定性条件，尽可能将条件表示为肯定形式。</p><p>(30). 函数只该做一件事</p><p>(31). 掩蔽时序耦合，排列函数参数，好让它们被调用的次序显而易见。</p><p>(32). 别随意，构建代码需要理由，而且理由应于代码结构相契合。</p><p>(33). 封装边界条件，把处理边界条件的代码集中到一处，不要散落于代码中。</p><p>(34). 函数应该只在一个抽象层级上，函数中的语句应该在同意抽象级上，该层级应该是函数名所示操作的下一层。</p><p>(35). 在较高层级放置可配置数据，如果你有个已知并在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。</p><p>(36). 避免传递浏览，编写害羞代码。</p><p>(37). 不要继承常量</p><h3 id="17-5-测试"><a href="#17-5-测试" class="headerlink" title="17.5 测试"></a>17.5 测试</h3><ol><li>使用覆盖率工具，覆盖率工具能汇报你测试策略中的缺口。使用测试覆盖率工具能更容易地找到不足的模块，类和函数。</li><li>别略过小测试</li><li>被忽略的测试就是对不确定事物的疑问。</li><li>测试边界条件</li><li>全面测试相近的缺陷，缺陷趋向于扎堆。</li><li>测试失败的模式有启发性。</li><li>测试覆盖率的模式有启发性，查看被或未被以通过的测试执行的代码，往往能发现失败的测试为何失败的线索。</li><li>测试应该快速。</li></ol><p>来自：<a href="http://www.uml.org.cn/codeNorms/201701162.asp" target="_blank" rel="noopener">代码整洁之道内容概要</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整洁代码 </tag>
            
            <tag> 重构 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之观察者模式</title>
      <link href="/2018/101432841.html"/>
      <url>/2018/101432841.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>观察者模式(<code>Observer Pattern</code>)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（<code>Publish</code>/<code>Subscribe</code>）模式、模型-视图（<code>Model</code>/<code>View</code>）模式、源-监听器（<code>Source</code>/<code>Listener</code>）模式或从属者（<code>Dependents</code>）模式。</p></blockquote><p>观察者模式是一种<strong>对象行为型模式</strong>。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>观察者模式包含如下角色：</p><ul><li><code>Subject</code>: 目标（抽象的被观察着）</li><li><code>ConcreteSubject</code>: 具体目标（具体的被观察者）</li><li><code>Observer</code>: 观察者</li><li><code>ConcreteObserver</code>: 具体观察者</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="http://static.blinkfox.com/Obeserver.jpg" alt="观察者模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="http://static.blinkfox.com/seq_Obeserver.jpg" alt="观察者模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是观察者接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者接口 * Created by blinkfox on 16/7/14. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 更新的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来，是具体的观察者类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的观察者. * * Created by blinkfox on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现更新方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到信息,并进行处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是被观察者的抽象类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被观察者的抽象类. * * Created by blinkfox on 16/7/14. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义一个观察者的集合. */</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 增加一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通知所有观察者.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer o<span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            o<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>具体的被观察者：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的被观察者. * * Created by blinkfox on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是用于测试观察者模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者模式客户端场景类. * * Created by blinkfox on 16/7/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个被观察者和观察者.</span>        ConcreteSubject sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Observer obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者观察被观察者.</span>        sub<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>obs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者开始活动了.</span>        sub<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅</strong>(<code>publish-subscribe</code>)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>观察者模式的优点：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>观察者模式的缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><blockquote><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li><li>在JDK的<code>java.util</code>包中，提供了<code>Observable</code>类以及<code>Observer</code>接口，它们构成了Java语言对观察者模式的支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Java编程风格指南</title>
      <link href="/2018/10056920.html"/>
      <url>/2018/10056920.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>这份文档是<code>Google Java</code>编程风格规范的完整定义。当且仅当一个<code>Java</code>源文件符合此文档中的规则，我们才认为它符合<code>Google</code>的<code>Java</code>编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>本文档中除非特殊说明，否则：</p><ul><li>术语<code>class</code>可表示一个普通类、枚举类、接口或者注解。</li><li>术语<code>comment</code>只用来指代实现的注释(<code>implementation comments</code>)，我们不使用文档注释(<code>documentation comments</code>)一词，而是用<code>Javadoc</code>。</li></ul><p>其他术语说明，将在文档中需要说明的地方单独说明。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2 源文件基础"></a>2 源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式使用<code>UTF-8</code>。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空格字符"><a href="#2-3-1-空格字符" class="headerlink" title="2.3.1 空格字符"></a>2.3.1 空格字符</h4><p>除了换行符外，<code>ASCII</code>水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着：</p><ul><li>所有其他空白字符将被转义。</li><li><code>Tab</code>字符不被用作缩进控制。</li></ul><h4 id="2-3-2-特殊转义字符串"><a href="#2-3-2-特殊转义字符串" class="headerlink" title="2.3.2 特殊转义字符串"></a>2.3.2 特殊转义字符串</h4><p>任何需要转义字符串表示的字符（例如：<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>\&#39;</code>, <code>\\</code>等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 <code>\012</code>）或<code>Unicode</code>码（例如：<code>\u000a</code>）表示。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于其余非<code>ASCII</code>字符，直接使用<code>Unicode</code>字符（例如 <code>∞</code>），或者使用对应的<code>Unicode</code>码（例如：<code>\u221e</code>）转义，都是允许的。<strong>唯一需要考虑的是，何种方式更能使代码容易阅读和理解</strong>。</p><blockquote><p><strong>注意</strong>：在使用<code>Unicode</code>码转义，或者甚至是有时直接使用<code>Unicode</code>字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。</p></blockquote><p>例子：</p><table><thead><tr><th>示例</th><th>结论</th></tr></thead><tbody><tr><td>String unitAbbrev = “μs”;</td><td>赞：即使没有注释也非常清晰。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // “μs”</td><td>允许，但没有理由要这样做。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td><td>允许，但这样做显得笨拙还容易出错。</td></tr><tr><td>String unitAbbrev = “\u03bcs”;</td><td>很糟：读者根本看不出这是什么。</td></tr><tr><td>return ‘\ufeff’ + content; // byte order mark</td><td>很好：对于非打印字符，使用转义，并在必要时写上注释。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：永远不要由于害怕某些程序可能无法正确处理非<code>ASCII</code>字符而让你的代码可读性变差。当程序无法正确处理非<code>ASCII</code>字符时，它自然无法正确运行，你就会去<code>fix</code>这些问题的了。(言下之意就是大胆去用非<code>ASCII</code>字符，如果真的有需要的话)</p></blockquote><h2 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3 源文件结构"></a>3 源文件结构</h2><p>源文件按照先后顺序，由以下几部分组成：</p><ul><li>许可证(<code>License</code>)或版权信息(<code>copyright</code>)（如果需要）</li><li><code>package</code>语句</li><li><code>import</code>语句</li><li><code>class</code>类声明（每个源码文件只能有唯一一个顶级<code>class</code>）。</li></ul><blockquote><p><strong>注意</strong>：以上每个部分之间应该只有<strong>一个空行</strong>作为间隔。</p></blockquote><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p><code>package</code>语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不使用通配符"><a href="#3-3-1-import不使用通配符" class="headerlink" title="3.3.1 import不使用通配符"></a>3.3.1 import不使用通配符</h4><p><code>import</code>语句中不应该使用通配符，不管是否是静态导入。</p><h4 id="3-3-2-import不换行"><a href="#3-3-2-import不换行" class="headerlink" title="3.3.2 import不换行"></a>3.3.2 import不换行</h4><p><code>import</code>语句不换行，列限制(4.4节)并不适用于<code>import</code>语句。(每个<code>import</code>语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p><code>import</code>语句可分为以下几组，按照顺序，每组由<strong>一个空行</strong>分隔：</p><ul><li>所有的静态导入(static import)归为一组</li><li><code>com.google</code>包的<code>import</code>归为一组</li><li>使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：<code>android</code>, <code>com</code>, <code>junit</code>, <code>org</code>, <code>sun</code></li><li><code>java</code>包归为一组</li><li><code>javax</code>包归为一组</li></ul><blockquote><p><strong>注意</strong>：同一组内的<code>import</code>语句之间不应用空行隔开，同一组中的<code>import</code>语句按字典序排列。</p></blockquote><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只声明唯一一个顶级class"><a href="#3-4-1-只声明唯一一个顶级class" class="headerlink" title="3.4.1 只声明唯一一个顶级class"></a>3.4.1 只声明唯一一个顶级class</h4><p>每个源文件中只能有一个顶级class。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。</p><p>最重要的一点，<strong>每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑</strong>。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。</p><h2 id="4-格式"><a href="#4-格式" class="headerlink" title="4 格式"></a>4 格式</h2><blockquote><p><strong>术语说明</strong>：块状结构(<code>block-­like construct</code>)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p></blockquote><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号一般用在<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>等语句，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空语句块采用K-amp-R风格"><a href="#4-1-2-非空语句块采用K-amp-R风格" class="headerlink" title="4.1.2 非空语句块采用K&amp;R风格"></a>4.1.2 非空语句块采用<code>K&amp;R</code>风格</h4><p>对于非空语句块，大括号遵循<code>Kernighan</code>和<code>Ritchie</code>风格 (<a href="https://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号结束是一个<code>语句块</code>或者<code>方法体</code>、<code>构造函数体</code>或者<code>有命名的类体</code>，则需要换行。当右括号后面接<code>else</code>或者<code>逗号</code>时，不应该换行。</li></ul><p>示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ProblemException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">otherCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">somethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">lastThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>一些例外的情况，将在<code>4.8.1</code>节讲<code>枚举类型</code>的时候讲到。</p><h4 id="4-1-3-空语句块：使代码更简洁"><a href="#4-1-3-空语句块：使代码更简洁" class="headerlink" title="4.1.3 空语句块：使代码更简洁"></a>4.1.3 空语句块：使代码更简洁</h4><p>一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：<code>if/else</code> 或者<code>try/catch/finally</code>）.</p><p>示例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是可接受的</span><span class="token keyword">void</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这同样是可接受的</span><span class="token keyword">void</span> <span class="token function">doNothingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是不可接受的：多块语句中没有简洁的空语句块</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="4-2块缩进：2个空格"><a href="#4-2块缩进：2个空格" class="headerlink" title="4.2块缩进：2个空格"></a>4.2块缩进：2个空格</h3><p>每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。</p><blockquote><p><strong>注意</strong>：根据实际的编程经验，<code>2</code>个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码<code>臃肿</code>不够美观。所以，我这里建议使用<code>4</code>个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。</p></blockquote><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每条语句结束都需要换行。</p><h3 id="4-4-列长度限制：100"><a href="#4-4-列长度限制：100" class="headerlink" title="4.4 列长度限制：100"></a>4.4 列长度限制：100</h3><p>Java代码的列长度限制为<code>100个</code>字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。</p><p>例外：</p><ul><li>不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)</li><li>注释中那些可能被剪切并粘贴到shell中的命令行</li></ul><blockquote><p><strong>注意</strong>：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，<code>100</code>个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用<code>120</code>个字符的宽度更为合适。</p></blockquote><h3 id="4-5-换行"><a href="#4-5-换行" class="headerlink" title="4.5 换行"></a>4.5 换行</h3><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(<code>100</code>个字符)而被分为多行，我们称之为断行(<code>line­-wrapping</code>)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。</p><blockquote><p><strong>注意</strong>: 提取<code>方法</code>或<code>局部变量</code>可以解决问题，而不不需要进行断行。</p></blockquote><h4 id="4-5-1-在何处断行"><a href="#4-5-1-在何处断行" class="headerlink" title="4.5.1 在何处断行"></a>4.5.1 在何处断行</h4><p>断行的主要原则是：<strong>选择在更高级的语法逻辑处断行</strong>。其他一些原则如下：</p><ul><li>当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。</li><li>如果要在非赋值运算符处断行，那么在该符号前断开(比如<code>+</code>操作符，它将位于下一行)。以下的<code>类运算符</code>也可作为参考：<ul><li>点操作符<code>.</code></li><li>类型界限中的<code>&amp;</code>、<code>||</code>等（例如：<code>&lt;T extends Foo &amp; Bar&gt;</code>)</li></ul></li><li>当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：<code>=</code>，它与前面的内容留在同一行)。<ul><li>这条规则也适用于<code>foreach</code>语句中的冒号。</li></ul></li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(<code>,</code>)与其前面的内容留在同一行。也就是在逗号之后断行。</li><li><code>Lambda</code>表达式在箭头符号(<code>-&gt;</code>)后断行。</li></ul><p>示例：</p><pre class=" language-java"><code class="language-java">MyLambda<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token punctuation">,</span> Object<span class="token operator">></span> lambda <span class="token operator">=</span>    <span class="token punctuation">(</span>String label<span class="token punctuation">,</span> Long value<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> str <span class="token operator">-</span><span class="token operator">></span>    <span class="token function">longExpressionInvolving</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注意</strong>：换行的主要目标是使代码更清晰易读。</p></blockquote><h4 id="4-5-2-断行的缩进：至少-4个空格"><a href="#4-5-2-断行的缩进：至少-4个空格" class="headerlink" title="4.5.2 断行的缩进：至少+4个空格"></a>4.5.2 断行的缩进：至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进<code>4</code>个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只<code>4</code>个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用单行空行：</p><ul><li>类成员之间需要单个空行隔开：例如：<code>字段</code>，<code>构造函数</code>，<code>方法</code>，<code>嵌套类</code>，<code>静态初始化块</code>，<code>实例初始化块</code>。但也有以下两种例外情况：<ul><li>两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。</li><li>枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。</li></ul></li><li>在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。</li><li>类的第一个成员之前或最后一个成员之后，使用空行(可选)。</li><li>本文档所介绍的其他章节的空行要求(比如3.3节：<code>import</code>语句)。</li></ul><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现：</p><ul><li>所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：<code>if</code>, <code>for</code> <code>catch</code>等)</li><li>所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：<code>else</code>、<code>catch</code>）</li><li>在左大括号之前都需要空格隔开。只有两种例外：<ul><li><code>@SomeAnnotation({a, b})</code></li><li><code>String[][] x = foo;</code></li></ul></li><li>所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：<code>a + b</code>、<code>b = a &lt; 0 ? 0 : a</code>)</li><li>逗号(<code>,</code>)、冒号(<code>:</code>)、分号(<code>;</code>)和右小括号(<code>)</code>)、Lambda箭头符号(<code>-&gt;</code>)之后，需要空格隔开。</li><li><code>//</code>双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：<code>a = 0; // 赋值为0</code>）</li><li>变量声明时，变量类型和变量名之间需要用空格隔开。（例如：<code>List&lt;String&gt; list</code>）</li><li>初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>）</li></ul><blockquote><p><strong>注意</strong>：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><blockquote><p><strong>术语说明</strong>：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。</p></blockquote><p>这种对齐是被允许的，但是不会做强制要求。</p><p>以下是没有水平对齐和水平对齐的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 这种挺好</span><span class="token keyword">private</span> Color color<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 同上</span><span class="token keyword">private</span> <span class="token keyword">int</span>   x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 允许，但是未来会继续编辑</span><span class="token keyword">private</span> Color color<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可能会使它对不齐</span></code></pre><blockquote><p><strong>注意</strong>：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为<strong>爆炸半径</strong>。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码<code>review</code>的速度，引起更多<code>merge</code>代码冲突的情况。</p></blockquote><h3 id="4-7-分组小括号：推荐使用"><a href="#4-7-分组小括号：推荐使用" class="headerlink" title="4.7 分组小括号：推荐使用"></a>4.7 分组小括号：推荐使用</h3><p>除非作者和<code>reviewer</code>都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-特殊结构"><a href="#4-8-特殊结构" class="headerlink" title="4.8 特殊结构"></a>4.8 特殊结构</h3><h4 id="4-8-1-枚举类型"><a href="#4-8-1-枚举类型" class="headerlink" title="4.8.1 枚举类型"></a>4.8.1 枚举类型</h4><p>枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Answer <span class="token punctuation">{</span>    YES <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"yes"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    NO<span class="token punctuation">,</span>    MAYBE<span class="token punctuation">}</span></code></pre><p>没有方法和Javadoc的枚举类可写成数组初始化的格式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Suit <span class="token punctuation">{</span> CLUBS<span class="token punctuation">,</span> HEARTS<span class="token punctuation">,</span> SPADES<span class="token punctuation">,</span> DIAMONDS <span class="token punctuation">}</span></code></pre><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次声明一个变量"><a href="#4-8-2-1-每次声明一个变量" class="headerlink" title="4.8.2.1 每次声明一个变量"></a>4.8.2.1 每次声明一个变量</h5><p>不要使用组合声明。例如：<code>int a, b;</code>是不允许的。</p><h5 id="4-8-2-2-需要时才声明，尽快进行初始化"><a href="#4-8-2-2-需要时才声明，尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，尽快进行初始化"></a>4.8.2.2 需要时才声明，尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，例如以下格式的写法都是允许的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>           <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>            <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span>                       <span class="token number">1</span><span class="token punctuation">,</span>                        <span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>             <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>               <span class="token punctuation">}</span>  <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>                     <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                          <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p><strong>术语说明</strong>：<code>switch</code>块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>和其他语句块一样，<code>switch</code>大括号之后缩进两个字符。每个<code>switch</code>标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。</p><h5 id="4-8-4-2-继续向下执行的注释"><a href="#4-8-4-2-继续向下执行的注释" class="headerlink" title="4.8.4.2 继续向下执行的注释"></a>4.8.4.2 继续向下执行的注释</h5><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>抛出异常</code>来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token function">prepareOneOrTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// fall through</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>        <span class="token function">handleOneTwoOrThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token function">handleLargeNumber</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注意</strong>：在<code>case 1</code>之后不需要该注释，仅在语句组的末尾。</p></blockquote><h5 id="4-8-4-3-default标签需要显式声明"><a href="#4-8-4-3-default标签需要显式声明" class="headerlink" title="4.8.4.3 default标签需要显式声明"></a>4.8.4.3 default标签需要显式声明</h5><p>每个<code>switch</code>语句中，都需要显式声明<code>default</code>标签。即使没有任何代码也需要显示声明。</p><blockquote><p><strong>注意</strong>：枚举类型的<code>switch</code>语句可以省略<code>default</code>语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。</p></blockquote><h4 id="4-8-5-注解"><a href="#4-8-5-注解" class="headerlink" title="4.8.5 注解"></a>4.8.5 注解</h4><p>注解应用到类、方法或者构造方法时，应紧接<code>Javadoc</code>之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> String <span class="token function">getNameIfPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p><strong>例外</strong>：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>注解应用到成员变量时，也是紧接<code>Javadoc</code>之后。不同的是，多个注解可以放在同一行。例如：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Partial</span> <span class="token annotation punctuation">@Mock</span> DataLoader loader<span class="token punctuation">;</span></code></pre><p>对于参数或者局部变量使用注解的情况，没有特定的规范。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>注释的缩进与它所注释的代码缩进相同。可以采用<code>/* */</code>进行注释，也可以用<code>//</code>进行注释。当使用<code>/* */</code>进行多行注释时，每一行都应该以<code>*</code>开始，并且<code>*</code>应该上下对齐。</p><p>例如：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* * This is * okay. */</span><span class="token comment" spellcheck="true">// And so</span><span class="token comment" spellcheck="true">// is this.</span><span class="token comment" spellcheck="true">/* Or you can * even do this. */</span></code></pre><blockquote><p><strong>注意</strong>：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用<code>/* */</code>，<code>//</code>一般不会自动对齐。</p></blockquote><h4 id="4-8-7-修饰符"><a href="#4-8-7-修饰符" class="headerlink" title="4.8.7 修饰符"></a>4.8.7 修饰符</h4><p>类和成员变量的修饰符，按<code>Java Lauguage Specification</code>中介绍的先后顺序排序。具体是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">protected</span> <span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">default</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">synchronized</span> <span class="token keyword">native</span> <span class="token keyword">strictfp</span></code></pre><h4 id="4-8-8-数字字面量"><a href="#4-8-8-数字字面量" class="headerlink" title="4.8.8 数字字面量"></a>4.8.8 数字字面量</h4><p>长整型的数字字面量使用大写的<code>L</code>作为后缀，不得使用小写（以免与数字1混淆）。例如：使用<code>3000000000L</code>，而不是<code>3000000000l</code>。</p><h2 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5 命名约定"></a>5 命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用<code>ASCII</code>字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用<code>com.example.deepspace</code>，而不是<code>com.example.deepSpace</code>或者<code>com.example.deep_space</code>。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语。例如：<code>Character</code>或者<code>ImmutableList</code>。接口名称也可以是名词或名词短语（例如：<code>List</code>），但有时可能是形容词或形容词短语（例如：<code>Readable</code>）。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如：<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。例如：<code>sendMessage</code>或者<code>stop</code>。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如：<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？</p><p>每个常量都是一个静态<code>final</code>字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 常量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableList<span class="token operator">&lt;</span>String<span class="token operator">></span> NAMES <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> AGES <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Joiner COMMA_JOINER <span class="token operator">=</span> Joiner<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为Joiner是不可变的</span><span class="token keyword">static</span> <span class="token keyword">final</span> SomeMutableType<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> SomeEnum <span class="token punctuation">{</span> ENUM_CONSTANT <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 非常量</span><span class="token keyword">static</span> String nonFinal <span class="token operator">=</span> <span class="token string">"non-final"</span><span class="token punctuation">;</span><span class="token keyword">final</span> String nonStatic <span class="token operator">=</span> <span class="token string">"non-static"</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> mutableCollection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableSet<span class="token operator">&lt;</span>SomeMutableType<span class="token operator">></span> mutableElements <span class="token operator">=</span> ImmutableSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>mutable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> SomeMutableType<span class="token operator">></span> mutableValues <span class="token operator">=</span>    ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> mutableInstance<span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> mutableInstance2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> nonEmptyArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"these"</span><span class="token punctuation">,</span> <span class="token string">"can"</span><span class="token punctuation">,</span> <span class="token string">"change"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这些常量的名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。例如：<code>computedValues</code>或者<code>index</code>。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以<code>lowerCamelCase</code>风格编写。</p><p>即使局部变量是<code>final</code>和<code>不可改变</code>的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以视具体情况跟一个数字(如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：<code>RequestT</code>, <code>FooBarT</code>)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p><strong>驼峰式命名法</strong>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：<code>IPv6</code>或<code>iOS</code>)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ul><li>把短语转换为纯<code>ASCII</code>码，并且移除任何单引号。例如：<code>Müller’s algorithm</code>将变成<code>Muellers algorithm</code>。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li><strong>推荐</strong>：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如<code>AdWords</code>将分割成<code>ad words</code>)。 </li><li>需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ul><p>示例：</p><table><thead><tr><th>散文形式</th><th>正确</th><th>不正确</th></tr></thead><tbody><tr><td>“XML HTTP request”</td><td>XmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>“new customer ID”</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>“inner stopwatch”</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>“supports IPv6 on iOS?”</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>“YouTube importer”</td><td>YouTubeImporter YoutubeImporter^</td><td>无</td></tr></tbody></table><p>加<code>^</code>号处表示可以，但不推荐。</p><blockquote><p><strong>注意</strong>：在英语中，某些带有连字符的单词形式不唯一。例如：<code>nonempty</code>和<code>non-empty</code>都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h2 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6 编程实践"></a>6 编程实践</h2><h3 id="6-1-Override：总是使用"><a href="#6-1-Override：总是使用" class="headerlink" title="6.1 @Override：总是使用"></a>6.1 <code>@Override</code>：总是使用</h3><p>只要是合法的方法，就把<code>@Override</code>注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。</p><p><strong>例外</strong>：当父方法为<code>@Deprecated</code>时，可以省略<code>@Override</code>。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">handleNumericResponse</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 它不是一个数字，不过没关系，继续</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">handleTextResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    emptyStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchElementException</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>6.3 静态成员：使用类来调用</p><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><pre class=" language-java"><code class="language-java">Foo aFoo <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>Foo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 好</span>aFoo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 糟</span><span class="token function">somethingThatYieldsAFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 很糟</span></code></pre><p>6.4 <code>Finalizers</code>: 禁用</p><p>极少会去重载<code>Object.finalize</code>。</p><blockquote><p><strong>注意</strong>：不要使用<code>finalize</code>。如果你非要使用它，请先仔细阅读和理解<code>Effective Java第7条款</code>：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h2 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7 Javadoc"></a>7 Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p><code>Javadoc</code>块的基本格式如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Multiple lines of Javadoc text are written here, * wrapped normally... */</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span>String p1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>或者是以下单行形式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** An especially short bit of Javadoc. */</span></code></pre><p>基本格式总是可以接受的。当整个<code>Javadoc</code>块能容纳于一行时(且没有标记<code>@XXX</code>)，就可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(只包含最左侧星号的行)会出现在段落之间和<code>Javadoc</code>标记(<code>@XXX</code>)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的<code>Javadoc</code>标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进<code>4</code>个空格(<strong>注</strong>：如果你的缩进统一采用采用<code>4</code>个空格，那么这里就应该是<code>8</code>个空格)。</p><h4 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h4><p>每个类或成员的<code>Javadoc</code>以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或者<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record.</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p><strong>注意</strong>：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h3 id="7-3-在哪里使用Javadoc"><a href="#7-3-在哪里使用Javadoc" class="headerlink" title="7.3 在哪里使用Javadoc"></a>7.3 在哪里使用Javadoc</h3><p>至少在每个<code>public</code>类及它的每个<code>public</code>和<code>protected</code>成员处使用<code>Javadoc</code>，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，<code>Javadoc</code>是可选的(可以不写)。这种情况下除了写<code>Returns the foo</code>，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p><strong>注意</strong>：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么<code>Javadoc</code>并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用<code>Javadoc</code>的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成<code>Javadoc</code>，这样更统一更友好。</p><p>原文地址: <a href="http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html" target="_blank" rel="noopener">Google Java Style Guide</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git知识点整理</title>
      <link href="/2018/092433617.html"/>
      <url>/2018/092433617.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git基本概念。"><a href="#1-Git基本概念。" class="headerlink" title="1. Git基本概念。"></a>1. Git基本概念。</h2><ul><li><code>repository</code></li><li><code>config</code></li><li><code>init</code></li><li><code>clone</code></li><li><code>fetch</code></li><li><code>pull</code></li><li><code>commit</code></li><li><code>push</code></li><li><code>branch</code></li><li><code>head</code></li><li><code>tag</code></li><li><code>merge</code></li><li><code>conflict</code></li><li><code>diff</code></li><li><code>log</code></li><li><code>show</code></li><li><code>status</code></li></ul><h2 id="2-Git工作空间和文件状态"><a href="#2-Git工作空间和文件状态" class="headerlink" title="2. Git工作空间和文件状态"></a>2. Git工作空间和文件状态</h2><h3 id="1-工作空间"><a href="#1-工作空间" class="headerlink" title="(1).工作空间"></a>(1).工作空间</h3><p>![Git工作空间][1]</p><p>左侧为工作区，右侧为版本库。</p><ul><li>工作区（<code>Working Directory</code>） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。</li><li>版本库（<code>Repository</code>）工作区有一个隐藏目录<code>.git</code>，是Git的版本库。</li></ul><p>在版本库中标记为<code>index</code>的区域为暂存区，标记为<code>master</code>的是Git为我们自动创建的第一个分支，代表的是目录树。此时<code>HEAD</code>实际是指向<code>master</code>分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用<code>master</code>来替换。图中的objects标识的区域为git的对象库，实际位于<code>.git/objects</code>目录下。</p><ul><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行<code>git rm --cached</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行<code>git checkout .</code>或<code>git checkout --</code> 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。</li><li>当执行<code>git checkout HEAD .</code>或<code>git checkout HEAD</code>命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</li></ul><h3 id="1-文件状态"><a href="#1-文件状态" class="headerlink" title="(1).文件状态"></a>(1).文件状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：<strong>已提交(<code>committed</code>)</strong>、<strong>已修改(<code>modified</code>)</strong>和<strong>已暂存(<code>staged</code>)</strong>。</p><h2 id="3-Git配置系统级、全局、当前仓库用户名、邮箱的命令"><a href="#3-Git配置系统级、全局、当前仓库用户名、邮箱的命令" class="headerlink" title="3. Git配置系统级、全局、当前仓库用户名、邮箱的命令"></a>3. Git配置系统级、全局、当前仓库用户名、邮箱的命令</h2><p>系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"Jerry Mouse"</span><span class="token function">git</span> config --global user.email <span class="token string">"jerry@yiibai.com"</span></code></pre><p>列出Git设置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span class="token function">git</span> config -l</code></pre><h2 id="4-Git-fetch和pull的区别"><a href="#4-Git-fetch和pull的区别" class="headerlink" title="4. Git fetch和pull的区别"></a>4. Git fetch和pull的区别</h2><ul><li><code>git fetch</code>：相当于是从远程获取最新版本到本地，不会自动merge.</li><li><code>git pull</code>：相当于是从远程获取最新版本并merge到本地.</li></ul><h3 id="1-git-fetch示例："><a href="#1-git-fetch示例：" class="headerlink" title="(1). git fetch示例："></a>(1). git fetch示例：</h3><pre class=" language-bash"><code class="language-bash">Git fetch origin master<span class="token function">git</span> log -p master<span class="token punctuation">..</span>origin/master<span class="token function">git</span> merge origin/master</code></pre><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li><li>上述过程其实可以用以下更清晰的方式来进行：</li></ul><h3 id="1-git-pull示例："><a href="#1-git-pull示例：" class="headerlink" title="(1). git pull示例："></a>(1). git pull示例：</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master</code></pre><p>上述命令其实相当于<code>git fetch</code>和<code>git merge</code>。在实际使用中，<code>git fetch</code>更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p><h2 id="5-Git-reset和revert的却别"><a href="#5-Git-reset和revert的却别" class="headerlink" title="5. Git reset和revert的却别"></a>5. Git reset和revert的却别</h2><ul><li><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。 </li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li><code>git reset</code>是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li><li>git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。</li></ul><p>另外，说一下<code>git revert</code>， <code>git reset –hard</code>和 <code>–soft</code>的区别</p><ul><li><code>git reset –mixed id</code>: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。</li><li><code>git reset –soft id</code>: 实际上，是<code>git reset –mixed id</code>后，又做了一次<code>git add</code>。</li><li><code>git reset –herd id</code>: 是将git的HEAD变了，文件也变了。</li></ul><h2 id="6-Git-merge和reabse的相同点和不同点"><a href="#6-Git-merge和reabse的相同点和不同点" class="headerlink" title="6. Git merge和reabse的相同点和不同点"></a>6. Git merge和reabse的相同点和不同点</h2><p><code>merge</code>是合并的意思，<code>rebase</code>是复位基底的意思，相同点都是用来合并分支的。</p><p>![merge和rebase][2]</p><p>不同点:</p><ul><li><code>merge</code>操作会生成一个新的节点，之前的提交分开显示。而<code>rebase</code>操作不会生成新的节点，是将两个分支融合成一个线性的提交。</li><li>解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而<code>rebase</code>操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li><li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是”获取”和”合并”。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</li></ul><p><strong>总结</strong>：选择 merge 还是 rebase？</p><ul><li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li><li>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面</li><li>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面</li><li>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面</li><li>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定</li><li>merge 和 rebase 还有很多强大的选项，可以使用 git help <command> 查看</li></ul><h2 id="7-Git-stash是什么？它的相关使用方式命令"><a href="#7-Git-stash是什么？它的相关使用方式命令" class="headerlink" title="7. Git stash是什么？它的相关使用方式命令"></a>7. Git stash是什么？它的相关使用方式命令</h2><ul><li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li><li>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li><li>git stash pop –index stash@{0}: 恢复编号为0的进度的工作区和暂存区。</li><li>git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来</li><li>git stash drop[<stash>] 删除某一个进度，默认删除最新进度</stash></li><li>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li><li>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复工作进度</span><span class="token function">git</span> stash pop <span class="token punctuation">[</span>--index<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>stash<span class="token operator">></span><span class="token punctuation">]</span>--index 参数：不仅恢复工作区，还恢复暂存区<span class="token operator">&lt;</span>stash<span class="token operator">></span> 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度<span class="token comment" spellcheck="true"># 这是git stash保存进度的完整命令形式</span><span class="token function">git</span> stash <span class="token punctuation">[</span>save message<span class="token punctuation">]</span> <span class="token punctuation">[</span>-k<span class="token operator">|</span>--no-keep-index<span class="token punctuation">]</span> <span class="token punctuation">[</span>--patch<span class="token punctuation">]</span>-k和--no-keep-index指定保存进度后，是否重置暂存区--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似使用save可以对进度添加备注<span class="token comment" spellcheck="true"># git stash save "这是保存的进度"</span></code></pre><h2 id="8-Git只从暂存区删除，从工作空间删除的命令分别是什么"><a href="#8-Git只从暂存区删除，从工作空间删除的命令分别是什么" class="headerlink" title="8. Git只从暂存区删除，从工作空间删除的命令分别是什么?"></a>8. Git只从暂存区删除，从工作空间删除的命令分别是什么?</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> --cached<span class="token function">git</span> <span class="token function">rm</span><span class="token function">git</span> commit</code></pre><h2 id="9-Git标签的使用"><a href="#9-Git标签的使用" class="headerlink" title="9. Git标签的使用"></a>9. Git标签的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出现有的标签</span><span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 打标签</span><span class="token function">git</span> tag -a v1.01 -m <span class="token string">"Relase version 1.01"</span><span class="token comment" spellcheck="true"># 查看相应标签的版本信息</span><span class="token function">git</span> show v1.4</code></pre><ul><li>-a 选项,创建一个含附注类型的标签</li><li>-m 选项,指定了对应的标签说明</li></ul><h2 id="9-Git分支的使用"><a href="#9-Git分支的使用" class="headerlink" title="9. Git分支的使用"></a>9. Git分支的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看本地分支</span><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 查看远程分支</span><span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 创建本地分支(注意新分支创建后不会自动切换为当前分支)</span><span class="token function">git</span> branch <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换分支</span><span class="token function">git</span> checkout <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 创建新分支并立即切换到新分支</span><span class="token function">git</span> checkout -b <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强制删除一个分支</span><span class="token function">git</span> branch -D <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并分支(将名称为[name]的分支与当前分支合并)</span><span class="token function">git</span> merge <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看各个分支最后提交信息</span><span class="token function">git</span> br -v<span class="token comment" spellcheck="true"># 查看已经被合并到当前分支的分支</span><span class="token function">git</span> br --merged<span class="token comment" spellcheck="true"># 查看尚未被合并到当前分支的分支</span><span class="token function">git</span> br --no-merged</code></pre><h2 id="10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"><a href="#10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。" class="headerlink" title="10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"></a>10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。</h2><p>merge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个<code>git checkout upstream</code>的过程，将<code>HEAD</code>从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。</p><h2 id="11-Git远程操作相关"><a href="#11-Git远程操作相关" class="headerlink" title="11. Git远程操作相关"></a>11. Git远程操作相关</h2><h3 id="1-clone"><a href="#1-clone" class="headerlink" title="(1). clone"></a>(1). clone</h3><blockquote><p>git clone &lt;版本库的网址&gt;<br>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆jQuery的版本库</span> <span class="token function">git</span> clone https://github.com/jquery/jquery.git <span class="token function">git</span> clone -o jQuery https://github.com/jquery/jquery.git</code></pre><h3 id="2-remote"><a href="#2-remote" class="headerlink" title="(2). remote"></a>(2). remote</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有远程主机</span><span class="token function">git</span> remote<span class="token comment" spellcheck="true"># 使用-v选项，可以参看远程主机的网址</span><span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 可以查看该主机的详细信息</span><span class="token function">git</span> remote show <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 添加远程主机</span><span class="token function">git</span> remote add <span class="token operator">&lt;</span>主机名<span class="token operator">></span> <span class="token operator">&lt;</span>网址<span class="token operator">></span><span class="token comment" spellcheck="true"># 删除远程主机</span><span class="token function">git</span> remote <span class="token function">rm</span> <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 修改远程主机名称</span><span class="token function">git</span> remote <span class="token function">rename</span> <span class="token operator">&lt;</span>原主机名<span class="token operator">></span> <span class="token operator">&lt;</span>新主机名<span class="token operator">></span></code></pre><h3 id="3-fetch"><a href="#3-fetch" class="headerlink" title="(3). fetch"></a>(3). fetch</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回所有分支(branch)的更新到本地</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回某的特定分支的更新</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回origin主机的master分支的更新</span><span class="token function">git</span> fetch origin master<span class="token comment" spellcheck="true"># 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支</span><span class="token function">git</span> merge origin/master<span class="token function">git</span> rebase origin/master</code></pre><h3 id="4-pull"><a href="#4-pull" class="headerlink" title="(4). pull"></a>(4). pull</h3><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回origin主机的next分支，与本地的master分支合并</span><span class="token function">git</span> pull origin next:master<span class="token comment" spellcheck="true"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><span class="token function">git</span> pull origin next<span class="token comment" spellcheck="true"># 上面的命令实质上等同于先做git fetch，再做git merge。</span><span class="token function">git</span> fetch origin<span class="token function">git</span> merge origin/next<span class="token comment" spellcheck="true"># 合并需要采用rebase模式</span><span class="token function">git</span> pull --rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">></span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">></span></code></pre><h3 id="5-push"><a href="#5-push" class="headerlink" title="(5). push"></a>(5). push</h3><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><p><strong>注意</strong>:分支推送顺序的写法是”&lt;来源地&gt;:&lt;目的地&gt;”，所以git pull是”&lt;远程分支&gt;:&lt;本地分支&gt;”，而git push是”&lt;本地分支&gt;:&lt;远程分支&gt;”。</p><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建</span><span class="token function">git</span> push origin master<span class="token comment" spellcheck="true"># 省略了本地分支，以下等同，删除origin主机的master分支</span><span class="token function">git</span> push origin :master<span class="token function">git</span> push origin --delete master<span class="token comment" spellcheck="true"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略</span><span class="token function">git</span> push origin<span class="token comment" spellcheck="true"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><span class="token function">git</span> push<span class="token comment" spellcheck="true"># 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push</span><span class="token function">git</span> push -u origin master<span class="token comment" spellcheck="true"># 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机</span><span class="token function">git</span> push --all origin<span class="token comment" spellcheck="true"># 强制推送</span><span class="token function">git</span> push --force origin<span class="token comment" spellcheck="true"># git push不会推送标签(tag)，除非使用–tags选项</span><span class="token function">git</span> push origin --tags</code></pre><h2 id="12-Git-Flow使用简介"><a href="#12-Git-Flow使用简介" class="headerlink" title="12. Git Flow使用简介"></a>12. Git Flow使用简介</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><p>三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是[Git flow][3]。</p><p>它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。</p><h3 id="1-Git-Flow流程图"><a href="#1-Git-Flow流程图" class="headerlink" title="(1). Git Flow流程图"></a>(1). Git Flow流程图</h3><p>![Git Flow流程图][4]</p><h3 id="2-Git-Flow常用的分支"><a href="#2-Git-Flow常用的分支" class="headerlink" title="(2). Git Flow常用的分支"></a>(2). Git Flow常用的分支</h3><ul><li><code>Production</code>分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。</li><li><code>Develop</code>分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。</li><li><code>Feature</code>分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li><li><code>Release</code>分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li><li><code>Hotfix</code>分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li></ul><h3 id="3-Git-Flow代码示例"><a href="#3-Git-Flow代码示例" class="headerlink" title="(3). Git Flow代码示例"></a>(3). Git Flow代码示例</h3><h4 id="a-创建develop分支"><a href="#a-创建develop分支" class="headerlink" title="a. 创建develop分支"></a>a. 创建develop分支</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch develop<span class="token function">git</span> push -u origin develop</code></pre><h4 id="b-开始新Feature开发"><a href="#b-开始新Feature开发" class="headerlink" title="b. 开始新Feature开发"></a>b. 开始新Feature开发</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b some-feature develop<span class="token comment" spellcheck="true"># Optionally, push branch to origin:</span><span class="token function">git</span> push -u origin some-feature<span class="token comment" spellcheck="true"># 做一些改动</span><span class="token function">git</span> status<span class="token function">git</span> add some-file<span class="token function">git</span> commit</code></pre><h4 id="c-完成Feature"><a href="#c-完成Feature" class="headerlink" title="c. 完成Feature"></a>c. 完成Feature</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin develop<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff some-feature<span class="token function">git</span> push origin develop<span class="token function">git</span> branch -d some-feature<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete some-feature</code></pre><h4 id="d-开始Relase"><a href="#d-开始Relase" class="headerlink" title="d. 开始Relase"></a>d. 开始Relase</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b release-0.1.0 develop<span class="token comment" spellcheck="true"># Optional: Bump version number, commit</span><span class="token comment" spellcheck="true"># Prepare release, commit</span></code></pre><h4 id="e-完成Release"><a href="#e-完成Release" class="headerlink" title="e. 完成Release"></a>e. 完成Release</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> branch -d release-0.1.0<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete release-0.1.0   <span class="token function">git</span> tag -a v0.1.0 master<span class="token function">git</span> push --tags</code></pre><h4 id="f-开始Hotfix"><a href="#f-开始Hotfix" class="headerlink" title="f. 开始Hotfix"></a>f. 开始Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b hotfix-0.1.1 master</code></pre><h4 id="g-完成Hotfix"><a href="#g-完成Hotfix" class="headerlink" title="g. 完成Hotfix"></a>g. 完成Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> branch -d hotfix-0.1.1<span class="token function">git</span> tag -a v0.1.1 master<span class="token function">git</span> push --tags</code></pre><h2 id="12-gitignore-设置失效的解决方法"><a href="#12-gitignore-设置失效的解决方法" class="headerlink" title="12. gitignore 设置失效的解决方法"></a>12. gitignore 设置失效的解决方法</h2><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。对应在解决方法：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> -r --cached <span class="token keyword">.</span><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">'update .gitignore'</span></code></pre><p>这样设置git的配置后再执行add操作就没有问题了。</p><p>##参考<br>[1]: <a href="http://blog.chinaunix.net/attachment/201402/19/10415985_139279770639pM.jpg" target="_blank" rel="noopener">http://blog.chinaunix.net/attachment/201402/19/10415985_139279770639pM.jpg</a><br>[2]: <a href="http://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png" target="_blank" rel="noopener">http://images2015.cnblogs.com/blog/759200/201608/759200-20160806092734215-279978821.png</a><br>[3]: <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">http://nvie.com/posts/a-successful-git-branching-model/</a><br>[4]: <a href="http://static.blinkfox.com/ghost/imagegit_flow.png" target="_blank" rel="noopener">http://static.blinkfox.com/ghost/imagegit_flow.png</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之状态模式</title>
      <link href="/2018/092123773.html"/>
      <url>/2018/092123773.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(<code>stateful</code>)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>状态模式(<code>State Pattern</code>)</strong>：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(<code>Objects for States</code>)，状态模式是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>状态模式包含如下角色：</p><ul><li><code>Context</code>: 环境类</li><li><code>State</code>: 抽象状态角色</li><li><code>ConcreteState</code>: 具体状态角色类</li></ul><h3 id="2-结构图："><a href="#2-结构图：" class="headerlink" title="2. 结构图："></a>2. 结构图：</h3><p><img src="http://static.blinkfox.com/State.jpg" alt="状态模式结构图"></p><h3 id="3-时序图："><a href="#3-时序图：" class="headerlink" title="3. 时序图："></a>3. 时序图：</h3><p><img src="http://static.blinkfox.com/seq_State.jpg" alt="状态模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的状态角色接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象状态角色 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法1     */</span>    <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法2     */</span>    <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来，是多个具体的状态角色类，分别如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类1 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState1</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类2 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState2</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是环境类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 环境角色类 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前状态</span>    <span class="token keyword">private</span> IState state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法     * @param state     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IState state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法1     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法2     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是用于测试状态模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 状态模式的客户端场景累 * Created by blinkfox on 16/7/12. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StateClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteState1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li></ul><p>在状态模式结构中需要理解环境类与抽象状态类的作用：</p><ul><li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。</li><li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>状态模式的优点：</p><ul><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>状态模式的缺点：</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用状态模式：</p><ul><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li></ul><blockquote><p>状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。</li><li>状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</li><li>状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之代理模式</title>
      <link href="/2018/092032073.html"/>
      <url>/2018/092032073.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>代理模式(<code>Proxy Pattern</code>)</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做<code>Proxy</code>或<code>Surrogate</code>，它是一种对象结构型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>代理模式包含如下角色：</p><ul><li><code>Subject</code>: 抽象主题角色</li><li><code>RealSubject</code>: 真实主题角色</li><li><code>Proxy</code>: 代理主题角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg" alt="代理模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的主题接口和真实主题类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象主题类 * Created by blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义一个方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 真实主题类 * Created by blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"真实主题类请求方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是代理类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理类 * Created by blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ISubject subject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Proxy</span><span class="token punctuation">(</span>ISubject subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 预处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行前(before)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 善后处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行后(after)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理模式客户端场景类 * Created by blinkfox on 2017/1/1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ISubject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Proxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>代理模式的优点：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li><li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对真实对象的使用权限。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>代理模式的缺点：</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li><li><strong>同步化(Synchronization)代理</strong>：使几个用户能够同时使用一个对象而没有冲突。</li><li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</li><li>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li><li>代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之工厂方法模式</title>
      <link href="/2018/091449719.html"/>
      <url>/2018/091449719.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><p>工厂方法模式(<code>Factory Method Pattern</code>)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>工厂方法模式包含如下角色：</p><ul><li><code>Product</code>：抽象产品</li><li><code>ConcreteProduct</code>：具体产品</li><li><code>Factory</code>：抽象工厂</li><li><code>ConcreteFactory</code>：具体工厂</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="http://static.blinkfox.com/FactoryMethod.jpg" alt="工厂方法模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="http://static.blinkfox.com/seq_FactoryMethod.jpg" alt="工厂方法模式时序图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是抽象的产品类和具体的产品类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象产品类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品类的公共方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是产品类的公共方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类1 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct1的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类2 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct2的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是抽象的工厂类和具体的工厂类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的工厂类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体生产产品的工厂类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式客户端场景类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Factory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>工厂方法模式的优点：</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>工厂方法模式的缺点：</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="五、模式扩展"><a href="#五、模式扩展" class="headerlink" title="五、模式扩展"></a>五、模式扩展</h2><p>工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍4种常用扩展。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式中的工厂类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式客户端场景类 * Created by blinkfox on 16-6-29. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。</p><h3 id="2-多工厂类工厂方法模式"><a href="#2-多工厂类工厂方法模式" class="headerlink" title="2. 多工厂类工厂方法模式"></a>2. 多工厂类工厂方法模式</h3><p>当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下：</p><p>多工厂模式的抽象工厂类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成多个产品的抽象工厂类 * Created by blinkfox on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成某种产品的方法     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第一种产品的创建工厂实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品1的具体工厂类1 * Created by blinkfox on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品1的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第二种产品的创建工厂实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品2的具体工厂类2 * Created by blinkfox on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品2的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>多工厂模式的客户端场景类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 多工厂方法模式客户端场景类 * Created by blinkfox on 16-7-2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product concreteProduct1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product concreteProduct2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-工厂方法的单例模式"><a href="#3-工厂方法的单例模式" class="headerlink" title="3. 工厂方法的单例模式"></a>3. 工厂方法的单例模式</h3><p>单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。</p><p>下面是单例类，其中定义了一个private的无参构造函数，目的是不允许通过new的方式创建对象，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式中的单例类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 私有化构造方法，不允许new产生一个对象     */</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 工厂方法模式中的单例模式业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工厂方法模式中的单例模式方法。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成单例的工厂类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Class <span class="token class-name">c</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获得无参构造</span>            Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置无参构造是可访问的</span>            constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 产生一个实例对象</span>            singleton <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生成单例的工厂类方法中生成单例出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>zuihou        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是工厂方法单例模式的客户端场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法单例模式客户端场景类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Singleton singleton <span class="token operator">=</span> SingletonFactory<span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        singleton<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4-工厂方法的延迟初始化"><a href="#4-工厂方法的延迟初始化" class="headerlink" title="4. 工厂方法的延迟初始化"></a>4. 工厂方法的延迟初始化</h3><p>何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> lazyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> lazyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 根据类型创建具体的产品对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 同时把对象放到缓存容器中</span>        lazyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面即为延迟加载的工厂类。代码比较简单，通过定义一个<code>map</code>容器来容纳所有产生的对象，如果在<code>map</code>容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到<code>map</code>容器中，以便下次调用。</p><p>延迟加载的工厂模式客户端场景类代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂模式客户端场景类 * Created by blinkfox on 16-7-4. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product11 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li><li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之装饰模式</title>
      <link href="/2018/091461471.html"/>
      <url>/2018/091461471.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li></ul><p><strong>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。<strong>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)</strong>，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p></blockquote><p>策略模式是一种<strong>对象结构型</strong>模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>装饰模式包含如下角色：</p><ul><li><code>Component</code>: 抽象构件</li><li><code>ConcreteComponent</code>: 具体构件</li><li><code>Decorator</code>: 抽象装饰类</li><li><code>ConcreteDecorator</code>: 具体装饰类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://static.blinkfox.com/Decorator.jpg" alt="装饰模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/seq_Decorator.jpg" alt="装饰模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个抽象构件接口：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象构件 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 接口方法</span>    <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后是具体构件实现类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体构件 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do Something..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着是装饰角色：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰角色 * 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Component component<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 委托给被修饰者执行     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面是具体的装饰类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类1 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator1</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator1</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法1     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method1修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类2 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator2</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator2</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法2     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method2修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是客户端的场景类：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰模式的客户端场景类 * Created by blinkfox on 16-6-26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第一修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator1</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第二修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator2</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 修饰后运行</span>        component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li><strong>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，<em>关联关系的缺点是比继承关系要创建更多的对象</em>。</li><li><strong>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>装饰模式的优点：</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰模式的缺点：</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>装饰模式的简化-需要注意的问题:</p><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。</li><li>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li><li>装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。</li><li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。</li><li>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li><li>装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。</li><li>装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象设计之策略模式</title>
      <link href="/2018/09149157.html"/>
      <url>/2018/09149157.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(<code>Hard Coding</code>)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</p><p>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><p>为了解决这些问题，可以<strong>定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</strong>。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)</strong>。</p></blockquote><p>策略模式是一种对象行为型模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>策略模式包含如下角色：</p><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="http://static.blinkfox.com/Strategy1.jpg" alt="策略模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="http://static.blinkfox.com/strategy2.jpg" alt="策略模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个策略接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 策略模式的运算法则     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后是具体的策略实现类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy1</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy2</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着是封装角色的类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 抽象策略</span>    <span class="token keyword">private</span> IStrategy strategy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数设置具体策略     * @param strategy     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IStrategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 封装后的策略方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后是客户端的调用策略类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 声明一个具体的策略</span>        IStrategy strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteStrategy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明上下文对象</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行封装后的方法</span>        context<span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“<strong>准备一组算法，并将每一个算法封装起来，使得它们可以互换</strong>”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>策略模式的优点：</p><ul><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>策略模式的缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>策略模式与状态模式：</p><ul><li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</li><li>策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。</li><li>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</li><li>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</li><li>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务定义-Martin Fowler</title>
      <link href="/2017/102933933.html"/>
      <url>/2017/102933933.html</url>
      
        <content type="html"><![CDATA[<p><em>转发自<a href="http://blog.cuicc.com/blog/2015/07/22/microservices" target="_blank" rel="noopener">YYGCui</a>，翻译的Martin Fowler<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">microservices</a>。</em></p><p>在过去几年中，“微服务架构”这一术语如雨后春笋般涌现出来，它描述了一种将软件应用程序设计为一组可独立部署的服务的特定方式。虽然这种架构风格没有明确的定义，但在组织、业务能力上有一些共同的特征：自动化部署，端点智能化，语言和数据的去中心化控制。</p><p>“微服务” - 软件架构拥挤大街上的有一个新术语。虽然我们自然的倾向是轻蔑的一瞥将它一带而过，然而我们发现这一术语描述了一种越来越吸引人的软件系统风格。我们已看到，在过去的几年中有许多项目使用了这种风格，并且到目前为止结果都还不错，以致于这已变成了我们同事在构建企业级应用程序时默认使用的架构风格。然而，遗憾的是并没有太多的信息来概述什么是微服务风格以及怎样用这种风格。</p><p>简单来说，微服务架构风格[1]是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。s</p><p>与单体风格作对比有助于开始解释微服务风格：单体应用程序被构建为单一单元。企业级应用程序通常由三部分组成：客户端侧用户接口(由运行于开发机上的浏览器里的HTML页面和Javascript组成)，数据库(由插入到通用关系型数据库管理系统中的许多数据表格组成)，服务端应用程序。服务端应用程序处理HTTP请求，执行领域逻辑，从数据库中检索、更新数据，选择、填充将要发送到浏览器的HTTP视图。服务端应用程序是一个单一的逻辑可执行单体[2]。系统的任何改变都将牵涉到重新构建和部署服务端的一个新版本。</p><p>这样的单体服务器是构建这样一个系统最自然的方式。处理请求的所有逻辑都运行在一个单一进程中，允许你使用编程语言的基本特性将应用程序划分类、函数和命名空间。你认真的在开发机上运行测试应用程序，并使用部署管道来保证变更已被正确地测试并部署到生产环境中。该单体的水平扩展可以通过在负载均衡器后面运行多个实例来实现。</p><p>单体应用程序可以是成功的，但人们日益对他们感到挫败，尤其是随着更多的应用程序被部署在云上。变更周期被捆绑在一起 —— 即使只变更应用程序的一部分，也需要重新构建并部署整个单体。长此以往，通常将很难保持一个良好的模块架构，这使得很难变更只发生在需要变更的模块内。程序扩展要求进行整个应用程序的扩展而不是需要更多资源的应用程序部分的扩展。</p><p><img src="https://pic.lixl.cn/2020/20200130203937.png/w1280" alt="图1: 单体和微服务"></p><p>这些挫败导向了微服务架构风格：构建应用程序为服务套件。除了服务是可独立部署、可独立扩展的之外，每个服务都提供一个固定的模块边界。甚至允许不同的服务用不同的的语言开发，由不同的团队管理。</p><p>我们不会声称微服务风格是新颖的、创新的，其本质至少可以回溯到Unix的设计哲学。但我们的确认为没有足够的人仔细考虑微服务架构，并且如果使用它很多软件实现将会更好。</p><h2 id="微服务架构的特征"><a href="#微服务架构的特征" class="headerlink" title="微服务架构的特征"></a>微服务架构的特征</h2><p>我们无法给出微服务架构风格的一个正式定义，但我们可以尝试去描述我们看到的符合该架构的一些共性。就概述共性的任何定义来说，并非所有的微服务架构风格都有这些共性，但我们期望大多数微服务架构风格展现出大多数特性。虽然本文作者一直是这个相当松散的社区的活跃用户，我们的目的是试图描述我们工作中和我们知道的一些团队的相似努力中的所见所闻。特别是我们不会制定一些可遵守的定义。</p><h3 id="通过服务组件化"><a href="#通过服务组件化" class="headerlink" title="通过服务组件化"></a>通过服务组件化</h3><p>只要我们一直从事软件行业，一个愿望就是通过把组件插在一起构建系统，如同我们看到的现实世界中事物的构造方式一样。在最近的二十年中，我们看到作为大多数语言平台一部分的公共库的大量汇编工作取得了很大的进展。</p><p>当谈到组件时，我们遭遇困难的定义：组件是什么。我们的定义是：组件是一个可独立替换和独立升级的软件单元。</p><p>微服务架构将使用库，但组件化软件的主要方式是分解成服务。我们把库定义为链接到程序并使用内存函数调用来调用的组件，而服务是一种进程外的组件，它通过web服务请求或rpc(远程过程调用)机制通信(这和很多面向对象程序中的服务对象的概念是不同的[3]。)</p><p>使用服务作为组件而不是使用库的一个主要原因是服务是可独立部署的。如果你有一个应用程序[4]是由单一进程里的多个库组成，任何一个组件的更改都导致必须重新部署整个应用程序。但如果应用程序可分解成多个服务，那么单个服务的变更只需要重新部署该服务即可。当然这也不是绝对的，一些变更将会改变服务接口导致一些协作，但一个好的微服务架构的目的是通过内聚服务边界和按合约演进机制来最小化这些协作。</p><p>使用服务作为组件的另一个结果是一个更加明确的组件接口。大多数语言没有一个好的机制来定义一个明确的<a href="http://martinfowler.com/bliki/PublishedInterface.html" target="_blank" rel="noopener">发布接口</a>。通常只有文档和规则来预防客户端打破组件的封装，这导致组件间过于紧耦合。服务通过明确的远程调用机制可以很容易的避免这些。</p><p>像这样使用服务确实有一些缺点，远程调用比进程内调用更昂贵，因此远程API被设计成粗粒度，这往往更不便于使用。如果你需要更改组件间的责任分配，当你跨进程边界时，这样的行为动作更难达成。</p><p>直观的估计，我们观察到服务与运行时进程一一映射，但这仅仅是直观的估计而已。一个服务可能由多进程组成，这些进程总是被一起开发和部署，比如只被这个服务使用的应用进程和数据库。</p><h3 id="围绕业务能力组织"><a href="#围绕业务能力组织" class="headerlink" title="围绕业务能力组织"></a>围绕业务能力组织</h3><p>当想要把大型应用程序拆分成部件时，通常管理层聚焦在技术层面，导致UI团队、服务侧逻辑团队、数据库团队的划分。当团队按这些技术线路划分时，即使是简单的更改也会导致跨团队的时间和预算审批。一个聪明的团队将围绕这些优化，两害取其轻 - 只把业务逻辑强制放在它们会访问的应用程序中。换句话说，逻辑无处不在。这是Conway法则[5]在起作用的一个例子。</p><blockquote><p>任何设计系统(广泛定义的)的组织将产生一种设计，他的结构就是该组织的通信结构。<br>– Melvyn Conway, 1967</p></blockquote><p><img src="https://pic.lixl.cn/2020/20200130204014.png/w1280" alt="图2: Conway法则在起作用"></p><p>微服务采用不同的分割方法，划分成围绕业务能力组织的服务。这些服务采取该业务领域软件的宽栈实现，包括用户接口、持久化存储和任何外部协作。因此，团队都是跨职能的，包括开发需要的全方位技能：用户体验、数据库、项目管理。</p><p><img src="https://pic.lixl.cn/2020/20200130204043.png/w1280" alt="图3: 团队边界增强的服务边界"></p><p><a href="www.comparethemarket.com">www.comparethemarket.com</a>是按这种方式组织的一个公司。跨职能团队负责创建和运营产品，产品被划分成若干个体服务，这些服务通过消息总线通信。</p><p>大型单体应用程序也总是可以围绕业务能力来模块化，虽然这不是常见的情况。当然，我们将敦促创建单体应用程序的大型团队将团队本身按业务线拆分。我们看到这种情况的主要问题是他们趋向于围绕太多的上下文进行组织。如果单体横跨了多个模块边界，对团队个体成员来说，很难把它们装进他们的短期记忆里。另外，我们看到模块化的路线需要大量的规则来强制实施。服务组件所要求的更加明确的分离，使得它更容易保持团队边界清晰。</p><blockquote><h3 id="侧边栏：微服务有多大？"><a href="#侧边栏：微服务有多大？" class="headerlink" title="侧边栏：微服务有多大？"></a>侧边栏：微服务有多大？</h3><p>虽然，“微服务”已成为这种架构风格的代称，这个名字确实会导致不幸的聚焦于服务的大小，并为“微”由什么组成争论不休。在与微服务实践者的对话中，我们发现有各种大小的服务。最大的服务报道遵循亚马逊两匹萨团队(也就是，整个团队吃两个披萨就吃饱了)的理念，这意味着团队不超过12个人。在更小的规模大小上，我们看到这样的安排，6人团队将支持6个服务。</p><p>这导致这样一个问题，在服务每12个人和服务每1个人的大小范围内，是否有足够大的不同使他们不能被集中在同一微服务标签下。目前，我们认为最好把它们组合在一起。但随着深入探索这种风格，我们一定有可能改变我们的看法。</p></blockquote><h3 id="是产品不是项目"><a href="#是产品不是项目" class="headerlink" title="是产品不是项目"></a>是产品不是项目</h3><p>我们看到大多数应用程序开发工作使用一个项目模式：目标是交付将要完成的一些软件。完成后的软件被交接给维护组织，然后它的构建团队就解散了。</p><p>微服务支持者倾向于避免这种模式，而是认为一个团队应该负责产品的整个生命周期。对此一个共同的启示是亚马逊的理念 <a href="https://queue.acm.org/detail.cfm?id=1142065" target="_blank" rel="noopener">“you build, you run it”</a> ，开发团队负责软件的整个产品周期。这使开发者经常接触他们的软件在生产环境如何工作，并增加与他们的用户联系，因为他们必须承担至少部分的支持工作。</p><p>产品思想与业务能力紧紧联系在一起。要持续关注软件如何帮助用户提升业务能力，而不是把软件看成是将要完成的一组功能。</p><p>没有理由说为什么同样的方法不能用在单体应用程序上，但服务的粒度更小，使得它更容易在服务开发者和用户之间建立个人关系。</p><h3 id="智能端点和哑管道"><a href="#智能端点和哑管道" class="headerlink" title="智能端点和哑管道"></a>智能端点和哑管道</h3><p>当在不同进程间创建通信结构时，我们已经看到了很多的产品和方法，把显著的智慧强压进通信机制本身。一个很好的例子就是企业服务总线(ESB)，在ESB产品中通常为消息路由、编排(choreography)、转化和应用业务规则引入先进的设施。</p><p>微服务社区主张另一种方法：智能端点和哑管道。基于微服务构建的应用程序的目标是尽可能的解耦和尽可能的内聚 - 他们拥有自己的领域逻辑，他们的行为更像经典UNIX理念中的过滤器 - 接收请求，应用适当的逻辑并产生响应。使用简单的REST风格的协议来编排他们，而不是使用像WS-Choreography或者BPEL或者通过中心工具编制(orchestration)等复杂的协议。</p><p>最常用的两种协议是使用资源API的HTTP请求-响应和轻量级消息传送[6]。对第一种协议最好的表述是</p><blockquote><p>本身就是web，而不是隐藏在web的后面。</p><footer><strong>--</strong><cite><a href="http://www.amazon.com/gp/product/0596805829?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596805829" target="_blank" rel="noopener">Ian Robinson</a></cite></footer></blockquote><p>微服务团队使用的规则和协议，正是构建万维网的规则和协议(在更大程度上，是UNIX的)。从开发者和运营人员的角度讲，通常使用的资源可以很容易的缓存。</p><p>第二种常用方法是在轻量级消息总线上传递消息。选择的基础设施是典型的哑的(哑在这里只充当消息路由器) - 像RabbitMQ或ZeroMQ这样简单的实现仅仅提供一个可靠的异步交换结构 - 在服务里，智能仍旧存活于端点中，生产和消费消息。</p><p>单体应用中，组件都在同一进程内执行，它们之间通过方法调用或函数调用通信。把单体变成微服务最大的问题在于通信模式的改变。一种幼稚的转换是从内存方法调用转变成RPC，这导致频繁通信且性能不好。相反，你需要用粗粒度通信代替细粒度通信。</p><h3 id="分权治理"><a href="#分权治理" class="headerlink" title="分权治理"></a>分权治理</h3><p>集中治理的一个后果是单一技术平台的标准化发展趋势。经验表明，这种方法正在收缩 - 不是每个问题都是钉子，也不是每个解决方案都是锤子。我们更喜欢使用正确的工具来完成工作，而单体应用程序在一定程度上可以利用语言的优势，这是不常见的。</p><p>把单体的组件分裂成服务，在构建这些服务时可以有自己的选择。你想使用Node.js开发一个简单的报告页面？去吧。用C++实现一个特别粗糙的近乎实时的组件？好极了。你想换用一个更适合组件读操作数据的不同风格的数据库？我们有技术来重建它。</p><p>当然，仅仅因为你可以做些什么，而不意味着你应该这样做 - 但用这种方式划分系统意味着你可以选择。</p><p>团队在构建微服务时也更喜欢用不同的方法来达标。他们更喜欢生产有用的工具这种想法，而不是写在纸上的标准，这样其他开发者可以用这些工具解决他们所面临的相似的问题。有时，这些工具通常在实施中收获并与更广泛的群体共享，但不完全使用一个内部开源模型。现在git和github已经成为事实上的版本控制系统的选择，在内部开放源代码的实践也正变得越来越常见。</p><blockquote><h3 id="侧边栏：微服务和SOA"><a href="#侧边栏：微服务和SOA" class="headerlink" title="侧边栏：微服务和SOA"></a>侧边栏：微服务和SOA</h3><p>当我们谈论微服务时，一个常见问题是它是否仅仅是十年前我们看到的面向服务的架构(SOA)。这一点是有可取之处的，因为微服务风格和SOA赞同的某些主张十分相似。然而，问题是SOA意味着<a href="http://martinfowler.com/bliki/ServiceOrientedAmbiguity.html" target="_blank" rel="noopener">很多不同的东西</a>，而大多数时候，我们遇到的所谓的SOA和这里我们描述的风格明显不同，这种不同通常由于SOA专注于用于集成单体应用的ESB。</p><p>特别是，我们已经看到许多拙劣的面向服务的实现——从倾向于将复杂性隐藏在 ESB [7]中，到花费数百万美元却毫无价值的失败的多年倡议，到积极抑制变化的集中治理模式，有时很难看到过去的这些问题。</p><p>当然，微服务社区用到的许多技术从开发者在大型组织机构整合服务的经验中成长。<a href="http://martinfowler.com/bliki/TolerantReader.html" target="_blank" rel="noopener">Tolerant Reader</a>模式就是这样的一个例子。使用简单协议是衍生自这些经验的另一个方法，使用网络的努力已做出远离中央标准的反应，坦率地说，中心标准已达到<a href="http://wiki.apache.org/ws/WebServiceSpecifications" target="_blank" rel="noopener">令人叹为观止</a>的复杂性。(任何时候，你需要一个本体来管理你的本体论，你知道你深陷困境。)</p><p>SOA的这种常见表现使得一些微服务倡导者完全拒绝SOA标签，尽管其他人认为微服务是SOA的一种形式[8]，也许服务导向做得对。无论哪种方式，事实上，SOA意味着如此不同的事情，这意味着有一个术语来更清晰地定义这种架构风格是有价值的。</p></blockquote><p>Netflix是遵守这一理念的很好的例子。尤其是，以库的形式分享有用的且经过市场检验的代码，这激励其他开发者用类似的方式解决相似的问题，同时还为采用不同方法敞开了大门。共享库倾向于聚焦在数据存储、进程间通信和我们接下来要深入讨论的基础设施自动化的共性问题。</p><p>对为服务社区来说，开销特别缺乏吸引力。这并不是说社区不重视服务合约。恰恰相反，因为他们有更多的合约。只是他们正在寻找不同的方式来管理这些合约。像<a href="http://martinfowler.com/bliki/TolerantReader.html" target="_blank" rel="noopener">Tolerant Reader</a>和消费者驱动的契约(<a href="http://martinfowler.com/articles/consumerDrivenContracts.html" target="_blank" rel="noopener">Consumer-Driven Contracts</a>)这样的模式通常被用于微服务。<br>这些援助服务合约在独立进化。执行消费者驱动的合约作为构建的一部分，增加了信心并对服务是否在运作提供了更快的反馈。事实上，我们知道澳大利亚的一个团队用消费者驱动的合约这种模式来驱动新业务的构建。他们使用简单的工具定义服务的合约。这已变成自动构建的一部分，即使新服务的代码还没写。服务仅在满足合约的时候才被创建出来 - 这是在构建新软件时避免”YAGNI”[9]困境的一个优雅的方法。围绕这些成长起来的技术和工具，通过减少服务间的临时耦合，限制了中心合约管理的需要。</p><blockquote><h3 id="侧边栏：许多语言，许多选项"><a href="#侧边栏：许多语言，许多选项" class="headerlink" title="侧边栏：许多语言，许多选项"></a>侧边栏：许多语言，许多选项</h3><p>JVM作为平台的成长就是在一个共同平台内混合语言的最新例子。几十年来，破壳到高级语言利用高层次抽象的优势已成为一种普遍的做法。如同下拉到机器硬件，用低层次语言写性能敏感的代码一样。然而，很多单体不需要这个级别的性能优化和常见的更高层次的抽象，也不是DSL的。相反，单体通常是单一语言的并趋向于限制使用的技术的数量[10]。</p></blockquote><p>也许去中心化治理的最高境界就是亚马逊广为流传的build it/run it理念。团队要对他们构建的软件的各方面负责，包括7*24小时的运营。这一级别的责任下放绝对是不规范的，但我们看到越来越多的公司让开发团队负起更多责任。Netflix是采用这一理念的另一家公司[11]。每天凌晨3点被传呼机叫醒无疑是一个强有力的激励，使你在写代码时关注质量。这是关于尽可能远离传统的集中治理模式的一些想法。</p><h3 id="去中心化数据管理"><a href="#去中心化数据管理" class="headerlink" title="去中心化数据管理"></a>去中心化数据管理</h3><p>数据管理的去中心化有许多不同的呈现方式。在最抽象的层面上，这意味着使系统间存在差异的世界概念模型。在整合一个大型企业时，客户的销售视图将不同于支持视图，这是一个常见的问题。客户的销售视图中的一些事情可能不会出现在支持视图中。它们确实可能有不同的属性和(更坏的)共同属性，这些共同属性在语义上有微妙的不同。</p><p>这个问题常见于应用程序之间，但也可能发生在应用程序内部，尤其当应用程序被划分成分离的组件时。一个有用的思维方式是有界上下文(<a href="http://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener">Bounded Context</a>)内的领域驱动设计(Domain-Driven Design, DDD)理念。DDD把一个复杂域划分成多个有界的上下文，并且映射出它们之间的关系。这个过程对单体架构和微服务架构都是有用的，但在服务和上下文边界间有天然的相关性，边界有助于澄清和加强分离，就像业务能力部分描述的那样。</p><blockquote><h3 id="侧边栏：久经考验的标准和执行标准"><a href="#侧边栏：久经考验的标准和执行标准" class="headerlink" title="侧边栏：久经考验的标准和执行标准"></a>侧边栏：久经考验的标准和执行标准</h3><p>这有一点分裂，微服务团队倾向于避开企业架构组规定的那种严格的执行标准，但又很乐意使用甚至传教开放标准，比如HTTP、ATOM和其他威格士。</p><p>关键的区别是如何定制标准和如何执行。由诸如IETF等组织管理的标准仅当在世界范围内有几个有用的实现时才变成标准，这往往会从成功的开源项目成长起来。</p><p>这些标准是远离企业世界的标准。往往被一个几乎没有近期编程经验的或受供应商过度影响的组织开发的。</p></blockquote><p>和概念模型的去中心化决策一样，微服务也去中心化数据存储决策。虽然单体应用程序更喜欢单一的逻辑数据库做持久化存储，但企业往往倾向于一系列应用程序共用一个单一的数据库 - 这些决定是供应商授权许可的商业模式驱动的。微服务更倾向于让每个服务管理自己的数据库，或者同一数据库技术的不同实例，或完全不同的数据库系统 - 这就是所谓的混合持久化(<a href="http://martinfowler.com/bliki/PolyglotPersistence.html" target="_blank" rel="noopener">Polyglot Persistence</a>)。你可以在单体应用程序中使用混合持久化，但它更常出现在为服务里。<br><img src="https://pic.lixl.cn/2020/20200130204113.png/w1280" alt></p><p>对跨微服务的数据来说，去中心化责任对管理升级有影响。处理更新的常用方法是在更新多个资源时使用事务来保证一致性。这个方法通常用在单体中。</p><p>像这样使用事务有助于一致性，但会产生显著地临时耦合，这在横跨多个服务时是有问题的。分布式事务是出了名的难以实现，因此微服务架构强调<a href="http://www.eaipatterns.com/ramblings/18_starbucks.html" target="_blank" rel="noopener">服务间的无事务协作</a>，对一致性可能只是最后一致性和通过补偿操作处理问题有明确的认知。</p><p>对很多开发团队来说，选择用这样的方式管理不一致性是一个新的挑战，但这通常与业务实践相匹配。通常业务处理一定程度的不一致，以快速响应需求，同时有某些类型的逆转过程来处理错误。这种权衡是值得的，只要修复错误的代价小于更大一致性下损失业务的代价。</p><h3 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h3><p>在过去的几年中，基础设施自动化已经发生了巨大的变化，特别是云和AWS的演化已经降低了构建、部署和运维微服务的操作复杂度。</p><p>许多用微服务构建的产品或系统是由在<a href="http://martinfowler.com/bliki/ContinuousDelivery.html" target="_blank" rel="noopener">持续部署</a>和它的前身<a href="http://martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="noopener">持续集成</a>有丰富经验的团队构建的。团队用这种方式构建软件，广泛使用了基础设施自动化。如下面的构建管线图所示：</p><p><img src="https://pic.lixl.cn/2020/20200130204143.png/w1280" alt="图5: 基础构建管道"></p><p>因为这不是一篇关于持续交付的文章，我们这里将之光住几个关键特性。我们希望有尽可能多的信心，我们的软件正在工作，所以我们运行大量的<strong>自动化测试</strong>。推广工作软件的流水线意味着我们可以<strong>自动化部署</strong>到每个新环境。</p><p>一个单体应用程序可以十分愉快地通过这些环境被构建、测试和推送。事实证明，一旦你为单体投入了自动化生产之路，那么部署更多的应用程序似乎也不会更可怕。请记住，持续部署的目标之一是使部署枯燥，所以无论是一个或三个应用程序，只要它的部署仍然枯燥就没关系[12]。</p><blockquote><h3 id="侧边栏：使它容易做正确的事情"><a href="#侧边栏：使它容易做正确的事情" class="headerlink" title="侧边栏：使它容易做正确的事情"></a>侧边栏：使它容易做正确的事情</h3><p>我们发现，作为持续交付和持续部署的一个后果，增加自动化的一个副作用是创造有用的工具，以帮助开发人员和运营人员。用于创造人工制品、管理代码库、起立(standing up)简单服务或添加标准监控和日志记录的工具现在都是很常见的。web上最好的例子可能是<a href="http://netflix.github.io/" target="_blank" rel="noopener">Netflix的开源工具集</a>，但也有其他我们广泛使用的工具，如<a href="http://dropwizard.codahale.com/" target="_blank" rel="noopener">Dropwizard</a>。</p></blockquote><p>我们看到团队使用大量的基础设施自动化的另一个领域是在生产环境中管理微服务时。与我们上面的断言(只要部署是枯燥的)相比，单体和微服务没有太大的差别，各运营场景可以明显不同。</p><p><img src="https://pic.lixl.cn/2020/20200130204204.png/w1280" alt="图6: 模块部署常常不同"></p><h3 id="为失败而设计"><a href="#为失败而设计" class="headerlink" title="为失败而设计"></a>为失败而设计</h3><p>使用服务作为组件的一个结果是，应用程序需要被设计成能够容忍服务失效。任何服务调用都可能因为供应者不可用而失败，客户端必须尽可能优雅的应对这种失败。与单体应用设计相比这是一个劣势，因为它引入额外的复杂性来处理它。结果是，微服务团队不断反思服务失效如何影响用户体验。Netflix的<a href="https://github.com/Netflix/SimianArmy" target="_blank" rel="noopener">Simian Army</a>在工作日诱导服务甚至是数据中心故障来测试应用程序的弹性和监测。</p><p>在生产环境中的这种自动化测试足够给大多数运营团队那种不寒而栗，通常在结束一周的工作之前。这不是说单体风格不能够进行完善的监测设置，只是在我们的经验中比较少见。</p><blockquote><h3 id="侧边栏：断路器和产品就绪代码"><a href="#侧边栏：断路器和产品就绪代码" class="headerlink" title="侧边栏：断路器和产品就绪代码"></a>侧边栏：断路器和产品就绪代码</h3><p><a href="http://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener">断路器(Circuit Breaker)</a>与其他模式如Bulkhead和Timeout出现在<a href="http://www.amazon.com/gp/product/B00A32NXZO?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00A32NXZO" target="_blank" rel="noopener">《Release it!》</a>中。这些模式是被一起实现的，在构建通信应用程序时，它们是至关重要的。<a href="http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html" target="_blank" rel="noopener">这篇Netflix博文</a>很好的解释了使用这些模式的应用程序。</p></blockquote><p>既然服务随时都可能失败，那么能够快速检测故障，如果可能的话，能自动恢复服务是很重要的。微服务应用程序投入大量比重来进行应用程序的实时监测，既检查构形要素(每秒多少次数据请求)，又检查业务相关指标(例如每分钟收到多少订单)。语义监测可以提供一套早期预警系统，触发开发团队跟进和调查。</p><p>这对微服务架构特别重要，因为微服务偏好编排和事件协作，这会带来突发行为。虽然很多专家称赞偶然涌现的价值，事实的真相是，突发行为有时可能是一件坏事请。监测对于快速发现不良突发行为是至关重要的，所以它可以被修复。</p><p>单体可以被构建成和微服务一样透明 - 事实上，它们应该是透明的。不同的是，你绝对需要知道在不同进程中运行的服务是否断开。对同一进程中的库来说，这种透明性是不大可能有用的。</p><blockquote><h3 id="侧边栏：同步调用被认为是有害的"><a href="#侧边栏：同步调用被认为是有害的" class="headerlink" title="侧边栏：同步调用被认为是有害的"></a>侧边栏：同步调用被认为是有害的</h3><p>任何时候，在服务间有大量的同步调用，你将遇到停机的乘法效应。简单地说，就是你的系统的停机时间编程各个组件停机时间的乘积。你面临一个选择，让你的调用变成异步或者管理停机时间。在<a href="http://www.guardian.co.uk，他们已在新平台实现了一个简单的规则" target="_blank" rel="noopener">www.guardian.co.uk，他们已在新平台实现了一个简单的规则</a> - 每个用户请求一个同步调用，而在Netflix，他们的平台API重设计成在API交换结构(fabric)建立异步性。</p></blockquote><p>微服务团队希望看到为每个单独的服务设置的完善的监控和日志记录，比如控制面板上显示启动/关闭状态和各种各样的运营和业务相关指标。断路器状态、当前吞吐量和时延的详细信息是我们经常遇到的其他例子。</p><h3 id="进化式设计"><a href="#进化式设计" class="headerlink" title="进化式设计"></a>进化式设计</h3><p>微服务从业者，通常有进化式设计背景并且把服务分解看做是进一步的工具，使应用程序开发者能够控制他们应用程序中的变更而不减缓变更。变更控制并不一定意味着变更的减少 - 用正确的态度和工具，你可以频繁、快速且控制良好的改变软件。</p><p>当你试图把软件系统组件化时，你就面临着如何划分成块的决策 - 我们决定分割我们的应用的原则是什么？组件的关键特性是独立的更换和升级的理念[13] - 这意味着我们要找到这样的点，我们可以想象重写组件而不影响其合作者。事实上很多微服务群组通过明确地预期许多服务将被废弃而不是长期演进来进一步找到这些点。</p><p>卫报网站是被设计和构建成单体应用程序的一个好例子，但它已向微服务方向演化。网站的核心仍是单体，但他们喜欢通过使用调用单体API构建的微服务添加新功能。这种方法对添加临时性的特性特别方便，比如处理体育赛事的专题页面。网站的这样一部分可以使用快速开发语言迅速的被放在一起，并且一旦赛事结束立即删除。在金融机构中，我们看到类似的方法，为一个市场机会添加新服务，并在几个月甚至几周后丢弃掉。</p><p>强调可替代性是模块设计更一般原则的一个特例，它是通过变更模式来驱动模块化的[14]。您希望将同时更改的内容保存在同一个模块中。系统中很少变更的部分应该和正在经历大量扰动的部分放在不同的服务里。如果你发现你自己不断地一起改变两个服务，这是它们应该被合并的一个标志。</p><p>把组件放在服务中，为更细粒度的发布计划增加了一个机会。对单体来说，任何变更都需要完整构建和部署整个应用程序。而对微服务来说，你只需要重新部署你修改的服务。这可以简化和加速发布过程。坏处是，你必须担心一个服务的变化会阻断其消费者。传统的集成方法试图使用版本管理解决这个问题，但是微服务世界的偏好是<a href="http://martinfowler.com/articles/enterpriseREST.html#versioning" target="_blank" rel="noopener">只把版本管理作为最后的手段</a>。我们可以避免大量的版本管理，通过把服务设计成对他们的提供者的变化尽可能的宽容。</p><h2 id="微服务是未来吗？"><a href="#微服务是未来吗？" class="headerlink" title="微服务是未来吗？"></a>微服务是未来吗？</h2><p>我们写这篇文章的主要目的是讲解微服务的主要思想和原则。通过花时间做这件事情，我们清楚地认为微服务架构风格是一个重要的思想 - 它值得为企业应用程序认真考虑。我们最近用这种风格构建了一些系统，也知道别人用这种风格并赞成这种风格。</p><p>那些我们知道的以某种方式开拓这种架构风格的包括亚马逊，Netflix，<a href="http://www.theguardian.com/" target="_blank" rel="noopener">卫报</a>，<a href="https://gds.blog.gov.uk/" target="_blank" rel="noopener">英国政府数字服务部门</a>，<a href="http://martinfowler.com/articles/realestate.com.au" target="_blank" rel="noopener">realestate.com.au</a>，前锋和<a href="http://www.comparethemarket.com/" target="_blank" rel="noopener">comparethemarket.com</a>。2013年的会议电路中全是正向微服务类别转移的公司 - 包括Travis CI。此外还有大量的组织长期以来一直在做可归为微服务类别的事情，但是还没有使用这个名字。(这通常被称为SOA - 虽然，正如我们说过的，SOA有许多矛盾的形式。[15])</p><p>尽管有这些积极的经验，但是，我们并不认为我们确信微服务是软件架构的未来发展方向。虽然到目前为止，与单体应用程序相比，我们的经验是正面的，但我们意识到这样的事实，并没有经过足够的时间使我们做出充分的判断。</p><p>通常，你的架构决策的真正后果是在你做出这些决定的几年后才显现的。我们已经看到对模块化有强烈愿望的一个好团队用单体架构构建的项目，已经衰败了多年。很多人相信微服务是不太可能出现这种衰败的，因为服务界限是明确的，并且很难围绕它打补丁。然而，除非我们看到足够多经过足够岁月的系统，我们不能真正评估微服务架构有多么成熟。</p><p>人们当然有理由希望微服务是多么不成熟。在组件化中做任何努力，成功取决于软件在多大程度上适用于组件化。很难弄清楚组件边界在哪里。进化式设计承认获取正确边界的困难性和使它们易于重构的重要性。但当你的组件是带有远程通信的服务时，那么重构它比重构带有进程内库的服务难很多。跨服务边界移动代码是很困难的，任何接口变更都需要在参与者之间进行协调，需要添加向后兼容层，并且测试也变得更加复杂。</p><blockquote><h3 id="侧边栏：《构建微服务》"><a href="#侧边栏：《构建微服务》" class="headerlink" title="侧边栏：《构建微服务》"></a>侧边栏：《构建微服务》</h3><p>我们的同事Sam Newman花费2014年的大部分时间写了<a href="http://www.amazon.com/gp/product/1491950358?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491950358" target="_blank" rel="noopener">一本书</a>，捕捉了我们构建微服务的经验。如果你想深入到这个话题中，这应该是你的下一步。</p></blockquote><p>另一个问题是，如果组件不组成的干净利索，那么所有你做的是将复杂度从组件内部转移到组件之间的连接。不仅仅是把复杂性移到周围，它将复杂性移动到一个不太明确、难以控制的地方。在没有服务间的凌乱连接的情况下，当你在看一个小的、简单的组件内部时，你可以很容易的认为事情是更好的。</p><p>最后，有团队技能的因素。更熟练的团队倾向于采用新技术。但是对更熟练的团队更有效的一种技术不一定适合于不太熟练的团队。我们已经看到大量的例子，不太熟练的团队构建了凌乱的单体架构，但这需要时间去看当微服务发生这种凌乱时会发生什么。一个差的团队总是创建一个差的系统 - 很难讲在这个例子中微服务会减少这种凌乱还是使它更糟糕。</p><p>我们听到的一个合理的说法是，你不应该从微服务架构开始。相反，从单体开始，使它保持模块化，一旦单体成为问题时把它分解成微服务。(虽然这个建议是不理想的，因为一个好的进程内接口通常不是一个好的服务接口。)</p><p>所以我们怀着谨慎乐观的态度写了这篇文章。到目前为止，我们已经看到关于微服务风格足以觉得这是一条值得探索的路。我们不能肯定地说，我们将在哪里结束，但软件开发的挑战之一是，你只能基于目前能拿到手的不完善的信息作出决定。</p><hr><p>[1]: 2011年5月在威尼斯召开的软件架构研讨会上，“微服务”这一术语被讨论用来描述参与者一直在探索的一种常见的架构风格。2012年5月，该研讨会决定使用“微服务”作为最合适的名字。2012年3月在波兰克拉科夫市举办的33届Degree大会上，James介绍了这些想法作为一个案例研究<a href="http://2012.33degree.org/talk/show/67" target="_blank" rel="noopener">微服务 - Java，Unix方式</a>，Fred George也<a href="http://www.slideshare.net/fredgeorge/micro-service-architecure" target="_blank" rel="noopener">差不多在同一时间</a>提出。Netflix的Adrian Cockcroft把这种方法描述为“细粒度的SOA”，在网域级开拓了这一风格，还有在该文中提到的许多人 - Joe Walnes, Dan North, Evan Botcher 和 Graham Tackley。<br>[2]: 单体这一术语已被Unix社区使用了一段时间，在<a href="http://www.amazon.com/gp/product/B003U2T5BA?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B003U2T5BA" target="_blank" rel="noopener">《Unix编程艺术》</a>中用它来描述非常大的系统。<br>[3]: 很多面向对象的设计人员，包括我们自己，在<a href="http://www.amazon.com/gp/product/0321125215?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321125215" target="_blank" rel="noopener">领域驱动设计</a>意义上使用服务对象术语，该对象不依赖于实体执行一个重要进程。这和我们在本文中如何使用“服务”是不同的概念。不幸的是，服务这个词有两个含义，我们不得不忍受这个多义词。<br>[4]: 我们认为<a href="http://martinfowler.com/bliki/ApplicationBoundary.html" target="_blank" rel="noopener">应用程序是一个社会结构</a>，它由代码基、功能组、资金体组合在一起。<br>[5]: 原文可在Melvyn Conway的网站上找到，<a href="http://www.melconway.com/Home/Committees_Paper.html" target="_blank" rel="noopener">在这里</a>。<br>[6]: 在极端规模下，组织通常移至二进制协议并权衡规模的透明度。例如<a href>protobufs</a>。使用二进制协议的系统仍旧展现出智能端点、哑管道。大多数网站，当然绝大多数企业不需要做这种权衡，透明度可以是一个很大的胜利。<br>[7]: 我们忍不住提起Jim Webber的说法，ESB全称是<a href="http://www.infoq.com/presentations/soa-without-esb" target="_blank" rel="noopener">“令人震惊的意大利面条盒”</a><br>[8]: Netflix使这种联系清晰起来 - 直到最近作为细粒度SOA提及他们的架构风格。<br>[9]: “YAGNI”也就是“You Aren’t Going To Need It(你将不需要它)”是一个<a href="http://c2.com/cgi/wiki?YouArentGonnaNeedIt" target="_blank" rel="noopener">XP原则</a>和劝诫，在你知道你需要它们时才添加特性<br>[10]: 我们声称单体是单一语言的，这有一点不诚实 - 要在现在web上构建系统，你可能需要知道JavaScript、XHTML、CSS、选择的服务器语言、SQL和ORM方言。很难只用单一语言，但是你知道我的意思。<br>[11]: 在2013年11月的Flowcon大会上提交的<a href="http://www.slideshare.net/adrianco/flowcon-added-to-for-cmg-keynote-talk-on-how-speed-wins-and-how-netflix-is-doing-continuous-delivery" target="_blank" rel="noopener">这个出色演讲中</a>，Adrian Cockcroft特别提到“开发者自助服务”和“开发者运行他们自己写的代码”(原文如此)。<br>[12]: 我们这里有一点不诚实。显然在更复杂的拓扑结构中部署更多的服务要比部署单一单体更困难。幸运的是，模式减少了这种复杂性 - 在工具上的投资仍是必须的。<br>[13]: 事实上，Dan North提到这种风格是可更换的组件架构而不是微服务。因为这似乎是在讨论我们更喜欢的后者的一个特征子集。<br>[14]: Kent Beck强调这是他<a href="http://www.amazon.com/gp/product/0321413091?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321413091" target="_blank" rel="noopener">《实现模式》</a>一书中的设计原则之一。<br>[15]: SOA几乎是这段历史的根源。我记得当SOA这一术语出现在本世纪初时，有人说“多年来我们一直这样做”。一个理由是，这种风格看其根源是在企业计算早期COBOL程序通过数据文件通信的方式。在另一个方向，有人可能会说微服务和Erlang编程模型相同，但被应用于企业应用程序上下文。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务系列文章</title>
      <link href="/2017/102933111.html"/>
      <url>/2017/102933111.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、微服务架构的优势与不足"><a href="#一、微服务架构的优势与不足" class="headerlink" title="一、微服务架构的优势与不足"></a>一、微服务架构的优势与不足</h2><p>本章介绍了微服务架构模式，讨论了使用微服务的优缺点，以及为什么微服务虽然复杂度高却是复杂应用程序的理想选择。</p><h3 id="单体架构的地狱"><a href="#单体架构的地狱" class="headerlink" title="单体架构的地狱"></a>单体架构的地狱</h3><p>成功的应用最终会随着时间变得巨大。在每个 sprint 阶段，开发团队都会新加许多行代码。几年后，原本小而简单的应用会变得臃肿。举个极端的例子，我最近与一位开发者交流，他正在开发一款小工具，来分析他们应用（包括几百万行代码）中的几千个 JARs 的依赖。我相信每年都会有大量开发者不遗余力地对付这种麻烦。</p><p>一旦你的应用变得庞大、复杂，你的开发团队将饱受折磨，苦苦挣扎于敏捷开发和交付。一大原因就是应用已经格外复杂，庞大到任何一个开发者都无法完全理解。最后，修复 bug 和实施新功能也就极其困难且耗时颇多。更可怕的是，这是一个向下的螺旋发展。代码库越难理解，正确的修改就越难。最后你会深陷庞大的、无法估量的泥淖之中。</p><p>而这种应用的尺寸也会拖慢开发进度。应用越大，启动时间越长。譬如在最近的调查中，不少开发者指出启动时间长达 12 分钟。我也听说有的应用启动时间居然得 40 分钟。如果开发者不得不频繁重启应用服务器，那大量时间就被浪费，生产效率也饱受其害。</p><p>庞大且复杂的单体应用的另一大问题就是难以进行持续部署。现在， SaaS 应用的发展水平足以在单日内多次将修改推送到生产环境。然而要让复杂的单个应用达到此水平却极为棘手。想更新应用的单个部分，必须重新部署整个应用，漫长的启动时间更是雪上加霜。另外，由于不能完全预见修改的影响，你不得不提前进行大量人工测试。结果就是，持续部署变得不可能。</p><p>如果单体应用的不同模块在资源需求方面有冲突的话，那应用的扩展也很难。比如，模块之一需要执行 CPU-intensive 图像处理逻辑，最好部署到 AWS 的 EC2 Compute Optimized instances；而另一模块需要内存数据库，最好适配 EC2 Memory-optimized instances。由于这两个模块需要共同部署，你不得不在在硬件选择方面做妥协。</p><p>单体应用的另一问题就是可靠性。由于所有模块都运行在同一进程中，任何模块中的一个 bug，比如内存泄漏都可能弄垮整个进程；此外，由于应用中的所有实例都是唯一，这个 bug 将影响整个应用的可用性。</p><p>最后，单体应用会让采用新框架和语言极其困难。举例来说，你有两百万行使用 XYZ 框架的代码，如果要使用 ABC 框架重写代码，无论时间还是成本都将非常高昂，即便新框架更好。这也就成为使用新技术的阻碍。</p><p>总结：这个一开始曾经成功关键业务应用，最终却变成一个臃肿的、无法理解的庞然大物。它使用老旧、陈腐、低效的技术，几乎吸引不到出色的开发者。这个应用非常难于扩展，也不稳定可靠。最终，敏捷开发和交付几乎成为不可能。</p><h3 id="微服务——直击痛点"><a href="#微服务——直击痛点" class="headerlink" title="微服务——直击痛点"></a>微服务——直击痛点</h3><p>诸如亚马逊、eBay、Netflix 等公司已经通过采用微服务架构范式解决了上文（第一部分）提到的问题。不同于构建单一、庞大的应用，微服务架构将应用拆分为一套小且互相关联的服务。</p><p>一个微服务一般完成某个特定的功能，比如订单管理、客户管理等。每个微服务都是一个微型应用，有着自己六边形架构，包括商业逻辑和各种接口。有的微服务通过暴露 API 被别的微服务或者应用客户端所用；有的微服务则通过网页 UI 实现。在运行时，每个实例通常是一个云虚拟机或者 Docker 容器。</p><p>微服务架构范式对应用和数据库的关系影响巨大。每个服务都有自身的数据库计划，而不与其它服务共享同一个数据库。一方面，这个方法类似企业级数据模型。同时，它也导致部分数据的重复。然而，要想从微服务中获益，为每个服务提供单个的数据库计划就非常必要，这能保证松散耦合。</p><p>每个服务都有其自己的数据库。此外，单个服务可以使用符合自己需要的特定类型的数据库，即多语言一致性架构。例如，为了发现附近乘客，驾驶员管理服务必须使用高效支持地理位置请求的数据库。</p><p>表面上看，微服务架构范式与 SOA 非常类似，这两种架构都包括一套服务。然而，微服务架构范式被看作不包含某些功能的 SOA 。这些功能包括网络服务说明（ WS-<em> ）和 Enterprise Service Bus (ESB) 的商品化和请求包。基于微服务的应用更青睐 REST 这样简单的、轻量级的协议，而不是 WS-</em> 。他们也极力避免在微服务中使用 ESBs 及类似功能。微服务架构范式也拒绝 SOA 的其它部分，比如 canonical schema 的概念。</p><h3 id="微服务架构的好处"><a href="#微服务架构的好处" class="headerlink" title="微服务架构的好处"></a>微服务架构的好处</h3><p>微服务架构模式有很多好处。首先，通过分解巨大单体应用为多个服务方法解决了复杂性问题。在功能不变的情况下，应用被分解为多个可管理的分支或服务。每个服务都有一个用 RPC- 或者消息驱动 API 定义清楚的边界。微服务架构模式给采用单体式编码方式很难实现的功能提供了模块化的解决方案，由此，单个服务很容易开发、理解和维护。</p><p>第二，这种架构使得每个服务都可以有专门开发团队来开发。开发者可以自由选择开发技术，提供 API 服务。当然，许多公司试图避免混乱，只提供某些技术选择。然后，这种自由意味着开发者不需要被迫使用某项目开始时采用的过时技术，他们可以选择现在的技术。甚至于，因为服务都是相对简单，即使用现在技术重写以前代码也不是很困难的事情。</p><p>第三，微服务架构模式使得每个微服务独立部署，开发者不再需要协调其它服务部署对本服务的影响。这种改变可以加快部署速度，譬如 UI 团队可以采用 AB 测试并快速部署变化。微服务架构模式使得持续化部署成为可能。</p><p>最后，微服务架构模式使得每个服务独立扩展。你可以根据每个服务的规模来部署满足需求的实利。甚至于，你可以使用更适合于服务资源需求的硬件。比如，你可以在 EC2 Compute Optimized instances 上部署 CPU 敏感的服务，而在 EC2 memory-optimized instances 上部署内存数据库。</p><h3 id="微服务架构的不足"><a href="#微服务架构的不足" class="headerlink" title="微服务架构的不足"></a>微服务架构的不足</h3><p>像任何其它科技一样，微服务架构也有不足。其中一个跟他的名字类似，“微服务”强调了服务大小，实际上，有一些开发者鼓吹建立稍微大一些的，10-100 LOC服务组。尽管小服务更乐于被采用，但是不要忘了微服务只是结果，而不是最终目的。微服务的目的是有效的拆分应用，实现敏捷开发和部署。</p><p>另外一个不足之处在于，微服务应用是分布式系统，由此会带来固有的复杂性。开发者需要在 RPC 或者消息传递之间选择并完成进程间通讯机制。此外，他们必须写代码来处理消息传递中速度过慢或者不可用等局部失效问题。当然这并不是什么难事，但相对于单体式应用中通过语言层级的方法或者进程调用，微服务下这种技术显得更复杂一些。</p><p>另外一个关于微服务的挑战来自于分区的数据库架构。同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库。使用分布式事务并不一定是好的选择，不仅仅是因为 CAP 理论，还因为当前高扩展性的 NoSQL 数据库和消息传递中间件并不支持这一需求。最终你不得不使用一个最终一致性的方法，从而对开发者提出了更高的要求和挑战。</p><p>测试一个基于微服务架构的应用也是很复杂的任务。比如，对于采用流行的 Spring Boot 架构的单体式 web 应用，测试它的 REST API，是很容易的事情。反过来，同样的服务测试需要启动与它有关的所有服务（至少需要这些服务的 stubs）。再重申一次，不能低估了采用微服务架构带来的复杂性。</p><p>另外一个挑战在于，微服务架构模式应用的改变将会波及多个服务。比如，假设你在完成一个案例，需要修改服务A、B、C，而 A 依赖 B，B 依赖 C。在单体应用中，你只需要改变相关模块，整合变化，部署就好了。对比之下，微服务架构模式就需要考虑相关改变对不同服务的影响。比如，你需要更新服务 C，然后是 B，最后才是 A。幸运的是，许多改变一般只影响一个服务，而需要协调多服务的改变很少。</p><p>部署一个微服务应用也很复杂，一个单体应用只需要在复杂均衡器后面部署各自的服务器就好了。每个应用实例是需要配置诸如数据库和消息中间件等基础服务。相比之下，一个微服务应用一般由大批服务构成。根据 Adrian Cockcroft 的分享，Hailo 由 160 个不同服务构成，而 NetFlix 则超过 600 个服务。每个服务都有多个实例，这就形成大量需要配置、部署、扩展和监控的部分。除此之外，你还需要完成一个服务发现机制（后续文章中发表），以用来发现与它通讯服务的地址（包括服务器地址和端口）。传统的解决问题办法并不能解决这么复杂的问题。最终，成功部署一个微服务应用需要开发者有足够的控制部署方法，并高度自动化。</p><p>自动化的方法之一是使用譬如 Cloud Foundry 这样的 PaaS 服务。PaaS 能让开发者轻松部署和管理微服务，让他们无需为获取并配置 IT 资源劳神。同时，配置 PaaS 的系统和网络专家可以采用最佳实践和策略来简化这些问题。另外一个自动部署微服务应用的方法是开发自己的基础 PaaS 系统。通常的起步方式是 Mesos 或 Kubernetes 这样的集群管理方案，配合 Docker 使用。作为一种基于软件的应用交付方法，NGINX 能够方便地在微服务层面提供缓冲、权限控制、API 统计、以及监控。我们会在后续的文章中分析它如何解决这些问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>构建复杂的应用的确非常困难。单体式的架构更适合轻量级的简单应用。如果你用它来开发复杂应用，那真的会很糟糕。微服务架构模式可以用来构建复杂应用，当然，这种架构模型也有自己的缺点和挑战。</p><h2 id="二、使用-API-网关构建微服务"><a href="#二、使用-API-网关构建微服务" class="headerlink" title="二、使用 API 网关构建微服务"></a>二、使用 API 网关构建微服务</h2><p>在决定以一组微服务来构建自己的应用时，你需要确定应用客户端如何与微服务交互。</p><p>在单体式程序中，通常只有一组冗余的或者负载均衡的服务提供点。在微服务架构中，每一个微服务暴露一组细粒度的服务提供点。在本篇文章中，我们来看它如何影响客户端到服务端通信，并提出一种使用 API 网关的方法。</p><h3 id="简要概述"><a href="#简要概述" class="headerlink" title="简要概述"></a>简要概述</h3><p>让我们想象一下，你要为一个购物应用程序开发一个原生移动客户端。你很可能需要实现一个产品详情页面，展示任何指定商品的信息。即使只是个智能手机应用，产品详情页面也显示了大量的信息。该页面不仅包含基本的产品信息（如名称、描述、价格），而且还显示了大量其他模块/组件提供的信息。</p><p>使用单体应用程序架构时，移动客户端通过向应用程序发起一次 REST 调用（GET api.company.com/productdetails/）来获取这些数据。负载均衡器将请求路由给 N 个相同的应用程序实例中的其中之一。然后，应用程序会查询各种数据库表，并将响应返回给客户端。</p><p>相反，若是采用微服务架构，显示在产品页上的数据会分布在不同的微服务上。我们需要决定移动客户端如何访问这些服务。让我们看看有哪些方法。</p><h3 id="客户端与微服务直接通信"><a href="#客户端与微服务直接通信" class="headerlink" title="客户端与微服务直接通信"></a>客户端与微服务直接通信</h3><p>从理论上讲，客户端可以直接向每个微服务发送请求。每个微服务都有一个公开的端点(https ://.api.company.name）。该 URL 映射到微服务的负载均衡器，由后者负责在可用实例之间分发请求。为了获取产品详情，移动客户端将逐一向上文列出的 N 个服务发送请求。</p><p>遗憾的是，这种方法存在挑战和局限。问题之一是客户端需求和每个微服务暴露的细粒度 API 不匹配。在这个例子中，客户端需要发送 7 个独立请求。在更复杂的应用程序中，可能要发送更多的请求；按照 Amazon 的说法，他们在显示他们的产品页面时就调用了数百个服务。然而，客户端通过 LAN 发送许多请求，这在公网上可能会很低效，在移动网络上就根本不可行。这种方法还使得客户端代码非常复杂。</p><p>客户端直接调用微服务的另一个问题是，部分服务使用的协议对 web 并不友好。一个服务可能使用 Thrift 二进制 RPC，而另一个服务可能使用 AMQP 消息传递协议。不管哪种协议对于浏览器或防火墙都不够友好，最好是内部使用。在防火墙之外，应用程序应该使用诸如 HTTP 和 WebSocket 之类的协议。</p><p>这种方法的另一个缺点是，它会使得微服务难以重构。随着时间推移，我们可能想要更改系统拆分成服务的方式。例如，我们可能合并两个服务，或者将一个服务拆分成两个或更多服务。然而，如果客户端与微服务直接通信，那么执行这类重构就非常困难了。</p><p>由于上述三种问题的原因，客户端直接与服务器端通信的方式很少在实际中使用。</p><h3 id="使用-API-网关构建微服务"><a href="#使用-API-网关构建微服务" class="headerlink" title="使用 API 网关构建微服务"></a>使用 API 网关构建微服务</h3><p>通常来说，使用 API 网关是更好的解决方式。API 网关是一个服务器，也可以说是进入系统的唯一节点。这与面向对象设计模式中的 Facade 模式很像。API 网关封装内部系统的架构，并且提供 API 给各个客户端。它还可能还具备授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等功能。下图展示了一个适应当前架构的 API 网关。<br><img src="https://user-images.githubusercontent.com/3287183/27023336-b223546e-4f84-11e7-81c4-b882594e8949.png" alt> </p><p>API 网关负责服务请求路由、组合及协议转换。客户端的所有请求都首先经过 API 网关，然后由它将请求路由到合适的微服务。API 网关经常会通过调用多个微服务并合并结果来处理一个请求。它可以在 web 协议（如 HTTP 与 WebSocket）与内部使用的非 web 友好协议之间转换。</p><p>API 网关还能为每个客户端提供一个定制的 API。通常，它会向移动客户端暴露一个粗粒度的 API。以产品详情的场景为例，API 网关可以提供一个端点（/productdetails?productid=xxx），使移动客户端可以通过一个请求获取所有的产品详情。API 网关通过调用各个服务（产品信息、推荐、评论等等）并合并结果来处理请求。</p><p>Netflix API 网关是一个很好的 API 网关实例。Netflix 流媒体服务提供给成百上千种类型的设备使用，包括电视、机顶盒、智能手机、游戏系统、平板电脑等等。</p><p>最初，Netflix 试图为他们的流媒体服务提供一个通用的 API。然而他们发现，由于各种各样的设备都有自己独特的需求，这种方式并不能很好地工作。如今，他们使用一个 API 网关，通过运行与针对特定设备的适配器代码，来为每种设备提供定制的 API。通常，一个适配器通过调用平均 6 到 7 个后端服务来处理每个请求。Netflix API 网关每天处理数十亿请求。</p><h3 id="API-网关的优点和缺点"><a href="#API-网关的优点和缺点" class="headerlink" title="API 网关的优点和缺点"></a>API 网关的优点和缺点</h3><p>如你所料，使用 API 网关有优点也有不足。使用 API 网关的最大优点是，它封装了应用程序的内部结构。客户端只需要同网关交互，而不必调用特定的服务。API 网关为每一类客户端提供了特定的 API，这减少了客户端与应用程序间的交互次数，还简化了客户端代码。</p><p>API 网关也有一些不足。它增加了一个我们必须开发、部署和维护的高可用组件。还有一个风险是，API 网关变成了开发瓶颈。为了暴露每个微服务的端点，开发人员必须更新 API 网关。API网关的更新过程要尽可能地简单，这很重要；否则，为了更新网关，开发人员将不得不排队等待。不过，虽然有这些不足，但对于大多数现实世界的应用程序而言，使用 API 网关是合理的。</p><h4 id="实现-API-网关"><a href="#实现-API-网关" class="headerlink" title="实现 API 网关"></a>实现 API 网关</h4><p>到目前为止，我们已经探讨了使用 API 网关的动力及其优缺点。下面让我们看一下需要考虑的各种设计问题。</p><h3 id="性能和可扩展性"><a href="#性能和可扩展性" class="headerlink" title="性能和可扩展性"></a>性能和可扩展性</h3><p>只有少数公司拥有 Netflix 这样的规模，需要每天处理每天需要处理数十亿请求。不管怎样，对于大多数应用程序而言，API 网关的性能和可扩展性都非常重要。因此，将 API 网关构建在一个支持异步、I/O 非阻塞的平台上是合理的。有多种不同的技术可以实现一个可扩展的 API 网关。在 JVM 上，可以使用一种基于 NIO 的框架，比如 Netty、Vertx、Spring Reactor 或 JBoss Undertow 中的一种。一个非常流行的非 JVM 选项是 Node.js，它是一个基于 Chrome JavaScript 引擎构建的平台。</p><p>另一个方法是使用 NGINX Plus。NGINX Plus 提供了一个成熟的、可扩展的、高性能 web 服务器和一个易于部署的、可配置可编程的反向代理。NGINX Plus 可以管理身份验证、访问控制、负载均衡请求、缓存响应，并提供应用程序可感知的健康检查和监控。</p><h3 id="使用响应式编程模型"><a href="#使用响应式编程模型" class="headerlink" title="使用响应式编程模型"></a>使用响应式编程模型</h3><p>API 网关通过简单地将请求路由给合适的后端服务来处理部分请求，而通过调用多个后端服务并合并结果来处理其它请求。对于部分请求，比如产品详情相关的多个请求，它们对后端服务的请求是独立于其它请求的。为了最小化响应时间，API 网关应该并发执行独立请求。</p><p>然而，有时候，请求之间存在依赖。在将请求路由到后端服务之前，API 网关可能首先需要调用身份验证服务验证请求的合法性。类似地，为了获取客户心愿单中的产品信息，API 网关必须首先获取包含这些信息的客户资料，然后再获取每个产品的信息。关于 API 组合，另一个有趣的例子是 Netflix Video Grid。</p><p>使用传统的异步回调方法编写 API 组合代码会让你迅速坠入回调地狱。代码会变得混乱、难以理解且容易出错。一个更好的方法是使用响应式方法，以一种声明式样式编写 API 网关代码。响应式抽象概念的例子有 Scala 中的 Future、Java 8 中的 CompletableFuture 和 JavaScript 中的P romise，还有最初微软为 .NET 平台开发的 Reactive Extensions（RX）。Netflix 创建了 RxJava for JVM，专门用于他们的 API 网关。此外，还有 RxJS for JavaScript，它既可以在浏览器中运行，也可以在 Node.js 中运行。使用响应式方法能让你编写简单但高效的 API 网关代码。</p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>基于微服务的应用程序是一个分布式系统，必须使用一种进程间通信机制。有两种类型的进程间通信机制可供选择。一种是使用异步的、基于消息传递的机制。有些实现使用诸如 JMS 或 AMQP 那样的消息代理，而其它的实现（如 Zeromq）则没有代理，服务间直接通信。</p><p>另一种进程间通信类型是诸如 HTTP 或 Thrift 那样的同步机制。通常，一个系统会同时使用异步和同步两种类型。它甚至还可能使用同一类型的多种实现。总之，API 网关需要支持多种通信机制。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>API 网关需要知道它与之通信的每个微服务的位置（IP 地址和端口）。在传统的应用程序中，或许可以硬连线这个位置，但在现代的、基于云的微服务应用程序中，这并不是一个容易解决的问题。基础设施服务（如消息代理）通常会有一个静态位置，可以通过 OS 环境变量指定。但是，确定一个应用程序服务的位置没有这么简单。应用程序服务的位置是动态分配的，而且，单个服务的一组实例也会随着自动扩展或升级而动态变化。</p><p>总之，像系统中的其它服务客户端一样，API 网关需要使用系统的服务发现机制，可以是服务器端发现，也可以是客户端发现。下一篇文章将更详细地描述服务发现。现在，需要注意的是，如果系统使用客户端发现，那么 API 网关必须能够查询服务注册中心，这是一个包含所有微服务实例及其位置的数据库。</p><h3 id="处理局部失败"><a href="#处理局部失败" class="headerlink" title="处理局部失败"></a>处理局部失败</h3><p>在实现 API 网关时，还需要处理局部失败的问题。该问题出现在所有的分布式系统中。当一个服务调用另一个服务，而后者响应慢或不可用的时候，就会出现这个问题。API 网关不能因为无限期地等待下游服务而阻塞。不过，如何处理失败取决于特定的场景以及哪个服务失败。例如，在产品详情场景下，如果推荐服务无响应，那么 API 网关应该向客户端返回产品详情的其它内容，因为它们对用户依然有用。推荐内容可以为空，也可以用一个固定的 TOP 10 列表取代。不过，如果产品信息服务无响应，那么 API 网关应该向客户端返回一个错误信息。</p><p>如果缓存数据可用，那么 API 网关还可以返回缓存数据。例如，鉴于产品价格不会频繁变动，如果价格服务不可用，API 网关可以返回缓存的价格数据。数据可以由 API 网关自己缓存，也可以存储在像 Redis 或 Memcached 之类的外部缓存中。通过返回默认数据或者缓存数据，API 网关可以确保系统故障不影响用户体验。</p><p>在编写代码调用远程服务方面，Netflix Hystrix 是一个格外有用的库。Hystrix 会暂停超出特定阈限的调用。它实现了一个“断路器（circuit breaker）”模式，可以防止客户端对无响应的服务进行不必要的等待。如果服务的错误率超出了设定的阈值，那么 Hystrix 会启动断路器，所有请求会立即失败并持续一定时间。Hystrix 允许用户定义一个请求失败后的后援操作，比如从缓存读取数据，或者返回一个默认值。如果你正在使用 JVM，那么你应该考虑使用 Hystrix；如果你正在使用一个非 JVM 环境，那么可以使用一个功能相同的库。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>对于大多数基于微服务的应用程序而言，实现 API 网关，将其作为系统的唯一入口很有必要。API 网关负责服务请求路由、组合及协议转换。它为每个应用程序客户端提供一个定制的 API。API 网关还可以通过返回缓存数据或默认数据屏蔽后端服务失败。</p><h2 id="三、微服务架构中的进程间通信"><a href="#三、微服务架构中的进程间通信" class="headerlink" title="三、微服务架构中的进程间通信"></a>三、微服务架构中的进程间通信</h2><p>在单体应用中，各模块之间的调用是通过编程语言级别的方法或者函数来实现的。而基于微服务的分布式应用是运行在多台机器上的；一般来说，每个服务实例都是一个进程。服务之间的交互必须通过进程间通信（IPC）来实现。</p><h3 id="交付模式"><a href="#交付模式" class="headerlink" title="交付模式"></a>交付模式</h3><p>当为某个服务选择 IPC 时，首先需要考虑服务之间的交互问题。客户端和服务器之间有很多的交互模式，我们可以从两个维度进行归类。第一个维度是一对一还是一对多：</p><p>• 一对一：每个客户端请求有一个服务实例来响应。</p><p>• 一对多：每个客户端请求有多个服务实例来响应。</p><p>第二个维度是这些交互式是同步还是异步：</p><p>• 同步模式：客户端请求需要服务端即时响应，甚至可能由于等待而阻塞。</p><p>• 异步模式：客户端请求不会阻塞进程，服务端的响应可以是非即时的。</p><p>每个服务都是以上这些模式的组合。对某些服务，一个 IPC 机制就足够了；而对另外一些服务则需要多种 IPC 机制组合。</p><h3 id="定义-API"><a href="#定义-API" class="headerlink" title="定义 API"></a>定义 API</h3><p>API 是服务端和客户端之间的契约。无论选择了何种 IPC 机制，重点是使用某种交互定义语言（IDL）来准确定义服务的 API。对于如何使用 API 优先的方式来定义服务，已经有了一些很好的讨论。你在开发服务之前，要定义服务接口并与客户端开发者共同讨论，后续只需要迭代 API 定义。这样的设计能够大幅提升服务的可用度。</p><p>API 定义实质上依赖于选定的 IPC 机制。如果使用消息机制，API 则由消息频道（channel）和消息类型构成；如果选择使用 HTTP 机制，API 则由 URL 和请求、响应格式构成。</p><h3 id="不断进化的-API"><a href="#不断进化的-API" class="headerlink" title="不断进化的 API"></a>不断进化的 API</h3><p>服务的 API 会随着时间而不断变化。在单体应用中，经常会直接修改 API 并更新所有的调用者。但是在基于微服务的应用中，即使所有的 API 的使用者都在同一应用中，这种做法也困难重重，通常不能强制让所有客户端都与服务保持同步更新。此外，你可能会增量部署服务的新版本，这时旧版本会与新版本同时运行。了解这些问题的处理策略至关重要。<br>对 API 变化的处理方式与变化的大小有关。有的变化很小，并且可以兼容之前的版本；比如给请求或响应增加属性。在设计客户端和服务时，很有必要遵循健壮性原则。服务更新版本后，使用旧版 API 的客户端应该继续使用。服务为缺失的请求属性提供默认值，客户端则忽略任何额外的响应。使用 IPC 机制和消息格式能够让你轻松改进 API。</p><p>然而有时候，API 需要进行大规模改动，并且不兼容旧版本。鉴于不能强制让所有客户端立即升级，支持旧版 API 的服务还要再运行一段时间。如果你使用的是诸如 REST 这样的基于 HTTP 机制的 IPC，一种方法就是将版本号嵌入到 URL 中，每个服务实例可以同时处理多个版本。另一种方法是部署不同实例，每个实例处理一个版本的请求。</p><h3 id="处理局部失败-1"><a href="#处理局部失败-1" class="headerlink" title="处理局部失败"></a>处理局部失败</h3><p>在上一篇关于 API 网关的文章中，我们了解到，分布式系统普遍存在局部失败的问题。由于客户端和服务端是独立的进程，服务端可能无法及时响应客户端请求。服务端可能会因为故障或者维护而暂时不可用。服务端也可能会由于过载，导致对请求的响应极其缓慢。</p><p>以上篇文章中提及的产品页为例，假设推荐服务无法响应，客户端可能会由于无限期等待响应而阻塞。这不仅会导致很差的用户体验，并且在很多应用中还会占用之前的资源，比如线程；最终，如下图所示，运行时耗尽线程资源，无法响应。</p><p>为了预防这种问题，设计服务时候必须要考虑部分失败的问题。</p><h3 id="IPC-技术"><a href="#IPC-技术" class="headerlink" title="IPC 技术"></a>IPC 技术</h3><p>现在有很多不同的 IPC 技术。服务间通信可以使用同步的请求/响应模式，比如基于 HTTP 的 REST 或者 Thrift。另外，也可以选择异步的、基于消息的通信模式，比如 AMQP 或者 STOMP。此外，还可以选择 JSON 或者 XML 这种可读的、基于文本的消息格式。当然，也还有效率更高的二进制格式，比如 Avro 和 Protocol Buffer。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>微服务必须使用进程间通信机制来交互。在设计服务的通信模式时，你需要考虑几个问题：服务如何交互，每个服务如何标识 API，如何升级 API，以及如何处理局部失败。微服务架构异步消息机制和同步请求/响应机制这两类 IPC 机制可用。</p><h2 id="四、服务发现的可行方案以及实践案例"><a href="#四、服务发现的可行方案以及实践案例" class="headerlink" title="四、服务发现的可行方案以及实践案例"></a>四、服务发现的可行方案以及实践案例</h2><p>为什么要使用服务发现?<br>假设我们写的代码会调用 REST API 或者 Thrift API 的服务。为了完成一次请求，代码需要知道服务实例的网络位置（IP 地址和端口）。运行在物理硬件上的传统应用中，服务实例的网络位置是相对固定的；代码能从一个偶尔更新的配置文件中读取网络位置。</p><p>对于基于云端的、现代化的微服务应用而言，这却是一大难题，服务实例的网络位置都是动态分配的。由于扩展、失败和升级，服务实例会经常动态改变，因此，客户端代码需要使用更加复杂的服务发现机制。</p><p>服务发现有两大模式：客户端发现模式和服务端发现模式。我们先来了解客客户端发现模式。</p><h3 id="客户端发现模式"><a href="#客户端发现模式" class="headerlink" title="客户端发现模式"></a>客户端发现模式</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://blog.daocloud.io/microservices-1/" target="_blank" rel="noopener">微服务架构概念解析</a></li><li><a href="http://blog.daocloud.io/microservices-2/" target="_blank" rel="noopener">使用 API 网关构建微服务</a></li><li><a href="http://blog.daocloud.io/microservices-3/" target="_blank" rel="noopener">微服务架构中的进程间通信</a></li><li><a href="http://blog.daocloud.io/microservices-4/" target="_blank" rel="noopener">服务发现的可行方案以及实践案例</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务-SOA-API的关系</title>
      <link href="/2017/102949881.html"/>
      <url>/2017/102949881.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、简单定义"><a href="#一、简单定义" class="headerlink" title="一、简单定义"></a>一、简单定义</h2><p><strong>微服务架构</strong>是一种构造应用程序的替代性方法。应用程序被分解为更小、完全独立的组件，这使得它们拥有更高的敏捷性、可伸缩性和可用性。<br><strong>SOA</strong>将应用程序的功能公开为更容易访问的服务接口，使得在下一代应用程序中使用它们的数据和逻辑变得更容易。  </p><p>SOA 似乎拥有 企业范围，应用程序在该范围内彼此通信。SOA 通过应用程序之间的标准化接口来公开服务。微服务架构似乎拥有 应用程序范围，仅关注一个应用程序内的结构和组件。</p><h2 id="微服务：一种替代性架构"><a href="#微服务：一种替代性架构" class="headerlink" title="微服务：一种替代性架构"></a>微服务：一种替代性架构</h2><p>在考虑对比微服务和 SOA 之前，需要理解微服务架构的含义。从基本角度讲，微服务是构建 应用程序的替代性架构。它们提供了更好的方法来解耦应用程序边界 内的组件。事实上，如果将微服务称为 “微型组件”，它们的实际性质会更加明确。<br>尽管应用程序在内部被分解为不同的微服务组件，但从外部来看，应用程序仍是相同的。基于微服务的应用程序公开的 API 的数量和粒度不应与将 API 构建为孤立应用程序有任何不同。微服务中的第一个词 “微型” 表示内部组件的粒度，而不是公开的接口的粒度。</p><blockquote><p>从单个庞大的应用程序到微服务<br><img src="https://www.ibm.com/developerworks/cn/websphere/library/techarticles/1601_clark-trs/images/figure5.jpg" alt></p></blockquote><h3 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h3><p>完全独立的微服务组件有助于实现完全自主的所有权，带来以下优势：</p><ul><li><p>敏捷性和生产力。开发微服务的团队可以完全理解代码库。他们可以在快得多的周期中与其他组件独立地构建、部署和测试代码库。因为微服务组件只是网络上的另一个组件，所以您可以采用最适合所需功能的语言或框架来编写它，并采用最合适的持久性机制。<br>这种方法可显著减少要编写的代码量，使维护得到显著简化。它可以确保团队能够根据需要采用新技术或现有技术的新版本，而不是等待应用程序域的剩余部分跟上节奏。对于微服务粒度的定义，微服务组件应足够简单，以便在必要时在其下一次迭代中重写。</p></li><li><p>可伸缩性：微服务开发团队可以在运行时与其他组件独立地扩展微服务组件，实现资源的高效使用和对工作负载变化的快速反应。从理论上讲，一个组件的工作负载可以转移到对任务最合适的基础架构上。它还可以与剩余组件独立地重新放置，以便充分利用网络位置。精心编写的微服务提供了非凡的按需可伸缩性，这一领域的早期创新者和采用者已证明这一点。这些微服务也得到了最佳布置，以便充分利用弹性功能，以富有成本效益的方式访问大量资源的原生云环境。</p></li><li>恢复能力：独立的运行时可以立即提供与其他组件中的故障独立的恢复能力。借助小心地解耦的设计，比如避免同步依赖关系和使用断路器模式，可以编写每个微服务组件来满足自己的可用性需求，而不是在整个应用程序域中引入这些需求。容器等技术和轻量型运行时使微服务组件能够快速且独立地失败，而不是让所有不相关的功能区域都失效。同样地，它们是以一种高度无状态的方式编写的，以便可以立即重新分布工作负载并几乎同时地调出新运行时。  </li></ul><p>这些优势的示例是组织转而使用微服务的一些最常见的原因。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SOA 的概念存在于现代架构中，但已通过多种方式发生了演变。集成工具、模式和标准也已发生演变，所以功能和数据更容易公开。服务公开已演变为 API，简化了公开、使用、管理，在某些情况下，还可以从业务功能中牟利。新应用程序架构（包括微服务架构）使得开发人员能够更密切地关注业务逻辑，不断将基础架构细节推送到他们所在的环境。这些开发方式的组合有助于以更敏捷的风格构建解决方案，有助于应用程序获得全新的弹性可伸缩性和容错水平。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/websphere/library/techarticles/1601_clark-trs/1601_clark.html" target="_blank" rel="noopener">微服务、SOA 和 API：是敌是友？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> SOA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
